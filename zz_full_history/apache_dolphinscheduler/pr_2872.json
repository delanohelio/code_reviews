{"pr_number": 2872, "pr_title": "Using Jackson instead of Fastjson", "pr_author": "simon824", "pr_createdAt": "2020-06-02T07:58:44Z", "pr_url": "https://github.com/apache/dolphinscheduler/pull/2872", "timeline": [{"oid": "a9f72c20812323794067a6b1358d27a131469703", "url": "https://github.com/apache/dolphinscheduler/commit/a9f72c20812323794067a6b1358d27a131469703", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T07:54:34Z", "type": "commit"}, {"oid": "e386af700d4276882e7b272041d1014a2ce4ca36", "url": "https://github.com/apache/dolphinscheduler/commit/e386af700d4276882e7b272041d1014a2ce4ca36", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T09:22:39Z", "type": "commit"}, {"oid": "39d2713d0a3122f0bbc6b15fee959b14108cd980", "url": "https://github.com/apache/dolphinscheduler/commit/39d2713d0a3122f0bbc6b15fee959b14108cd980", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T10:19:21Z", "type": "commit"}, {"oid": "3ccd96aabbadb284a49b9d2d9d4ca9dbf3f38a53", "url": "https://github.com/apache/dolphinscheduler/commit/3ccd96aabbadb284a49b9d2d9d4ca9dbf3f38a53", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T10:42:04Z", "type": "commit"}, {"oid": "48735a8bf4f0b6448c9e11caa03d927cc4161c6a", "url": "https://github.com/apache/dolphinscheduler/commit/48735a8bf4f0b6448c9e11caa03d927cc4161c6a", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T11:07:24Z", "type": "commit"}, {"oid": "f26e246706c6d89b49190a0eb9347e23bcd3144e", "url": "https://github.com/apache/dolphinscheduler/commit/f26e246706c6d89b49190a0eb9347e23bcd3144e", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T12:00:49Z", "type": "commit"}, {"oid": "dea2d4634dee5eaf8d4f22c4376032b3d8b1268a", "url": "https://github.com/apache/dolphinscheduler/commit/dea2d4634dee5eaf8d4f22c4376032b3d8b1268a", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-02T12:13:23Z", "type": "commit"}, {"oid": "33bd6586dd118acd29d8ab0eea155a6be5de3d7a", "url": "https://github.com/apache/dolphinscheduler/commit/33bd6586dd118acd29d8ab0eea155a6be5de3d7a", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-03T01:19:59Z", "type": "commit"}, {"oid": "bb089288c4fe8e228d119737dfd10c2b21f7328b", "url": "https://github.com/apache/dolphinscheduler/commit/bb089288c4fe8e228d119737dfd10c2b21f7328b", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-03T04:40:28Z", "type": "commit"}, {"oid": "8bab8abcd23cd6a03d8b567901da7b5959566f69", "url": "https://github.com/apache/dolphinscheduler/commit/8bab8abcd23cd6a03d8b567901da7b5959566f69", "message": "ut fix", "committedDate": "2020-06-03T11:21:19Z", "type": "commit"}, {"oid": "9c36829278b4e5ff2259bfe0014c19e5345e349d", "url": "https://github.com/apache/dolphinscheduler/commit/9c36829278b4e5ff2259bfe0014c19e5345e349d", "message": "ut fix", "committedDate": "2020-06-03T12:05:07Z", "type": "commit"}, {"oid": "4a10157506c0659e6bff20fdb47b930a4630b1c1", "url": "https://github.com/apache/dolphinscheduler/commit/4a10157506c0659e6bff20fdb47b930a4630b1c1", "message": "ut fix", "committedDate": "2020-06-04T01:42:41Z", "type": "commit"}, {"oid": "6205e687c2c96bf0a87e300081d1395e509b26c3", "url": "https://github.com/apache/dolphinscheduler/commit/6205e687c2c96bf0a87e300081d1395e509b26c3", "message": "annotation reset", "committedDate": "2020-06-04T02:11:11Z", "type": "commit"}, {"oid": "572ee0fc6474bc238761eca79848e8f12fff22c8", "url": "https://github.com/apache/dolphinscheduler/commit/572ee0fc6474bc238761eca79848e8f12fff22c8", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-04T08:23:59Z", "type": "commit"}, {"oid": "4197ee8a8f3fcf238cba3186db04bf5f18ac2073", "url": "https://github.com/apache/dolphinscheduler/commit/4197ee8a8f3fcf238cba3186db04bf5f18ac2073", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-04T08:46:11Z", "type": "commit"}, {"oid": "32863755eccabec6d88028011e0c394417b248fb", "url": "https://github.com/apache/dolphinscheduler/commit/32863755eccabec6d88028011e0c394417b248fb", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-04T08:56:31Z", "type": "commit"}, {"oid": "9ada3c7aacbae76d23d3d49c68ce03b3c8336db1", "url": "https://github.com/apache/dolphinscheduler/commit/9ada3c7aacbae76d23d3d49c68ce03b3c8336db1", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-04T09:20:24Z", "type": "commit"}, {"oid": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "url": "https://github.com/apache/dolphinscheduler/commit/9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "message": "Using Jackson instead of Fastjson", "committedDate": "2020-06-04T09:56:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzE3NA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435903174", "body": "the type of 'list' variable is List<String> , why replace String with Object ", "bodyText": "the type of 'list' variable is List , why replace String with Object", "bodyHTML": "<p dir=\"auto\">the type of 'list' variable is List , why replace String with Object</p>", "author": "gabrywu", "createdAt": "2020-06-05T12:57:28Z", "path": "dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java", "diffHunk": "@@ -116,9 +116,9 @@ private String getTextTypeMessage(String content,boolean showAll){\n             }\n \n             StringBuilder contents = new StringBuilder(100);\n-            for (String str : list){\n+            for (Object obj : list){", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTM5MA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436231390", "bodyText": "JSONUtils.toList will return List< LinkedHashMap > and will Cause exception : LinkedHashMap cannot be cast to String", "author": "simon824", "createdAt": "2020-06-06T02:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzE3NA=="}], "type": "inlineReview", "revised_code": {"commit": "83ede1037ead8c8cc237b66c996c59d0d2e388f5", "changed_code": [{"header": "diff --git a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\nindex 063a4a4e8..7039d7c5c 100644\n--- a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\n+++ b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\n", "chunk": "@@ -116,9 +116,9 @@ public class DefaultHTMLTemplate implements AlertTemplate {\n             }\n \n             StringBuilder contents = new StringBuilder(100);\n-            for (Object obj : list){\n+            for (String str : list){\n                 contents.append(Constants.TR);\n-                contents.append(Constants.TD).append(obj).append(Constants.TD_END);\n+                contents.append(Constants.TD).append(str).append(Constants.TD_END);\n                 contents.append(Constants.TR_END);\n             }\n \n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\nindex 7039d7c5c..7331df391 100644\n--- a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\n+++ b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\n", "chunk": "@@ -107,18 +109,11 @@ public class DefaultHTMLTemplate implements AlertTemplate {\n     private String getTextTypeMessage(String content,boolean showAll){\n \n         if (StringUtils.isNotEmpty(content)){\n-            List<String> list;\n-            try {\n-                list = JSONUtils.toList(content,String.class);\n-            }catch (Exception e){\n-                logger.error(\"json format exception\",e);\n-                return null;\n-            }\n-\n+            ArrayNode list = JSONUtils.parseArray(content);\n             StringBuilder contents = new StringBuilder(100);\n-            for (String str : list){\n+            for (JsonNode jsonNode : list){\n                 contents.append(Constants.TR);\n-                contents.append(Constants.TD).append(str).append(Constants.TD_END);\n+                contents.append(Constants.TD).append(jsonNode.toString()).append(Constants.TD_END);\n                 contents.append(Constants.TR_END);\n             }\n \n", "next_change": {"commit": "1d254347df32ed832b69c621a24c242f33df0b13", "changed_code": [{"header": "diff --git a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\ndeleted file mode 100644\nindex 7331df391..000000000\n--- a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/template/impl/DefaultHTMLTemplate.java\n+++ /dev/null\n", "chunk": "@@ -1,155 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dolphinscheduler.alert.template.impl;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.node.ArrayNode;\n-import org.apache.dolphinscheduler.alert.template.AlertTemplate;\n-import org.apache.dolphinscheduler.alert.utils.Constants;\n-import org.apache.dolphinscheduler.common.enums.ShowType;\n-import org.apache.dolphinscheduler.common.utils.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.apache.dolphinscheduler.common.utils.*;\n-\n-import java.util.*;\n-\n-import static org.apache.dolphinscheduler.common.utils.Preconditions.*;\n-\n-/**\n- * the default html alert message template\n- */\n-public class DefaultHTMLTemplate implements AlertTemplate {\n-\n-    public static final Logger logger = LoggerFactory.getLogger(DefaultHTMLTemplate.class);\n-\n-    @Override\n-    public String getMessageFromTemplate(String content, ShowType showType,boolean showAll) {\n-\n-        switch (showType){\n-            case TABLE:\n-                return getTableTypeMessage(content,showAll);\n-            case TEXT:\n-                return getTextTypeMessage(content,showAll);\n-            default:\n-                throw new IllegalArgumentException(String.format(\"not support showType: %s in DefaultHTMLTemplate\",showType));\n-        }\n-    }\n-\n-    /**\n-     * get alert message which type is TABLE\n-     * @param content message content\n-     * @param showAll weather to show all\n-     * @return alert message\n-     */\n-    private String getTableTypeMessage(String content,boolean showAll){\n-\n-        if (StringUtils.isNotEmpty(content)){\n-            List<LinkedHashMap> mapItemsList = JSONUtils.toList(content, LinkedHashMap.class);\n-\n-            if(!showAll && mapItemsList.size() > Constants.NUMBER_1000){\n-                mapItemsList = mapItemsList.subList(0,Constants.NUMBER_1000);\n-            }\n-\n-            StringBuilder contents = new StringBuilder(200);\n-\n-            boolean flag = true;\n-\n-            String title = \"\";\n-            for (LinkedHashMap mapItems : mapItemsList){\n-\n-                Set<Map.Entry<String, Object>> entries = mapItems.entrySet();\n-\n-                Iterator<Map.Entry<String, Object>> iterator = entries.iterator();\n-\n-                StringBuilder t = new StringBuilder(Constants.TR);\n-                StringBuilder cs = new StringBuilder(Constants.TR);\n-                while (iterator.hasNext()){\n-\n-                    Map.Entry<String, Object> entry = iterator.next();\n-                    t.append(Constants.TH).append(entry.getKey()).append(Constants.TH_END);\n-                    cs.append(Constants.TD).append(String.valueOf(entry.getValue())).append(Constants.TD_END);\n-\n-                }\n-                t.append(Constants.TR_END);\n-                cs.append(Constants.TR_END);\n-                if (flag){\n-                    title = t.toString();\n-                }\n-                flag = false;\n-                contents.append(cs);\n-            }\n-\n-            return getMessageFromHtmlTemplate(title,contents.toString());\n-        }\n-\n-        return content;\n-    }\n-\n-    /**\n-     * get alert message which type is TEXT\n-     * @param content message content\n-     * @param showAll weather to show all\n-     * @return alert message\n-     */\n-    private String getTextTypeMessage(String content,boolean showAll){\n-\n-        if (StringUtils.isNotEmpty(content)){\n-            ArrayNode list = JSONUtils.parseArray(content);\n-            StringBuilder contents = new StringBuilder(100);\n-            for (JsonNode jsonNode : list){\n-                contents.append(Constants.TR);\n-                contents.append(Constants.TD).append(jsonNode.toString()).append(Constants.TD_END);\n-                contents.append(Constants.TR_END);\n-            }\n-\n-            return getMessageFromHtmlTemplate(null,contents.toString());\n-\n-        }\n-\n-        return content;\n-    }\n-\n-    /**\n-     * get alert message from a html template\n-     * @param title     message title\n-     * @param content   message content\n-     * @return alert message which use html template\n-     */\n-    private String getMessageFromHtmlTemplate(String title,String content){\n-\n-        checkNotNull(content);\n-        String htmlTableThead = StringUtils.isEmpty(title) ? \"\" : String.format(\"<thead>%s</thead>\\n\",title);\n-\n-        return \"<html>\\n\" +\n-                \"    <head>\\n\" +\n-                \"        <title>dolphinscheduler</title>\\n\" +\n-                \"        <meta name='Keywords' content=''>\\n\" +\n-                \"        <meta name='Description' content=''>\\n\" +\n-                \"        <style type=\\\"text/css\\\">\\n\" +\n-                \"            table {margin-top:0px;padding-top:0px;border:1px solid;font-size: 14px;color: #333333;border-width: 1px;border-color: #666666;border-collapse: collapse;}\\n\" +\n-                \"            table th {border-width: 1px;padding: 8px;border-style: solid;border-color: #666666;background-color: #dedede;text-align: right;}\\n\" +\n-                \"            table td {border-width: 1px;padding: 8px;border-style: solid;border-color: #666666;background-color: #ffffff;text-align: right;}\\n\" +\n-                \"        </style>\\n\" +\n-                \"    </head>\\n\" +\n-                \"    <body style=\\\"margin:0;padding:0\\\">\\n\" +\n-                \"        <table border=\\\"1px\\\" cellpadding=\\\"5px\\\" cellspacing=\\\"-10px\\\">\\n\" + htmlTableThead + content +\n-                \"        </table>\\n\" +\n-                \"    </body>\\n\" +\n-                \"</html>\";\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNzc1Mw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435907753", "body": "parseObject is hard to understand ,suggest add parseMap method ,refer to the following code \r\n`TypeReference<HashMap<String, String>> typeRef \r\n  = new TypeReference<HashMap<String, String>>() {};\r\nMap<String, String> map = mapper.readValue(jsonInput, typeRef);`", "bodyText": "parseObject is hard to understand ,suggest add parseMap method ,refer to the following code\nTypeReference<HashMap<String, String>> typeRef  = new TypeReference<HashMap<String, String>>() {}; Map<String, String> map = mapper.readValue(jsonInput, typeRef);", "bodyHTML": "<p dir=\"auto\">parseObject is hard to understand ,suggest add parseMap method ,refer to the following code<br>\n<code>TypeReference&lt;HashMap&lt;String, String&gt;&gt; typeRef  = new TypeReference&lt;HashMap&lt;String, String&gt;&gt;() {}; Map&lt;String, String&gt; map = mapper.readValue(jsonInput, typeRef);</code></p>", "author": "gabrywu", "createdAt": "2020-06-05T13:05:45Z", "path": "dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java", "diffHunk": "@@ -99,9 +99,7 @@ public static String getToken() throws IOException {\n                 response.close();\n             }\n \n-            Map<String, Object> map = JSON.parseObject(resp,\n-                    new TypeToken<Map<String, Object>>() {\n-                    }.getType());\n+            Map<String, Object> map = JSONUtils.parseObject(resp, Map.class);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDY0Mw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436230643", "bodyText": "ok\uff0cI will fix all similar problems", "author": "simon824", "createdAt": "2020-06-06T02:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNzc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java\nindex 03cd53c0c..bebb70bae 100644\n--- a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java\n+++ b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java\n", "chunk": "@@ -99,8 +101,12 @@ public class EnterpriseWeChatUtils {\n                 response.close();\n             }\n \n-            Map<String, Object> map = JSONUtils.parseObject(resp, Map.class);\n-            return map.get(\"access_token\").toString();\n+            Map<String, String> map = JSONUtils.toMap(resp);\n+            if (map != null) {\n+                return map.get(\"access_token\");\n+            } else {\n+                return null;\n+            }\n         } finally {\n             httpClient.close();\n         }\n", "next_change": {"commit": "449cbbe21eaca0d2a886d90ce2731702347bf45a", "changed_code": [{"header": "diff --git a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java b/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java\ndeleted file mode 100644\nindex bebb70bae..000000000\n--- a/dolphinscheduler-alert/src/main/java/org/apache/dolphinscheduler/alert/utils/EnterpriseWeChatUtils.java\n+++ /dev/null\n", "chunk": "@@ -1,282 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dolphinscheduler.alert.utils;\n-\n-import org.apache.dolphinscheduler.common.enums.ShowType;\n-import org.apache.dolphinscheduler.common.utils.StringUtils;\n-import org.apache.dolphinscheduler.common.utils.*;\n-\n-import com.google.common.reflect.TypeToken;\n-import org.apache.dolphinscheduler.plugin.model.AlertData;\n-import org.apache.http.HttpEntity;\n-import org.apache.http.client.methods.CloseableHttpResponse;\n-import org.apache.http.client.methods.HttpGet;\n-import org.apache.http.client.methods.HttpPost;\n-import org.apache.http.entity.StringEntity;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.apache.http.util.EntityUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.util.*;\n-\n-/**\n- * Enterprise WeChat utils\n- */\n-public class EnterpriseWeChatUtils {\n-\n-    public static final Logger logger = LoggerFactory.getLogger(EnterpriseWeChatUtils.class);\n-\n-    private static final String ENTERPRISE_WE_CHAT_CORP_ID = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_CORP_ID);\n-\n-    private static final String ENTERPRISE_WE_CHAT_SECRET = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_SECRET);\n-\n-    private static final String ENTERPRISE_WE_CHAT_TOKEN_URL = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_TOKEN_URL);\n-    private static final String ENTERPRISE_WE_CHAT_TOKEN_URL_REPLACE = ENTERPRISE_WE_CHAT_TOKEN_URL == null ? null : ENTERPRISE_WE_CHAT_TOKEN_URL\n-            .replaceAll(\"\\\\$corpId\", ENTERPRISE_WE_CHAT_CORP_ID)\n-            .replaceAll(\"\\\\$secret\", ENTERPRISE_WE_CHAT_SECRET);\n-\n-    private static final String ENTERPRISE_WE_CHAT_PUSH_URL = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_PUSH_URL);\n-\n-    private static final String ENTERPRISE_WE_CHAT_TEAM_SEND_MSG = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_TEAM_SEND_MSG);\n-\n-    private static final String ENTERPRISE_WE_CHAT_USER_SEND_MSG = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_USER_SEND_MSG);\n-\n-    public static final String ENTERPRISE_WE_CHAT_AGENT_ID = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_AGENT_ID);\n-\n-    public static final String ENTERPRISE_WE_CHAT_USERS = PropertyUtils.getString(Constants.ENTERPRISE_WECHAT_USERS);\n-\n-    /**\n-     * get Enterprise WeChat is enable\n-     *\n-     * @return isEnable\n-     */\n-    public static boolean isEnable() {\n-        Boolean isEnable = null;\n-        try {\n-            isEnable = PropertyUtils.getBoolean(Constants.ENTERPRISE_WECHAT_ENABLE);\n-        } catch (Exception e) {\n-            logger.error(e.getMessage(), e);\n-        }\n-        if (isEnable == null) {\n-            return false;\n-        }\n-        return isEnable;\n-    }\n-\n-    /**\n-     * get Enterprise WeChat token info\n-     *\n-     * @return token string info\n-     * @throws IOException the IOException\n-     */\n-    public static String getToken() throws IOException {\n-        String resp;\n-\n-        CloseableHttpClient httpClient = HttpClients.createDefault();\n-        try {\n-            HttpGet httpGet = new HttpGet(ENTERPRISE_WE_CHAT_TOKEN_URL_REPLACE);\n-            CloseableHttpResponse response = httpClient.execute(httpGet);\n-            try {\n-                HttpEntity entity = response.getEntity();\n-                resp = EntityUtils.toString(entity, Constants.UTF_8);\n-                EntityUtils.consume(entity);\n-            } finally {\n-                response.close();\n-            }\n-\n-            Map<String, String> map = JSONUtils.toMap(resp);\n-            if (map != null) {\n-                return map.get(\"access_token\");\n-            } else {\n-                return null;\n-            }\n-        } finally {\n-            httpClient.close();\n-        }\n-    }\n-\n-    /**\n-     * make team single Enterprise WeChat message\n-     *\n-     * @param toParty the toParty\n-     * @param agentId the agentId\n-     * @param msg     the msg\n-     * @return Enterprise WeChat send message\n-     */\n-    public static String makeTeamSendMsg(String toParty, String agentId, String msg) {\n-        return ENTERPRISE_WE_CHAT_TEAM_SEND_MSG.replaceAll(\"\\\\$toParty\", toParty)\n-                .replaceAll(\"\\\\$agentId\", agentId)\n-                .replaceAll(\"\\\\$msg\", msg);\n-    }\n-\n-    /**\n-     * make team multi Enterprise WeChat message\n-     *\n-     * @param toParty the toParty\n-     * @param agentId the agentId\n-     * @param msg     the msg\n-     * @return Enterprise WeChat send message\n-     */\n-    public static String makeTeamSendMsg(Collection<String> toParty, String agentId, String msg) {\n-        String listParty = FuncUtils.mkString(toParty, \"|\");\n-        return ENTERPRISE_WE_CHAT_TEAM_SEND_MSG.replaceAll(\"\\\\$toParty\", listParty)\n-                .replaceAll(\"\\\\$agentId\", agentId)\n-                .replaceAll(\"\\\\$msg\", msg);\n-    }\n-\n-    /**\n-     * make team single user message\n-     *\n-     * @param toUser  the toUser\n-     * @param agentId the agentId\n-     * @param msg     the msg\n-     * @return Enterprise WeChat send message\n-     */\n-    public static String makeUserSendMsg(String toUser, String agentId, String msg) {\n-        return ENTERPRISE_WE_CHAT_USER_SEND_MSG.replaceAll(\"\\\\$toUser\", toUser)\n-                .replaceAll(\"\\\\$agentId\", agentId)\n-                .replaceAll(\"\\\\$msg\", msg);\n-    }\n-\n-    /**\n-     * make team multi user message\n-     *\n-     * @param toUser  the toUser\n-     * @param agentId the agentId\n-     * @param msg     the msg\n-     * @return Enterprise WeChat send message\n-     */\n-    public static String makeUserSendMsg(Collection<String> toUser, String agentId, String msg) {\n-        String listUser = FuncUtils.mkString(toUser, \"|\");\n-        return ENTERPRISE_WE_CHAT_USER_SEND_MSG.replaceAll(\"\\\\$toUser\", listUser)\n-                .replaceAll(\"\\\\$agentId\", agentId)\n-                .replaceAll(\"\\\\$msg\", msg);\n-    }\n-\n-    /**\n-     * send Enterprise WeChat\n-     *\n-     * @param charset the charset\n-     * @param data    the data\n-     * @param token   the token\n-     * @return Enterprise WeChat resp, demo: {\"errcode\":0,\"errmsg\":\"ok\",\"invaliduser\":\"\"}\n-     * @throws IOException the IOException\n-     */\n-    public static String sendEnterpriseWeChat(String charset, String data, String token) throws IOException {\n-        String enterpriseWeChatPushUrlReplace = ENTERPRISE_WE_CHAT_PUSH_URL.replaceAll(\"\\\\$token\", token);\n-\n-        CloseableHttpClient httpClient = HttpClients.createDefault();\n-        try {\n-            HttpPost httpPost = new HttpPost(enterpriseWeChatPushUrlReplace);\n-            httpPost.setEntity(new StringEntity(data, charset));\n-            CloseableHttpResponse response = httpClient.execute(httpPost);\n-            String resp;\n-            try {\n-                HttpEntity entity = response.getEntity();\n-                resp = EntityUtils.toString(entity, charset);\n-                EntityUtils.consume(entity);\n-            } finally {\n-                response.close();\n-            }\n-            logger.info(\"Enterprise WeChat send [{}], param:{}, resp:{}\",\n-                    ENTERPRISE_WE_CHAT_PUSH_URL, data, resp);\n-            return resp;\n-        } finally {\n-            httpClient.close();\n-        }\n-    }\n-\n-    /**\n-     * convert table to markdown style\n-     *\n-     * @param title   the title\n-     * @param content the content\n-     * @return markdown table content\n-     */\n-    public static String markdownTable(String title, String content) {\n-        List<LinkedHashMap> mapItemsList = JSONUtils.toList(content, LinkedHashMap.class);\n-        StringBuilder contents = new StringBuilder(200);\n-\n-        if (null != mapItemsList) {\n-            for (LinkedHashMap mapItems : mapItemsList) {\n-                Set<Map.Entry<String, String>> entries = mapItems.entrySet();\n-                Iterator<Map.Entry<String, String>> iterator = entries.iterator();\n-                StringBuilder t = new StringBuilder(String.format(\"`%s`%s\", title, Constants.MARKDOWN_ENTER));\n-\n-                while (iterator.hasNext()) {\n-\n-                    Map.Entry<String, String> entry = iterator.next();\n-                    t.append(Constants.MARKDOWN_QUOTE);\n-                    t.append(entry.getKey()).append(\":\").append(entry.getValue());\n-                    t.append(Constants.MARKDOWN_ENTER);\n-                }\n-                contents.append(t);\n-            }\n-        }\n-        return contents.toString();\n-    }\n-\n-    /**\n-     * convert text to markdown style\n-     *\n-     * @param title   the title\n-     * @param content the content\n-     * @return markdown text\n-     */\n-    public static String markdownText(String title, String content) {\n-        if (StringUtils.isNotEmpty(content)) {\n-            List<String> list;\n-            try {\n-                list = JSONUtils.toList(content, String.class);\n-            } catch (Exception e) {\n-                logger.error(\"json format exception\", e);\n-                return null;\n-            }\n-\n-            StringBuilder contents = new StringBuilder(100);\n-            contents.append(String.format(\"`%s`%n\", title));\n-            for (String str : list) {\n-                contents.append(Constants.MARKDOWN_QUOTE);\n-                contents.append(str);\n-                contents.append(Constants.MARKDOWN_ENTER);\n-            }\n-\n-            return contents.toString();\n-\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Determine the mardown style based on the show type of the alert\n-     *\n-     * @return the markdown alert table/text\n-     */\n-    public static String markdownByAlert(AlertData alert) {\n-        String result = \"\";\n-        if (alert.getShowType().equals(ShowType.TABLE.getDescp())) {\n-            result = markdownTable(alert.getTitle(), alert.getContent());\n-        } else if (alert.getShowType().equals(ShowType.TEXT.getDescp())) {\n-            result = markdownText(alert.getTitle(), alert.getContent());\n-        }\n-        return result;\n-\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxMDczNA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435910734", "body": "why still using the fastjson annotation?", "bodyText": "why still using the fastjson annotation?", "bodyHTML": "<p dir=\"auto\">why still using the fastjson annotation?</p>", "author": "gabrywu", "createdAt": "2020-06-05T13:11:29Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java", "diffHunk": "@@ -1,7 +1,7 @@\n package org.apache.dolphinscheduler.api.dto.resources;\n \n-import com.alibaba.fastjson.annotation.JSONField;\n import com.alibaba.fastjson.annotation.JSONType;\n+import com.alibaba.fastjson.annotation.JSONField;", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTAwOA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436231008", "bodyText": "sorry\uff0cI missed it\ni will fix it later", "author": "simon824", "createdAt": "2020-06-06T02:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxMDczNA=="}], "type": "inlineReview", "revised_code": {"commit": "c5b3f35bd4f217df31cd1fba8eb605e52909f972", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java\nindex 3f7c227ae..6a5b6e335 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java\n", "chunk": "@@ -1,7 +1,6 @@\n package org.apache.dolphinscheduler.api.dto.resources;\n \n-import com.alibaba.fastjson.annotation.JSONType;\n-import com.alibaba.fastjson.annotation.JSONField;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import org.apache.dolphinscheduler.common.enums.ResourceType;\n \n import java.util.ArrayList;\n", "next_change": {"commit": "657ea4752feadd16b4db51aeb09d89555cee9dbd", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java\nindex 6a5b6e335..999fc88b0 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/resources/ResourceComponent.java\n", "chunk": "@@ -1,11 +1,3 @@\n-package org.apache.dolphinscheduler.api.dto.resources;\n-\n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n-import org.apache.dolphinscheduler.common.enums.ResourceType;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n  * contributor license agreements.  See the NOTICE file distributed with\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyMjYwNQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435922605", "body": "paramObject is ObjectNode ,why not use toString directly ?", "bodyText": "paramObject is ObjectNode ,why not use toString directly ?", "bodyHTML": "<p dir=\"auto\">paramObject is ObjectNode ,why not use toString directly ?</p>", "author": "gabrywu", "createdAt": "2020-06-05T13:31:54Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java", "diffHunk": "@@ -161,15 +159,15 @@\n             return result;\n         }\n         //check password\uff0cif the password is not updated, set to the old password.\n-        JSONObject paramObject = JSON.parseObject(parameter);\n-        String password = paramObject.getString(Constants.PASSWORD);\n+        ObjectNode paramObject = JSONUtils.parseObject(parameter);\n+        String password = paramObject.path(Constants.PASSWORD).asText();\n         if (StringUtils.isBlank(password)) {\n             String oldConnectionParams = dataSource.getConnectionParams();\n-            JSONObject oldParams = JSON.parseObject(oldConnectionParams);\n-            paramObject.put(Constants.PASSWORD, oldParams.getString(Constants.PASSWORD));\n+            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);\n+            paramObject.put(Constants.PASSWORD, oldParams.path(Constants.PASSWORD).asText());\n         }\n         // connectionParams json\n-        String connectionParams = paramObject.toJSONString();\n+        String connectionParams = JSONUtils.toJsonString(paramObject);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTA1Ng==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436231056", "bodyText": "ok\uff0cI will fix all similar problems", "author": "simon824", "createdAt": "2020-06-06T02:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyMjYwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "fadb69b18134c1160deac9db9a3084217f5aee8f", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex a702ffe1e..b2b42512a 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -158,18 +159,8 @@ public class DataSourceService extends BaseService{\n             putMsg(result, Status.DATASOURCE_EXIST);\n             return result;\n         }\n-        //check password\uff0cif the password is not updated, set to the old password.\n-        ObjectNode paramObject = JSONUtils.parseObject(parameter);\n-        String password = paramObject.path(Constants.PASSWORD).asText();\n-        if (StringUtils.isBlank(password)) {\n-            String oldConnectionParams = dataSource.getConnectionParams();\n-            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);\n-            paramObject.put(Constants.PASSWORD, oldParams.path(Constants.PASSWORD).asText());\n-        }\n-        // connectionParams json\n-        String connectionParams = JSONUtils.toJsonString(paramObject);\n \n-        Boolean isConnection = checkConnection(type, connectionParams);\n+        Boolean isConnection = checkConnection(type, parameter);\n         if (!isConnection) {\n             logger.info(\"connect failed, type:{}, parameter:{}\", type, parameter);\n             putMsg(result, Status.DATASOURCE_CONNECT_FAILED);\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex b2b42512a..735cd8ce8 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -159,8 +158,18 @@ public class DataSourceService extends BaseService{\n             putMsg(result, Status.DATASOURCE_EXIST);\n             return result;\n         }\n+        //check password\uff0cif the password is not updated, set to the old password.\n+        ObjectNode paramObject = JSONUtils.parseObject(parameter);\n+        String password = paramObject.path(Constants.PASSWORD).asText();\n+        if (StringUtils.isBlank(password)) {\n+            String oldConnectionParams = dataSource.getConnectionParams();\n+            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);\n+            paramObject.put(Constants.PASSWORD, oldParams.path(Constants.PASSWORD).asText());\n+        }\n+        // connectionParams json\n+        String connectionParams = paramObject.toString();\n \n-        Boolean isConnection = checkConnection(type, parameter);\n+        Boolean isConnection = checkConnection(type, connectionParams);\n         if (!isConnection) {\n             logger.info(\"connect failed, type:{}, parameter:{}\", type, parameter);\n             putMsg(result, Status.DATASOURCE_CONNECT_FAILED);\n", "next_change": {"commit": "1904a7022a38ff9bc8fbe42f1e8e9c4547916fd6", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 735cd8ce8..9092270b4 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -159,15 +161,15 @@ public class DataSourceService extends BaseService{\n             return result;\n         }\n         //check password\uff0cif the password is not updated, set to the old password.\n-        ObjectNode paramObject = JSONUtils.parseObject(parameter);\n-        String password = paramObject.path(Constants.PASSWORD).asText();\n+        JSONObject paramObject = JSON.parseObject(parameter);\n+        String password = paramObject.getString(Constants.PASSWORD);\n         if (StringUtils.isBlank(password)) {\n             String oldConnectionParams = dataSource.getConnectionParams();\n-            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);\n-            paramObject.put(Constants.PASSWORD, oldParams.path(Constants.PASSWORD).asText());\n+            JSONObject oldParams = JSON.parseObject(oldConnectionParams);\n+            paramObject.put(Constants.PASSWORD, oldParams.getString(Constants.PASSWORD));\n         }\n         // connectionParams json\n-        String connectionParams = paramObject.toString();\n+        String connectionParams = paramObject.toJSONString();\n \n         Boolean isConnection = checkConnection(type, connectionParams);\n         if (!isConnection) {\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 9092270b4..1bfacfb93 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -161,15 +159,15 @@ public class DataSourceService extends BaseService{\n             return result;\n         }\n         //check password\uff0cif the password is not updated, set to the old password.\n-        JSONObject paramObject = JSON.parseObject(parameter);\n-        String password = paramObject.getString(Constants.PASSWORD);\n+        ObjectNode paramObject = JSONUtils.parseObject(parameter);\n+        String password = paramObject.path(Constants.PASSWORD).asText();\n         if (StringUtils.isBlank(password)) {\n             String oldConnectionParams = dataSource.getConnectionParams();\n-            JSONObject oldParams = JSON.parseObject(oldConnectionParams);\n-            paramObject.put(Constants.PASSWORD, oldParams.getString(Constants.PASSWORD));\n+            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);\n+            paramObject.put(Constants.PASSWORD, oldParams.path(Constants.PASSWORD).asText());\n         }\n         // connectionParams json\n-        String connectionParams = paramObject.toJSONString();\n+        String connectionParams = paramObject.toString();\n \n         Boolean isConnection = checkConnection(type, connectionParams);\n         if (!isConnection) {\n", "next_change": {"commit": "91dfe0913f86748130d26edb653dee62d582e5ca", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 1bfacfb93..58bb657c6 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -169,12 +163,11 @@ public class DataSourceService extends BaseService{\n         // connectionParams json\n         String connectionParams = paramObject.toString();\n \n-        Boolean isConnection = checkConnection(type, connectionParams);\n-        if (!isConnection) {\n-            logger.info(\"connect failed, type:{}, parameter:{}\", type, parameter);\n-            putMsg(result, Status.DATASOURCE_CONNECT_FAILED);\n+        Result<Object> isConnection = checkConnection(type, parameter);\n+        if (Status.SUCCESS.getCode() != isConnection.getCode()) {\n             return result;\n         }\n+\n         Date now = new Date();\n \n         dataSource.setName(name.trim());\n", "next_change": {"commit": "15a5b0588399bbafd201405af02d611d548fac12", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 58bb657c6..8d2a02306 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -132,59 +52,7 @@ public class DataSourceService extends BaseService {\n      * @param id        data source id\n      * @return update result code\n      */\n-    public Result<Object> updateDataSource(int id, User loginUser, String name, String desc, DbType type, String parameter) {\n-\n-        Result<Object> result = new Result<>();\n-        // determine whether the data source exists\n-        DataSource dataSource = dataSourceMapper.selectById(id);\n-        if (dataSource == null) {\n-            putMsg(result, Status.RESOURCE_NOT_EXIST);\n-            return result;\n-        }\n-\n-        if (!hasPerm(loginUser, dataSource.getUserId())) {\n-            putMsg(result, Status.USER_NO_OPERATION_PERM);\n-            return result;\n-        }\n-\n-        //check name can use or not\n-        if (!name.trim().equals(dataSource.getName()) && checkName(name)) {\n-            putMsg(result, Status.DATASOURCE_EXIST);\n-            return result;\n-        }\n-        //check password\uff0cif the password is not updated, set to the old password.\n-        ObjectNode paramObject = JSONUtils.parseObject(parameter);\n-        String password = paramObject.path(Constants.PASSWORD).asText();\n-        if (StringUtils.isBlank(password)) {\n-            String oldConnectionParams = dataSource.getConnectionParams();\n-            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);\n-            paramObject.put(Constants.PASSWORD, oldParams.path(Constants.PASSWORD).asText());\n-        }\n-        // connectionParams json\n-        String connectionParams = paramObject.toString();\n-\n-        Result<Object> isConnection = checkConnection(type, parameter);\n-        if (Status.SUCCESS.getCode() != isConnection.getCode()) {\n-            return result;\n-        }\n-\n-        Date now = new Date();\n-\n-        dataSource.setName(name.trim());\n-        dataSource.setNote(desc);\n-        dataSource.setUserName(loginUser.getUserName());\n-        dataSource.setType(type);\n-        dataSource.setConnectionParams(connectionParams);\n-        dataSource.setUpdateTime(now);\n-        dataSourceMapper.updateById(dataSource);\n-        putMsg(result, Status.SUCCESS);\n-        return result;\n-    }\n-\n-    private boolean checkName(String name) {\n-        List<DataSource> queryDataSource = dataSourceMapper.queryDataSourceByName(name.trim());\n-        return queryDataSource != null && queryDataSource.size() > 0;\n-    }\n+    Result<Object> updateDataSource(int id, User loginUser, String name, String desc, DbType type, String parameter);\n \n     /**\n      * updateProcessInstance datasource\n", "next_change": {"commit": "e6d8da484f8d3eff528b206ab4b159b451865df3", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 8d2a02306..59ada6e05 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -33,26 +34,20 @@ public interface DataSourceService {\n      * create data source\n      *\n      * @param loginUser login user\n-     * @param name      data source name\n-     * @param desc      data source description\n-     * @param type      data source type\n-     * @param parameter datasource parameters\n+     * @param datasourceParam datasource parameter\n      * @return create result code\n      */\n-    Result<Object> createDataSource(User loginUser, String name, String desc, DbType type, String parameter);\n+    Result<Object> createDataSource(User loginUser, BaseDataSourceParamDTO datasourceParam);\n \n     /**\n      * updateProcessInstance datasource\n      *\n      * @param loginUser login user\n-     * @param name      data source name\n-     * @param desc      data source description\n-     * @param type      data source type\n-     * @param parameter datasource parameters\n-     * @param id        data source id\n+     * @param id data source id\n+     * @param dataSourceParam data source params\n      * @return update result code\n      */\n-    Result<Object> updateDataSource(int id, User loginUser, String name, String desc, DbType type, String parameter);\n+    Result<Object> updateDataSource(int id, User loginUser, BaseDataSourceParamDTO dataSourceParam);\n \n     /**\n      * updateProcessInstance datasource\n", "next_change": {"commit": "80da35e39cae8edd5d228d4d189f1eb3d4013aee", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 59ada6e05..c7f3ca0d7 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -55,7 +55,7 @@ public interface DataSourceService {\n      * @param id datasource id\n      * @return data source detail\n      */\n-    Map<String, Object> queryDataSource(int id);\n+    Map<String, Object> queryDataSource(int id, User loginUser);\n \n     /**\n      * query datasource list by keyword\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyMjg2Ng==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435922866", "body": "object is ObjectNode ,why not use toString directly ?", "bodyText": "object is ObjectNode ,why not use toString directly ?", "bodyHTML": "<p dir=\"auto\">object is ObjectNode ,why not use toString directly ?</p>", "author": "gabrywu", "createdAt": "2020-06-05T13:32:21Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java", "diffHunk": "@@ -315,9 +313,9 @@ private void handlePasswd(List<DataSource> dataSourceList) {\n         for (DataSource dataSource : dataSourceList) {\n \n             String connectionParams  = dataSource.getConnectionParams();\n-            JSONObject  object = JSON.parseObject(connectionParams);\n+            ObjectNode  object = JSONUtils.parseObject(connectionParams);\n             object.put(Constants.PASSWORD, Constants.XXXXXX);\n-            dataSource.setConnectionParams(JSONUtils.toJson(object));\n+            dataSource.setConnectionParams(JSONUtils.toJsonString(object));", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fadb69b18134c1160deac9db9a3084217f5aee8f", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex a702ffe1e..b2b42512a 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -313,9 +317,9 @@ public class DataSourceService extends BaseService{\n         for (DataSource dataSource : dataSourceList) {\n \n             String connectionParams  = dataSource.getConnectionParams();\n-            ObjectNode  object = JSONUtils.parseObject(connectionParams);\n+            JSONObject  object = JSON.parseObject(connectionParams);\n             object.put(Constants.PASSWORD, Constants.XXXXXX);\n-            dataSource.setConnectionParams(JSONUtils.toJsonString(object));\n+            dataSource.setConnectionParams(JSONUtils.toJson(object));\n \n         }\n     }\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex b2b42512a..735cd8ce8 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -317,9 +313,9 @@ public class DataSourceService extends BaseService{\n         for (DataSource dataSource : dataSourceList) {\n \n             String connectionParams  = dataSource.getConnectionParams();\n-            JSONObject  object = JSON.parseObject(connectionParams);\n+            ObjectNode  object = JSONUtils.parseObject(connectionParams);\n             object.put(Constants.PASSWORD, Constants.XXXXXX);\n-            dataSource.setConnectionParams(JSONUtils.toJson(object));\n+            dataSource.setConnectionParams(object.toString());\n \n         }\n     }\n", "next_change": {"commit": "1904a7022a38ff9bc8fbe42f1e8e9c4547916fd6", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 735cd8ce8..9092270b4 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -313,9 +327,9 @@ public class DataSourceService extends BaseService{\n         for (DataSource dataSource : dataSourceList) {\n \n             String connectionParams  = dataSource.getConnectionParams();\n-            ObjectNode  object = JSONUtils.parseObject(connectionParams);\n+            JSONObject  object = JSON.parseObject(connectionParams);\n             object.put(Constants.PASSWORD, Constants.XXXXXX);\n-            dataSource.setConnectionParams(object.toString());\n+            dataSource.setConnectionParams(JSONUtils.toJson(object));\n \n         }\n     }\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 9092270b4..1bfacfb93 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -327,9 +313,9 @@ public class DataSourceService extends BaseService{\n         for (DataSource dataSource : dataSourceList) {\n \n             String connectionParams  = dataSource.getConnectionParams();\n-            JSONObject  object = JSON.parseObject(connectionParams);\n+            ObjectNode  object = JSONUtils.parseObject(connectionParams);\n             object.put(Constants.PASSWORD, Constants.XXXXXX);\n-            dataSource.setConnectionParams(JSONUtils.toJson(object));\n+            dataSource.setConnectionParams(object.toString());\n \n         }\n     }\n", "next_change": {"commit": "78eb07b361967a054df6f1435899cee963843855", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 1bfacfb93..69ab6662b 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -306,14 +318,15 @@ public class DataSourceService extends BaseService{\n \n     /**\n      * handle datasource connection password for safety\n+     *\n      * @param dataSourceList\n      */\n     private void handlePasswd(List<DataSource> dataSourceList) {\n \n         for (DataSource dataSource : dataSourceList) {\n \n-            String connectionParams  = dataSource.getConnectionParams();\n-            ObjectNode  object = JSONUtils.parseObject(connectionParams);\n+            String connectionParams = dataSource.getConnectionParams();\n+            ObjectNode object = JSONUtils.parseObject(connectionParams);\n             object.put(Constants.PASSWORD, Constants.XXXXXX);\n             dataSource.setConnectionParams(object.toString());\n \n", "next_change": {"commit": "15a5b0588399bbafd201405af02d611d548fac12", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 69ab6662b..8d2a02306 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -294,44 +71,7 @@ public class DataSourceService extends BaseService {\n      * @param pageSize  page size\n      * @return data source list page\n      */\n-    public Map<String, Object> queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize) {\n-        Map<String, Object> result = new HashMap<>();\n-        IPage<DataSource> dataSourceList = null;\n-        Page<DataSource> dataSourcePage = new Page(pageNo, pageSize);\n-\n-        if (isAdmin(loginUser)) {\n-            dataSourceList = dataSourceMapper.selectPaging(dataSourcePage, 0, searchVal);\n-        } else {\n-            dataSourceList = dataSourceMapper.selectPaging(dataSourcePage, loginUser.getId(), searchVal);\n-        }\n-\n-        List<DataSource> dataSources = dataSourceList != null ? dataSourceList.getRecords() : new ArrayList<>();\n-        handlePasswd(dataSources);\n-        PageInfo pageInfo = new PageInfo<Resource>(pageNo, pageSize);\n-        pageInfo.setTotalCount((int) (dataSourceList != null ? dataSourceList.getTotal() : 0L));\n-        pageInfo.setLists(dataSources);\n-        result.put(Constants.DATA_LIST, pageInfo);\n-        putMsg(result, Status.SUCCESS);\n-\n-        return result;\n-    }\n-\n-    /**\n-     * handle datasource connection password for safety\n-     *\n-     * @param dataSourceList\n-     */\n-    private void handlePasswd(List<DataSource> dataSourceList) {\n-\n-        for (DataSource dataSource : dataSourceList) {\n-\n-            String connectionParams = dataSource.getConnectionParams();\n-            ObjectNode object = JSONUtils.parseObject(connectionParams);\n-            object.put(Constants.PASSWORD, Constants.XXXXXX);\n-            dataSource.setConnectionParams(object.toString());\n-\n-        }\n-    }\n+    Map<String, Object> queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n \n     /**\n      * query data resource list\n", "next_change": {"commit": "f5675170311ccc3cc8e6f88e74c956220297e8cd", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 8d2a02306..dc1637e20 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -71,7 +66,7 @@ public interface DataSourceService {\n      * @param pageSize  page size\n      * @return data source list page\n      */\n-    Map<String, Object> queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n+    Result queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n \n     /**\n      * query data resource list\n", "next_change": {"commit": "5b384f3fab8bc8fbe61cbd3bcb687efd4f34b5a1", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex dc1637e20..eaf1552ca 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -69,13 +69,13 @@ public interface DataSourceService {\n     Result queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n \n     /**\n-     * query data resource list\n+     * query online/test data resource list\n      *\n      * @param loginUser login user\n      * @param type      data source type\n      * @return data source list page\n      */\n-    Map<String, Object> queryDataSourceList(User loginUser, Integer type);\n+    Map<String, Object> queryDataSourceList(User loginUser, Integer type, int testFlag);\n \n     /**\n      * verify datasource exists\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 1bfacfb93..69ab6662b 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -324,17 +337,17 @@ public class DataSourceService extends BaseService{\n      * query data resource list\n      *\n      * @param loginUser login user\n-     * @param type data source type\n+     * @param type      data source type\n      * @return data source list page\n      */\n     public Map<String, Object> queryDataSourceList(User loginUser, Integer type) {\n-        Map<String, Object> result = new HashMap<>(5);\n+        Map<String, Object> result = new HashMap<>();\n \n         List<DataSource> datasourceList;\n \n         if (isAdmin(loginUser)) {\n             datasourceList = dataSourceMapper.listAllDataSourceByType(type);\n-        }else{\n+        } else {\n             datasourceList = dataSourceMapper.queryDataSourceByType(loginUser.getId(), type);\n         }\n \n", "next_change": {"commit": "15a5b0588399bbafd201405af02d611d548fac12", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 69ab6662b..8d2a02306 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -340,22 +80,7 @@ public class DataSourceService extends BaseService {\n      * @param type      data source type\n      * @return data source list page\n      */\n-    public Map<String, Object> queryDataSourceList(User loginUser, Integer type) {\n-        Map<String, Object> result = new HashMap<>();\n-\n-        List<DataSource> datasourceList;\n-\n-        if (isAdmin(loginUser)) {\n-            datasourceList = dataSourceMapper.listAllDataSourceByType(type);\n-        } else {\n-            datasourceList = dataSourceMapper.queryDataSourceByType(loginUser.getId(), type);\n-        }\n-\n-        result.put(Constants.DATA_LIST, datasourceList);\n-        putMsg(result, Status.SUCCESS);\n-\n-        return result;\n-    }\n+    Map<String, Object> queryDataSourceList(User loginUser, Integer type);\n \n     /**\n      * verify datasource exists\n", "next_change": {"commit": "5b384f3fab8bc8fbe61cbd3bcb687efd4f34b5a1", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 8d2a02306..eaf1552ca 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -71,16 +66,16 @@ public interface DataSourceService {\n      * @param pageSize  page size\n      * @return data source list page\n      */\n-    Map<String, Object> queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n+    Result queryDataSourceListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n \n     /**\n-     * query data resource list\n+     * query online/test data resource list\n      *\n      * @param loginUser login user\n      * @param type      data source type\n      * @return data source list page\n      */\n-    Map<String, Object> queryDataSourceList(User loginUser, Integer type);\n+    Map<String, Object> queryDataSourceList(User loginUser, Integer type, int testFlag);\n \n     /**\n      * verify datasource exists\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyNDQ5MA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435924490", "body": "suggest use TypeReference to parse 'other' variable\r\n`TypeReference<HashMap<String, String>> typeRef \r\n  = new TypeReference<HashMap<String, String>>() {};\r\nMap<String, String> map = mapper.readValue(jsonInput, typeRef);`", "bodyText": "suggest use TypeReference to parse 'other' variable\nTypeReference<HashMap<String, String>> typeRef  = new TypeReference<HashMap<String, String>>() {}; Map<String, String> map = mapper.readValue(jsonInput, typeRef);", "bodyHTML": "<p dir=\"auto\">suggest use TypeReference to parse 'other' variable<br>\n<code>TypeReference&lt;HashMap&lt;String, String&gt;&gt; typeRef  = new TypeReference&lt;HashMap&lt;String, String&gt;&gt;() {}; Map&lt;String, String&gt; map = mapper.readValue(jsonInput, typeRef);</code></p>", "author": "gabrywu", "createdAt": "2020-06-05T13:34:59Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java", "diffHunk": "@@ -526,8 +524,7 @@ public String buildParameter(String name, String desc, DbType type, String host,\n             parameterMap.put(Constants.PRINCIPAL,principal);\n         }\n         if (other != null && !\"\".equals(other)) {\n-            LinkedHashMap<String, String> map = JSON.parseObject(other, new TypeReference<LinkedHashMap<String, String>>() {\n-            });\n+            LinkedHashMap<String, String> map = JSONUtils.parseObject(other, LinkedHashMap.class);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fadb69b18134c1160deac9db9a3084217f5aee8f", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex a702ffe1e..b2b42512a 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -524,7 +524,8 @@ public class DataSourceService extends BaseService{\n             parameterMap.put(Constants.PRINCIPAL,principal);\n         }\n         if (other != null && !\"\".equals(other)) {\n-            LinkedHashMap<String, String> map = JSONUtils.parseObject(other, LinkedHashMap.class);\n+            LinkedHashMap<String, String> map = JSON.parseObject(other, new TypeReference<LinkedHashMap<String, String>>() {\n+            });\n             if (map.size() > 0) {\n                 StringBuilder otherSb = new StringBuilder();\n                 for (Map.Entry<String, String> entry: map.entrySet()) {\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex b2b42512a..735cd8ce8 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -524,8 +524,7 @@ public class DataSourceService extends BaseService{\n             parameterMap.put(Constants.PRINCIPAL,principal);\n         }\n         if (other != null && !\"\".equals(other)) {\n-            LinkedHashMap<String, String> map = JSON.parseObject(other, new TypeReference<LinkedHashMap<String, String>>() {\n-            });\n+            Map<String, String> map = JSONUtils.toMap(other);\n             if (map.size() > 0) {\n                 StringBuilder otherSb = new StringBuilder();\n                 for (Map.Entry<String, String> entry: map.entrySet()) {\n", "next_change": {"commit": "1904a7022a38ff9bc8fbe42f1e8e9c4547916fd6", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 735cd8ce8..9092270b4 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -524,7 +534,8 @@ public class DataSourceService extends BaseService{\n             parameterMap.put(Constants.PRINCIPAL,principal);\n         }\n         if (other != null && !\"\".equals(other)) {\n-            Map<String, String> map = JSONUtils.toMap(other);\n+            LinkedHashMap<String, String> map = JSON.parseObject(other, new TypeReference<LinkedHashMap<String, String>>() {\n+            });\n             if (map.size() > 0) {\n                 StringBuilder otherSb = new StringBuilder();\n                 for (Map.Entry<String, String> entry: map.entrySet()) {\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 9092270b4..1bfacfb93 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -534,8 +524,7 @@ public class DataSourceService extends BaseService{\n             parameterMap.put(Constants.PRINCIPAL,principal);\n         }\n         if (other != null && !\"\".equals(other)) {\n-            LinkedHashMap<String, String> map = JSON.parseObject(other, new TypeReference<LinkedHashMap<String, String>>() {\n-            });\n+            Map<String, String> map = JSONUtils.toMap(other);\n             if (map.size() > 0) {\n                 StringBuilder otherSb = new StringBuilder();\n                 for (Map.Entry<String, String> entry: map.entrySet()) {\n", "next_change": {"commit": "78eb07b361967a054df6f1435899cee963843855", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 1bfacfb93..69ab6662b 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -513,21 +526,21 @@ public class DataSourceService extends BaseService{\n             separator = \";\";\n         }\n \n-        Map<String, Object> parameterMap = new LinkedHashMap<String, Object>(6);\n+        parameterMap.put(TYPE, connectType);\n         parameterMap.put(Constants.ADDRESS, address);\n         parameterMap.put(Constants.DATABASE, database);\n         parameterMap.put(Constants.JDBC_URL, jdbcUrl);\n         parameterMap.put(Constants.USER, userName);\n-        parameterMap.put(Constants.PASSWORD, password);\n+        parameterMap.put(Constants.PASSWORD, CommonUtils.encodePassword(password));\n         if (CommonUtils.getKerberosStartupState() &&\n-                (type == DbType.HIVE || type == DbType.SPARK)){\n-            parameterMap.put(Constants.PRINCIPAL,principal);\n+                (type == DbType.HIVE || type == DbType.SPARK)) {\n+            parameterMap.put(Constants.PRINCIPAL, principal);\n         }\n         if (other != null && !\"\".equals(other)) {\n             Map<String, String> map = JSONUtils.toMap(other);\n             if (map.size() > 0) {\n                 StringBuilder otherSb = new StringBuilder();\n-                for (Map.Entry<String, String> entry: map.entrySet()) {\n+                for (Map.Entry<String, String> entry : map.entrySet()) {\n                     otherSb.append(String.format(\"%s=%s%s\", entry.getKey(), entry.getValue(), separator));\n                 }\n                 if (!Constants.DB2.equals(type.name())) {\n", "next_change": {"commit": "3c89c9ad74e55e3aca1a36a4341202e31ceecbf7", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 69ab6662b..1fa0494d1 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -536,19 +539,17 @@ public class DataSourceService extends BaseService {\n                 (type == DbType.HIVE || type == DbType.SPARK)) {\n             parameterMap.put(Constants.PRINCIPAL, principal);\n         }\n-        if (other != null && !\"\".equals(other)) {\n-            Map<String, String> map = JSONUtils.toMap(other);\n-            if (map.size() > 0) {\n-                StringBuilder otherSb = new StringBuilder();\n-                for (Map.Entry<String, String> entry : map.entrySet()) {\n-                    otherSb.append(String.format(\"%s=%s%s\", entry.getKey(), entry.getValue(), separator));\n-                }\n-                if (!Constants.DB2.equals(type.name())) {\n-                    otherSb.deleteCharAt(otherSb.length() - 1);\n-                }\n-                parameterMap.put(Constants.OTHER, otherSb);\n-            }\n \n+        Map<String, String> map = JSONUtils.toMap(other);\n+        if (map != null) {\n+            StringBuilder otherSb = new StringBuilder();\n+            for (Map.Entry<String, String> entry: map.entrySet()) {\n+                otherSb.append(String.format(\"%s=%s%s\", entry.getKey(), entry.getValue(), separator));\n+            }\n+            if (!Constants.DB2.equals(type.name())) {\n+                otherSb.deleteCharAt(otherSb.length() - 1);\n+            }\n+            parameterMap.put(Constants.OTHER, otherSb);\n         }\n \n         if (logger.isDebugEnabled()) {\n", "next_change": {"commit": "91dfe0913f86748130d26edb653dee62d582e5ca", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 1fa0494d1..58bb657c6 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -557,7 +486,6 @@ public class DataSourceService extends BaseService {\n         }\n         return JSONUtils.toJsonString(parameterMap);\n \n-\n     }\n \n     private String buildAddress(DbType type, String host, String port, DbConnectType connectType) {\n", "next_change": {"commit": "15a5b0588399bbafd201405af02d611d548fac12", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 58bb657c6..8d2a02306 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -422,112 +120,10 @@ public class DataSourceService extends BaseService {\n      * @param principal principal\n      * @return datasource parameter\n      */\n-    public String buildParameter(DbType type, String host,\n-                                 String port, String database, String principal, String userName,\n-                                 String password, DbConnectType connectType, String other) {\n-\n-        String address = buildAddress(type, host, port, connectType);\n-        Map<String, Object> parameterMap = new LinkedHashMap<String, Object>(6);\n-        String jdbcUrl;\n-        if (DbType.SQLSERVER == type) {\n-            jdbcUrl = address + \";databaseName=\" + database;\n-        } else {\n-            jdbcUrl = address + \"/\" + database;\n-        }\n-\n-        if (Constants.ORACLE.equals(type.name())) {\n-            parameterMap.put(Constants.ORACLE_DB_CONNECT_TYPE, connectType);\n-        }\n-\n-        if (CommonUtils.getKerberosStartupState()\n-                && (type == DbType.HIVE || type == DbType.SPARK)) {\n-            jdbcUrl += \";principal=\" + principal;\n-        }\n-\n-        String separator = \"\";\n-        if (Constants.MYSQL.equals(type.name())\n-                || Constants.POSTGRESQL.equals(type.name())\n-                || Constants.CLICKHOUSE.equals(type.name())\n-                || Constants.ORACLE.equals(type.name())\n-                || Constants.PRESTO.equals(type.name())) {\n-            separator = \"&\";\n-        } else if (Constants.HIVE.equals(type.name())\n-                || Constants.SPARK.equals(type.name())\n-                || Constants.DB2.equals(type.name())\n-                || Constants.SQLSERVER.equals(type.name())) {\n-            separator = \";\";\n-        }\n-\n-        parameterMap.put(TYPE, connectType);\n-        parameterMap.put(Constants.ADDRESS, address);\n-        parameterMap.put(Constants.DATABASE, database);\n-        parameterMap.put(Constants.JDBC_URL, jdbcUrl);\n-        parameterMap.put(Constants.USER, userName);\n-        parameterMap.put(Constants.PASSWORD, CommonUtils.encodePassword(password));\n-        if (CommonUtils.getKerberosStartupState()\n-                && (type == DbType.HIVE || type == DbType.SPARK)) {\n-            parameterMap.put(Constants.PRINCIPAL, principal);\n-        }\n-\n-        Map<String, String> map = JSONUtils.toMap(other);\n-        if (map != null) {\n-            StringBuilder otherSb = new StringBuilder();\n-            for (Map.Entry<String, String> entry: map.entrySet()) {\n-                otherSb.append(String.format(\"%s=%s%s\", entry.getKey(), entry.getValue(), separator));\n-            }\n-            if (!Constants.DB2.equals(type.name())) {\n-                otherSb.deleteCharAt(otherSb.length() - 1);\n-            }\n-            parameterMap.put(Constants.OTHER, otherSb);\n-        }\n-\n-        if (logger.isDebugEnabled()) {\n-            logger.info(\"parameters map:{}\", JSONUtils.toJsonString(parameterMap));\n-        }\n-        return JSONUtils.toJsonString(parameterMap);\n-\n-    }\n-\n-    private String buildAddress(DbType type, String host, String port, DbConnectType connectType) {\n-        StringBuilder sb = new StringBuilder();\n-        if (Constants.MYSQL.equals(type.name())) {\n-            sb.append(Constants.JDBC_MYSQL);\n-            sb.append(host).append(\":\").append(port);\n-        } else if (Constants.POSTGRESQL.equals(type.name())) {\n-            sb.append(Constants.JDBC_POSTGRESQL);\n-            sb.append(host).append(\":\").append(port);\n-        } else if (Constants.HIVE.equals(type.name()) || Constants.SPARK.equals(type.name())) {\n-            sb.append(Constants.JDBC_HIVE_2);\n-            String[] hostArray = host.split(\",\");\n-            if (hostArray.length > 0) {\n-                for (String zkHost : hostArray) {\n-                    sb.append(String.format(\"%s:%s,\", zkHost, port));\n-                }\n-                sb.deleteCharAt(sb.length() - 1);\n-            }\n-        } else if (Constants.CLICKHOUSE.equals(type.name())) {\n-            sb.append(Constants.JDBC_CLICKHOUSE);\n-            sb.append(host).append(\":\").append(port);\n-        } else if (Constants.ORACLE.equals(type.name())) {\n-            if (connectType == DbConnectType.ORACLE_SID) {\n-                sb.append(Constants.JDBC_ORACLE_SID);\n-            } else {\n-                sb.append(Constants.JDBC_ORACLE_SERVICE_NAME);\n-            }\n-            sb.append(host).append(\":\").append(port);\n-        } else if (Constants.SQLSERVER.equals(type.name())) {\n-            sb.append(Constants.JDBC_SQLSERVER);\n-            sb.append(host).append(\":\").append(port);\n-        } else if (Constants.DB2.equals(type.name())) {\n-            sb.append(Constants.JDBC_DB2);\n-            sb.append(host).append(\":\").append(port);\n-        } else if (Constants.PRESTO.equals(type.name())) {\n-            sb.append(Constants.JDBC_PRESTO);\n-            sb.append(host).append(\":\").append(port);\n-        }\n-\n-        return sb.toString();\n-    }\n+    String buildParameter(DbType type, String host,\n+                          String port, String database, String principal, String userName,\n+                          String password, DbConnectType connectType, String other,\n+                          String javaSecurityKrb5Conf, String loginUserKeytabUsername, String loginUserKeytabPath);\n \n     /**\n      * delete datasource\n", "next_change": {"commit": "e6d8da484f8d3eff528b206ab4b159b451865df3", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\nindex 8d2a02306..59ada6e05 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/DataSourceService.java\n", "chunk": "@@ -107,24 +102,6 @@ public interface DataSourceService {\n      */\n     Result<Object> connectionTest(int id);\n \n-    /**\n-     * build paramters\n-     *\n-     * @param type      data source  type\n-     * @param host      data source  host\n-     * @param port      data source port\n-     * @param database  data source database name\n-     * @param userName  user name\n-     * @param password  password\n-     * @param other     other parameters\n-     * @param principal principal\n-     * @return datasource parameter\n-     */\n-    String buildParameter(DbType type, String host,\n-                          String port, String database, String principal, String userName,\n-                          String password, DbConnectType connectType, String other,\n-                          String javaSecurityKrb5Conf, String loginUserKeytabUsername, String loginUserKeytabPath);\n-\n     /**\n      * delete datasource\n      *\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkzMDUyOA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435930528", "body": "It's better add test code into JSONUtils.toJsonString to cover the List<ProcessMeta> parameter", "bodyText": "It's better add test code into JSONUtils.toJsonString to cover the List parameter", "bodyHTML": "<p dir=\"auto\">It's better add test code into JSONUtils.toJsonString to cover the List parameter</p>", "author": "gabrywu", "createdAt": "2020-06-05T13:44:41Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java", "diffHunk": "@@ -636,7 +636,7 @@ private void downloadProcessDefinitionFile(HttpServletResponse response, List<Pr\n         try {\n             out = response.getOutputStream();\n             buff = new BufferedOutputStream(out);\n-            buff.write(JSON.toJSONString(processDefinitionList).getBytes(StandardCharsets.UTF_8));\n+            buff.write(JSONUtils.toJsonString(processDefinitionList).getBytes(StandardCharsets.UTF_8));", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDU2NA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436230564", "bodyText": "ok", "author": "simon824", "createdAt": "2020-06-06T02:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkzMDUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "133b4de129a407402d1d663b4d00d4f6a776dd28", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex b76bfd00e..6a4eb974c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -505,244 +157,23 @@ public class ProcessDefinitionService extends BaseDAGService {\n      * @param releaseState release state\n      * @return release result code\n      */\n-    @Transactional(rollbackFor = Exception.class)\n-    public Map<String, Object> releaseProcessDefinition(User loginUser, String projectName, int id, int releaseState) {\n-        HashMap<String, Object> result = new HashMap<>();\n-        Project project = projectMapper.queryByName(projectName);\n-\n-        Map<String, Object> checkResult = projectService.checkProjectAndAuth(loginUser, project, projectName);\n-        Status resultEnum = (Status) checkResult.get(Constants.STATUS);\n-        if (resultEnum != Status.SUCCESS) {\n-            return checkResult;\n-        }\n-\n-        ReleaseState state = ReleaseState.getEnum(releaseState);\n-\n-        // check state\n-        if (null == state) {\n-            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, RELEASESTATE);\n-            return result;\n-        }\n-\n-        ProcessDefinition processDefinition = processDefineMapper.selectById(id);\n-\n-        switch (state) {\n-            case ONLINE:\n-                // To check resources whether they are already cancel authorized or deleted\n-                String resourceIds = processDefinition.getResourceIds();\n-                if (StringUtils.isNotBlank(resourceIds)) {\n-                    Integer[] resourceIdArray = Arrays.stream(resourceIds.split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n-                    PermissionCheck<Integer> permissionCheck = new PermissionCheck<>(AuthorizationType.RESOURCE_FILE_ID, processService, resourceIdArray, loginUser.getId(), logger);\n-                    try {\n-                        permissionCheck.checkPermission();\n-                    } catch (Exception e) {\n-                        logger.error(e.getMessage(), e);\n-                        putMsg(result, Status.RESOURCE_NOT_EXIST_OR_NO_PERMISSION, RELEASESTATE);\n-                        return result;\n-                    }\n-                }\n-\n-                processDefinition.setReleaseState(state);\n-                processDefineMapper.updateById(processDefinition);\n-                break;\n-            case OFFLINE:\n-                processDefinition.setReleaseState(state);\n-                processDefineMapper.updateById(processDefinition);\n-                List<Schedule> scheduleList = scheduleMapper.selectAllByProcessDefineArray(\n-                        new int[]{processDefinition.getId()}\n-                );\n-\n-                for (Schedule schedule : scheduleList) {\n-                    logger.info(\"set schedule offline, project id: {}, schedule id: {}, process definition id: {}\", project.getId(), schedule.getId(), id);\n-                    // set status\n-                    schedule.setReleaseState(ReleaseState.OFFLINE);\n-                    scheduleMapper.updateById(schedule);\n-                    SchedulerService.deleteSchedule(project.getId(), schedule.getId());\n-                }\n-                break;\n-            default:\n-                putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, RELEASESTATE);\n-                return result;\n-        }\n-\n-        putMsg(result, Status.SUCCESS);\n-        return result;\n-    }\n+    Map<String, Object> releaseProcessDefinition(User loginUser,\n+                                                 String projectName,\n+                                                 int id,\n+                                                 int releaseState);\n \n     /**\n      * batch export process definition by ids\n      *\n-     * @param loginUser\n-     * @param projectName\n-     * @param processDefinitionIds\n-     * @param response\n+     * @param loginUser            login user\n+     * @param projectName          project name\n+     * @param processDefinitionIds process definition ids\n+     * @param response             http servlet response\n      */\n-    public void batchExportProcessDefinitionByIds(User loginUser, String projectName, String processDefinitionIds, HttpServletResponse response) {\n-\n-        if (StringUtils.isEmpty(processDefinitionIds)) {\n-            return;\n-        }\n-\n-        //export project info\n-        Project project = projectMapper.queryByName(projectName);\n-\n-        //check user access for project\n-        Map<String, Object> checkResult = projectService.checkProjectAndAuth(loginUser, project, projectName);\n-        Status resultStatus = (Status) checkResult.get(Constants.STATUS);\n-\n-        if (resultStatus != Status.SUCCESS) {\n-            return;\n-        }\n-\n-        List<ProcessMeta> processDefinitionList =\n-                getProcessDefinitionList(processDefinitionIds);\n-\n-        if (CollectionUtils.isNotEmpty(processDefinitionList)) {\n-            downloadProcessDefinitionFile(response, processDefinitionList);\n-        }\n-    }\n-\n-    /**\n-     * get process definition list by ids\n-     *\n-     * @param processDefinitionIds\n-     * @return\n-     */\n-    private List<ProcessMeta> getProcessDefinitionList(String processDefinitionIds) {\n-        List<ProcessMeta> processDefinitionList = new ArrayList<>();\n-        String[] processDefinitionIdArray = processDefinitionIds.split(\",\");\n-        for (String strProcessDefinitionId : processDefinitionIdArray) {\n-            //get workflow info\n-            int processDefinitionId = Integer.parseInt(strProcessDefinitionId);\n-            ProcessDefinition processDefinition = processDefineMapper.queryByDefineId(processDefinitionId);\n-            if (null != processDefinition) {\n-                processDefinitionList.add(exportProcessMetaData(processDefinitionId, processDefinition));\n-            }\n-        }\n-\n-        return processDefinitionList;\n-    }\n-\n-    /**\n-     * download the process definition file\n-     *\n-     * @param response\n-     * @param processDefinitionList\n-     */\n-    private void downloadProcessDefinitionFile(HttpServletResponse response, List<ProcessMeta> processDefinitionList) {\n-        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);\n-        BufferedOutputStream buff = null;\n-        ServletOutputStream out = null;\n-        try {\n-            out = response.getOutputStream();\n-            buff = new BufferedOutputStream(out);\n-            buff.write(JSONUtils.toJsonString(processDefinitionList).getBytes(StandardCharsets.UTF_8));\n-            buff.flush();\n-            buff.close();\n-        } catch (IOException e) {\n-            logger.warn(\"export process fail\", e);\n-        } finally {\n-            if (null != buff) {\n-                try {\n-                    buff.close();\n-                } catch (Exception e) {\n-                    logger.warn(\"export process buffer not close\", e);\n-                }\n-            }\n-            if (null != out) {\n-                try {\n-                    out.close();\n-                } catch (Exception e) {\n-                    logger.warn(\"export process output stream not close\", e);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * get export process metadata string\n-     *\n-     * @param processDefinitionId process definition id\n-     * @param processDefinition   process definition\n-     * @return export process metadata string\n-     */\n-    public String exportProcessMetaDataStr(Integer processDefinitionId, ProcessDefinition processDefinition) {\n-        //create workflow json file\n-        return JSONUtils.toJsonString(exportProcessMetaData(processDefinitionId, processDefinition));\n-    }\n-\n-    /**\n-     * get export process metadata string\n-     *\n-     * @param processDefinitionId process definition id\n-     * @param processDefinition   process definition\n-     * @return export process metadata string\n-     */\n-    public ProcessMeta exportProcessMetaData(Integer processDefinitionId, ProcessDefinition processDefinition) {\n-        //correct task param which has data source or dependent param\n-        String correctProcessDefinitionJson = addExportTaskNodeSpecialParam(processDefinition.getProcessDefinitionJson());\n-        processDefinition.setProcessDefinitionJson(correctProcessDefinitionJson);\n-\n-        //export process metadata\n-        ProcessMeta exportProcessMeta = new ProcessMeta();\n-        exportProcessMeta.setProjectName(processDefinition.getProjectName());\n-        exportProcessMeta.setProcessDefinitionName(processDefinition.getName());\n-        exportProcessMeta.setProcessDefinitionJson(processDefinition.getProcessDefinitionJson());\n-        exportProcessMeta.setProcessDefinitionLocations(processDefinition.getLocations());\n-        exportProcessMeta.setProcessDefinitionConnects(processDefinition.getConnects());\n-\n-        //schedule info\n-        List<Schedule> schedules = scheduleMapper.queryByProcessDefinitionId(processDefinitionId);\n-        if (!schedules.isEmpty()) {\n-            Schedule schedule = schedules.get(0);\n-            exportProcessMeta.setScheduleWarningType(schedule.getWarningType().toString());\n-            exportProcessMeta.setScheduleWarningGroupId(schedule.getWarningGroupId());\n-            exportProcessMeta.setScheduleStartTime(DateUtils.dateToString(schedule.getStartTime()));\n-            exportProcessMeta.setScheduleEndTime(DateUtils.dateToString(schedule.getEndTime()));\n-            exportProcessMeta.setScheduleCrontab(schedule.getCrontab());\n-            exportProcessMeta.setScheduleFailureStrategy(String.valueOf(schedule.getFailureStrategy()));\n-            exportProcessMeta.setScheduleReleaseState(String.valueOf(ReleaseState.OFFLINE));\n-            exportProcessMeta.setScheduleProcessInstancePriority(String.valueOf(schedule.getProcessInstancePriority()));\n-            exportProcessMeta.setScheduleWorkerGroupName(schedule.getWorkerGroup());\n-        }\n-        //create workflow json file\n-        return exportProcessMeta;\n-    }\n-\n-    /**\n-     * correct task param which has datasource or dependent\n-     *\n-     * @param processDefinitionJson processDefinitionJson\n-     * @return correct processDefinitionJson\n-     */\n-    public String addExportTaskNodeSpecialParam(String processDefinitionJson) {\n-        ObjectNode jsonObject = JSONUtils.parseObject(processDefinitionJson);\n-        ArrayNode jsonArray = (ArrayNode) jsonObject.path(TASKS);\n-\n-        for (int i = 0; i < jsonArray.size(); i++) {\n-            JsonNode taskNode = jsonArray.path(i);\n-            if (StringUtils.isNotEmpty(taskNode.path(\"type\").asText())) {\n-                String taskType = taskNode.path(\"type\").asText();\n-\n-                ProcessAddTaskParam addTaskParam = TaskNodeParamFactory.getByTaskType(taskType);\n-                if (null != addTaskParam) {\n-                    addTaskParam.addExportSpecialParam(taskNode);\n-                }\n-            }\n-        }\n-        jsonObject.set(TASKS, jsonArray);\n-        return jsonObject.toString();\n-    }\n-\n-    /**\n-     * check task if has sub process\n-     *\n-     * @param taskType task type\n-     * @return if task has sub process return true else false\n-     */\n-    private boolean checkTaskHasSubProcess(String taskType) {\n-        return taskType.equals(TaskType.SUB_PROCESS.name());\n-    }\n+    void batchExportProcessDefinitionByIds(User loginUser,\n+                                          String projectName,\n+                                          String processDefinitionIds,\n+                                          HttpServletResponse response);\n \n     /**\n      * import process definition\n", "next_change": {"commit": "93660f4d617d750d803cc3a7f68fe06c6f694463", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 6a4eb974c..f6f786b6b 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -165,21 +182,21 @@ public interface ProcessDefinitionService {\n     /**\n      * batch export process definition by ids\n      *\n-     * @param loginUser            login user\n-     * @param projectName          project name\n+     * @param loginUser login user\n+     * @param projectName project name\n      * @param processDefinitionIds process definition ids\n-     * @param response             http servlet response\n+     * @param response http servlet response\n      */\n     void batchExportProcessDefinitionByIds(User loginUser,\n-                                          String projectName,\n-                                          String processDefinitionIds,\n-                                          HttpServletResponse response);\n+                                           String projectName,\n+                                           String processDefinitionIds,\n+                                           HttpServletResponse response);\n \n     /**\n      * import process definition\n      *\n-     * @param loginUser          login user\n-     * @param file               process metadata json file\n+     * @param loginUser login user\n+     * @param file process metadata json file\n      * @param currentProjectName current project name\n      * @return import process\n      */\n", "next_change": {"commit": "14035c03e2aaaebf1d0a9a1ae1c92118b855383e", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex f6f786b6b..0b55b2822 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -196,13 +224,13 @@ public interface ProcessDefinitionService {\n      * import process definition\n      *\n      * @param loginUser login user\n+     * @param projectCode project code\n      * @param file process metadata json file\n-     * @param currentProjectName current project name\n      * @return import process\n      */\n     Map<String, Object> importProcessDefinition(User loginUser,\n-                                                MultipartFile file,\n-                                                String currentProjectName);\n+                                                long projectCode,\n+                                                MultipartFile file);\n \n     /**\n      * check the process definition node meets the specifications\n", "next_change": {"commit": "8bd88d90c4852e5c58ef71a6c65acecbc3a930a9", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 0b55b2822..6290c310c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -233,30 +229,36 @@ public interface ProcessDefinitionService {\n                                                 MultipartFile file);\n \n     /**\n-     * check the process definition node meets the specifications\n+     * check the process task relation json\n      *\n-     * @param processData process data\n-     * @param processDefinitionJson process definition json\n+     * @param processTaskRelationJson process task relation json\n      * @return check result code\n      */\n-    Map<String, Object> checkProcessNodeList(ProcessData processData,\n-                                             String processDefinitionJson);\n+    Map<String, Object> checkProcessNodeList(String processTaskRelationJson);\n \n     /**\n      * get task node details based on process definition\n      *\n+     * @param loginUser loginUser\n+     * @param projectCode project code\n      * @param defineCode define code\n      * @return task node list\n      */\n-    Map<String, Object> getTaskNodeListByDefinitionCode(Long defineCode);\n+    Map<String, Object> getTaskNodeListByDefinitionCode(User loginUser,\n+                                                        long projectCode,\n+                                                        long defineCode);\n \n     /**\n-     * get task node details based on process definition\n+     * get task node details map based on process definition\n      *\n+     * @param loginUser loginUser\n+     * @param projectCode project code\n      * @param defineCodeList define code list\n      * @return task node list\n      */\n-    Map<String, Object> getTaskNodeListByDefinitionCodeList(String defineCodeList);\n+    Map<String, Object> getNodeListMapByDefinitionCodes(User loginUser,\n+                                                        long projectCode,\n+                                                        String defineCodeList);\n \n     /**\n      * query process definition all by project code\n", "next_change": {"commit": "effbad4e206fc79f5aa66b65443b2fed1927879a", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 6290c310c..42fce02ba 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -241,24 +242,24 @@ public interface ProcessDefinitionService {\n      *\n      * @param loginUser loginUser\n      * @param projectCode project code\n-     * @param defineCode define code\n+     * @param code processDefinition code\n      * @return task node list\n      */\n     Map<String, Object> getTaskNodeListByDefinitionCode(User loginUser,\n                                                         long projectCode,\n-                                                        long defineCode);\n+                                                        long code);\n \n     /**\n      * get task node details map based on process definition\n      *\n      * @param loginUser loginUser\n      * @param projectCode project code\n-     * @param defineCodeList define code list\n+     * @param codes define code list\n      * @return task node list\n      */\n     Map<String, Object> getNodeListMapByDefinitionCodes(User loginUser,\n                                                         long projectCode,\n-                                                        String defineCodeList);\n+                                                        String codes);\n \n     /**\n      * query process definition all by project code\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkzMTkyOQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r435931929", "body": "why not use JSONUtils.toList", "bodyText": "why not use JSONUtils.toList", "bodyHTML": "<p dir=\"auto\">why not use JSONUtils.toList</p>", "author": "gabrywu", "createdAt": "2020-06-05T13:46:51Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java", "diffHunk": "@@ -756,8 +756,13 @@ private boolean checkTaskHasSubProcess(String taskType) {\n     public Map<String, Object> importProcessDefinition(User loginUser, MultipartFile file, String currentProjectName) {\n         Map<String, Object> result = new HashMap<>(5);\n         String processMetaJson = FileUtils.file2String(file);\n-        List<ProcessMeta> processMetaList = JSON.parseArray(processMetaJson, ProcessMeta.class);\n+        List<ProcessMeta> processMetaList = new ArrayList<>();\n \n+        try {\n+            processMetaList = JSONUtils.getMapper().readValue(processMetaJson, new TypeReference<List<ProcessMeta>>() {});", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDUxNw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436230517", "bodyText": "toList will return List< LinkedHashMap > and will Cause  exception :\n\" Could not write JSON: java.util.LinkedHashMap cannot be cast to org.apache.dolphinscheduler.common.process.Property\"", "author": "simon824", "createdAt": "2020-06-06T02:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkzMTkyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex b76bfd00e..c3d8516ed 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -756,13 +756,8 @@ public class ProcessDefinitionService extends BaseDAGService {\n     public Map<String, Object> importProcessDefinition(User loginUser, MultipartFile file, String currentProjectName) {\n         Map<String, Object> result = new HashMap<>(5);\n         String processMetaJson = FileUtils.file2String(file);\n-        List<ProcessMeta> processMetaList = new ArrayList<>();\n+        List<ProcessMeta>  processMetaList = JSONUtils.toList(processMetaJson, ProcessMeta.class);\n \n-        try {\n-            processMetaList = JSONUtils.getMapper().readValue(processMetaJson, new TypeReference<List<ProcessMeta>>() {});\n-        } catch (Exception e) {\n-            logger.error(\"parse list exception!\", e);\n-        }\n         //check file content\n         if (CollectionUtils.isEmpty(processMetaList)) {\n             putMsg(result, Status.DATA_IS_NULL, \"fileContent\");\n", "next_change": {"commit": "133b4de129a407402d1d663b4d00d4f6a776dd28", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex c3d8516ed..6a4eb974c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -752,357 +183,9 @@ public class ProcessDefinitionService extends BaseDAGService {\n      * @param currentProjectName current project name\n      * @return import process\n      */\n-    @Transactional(rollbackFor = Exception.class)\n-    public Map<String, Object> importProcessDefinition(User loginUser, MultipartFile file, String currentProjectName) {\n-        Map<String, Object> result = new HashMap<>(5);\n-        String processMetaJson = FileUtils.file2String(file);\n-        List<ProcessMeta>  processMetaList = JSONUtils.toList(processMetaJson, ProcessMeta.class);\n-\n-        //check file content\n-        if (CollectionUtils.isEmpty(processMetaList)) {\n-            putMsg(result, Status.DATA_IS_NULL, \"fileContent\");\n-            return result;\n-        }\n-\n-        for (ProcessMeta processMeta : processMetaList) {\n-\n-            if (!checkAndImportProcessDefinition(loginUser, currentProjectName, result, processMeta)) {\n-                return result;\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * check and import process definition\n-     *\n-     * @param loginUser\n-     * @param currentProjectName\n-     * @param result\n-     * @param processMeta\n-     * @return\n-     */\n-    private boolean checkAndImportProcessDefinition(User loginUser, String currentProjectName, Map<String, Object> result, ProcessMeta processMeta) {\n-\n-        if (!checkImportanceParams(processMeta, result)) {\n-            return false;\n-        }\n-\n-        //deal with process name\n-        String processDefinitionName = processMeta.getProcessDefinitionName();\n-        //use currentProjectName to query\n-        Project targetProject = projectMapper.queryByName(currentProjectName);\n-        if (null != targetProject) {\n-            processDefinitionName = recursionProcessDefinitionName(targetProject.getId(),\n-                    processDefinitionName, 1);\n-        }\n-\n-        //unique check\n-        Map<String, Object> checkResult = verifyProcessDefinitionName(loginUser, currentProjectName, processDefinitionName);\n-        Status status = (Status) checkResult.get(Constants.STATUS);\n-        if (Status.SUCCESS.equals(status)) {\n-            putMsg(result, Status.SUCCESS);\n-        } else {\n-            result.putAll(checkResult);\n-            return false;\n-        }\n-\n-        // get create process result\n-        Map<String, Object> createProcessResult =\n-                getCreateProcessResult(loginUser,\n-                        currentProjectName,\n-                        result,\n-                        processMeta,\n-                        processDefinitionName,\n-                        addImportTaskNodeParam(loginUser, processMeta.getProcessDefinitionJson(), targetProject));\n-\n-        if (createProcessResult == null) {\n-            return false;\n-        }\n-\n-        //create process definition\n-        Integer processDefinitionId =\n-                Objects.isNull(createProcessResult.get(PROCESSDEFINITIONID)) ?\n-                        null : Integer.parseInt(createProcessResult.get(PROCESSDEFINITIONID).toString());\n-\n-        //scheduler param\n-        return getImportProcessScheduleResult(loginUser,\n-                currentProjectName,\n-                result,\n-                processMeta,\n-                processDefinitionName,\n-                processDefinitionId);\n-\n-    }\n-\n-    /**\n-     * get create process result\n-     *\n-     * @param loginUser\n-     * @param currentProjectName\n-     * @param result\n-     * @param processMeta\n-     * @param processDefinitionName\n-     * @param importProcessParam\n-     * @return\n-     */\n-    private Map<String, Object> getCreateProcessResult(User loginUser,\n-                                                       String currentProjectName,\n-                                                       Map<String, Object> result,\n-                                                       ProcessMeta processMeta,\n-                                                       String processDefinitionName,\n-                                                       String importProcessParam) {\n-        Map<String, Object> createProcessResult = null;\n-        try {\n-            createProcessResult = createProcessDefinition(loginUser\n-                    , currentProjectName,\n-                    processDefinitionName + \"_import_\" + System.currentTimeMillis(),\n-                    importProcessParam,\n-                    processMeta.getProcessDefinitionDescription(),\n-                    processMeta.getProcessDefinitionLocations(),\n-                    processMeta.getProcessDefinitionConnects());\n-            putMsg(result, Status.SUCCESS);\n-        } catch (JsonProcessingException e) {\n-            logger.error(\"import process meta json data: {}\", e.getMessage(), e);\n-            putMsg(result, Status.IMPORT_PROCESS_DEFINE_ERROR);\n-        }\n-\n-        return createProcessResult;\n-    }\n-\n-    /**\n-     * get import process schedule result\n-     *\n-     * @param loginUser\n-     * @param currentProjectName\n-     * @param result\n-     * @param processMeta\n-     * @param processDefinitionName\n-     * @param processDefinitionId\n-     * @return\n-     */\n-    private boolean getImportProcessScheduleResult(User loginUser,\n-                                                   String currentProjectName,\n-                                                   Map<String, Object> result,\n-                                                   ProcessMeta processMeta,\n-                                                   String processDefinitionName,\n-                                                   Integer processDefinitionId) {\n-        if (null != processMeta.getScheduleCrontab() && null != processDefinitionId) {\n-            int scheduleInsert = importProcessSchedule(loginUser,\n-                    currentProjectName,\n-                    processMeta,\n-                    processDefinitionName,\n-                    processDefinitionId);\n-\n-            if (0 == scheduleInsert) {\n-                putMsg(result, Status.IMPORT_PROCESS_DEFINE_ERROR);\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * check importance params\n-     *\n-     * @param processMeta\n-     * @param result\n-     * @return\n-     */\n-    private boolean checkImportanceParams(ProcessMeta processMeta, Map<String, Object> result) {\n-        if (StringUtils.isEmpty(processMeta.getProjectName())) {\n-            putMsg(result, Status.DATA_IS_NULL, \"projectName\");\n-            return false;\n-        }\n-        if (StringUtils.isEmpty(processMeta.getProcessDefinitionName())) {\n-            putMsg(result, Status.DATA_IS_NULL, \"processDefinitionName\");\n-            return false;\n-        }\n-        if (StringUtils.isEmpty(processMeta.getProcessDefinitionJson())) {\n-            putMsg(result, Status.DATA_IS_NULL, \"processDefinitionJson\");\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    /**\n-     * import process add special task param\n-     *\n-     * @param loginUser             login user\n-     * @param processDefinitionJson process definition json\n-     * @param targetProject         target project\n-     * @return import process param\n-     */\n-    private String addImportTaskNodeParam(User loginUser, String processDefinitionJson, Project targetProject) {\n-        ObjectNode jsonObject = JSONUtils.parseObject(processDefinitionJson);\n-        ArrayNode jsonArray = (ArrayNode) jsonObject.get(TASKS);\n-        //add sql and dependent param\n-        for (int i = 0; i < jsonArray.size(); i++) {\n-            JsonNode taskNode = jsonArray.path(i);\n-            String taskType = taskNode.path(\"type\").asText();\n-            ProcessAddTaskParam addTaskParam = TaskNodeParamFactory.getByTaskType(taskType);\n-            if (null != addTaskParam) {\n-                addTaskParam.addImportSpecialParam(taskNode);\n-            }\n-        }\n-\n-        //recursive sub-process parameter correction map key for old process id value for new process id\n-        Map<Integer, Integer> subProcessIdMap = new HashMap<>(20);\n-\n-        List<Object> subProcessList = StreamUtils.asStream(jsonArray.elements())\n-                .filter(elem -> checkTaskHasSubProcess(JSONUtils.parseObject(elem.toString()).path(\"type\").asText()))\n-                .collect(Collectors.toList());\n-\n-        if (CollectionUtils.isNotEmpty(subProcessList)) {\n-            importSubProcess(loginUser, targetProject, jsonArray, subProcessIdMap);\n-        }\n-\n-        jsonObject.set(TASKS, jsonArray);\n-        return jsonObject.toString();\n-    }\n-\n-    /**\n-     * import process schedule\n-     *\n-     * @param loginUser             login user\n-     * @param currentProjectName    current project name\n-     * @param processMeta           process meta data\n-     * @param processDefinitionName process definition name\n-     * @param processDefinitionId   process definition id\n-     * @return insert schedule flag\n-     */\n-    public int importProcessSchedule(User loginUser, String currentProjectName, ProcessMeta processMeta,\n-                                     String processDefinitionName, Integer processDefinitionId) {\n-        Date now = new Date();\n-        Schedule scheduleObj = new Schedule();\n-        scheduleObj.setProjectName(currentProjectName);\n-        scheduleObj.setProcessDefinitionId(processDefinitionId);\n-        scheduleObj.setProcessDefinitionName(processDefinitionName);\n-        scheduleObj.setCreateTime(now);\n-        scheduleObj.setUpdateTime(now);\n-        scheduleObj.setUserId(loginUser.getId());\n-        scheduleObj.setUserName(loginUser.getUserName());\n-\n-        scheduleObj.setCrontab(processMeta.getScheduleCrontab());\n-\n-        if (null != processMeta.getScheduleStartTime()) {\n-            scheduleObj.setStartTime(DateUtils.stringToDate(processMeta.getScheduleStartTime()));\n-        }\n-        if (null != processMeta.getScheduleEndTime()) {\n-            scheduleObj.setEndTime(DateUtils.stringToDate(processMeta.getScheduleEndTime()));\n-        }\n-        if (null != processMeta.getScheduleWarningType()) {\n-            scheduleObj.setWarningType(WarningType.valueOf(processMeta.getScheduleWarningType()));\n-        }\n-        if (null != processMeta.getScheduleWarningGroupId()) {\n-            scheduleObj.setWarningGroupId(processMeta.getScheduleWarningGroupId());\n-        }\n-        if (null != processMeta.getScheduleFailureStrategy()) {\n-            scheduleObj.setFailureStrategy(FailureStrategy.valueOf(processMeta.getScheduleFailureStrategy()));\n-        }\n-        if (null != processMeta.getScheduleReleaseState()) {\n-            scheduleObj.setReleaseState(ReleaseState.valueOf(processMeta.getScheduleReleaseState()));\n-        }\n-        if (null != processMeta.getScheduleProcessInstancePriority()) {\n-            scheduleObj.setProcessInstancePriority(Priority.valueOf(processMeta.getScheduleProcessInstancePriority()));\n-        }\n-\n-        if (null != processMeta.getScheduleWorkerGroupName()) {\n-            scheduleObj.setWorkerGroup(processMeta.getScheduleWorkerGroupName());\n-        }\n-\n-        return scheduleMapper.insert(scheduleObj);\n-    }\n-\n-    /**\n-     * check import process has sub process\n-     * recursion create sub process\n-     *\n-     * @param loginUser       login user\n-     * @param targetProject   target project\n-     * @param jsonArray       process task array\n-     * @param subProcessIdMap correct sub process id map\n-     */\n-    public void importSubProcess(User loginUser, Project targetProject, ArrayNode jsonArray, Map<Integer, Integer> subProcessIdMap) {\n-        for (int i = 0; i < jsonArray.size(); i++) {\n-            ObjectNode taskNode = (ObjectNode) jsonArray.path(i);\n-            String taskType = taskNode.path(\"type\").asText();\n-\n-            if (!checkTaskHasSubProcess(taskType)) {\n-                continue;\n-            }\n-            //get sub process info\n-            ObjectNode subParams = (ObjectNode) taskNode.path(\"params\");\n-            Integer subProcessId = subParams.path(PROCESSDEFINITIONID).asInt();\n-            ProcessDefinition subProcess = processDefineMapper.queryByDefineId(subProcessId);\n-            //check is sub process exist in db\n-            if (null == subProcess) {\n-                continue;\n-            }\n-            String subProcessJson = subProcess.getProcessDefinitionJson();\n-            //check current project has sub process\n-            ProcessDefinition currentProjectSubProcess = processDefineMapper.queryByDefineName(targetProject.getId(), subProcess.getName());\n-\n-            if (null == currentProjectSubProcess) {\n-                ArrayNode subJsonArray = (ArrayNode) JSONUtils.parseObject(subProcess.getProcessDefinitionJson()).get(TASKS);\n-\n-                List<Object> subProcessList = StreamUtils.asStream(subJsonArray.elements())\n-                        .filter(item -> checkTaskHasSubProcess(JSONUtils.parseObject(item.toString()).path(\"type\").asText()))\n-                        .collect(Collectors.toList());\n-\n-                if (CollectionUtils.isNotEmpty(subProcessList)) {\n-                    importSubProcess(loginUser, targetProject, subJsonArray, subProcessIdMap);\n-                    //sub process processId correct\n-                    if (!subProcessIdMap.isEmpty()) {\n-\n-                        for (Map.Entry<Integer, Integer> entry : subProcessIdMap.entrySet()) {\n-                            String oldSubProcessId = \"\\\"processDefinitionId\\\":\" + entry.getKey();\n-                            String newSubProcessId = \"\\\"processDefinitionId\\\":\" + entry.getValue();\n-                            subProcessJson = subProcessJson.replaceAll(oldSubProcessId, newSubProcessId);\n-                        }\n-\n-                        subProcessIdMap.clear();\n-                    }\n-                }\n-\n-                //if sub-process recursion\n-                Date now = new Date();\n-                //create sub process in target project\n-                ProcessDefinition processDefine = new ProcessDefinition();\n-                processDefine.setName(subProcess.getName());\n-                processDefine.setVersion(subProcess.getVersion());\n-                processDefine.setReleaseState(subProcess.getReleaseState());\n-                processDefine.setProjectId(targetProject.getId());\n-                processDefine.setUserId(loginUser.getId());\n-                processDefine.setProcessDefinitionJson(subProcessJson);\n-                processDefine.setDescription(subProcess.getDescription());\n-                processDefine.setLocations(subProcess.getLocations());\n-                processDefine.setConnects(subProcess.getConnects());\n-                processDefine.setTimeout(subProcess.getTimeout());\n-                processDefine.setTenantId(subProcess.getTenantId());\n-                processDefine.setGlobalParams(subProcess.getGlobalParams());\n-                processDefine.setCreateTime(now);\n-                processDefine.setUpdateTime(now);\n-                processDefine.setFlag(subProcess.getFlag());\n-                processDefine.setReceivers(subProcess.getReceivers());\n-                processDefine.setReceiversCc(subProcess.getReceiversCc());\n-                processDefineMapper.insert(processDefine);\n-\n-                logger.info(\"create sub process, project: {}, process name: {}\", targetProject.getName(), processDefine.getName());\n-\n-                //modify task node\n-                ProcessDefinition newSubProcessDefine = processDefineMapper.queryByDefineName(processDefine.getProjectId(), processDefine.getName());\n-\n-                if (null != newSubProcessDefine) {\n-                    subProcessIdMap.put(subProcessId, newSubProcessDefine.getId());\n-                    subParams.put(PROCESSDEFINITIONID, newSubProcessDefine.getId());\n-                    taskNode.set(\"params\", subParams);\n-                }\n-            }\n-        }\n-    }\n+    Map<String, Object> importProcessDefinition(User loginUser,\n+                                                MultipartFile file,\n+                                                String currentProjectName);\n \n \n     /**\n", "next_change": {"commit": "46ab86d6dff94827bd265965f0c70b4f9c979868", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 6a4eb974c..cc18de439 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -187,7 +199,6 @@ public interface ProcessDefinitionService {\n                                                 MultipartFile file,\n                                                 String currentProjectName);\n \n-\n     /**\n      * check the process definition node meets the specifications\n      *\n", "next_change": {"commit": "93660f4d617d750d803cc3a7f68fe06c6f694463", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex cc18de439..f6f786b6b 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -202,7 +207,7 @@ public interface ProcessDefinitionService {\n     /**\n      * check the process definition node meets the specifications\n      *\n-     * @param processData           process data\n+     * @param processData process data\n      * @param processDefinitionJson process definition json\n      * @return check result code\n      */\n", "next_change": {"commit": "8bd88d90c4852e5c58ef71a6c65acecbc3a930a9", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex f6f786b6b..6290c310c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -76,189 +81,246 @@ public interface ProcessDefinitionService {\n      * @return process definition page\n      */\n     Map<String, Object> queryProcessDefinitionListPaging(User loginUser,\n-                                                         String projectName,\n+                                                         long projectCode,\n                                                          String searchVal,\n                                                          Integer pageNo,\n                                                          Integer pageSize,\n                                                          Integer userId);\n \n+    /**\n+     * query detail of process definition\n+     *\n+     * @param loginUser login user\n+     * @param projectCode project code\n+     * @param code process definition code\n+     * @return process definition detail\n+     */\n+\n+    Map<String, Object> queryProcessDefinitionByCode(User loginUser,\n+                                                     long projectCode,\n+                                                     long code);\n+\n     /**\n      * query datail of process definition\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n-     * @param processId process definition id\n+     * @param projectCode project code\n+     * @param processDefinitionName process definition name\n      * @return process definition detail\n      */\n \n-    Map<String, Object> queryProcessDefinitionById(User loginUser,\n-                                                   String projectName,\n-                                                   Integer processId);\n+    Map<String, Object> queryProcessDefinitionByName(User loginUser,\n+                                                     long projectCode,\n+                                                     String processDefinitionName);\n \n     /**\n      * batch copy process definition\n      *\n      * @param loginUser loginUser\n-     * @param projectName projectName\n-     * @param processDefinitionIds processDefinitionIds\n-     * @param targetProjectId targetProjectId\n+     * @param projectCode projectCode\n+     * @param processDefinitionCodes processDefinitionCodes\n+     * @param targetProjectCode targetProjectCode\n      */\n     Map<String, Object> batchCopyProcessDefinition(User loginUser,\n-                                                   String projectName,\n-                                                   String processDefinitionIds,\n-                                                   int targetProjectId);\n+                                                   long projectCode,\n+                                                   String processDefinitionCodes,\n+                                                   long targetProjectCode);\n \n     /**\n      * batch move process definition\n      *\n      * @param loginUser loginUser\n-     * @param projectName projectName\n-     * @param processDefinitionIds processDefinitionIds\n-     * @param targetProjectId targetProjectId\n+     * @param projectCode projectCode\n+     * @param processDefinitionCodes processDefinitionCodes\n+     * @param targetProjectCode targetProjectCode\n      */\n     Map<String, Object> batchMoveProcessDefinition(User loginUser,\n-                                                   String projectName,\n-                                                   String processDefinitionIds,\n-                                                   int targetProjectId);\n+                                                   long projectCode,\n+                                                   String processDefinitionCodes,\n+                                                   long targetProjectCode);\n \n     /**\n      * update  process definition\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param name process definition name\n-     * @param id process definition id\n-     * @param processDefinitionJson process definition json\n-     * @param desc description\n+     * @param code process definition code\n+     * @param description description\n+     * @param globalParams global params\n      * @param locations locations for nodes\n-     * @param connects connects for nodes\n+     * @param timeout timeout\n+     * @param tenantCode tenantCode\n+     * @param taskRelationJson relation json for nodes\n      * @return update result code\n      */\n     Map<String, Object> updateProcessDefinition(User loginUser,\n-                                                String projectName,\n-                                                int id,\n+                                                long projectCode,\n                                                 String name,\n-                                                String processDefinitionJson, String desc,\n-                                                String locations, String connects);\n+                                                long code,\n+                                                String description,\n+                                                String globalParams,\n+                                                String locations,\n+                                                int timeout,\n+                                                String tenantCode,\n+                                                String taskRelationJson);\n \n     /**\n      * verify process definition name unique\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param name name\n      * @return true if process definition name not exists, otherwise false\n      */\n     Map<String, Object> verifyProcessDefinitionName(User loginUser,\n-                                                    String projectName,\n+                                                    long projectCode,\n                                                     String name);\n \n     /**\n      * delete process definition by id\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param processDefinitionId process definition id\n      * @return delete result code\n      */\n     Map<String, Object> deleteProcessDefinitionById(User loginUser,\n-                                                    String projectName,\n+                                                    long projectCode,\n                                                     Integer processDefinitionId);\n \n     /**\n      * release process definition: online / offline\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n-     * @param id process definition id\n+     * @param projectCode project code\n+     * @param code process definition code\n      * @param releaseState release state\n      * @return release result code\n      */\n     Map<String, Object> releaseProcessDefinition(User loginUser,\n-                                                 String projectName,\n-                                                 int id,\n-                                                 int releaseState);\n+                                                 long projectCode,\n+                                                 long code,\n+                                                 ReleaseState releaseState);\n \n     /**\n-     * batch export process definition by ids\n+     * batch export process definition by codes\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n-     * @param processDefinitionIds process definition ids\n+     * @param projectCode project code\n+     * @param processDefinitionCodes process definition codes\n      * @param response http servlet response\n      */\n-    void batchExportProcessDefinitionByIds(User loginUser,\n-                                           String projectName,\n-                                           String processDefinitionIds,\n-                                           HttpServletResponse response);\n+    void batchExportProcessDefinitionByCodes(User loginUser,\n+                                             long projectCode,\n+                                             String processDefinitionCodes,\n+                                             HttpServletResponse response);\n \n     /**\n      * import process definition\n      *\n      * @param loginUser login user\n+     * @param projectCode project code\n      * @param file process metadata json file\n-     * @param currentProjectName current project name\n      * @return import process\n      */\n     Map<String, Object> importProcessDefinition(User loginUser,\n-                                                MultipartFile file,\n-                                                String currentProjectName);\n+                                                long projectCode,\n+                                                MultipartFile file);\n \n     /**\n-     * check the process definition node meets the specifications\n+     * check the process task relation json\n      *\n-     * @param processData process data\n-     * @param processDefinitionJson process definition json\n+     * @param processTaskRelationJson process task relation json\n      * @return check result code\n      */\n-    Map<String, Object> checkProcessNodeList(ProcessData processData,\n-                                             String processDefinitionJson);\n+    Map<String, Object> checkProcessNodeList(String processTaskRelationJson);\n \n     /**\n      * get task node details based on process definition\n      *\n-     * @param defineId define id\n+     * @param loginUser loginUser\n+     * @param projectCode project code\n+     * @param defineCode define code\n      * @return task node list\n      */\n-    Map<String, Object> getTaskNodeListByDefinitionId(Integer defineId);\n+    Map<String, Object> getTaskNodeListByDefinitionCode(User loginUser,\n+                                                        long projectCode,\n+                                                        long defineCode);\n \n     /**\n-     * get task node details based on process definition\n+     * get task node details map based on process definition\n      *\n-     * @param defineIdList define id list\n+     * @param loginUser loginUser\n+     * @param projectCode project code\n+     * @param defineCodeList define code list\n      * @return task node list\n      */\n-    Map<String, Object> getTaskNodeListByDefinitionIdList(String defineIdList);\n+    Map<String, Object> getNodeListMapByDefinitionCodes(User loginUser,\n+                                                        long projectCode,\n+                                                        String defineCodeList);\n \n     /**\n-     * query process definition all by project id\n+     * query process definition all by project code\n      *\n-     * @param projectId project id\n+     * @param projectCode project code\n      * @return process definitions in the project\n      */\n-    Map<String, Object> queryProcessDefinitionAllByProjectId(Integer projectId);\n+    Map<String, Object> queryAllProcessDefinitionByProjectCode(User loginUser, long projectCode);\n \n     /**\n      * Encapsulates the TreeView structure\n      *\n-     * @param processId process definition id\n+     * @param code process definition code\n      * @param limit limit\n      * @return tree view json data\n      * @throws Exception exception\n      */\n-    Map<String, Object> viewTree(Integer processId,\n+    Map<String, Object> viewTree(long code,\n                                  Integer limit) throws Exception;\n \n     /**\n      * switch the defined process definition verison\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param processDefinitionId process definition id\n      * @param version the version user want to switch\n      * @return switch process definition version result code\n      */\n-    Map<String, Object> switchProcessDefinitionVersion(User loginUser, String projectName\n-            , int processDefinitionId, long version);\n+    Map<String, Object> switchProcessDefinitionVersion(User loginUser,\n+                                                       long projectCode,\n+                                                       int processDefinitionId,\n+                                                       long version);\n+\n+    /**\n+     * query the pagination versions info by one certain process definition code\n+     *\n+     * @param loginUser login user info to check auth\n+     * @param projectCode project code\n+     * @param pageNo page number\n+     * @param pageSize page size\n+     * @param processDefinitionCode process definition code\n+     * @return the pagination process definition versions info of the certain process definition\n+     */\n+    Map<String, Object> queryProcessDefinitionVersions(User loginUser,\n+                                                       long projectCode,\n+                                                       int pageNo,\n+                                                       int pageSize,\n+                                                       long processDefinitionCode);\n+\n+    /**\n+     * delete one certain process definition by version number and process definition id\n+     *\n+     * @param loginUser login user info to check auth\n+     * @param projectCode project code\n+     * @param processDefinitionId process definition id\n+     * @param version version number\n+     * @return delele result code\n+     */\n+    Map<String, Object> deleteByProcessDefinitionIdAndVersion(User loginUser,\n+                                                              long projectCode,\n+                                                              int processDefinitionId,\n+                                                              long version);\n }\n \n", "next_change": {"commit": "a5d94279a191486ec88cfd28d9f0aacaf8e0f8ef", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 6290c310c..b23173e68 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -321,6 +321,6 @@ public interface ProcessDefinitionService {\n     Map<String, Object> deleteByProcessDefinitionIdAndVersion(User loginUser,\n                                                               long projectCode,\n                                                               int processDefinitionId,\n-                                                              long version);\n+                                                              int version);\n }\n \n", "next_change": {"commit": "0344b21dbc32c8ff98801e536c03191d1b1f5f3d", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex b23173e68..42a8bb4c3 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -322,5 +322,6 @@ public interface ProcessDefinitionService {\n                                                               long projectCode,\n                                                               int processDefinitionId,\n                                                               int version);\n+\n }\n \n", "next_change": {"commit": "effbad4e206fc79f5aa66b65443b2fed1927879a", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 42a8bb4c3..42fce02ba 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -300,28 +299,28 @@ public interface ProcessDefinitionService {\n      * @param projectCode project code\n      * @param pageNo page number\n      * @param pageSize page size\n-     * @param processDefinitionCode process definition code\n+     * @param code process definition code\n      * @return the pagination process definition versions info of the certain process definition\n      */\n     Result queryProcessDefinitionVersions(User loginUser,\n-                                                       long projectCode,\n-                                                       int pageNo,\n-                                                       int pageSize,\n-                                                       long processDefinitionCode);\n+                                          long projectCode,\n+                                          int pageNo,\n+                                          int pageSize,\n+                                          long code);\n \n     /**\n-     * delete one certain process definition by version number and process definition id\n+     * delete one certain process definition by version number and process definition code\n      *\n      * @param loginUser login user info to check auth\n      * @param projectCode project code\n-     * @param processDefinitionId process definition id\n+     * @param code process definition code\n      * @param version version number\n      * @return delele result code\n      */\n-    Map<String, Object> deleteByProcessDefinitionIdAndVersion(User loginUser,\n-                                                              long projectCode,\n-                                                              int processDefinitionId,\n-                                                              int version);\n+    Map<String, Object> deleteProcessDefinitionVersion(User loginUser,\n+                                                       long projectCode,\n+                                                       long code,\n+                                                       int version);\n \n }\n \n", "next_change": {"commit": "f5e7da3cf667ff2d7a6323d2ae2126881b4a2fe2", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 42fce02ba..e1e05035e 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -322,5 +335,79 @@ public interface ProcessDefinitionService {\n                                                        long code,\n                                                        int version);\n \n+    /**\n+     * create empty process definition\n+     *\n+     * @param loginUser login user\n+     * @param projectCode project code\n+     * @param name process definition name\n+     * @param description description\n+     * @param globalParams globalParams\n+     * @param timeout timeout\n+     * @param tenantCode tenantCode\n+     * @param scheduleJson scheduleJson\n+     * @return process definition code\n+     */\n+    Map<String, Object> createEmptyProcessDefinition(User loginUser,\n+                                                     long projectCode,\n+                                                     String name,\n+                                                     String description,\n+                                                     String globalParams,\n+                                                     int timeout,\n+                                                     String tenantCode,\n+                                                     String scheduleJson,\n+                                                     ProcessExecutionTypeEnum executionType);\n+\n+    /**\n+     * update process definition basic info\n+     *\n+     * @param loginUser login user\n+     * @param projectCode project code\n+     * @param name process definition name\n+     * @param code process definition code\n+     * @param description description\n+     * @param globalParams globalParams\n+     * @param timeout timeout\n+     * @param tenantCode tenantCode\n+     * @param scheduleJson scheduleJson\n+     * @param executionType executionType\n+     * @return update result code\n+     */\n+    Map<String, Object> updateProcessDefinitionBasicInfo(User loginUser,\n+                                                         long projectCode,\n+                                                         String name,\n+                                                         long code,\n+                                                         String description,\n+                                                         String globalParams,\n+                                                         int timeout,\n+                                                         String tenantCode,\n+                                                         String scheduleJson,\n+                                                         ProcessExecutionTypeEnum executionType);\n+\n+    /**\n+     * release process definition and schedule\n+     *\n+     * @param loginUser login user\n+     * @param projectCode project code\n+     * @param code process definition code\n+     * @param releaseState releaseState\n+     * @return update result code\n+     */\n+    Map<String, Object> releaseWorkflowAndSchedule(User loginUser,\n+                                                   long projectCode,\n+                                                   long code,\n+                                                   ReleaseState releaseState);\n+\n+    /**\n+     * delete process definition and schedule\n+     *\n+     * @param loginUser login user\n+     * @param projectCode project code\n+     * @param code process definition code\n+     * @return update result code\n+     */\n+    Map<String, Object> deleteWorkflowAndSchedule(User loginUser,\n+                                                  long projectCode,\n+                                                  long code);\n }\n \n", "next_change": {"commit": "1e9973299fbb7109959941951f3695667bf7e8c8", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex e1e05035e..2f1c3f7e2 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -397,17 +397,5 @@ public interface ProcessDefinitionService {\n                                                    long projectCode,\n                                                    long code,\n                                                    ReleaseState releaseState);\n-\n-    /**\n-     * delete process definition and schedule\n-     *\n-     * @param loginUser login user\n-     * @param projectCode project code\n-     * @param code process definition code\n-     * @return update result code\n-     */\n-    Map<String, Object> deleteWorkflowAndSchedule(User loginUser,\n-                                                  long projectCode,\n-                                                  long code);\n }\n \n", "next_change": {"commit": "f3c647d45eebd5a7bae8c2083f80ce17824df892", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 2f1c3f7e2..49e3be075 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -397,5 +438,30 @@ public interface ProcessDefinitionService {\n                                                    long projectCode,\n                                                    long code,\n                                                    ReleaseState releaseState);\n+\n+    /**\n+     * delete other relation\n+     * @param project\n+     * @param result\n+     * @param processDefinition\n+     */\n+    void deleteOtherRelation(Project project, Map<String, Object> result, ProcessDefinition processDefinition);\n+\n+    /**\n+     * save other relation\n+     * @param loginUser\n+     * @param processDefinition\n+     * @param result\n+     * @param otherParamsJson\n+     */\n+    void saveOtherRelation(User loginUser, ProcessDefinition processDefinition, Map<String, Object> result, String otherParamsJson);\n+\n+    /**\n+     * get Json String\n+     * @param loginUser\n+     * @param processDefinition\n+     * @return Json String\n+     */\n+    String doOtherOperateProcess(User loginUser, ProcessDefinition processDefinition);\n }\n \n", "next_change": {"commit": "f1a9c0d8e90e7f03a0065255c097ee3fb9aee580", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 49e3be075..421cd920d 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -463,5 +464,90 @@ public interface ProcessDefinitionService {\n      * @return Json String\n      */\n     String doOtherOperateProcess(User loginUser, ProcessDefinition processDefinition);\n+\n+    /**\n+     * update dag define\n+     * @param loginUser\n+     * @param taskRelationList\n+     * @param processDefinition\n+     * @param processDefinitionDeepCopy\n+     * @param taskDefinitionLogs\n+     * @param otherParamsJson\n+     */\n+    Map<String, Object> updateDagDefine(User loginUser,\n+                    List<ProcessTaskRelationLog> taskRelationList,\n+                    ProcessDefinition processDefinition,\n+                    ProcessDefinition processDefinitionDeepCopy,\n+                    List<TaskDefinitionLog> taskDefinitionLogs,\n+                    String otherParamsJson);\n+\n+    /**\n+     * check task relation\n+     * @param taskRelationList\n+     * @param taskRelationJson\n+     * @param taskDefinitionLogs\n+     * @return\n+     */\n+    Map<String, Object> checkTaskRelationList(List<ProcessTaskRelationLog> taskRelationList, String taskRelationJson, List<TaskDefinitionLog> taskDefinitionLogs);\n+\n+    /**\n+     * check task define\n+     * @param taskDefinitionLogs\n+     * @param taskDefinitionJson\n+     * @return\n+     */\n+    Map<String, Object> checkTaskDefinitionList(List<TaskDefinitionLog> taskDefinitionLogs, String taskDefinitionJson);\n+\n+    /**\n+     * create dag define\n+     * @param loginUser\n+     * @param taskRelationList\n+     * @param processDefinition\n+     * @param taskDefinitionLogs\n+     * @param otherParamsJson\n+     * @return\n+     */\n+    Map<String, Object> createDagDefine(User loginUser,\n+                                        List<ProcessTaskRelationLog> taskRelationList,\n+                                        ProcessDefinition processDefinition,\n+                                        List<TaskDefinitionLog> taskDefinitionLogs, String otherParamsJson);\n+\n+    /**\n+     *\n+     * @param loginUser\n+     * @param targetProjectCode\n+     * @param failedProcessList\n+     * @param processDefinitionCodes\n+     * @param result\n+     * @param isCopy\n+     */\n+    void doBatchOperateProcessDefinition(User loginUser,\n+                                    long targetProjectCode,\n+                                    List<String> failedProcessList,\n+                                    String processDefinitionCodes,\n+                                    Map<String, Object> result,\n+                                    boolean isCopy);\n+\n+    /**\n+     * create dag schedule\n+     * @param loginUser\n+     * @param processDefinition\n+     * @param scheduleJson\n+     * @return\n+     */\n+    Map<String, Object> createDagSchedule(User loginUser, ProcessDefinition processDefinition, String scheduleJson);\n+\n+    /**\n+     * update dag schedule\n+     * @param loginUser\n+     * @param projectCode\n+     * @param processDefinitionCode\n+     * @param scheduleJson\n+     * @return\n+     */\n+    Map<String, Object> updateDagSchedule(User loginUser,\n+                                          long projectCode,\n+                                          long processDefinitionCode,\n+                                          String scheduleJson);\n }\n \n", "next_change": {"commit": "d7cf09afd53bee081c0acea443427774a657b7e6", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 421cd920d..49e3be075 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -464,90 +463,5 @@ public interface ProcessDefinitionService {\n      * @return Json String\n      */\n     String doOtherOperateProcess(User loginUser, ProcessDefinition processDefinition);\n-\n-    /**\n-     * update dag define\n-     * @param loginUser\n-     * @param taskRelationList\n-     * @param processDefinition\n-     * @param processDefinitionDeepCopy\n-     * @param taskDefinitionLogs\n-     * @param otherParamsJson\n-     */\n-    Map<String, Object> updateDagDefine(User loginUser,\n-                    List<ProcessTaskRelationLog> taskRelationList,\n-                    ProcessDefinition processDefinition,\n-                    ProcessDefinition processDefinitionDeepCopy,\n-                    List<TaskDefinitionLog> taskDefinitionLogs,\n-                    String otherParamsJson);\n-\n-    /**\n-     * check task relation\n-     * @param taskRelationList\n-     * @param taskRelationJson\n-     * @param taskDefinitionLogs\n-     * @return\n-     */\n-    Map<String, Object> checkTaskRelationList(List<ProcessTaskRelationLog> taskRelationList, String taskRelationJson, List<TaskDefinitionLog> taskDefinitionLogs);\n-\n-    /**\n-     * check task define\n-     * @param taskDefinitionLogs\n-     * @param taskDefinitionJson\n-     * @return\n-     */\n-    Map<String, Object> checkTaskDefinitionList(List<TaskDefinitionLog> taskDefinitionLogs, String taskDefinitionJson);\n-\n-    /**\n-     * create dag define\n-     * @param loginUser\n-     * @param taskRelationList\n-     * @param processDefinition\n-     * @param taskDefinitionLogs\n-     * @param otherParamsJson\n-     * @return\n-     */\n-    Map<String, Object> createDagDefine(User loginUser,\n-                                        List<ProcessTaskRelationLog> taskRelationList,\n-                                        ProcessDefinition processDefinition,\n-                                        List<TaskDefinitionLog> taskDefinitionLogs, String otherParamsJson);\n-\n-    /**\n-     *\n-     * @param loginUser\n-     * @param targetProjectCode\n-     * @param failedProcessList\n-     * @param processDefinitionCodes\n-     * @param result\n-     * @param isCopy\n-     */\n-    void doBatchOperateProcessDefinition(User loginUser,\n-                                    long targetProjectCode,\n-                                    List<String> failedProcessList,\n-                                    String processDefinitionCodes,\n-                                    Map<String, Object> result,\n-                                    boolean isCopy);\n-\n-    /**\n-     * create dag schedule\n-     * @param loginUser\n-     * @param processDefinition\n-     * @param scheduleJson\n-     * @return\n-     */\n-    Map<String, Object> createDagSchedule(User loginUser, ProcessDefinition processDefinition, String scheduleJson);\n-\n-    /**\n-     * update dag schedule\n-     * @param loginUser\n-     * @param projectCode\n-     * @param processDefinitionCode\n-     * @param scheduleJson\n-     * @return\n-     */\n-    Map<String, Object> updateDagSchedule(User loginUser,\n-                                          long projectCode,\n-                                          long processDefinitionCode,\n-                                          String scheduleJson);\n }\n \n", "next_change": {"commit": "8a47785f4290d53d6ecdc9413f6e7bf6faae343a", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex 49e3be075..beab02207 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -464,4 +470,3 @@ public interface ProcessDefinitionService {\n      */\n     String doOtherOperateProcess(User loginUser, ProcessDefinition processDefinition);\n }\n-\n", "next_change": {"commit": "d84f1ef2694d237e4d36604be77c6758a17c5cb4", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\nindex beab02207..64df82f8c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessDefinitionService.java\n", "chunk": "@@ -469,4 +522,13 @@ public interface ProcessDefinitionService {\n      * @return Json String\n      */\n     String doOtherOperateProcess(User loginUser, ProcessDefinition processDefinition);\n+\n+    /**\n+     * view process variables\n+     * @param loginUser    login user\n+     * @param projectCode project code\n+     * @param code process definition code\n+     * @return variables data\n+     */\n+    Map<String, Object> viewVariables(User loginUser, long projectCode, long code);\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY2Nzg5Mw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436667893", "body": "getMapper,createArrayNode,createObjectNode better private ,we should not use ObjectMapper directly", "bodyText": "getMapper,createArrayNode,createObjectNode better private ,we should not use ObjectMapper directly", "bodyHTML": "<p dir=\"auto\">getMapper,createArrayNode,createObjectNode better private ,we should not use ObjectMapper directly</p>", "author": "gabrywu", "createdAt": "2020-06-08T12:50:47Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java", "diffHunk": "@@ -50,23 +50,42 @@ private JSONUtils() {\n         objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true).setTimeZone(TimeZone.getDefault());\n     }\n \n+    public static ObjectMapper getMapper() {", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 97212154a..63611cc7d 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -50,10 +51,6 @@ public class JSONUtils {\n         objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true).setTimeZone(TimeZone.getDefault());\n     }\n \n-    public static ObjectMapper getMapper() {\n-        return objectMapper;\n-    }\n-\n \n     public static ArrayNode createArrayNode() {\n         return objectMapper.createArrayNode();\n", "next_change": {"commit": "a9eb7b18b061d17f5806db0a13a66a0dd0c4a5a7", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 63611cc7d..65a078778 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -40,17 +44,16 @@ public class JSONUtils {\n     /**\n      * can use static singleton, inject: just make sure to reuse!\n      */\n-    private static final ObjectMapper objectMapper = new ObjectMapper();\n+    private static final ObjectMapper objectMapper = new ObjectMapper()\n+            .configure(FAIL_ON_UNKNOWN_PROPERTIES, false)\n+            .configure(ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true)\n+            .configure(READ_UNKNOWN_ENUM_VALUES_AS_NULL, true)\n+            .setTimeZone(TimeZone.getDefault())\n+            ;\n \n     private JSONUtils() {\n     }\n \n-    static {\n-        //Feature that determines whether encountering of unknown properties, false means not analyzer unknown properties\n-        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).setTimeZone(TimeZone.getDefault());\n-        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true).setTimeZone(TimeZone.getDefault());\n-    }\n-\n \n     public static ArrayNode createArrayNode() {\n         return objectMapper.createArrayNode();\n", "next_change": {"commit": "ac4ed94061e91563268c3bc588c554182d22d277", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 65a078778..56ef74d6e 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -48,13 +62,13 @@ public class JSONUtils {\n             .configure(FAIL_ON_UNKNOWN_PROPERTIES, false)\n             .configure(ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true)\n             .configure(READ_UNKNOWN_ENUM_VALUES_AS_NULL, true)\n-            .setTimeZone(TimeZone.getDefault())\n-            ;\n+            .configure(REQUIRE_SETTERS_FOR_GETTERS, true)\n+            .setTimeZone(TimeZone.getDefault());\n \n     private JSONUtils() {\n+        throw new UnsupportedOperationException(\"Construct JSONUtils\");\n     }\n \n-\n     public static ArrayNode createArrayNode() {\n         return objectMapper.createArrayNode();\n     }\n", "next_change": {"commit": "062146eecd9ceabbd6d1fd32747372802749d6bd", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 56ef74d6e..1a09ae11e 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -63,12 +75,17 @@ public class JSONUtils {\n             .configure(ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true)\n             .configure(READ_UNKNOWN_ENUM_VALUES_AS_NULL, true)\n             .configure(REQUIRE_SETTERS_FOR_GETTERS, true)\n-            .setTimeZone(TimeZone.getDefault());\n+            .setTimeZone(TimeZone.getDefault())\n+            .setDateFormat(new SimpleDateFormat(Constants.YYYY_MM_DD_HH_MM_SS));\n \n     private JSONUtils() {\n         throw new UnsupportedOperationException(\"Construct JSONUtils\");\n     }\n \n+    public static synchronized void setTimeZone(TimeZone timeZone) {\n+        objectMapper.setTimeZone(timeZone);\n+    }\n+\n     public static ArrayNode createArrayNode() {\n         return objectMapper.createArrayNode();\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY2ODg2Nw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436668867", "body": "don't use getMapper directly , abstract one method to deserialize List<?>", "bodyText": "don't use getMapper directly , abstract one method to deserialize List<?>", "bodyHTML": "<p dir=\"auto\">don't use getMapper directly , abstract one method to deserialize List&lt;?&gt;</p>", "author": "gabrywu", "createdAt": "2020-06-08T12:52:29Z", "path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java", "diffHunk": "@@ -551,7 +562,13 @@ private void addDependResultForTaskList(List<TaskInstance> taskInstanceList) thr\n             String localParams = map.get(LOCAL_PARAMS);\n             if (localParams != null && !localParams.isEmpty()) {\n                 localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n-                List<Property> localParamsList = JSON.parseArray(localParams, Property.class);\n+                List<Property> localParamsList = new ArrayList<>();\n+                try {\n+                    localParamsList = JSONUtils.getMapper().readValue(localParams, new TypeReference<List<Property>>() {});", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "443a6d193553bfb15029b7db0851ecb9839238a2", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 725ffc00b..f8ad4c6e8 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -562,13 +553,7 @@ public class ProcessInstanceService extends BaseDAGService {\n             String localParams = map.get(LOCAL_PARAMS);\n             if (localParams != null && !localParams.isEmpty()) {\n                 localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n-                List<Property> localParamsList = new ArrayList<>();\n-                try {\n-                    localParamsList = JSONUtils.getMapper().readValue(localParams, new TypeReference<List<Property>>() {});\n-                } catch (Exception e) {\n-                    logger.error(\"parse list exception!\", e);\n-                }\n-\n+                List<Property> localParamsList = JSON.parseArray(localParams, Property.class);\n                 Map<String,Object> localParamsMap = new HashMap<>();\n                 localParamsMap.put(\"taskType\",taskNode.getType());\n                 localParamsMap.put(\"localParamsList\",localParamsList);\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex f8ad4c6e8..5d5eb006f 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -553,7 +554,9 @@ public class ProcessInstanceService extends BaseDAGService {\n             String localParams = map.get(LOCAL_PARAMS);\n             if (localParams != null && !localParams.isEmpty()) {\n                 localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n-                List<Property> localParamsList = JSON.parseArray(localParams, Property.class);\n+                List<Property> localParamsList = new ArrayList<>();\n+                localParamsList = JSONUtils.toList(localParams, Property.class);\n+\n                 Map<String,Object> localParamsMap = new HashMap<>();\n                 localParamsMap.put(\"taskType\",taskNode.getType());\n                 localParamsMap.put(\"localParamsList\",localParamsList);\n", "next_change": {"commit": "1904a7022a38ff9bc8fbe42f1e8e9c4547916fd6", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 5d5eb006f..9b4cdab71 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -554,9 +552,7 @@ public class ProcessInstanceService extends BaseDAGService {\n             String localParams = map.get(LOCAL_PARAMS);\n             if (localParams != null && !localParams.isEmpty()) {\n                 localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n-                List<Property> localParamsList = new ArrayList<>();\n-                localParamsList = JSONUtils.toList(localParams, Property.class);\n-\n+                List<Property> localParamsList = JSON.parseArray(localParams, Property.class);\n                 Map<String,Object> localParamsMap = new HashMap<>();\n                 localParamsMap.put(\"taskType\",taskNode.getType());\n                 localParamsMap.put(\"localParamsList\",localParamsList);\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 9b4cdab71..8b393a7fe 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -552,7 +553,8 @@ public class ProcessInstanceService extends BaseDAGService {\n             String localParams = map.get(LOCAL_PARAMS);\n             if (localParams != null && !localParams.isEmpty()) {\n                 localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n-                List<Property> localParamsList = JSON.parseArray(localParams, Property.class);\n+                List<Property> localParamsList = JSONUtils.toList(localParams, Property.class);\n+\n                 Map<String,Object> localParamsMap = new HashMap<>();\n                 localParamsMap.put(\"taskType\",taskNode.getType());\n                 localParamsMap.put(\"localParamsList\",localParamsList);\n", "next_change": {"commit": "93660f4d617d750d803cc3a7f68fe06c6f694463", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 8b393a7fe..54f6e9042 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -555,9 +622,9 @@ public class ProcessInstanceService extends BaseDAGService {\n                 localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n                 List<Property> localParamsList = JSONUtils.toList(localParams, Property.class);\n \n-                Map<String,Object> localParamsMap = new HashMap<>();\n-                localParamsMap.put(\"taskType\",taskNode.getType());\n-                localParamsMap.put(\"localParamsList\",localParamsList);\n+                Map<String, Object> localParamsMap = new HashMap<>();\n+                localParamsMap.put(\"taskType\", taskNode.getType());\n+                localParamsMap.put(\"localParamsList\", localParamsList);\n                 if (CollectionUtils.isNotEmpty(localParamsList)) {\n                     localUserDefParams.put(taskNode.getName(), localParamsMap);\n                 }\n", "next_change": {"commit": "67eae43154b7638f2777bdf98d1f66a7e2afa287", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 54f6e9042..21ba828d2 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -623,23 +668,15 @@ public class ProcessInstanceService extends BaseService {\n                 List<Property> localParamsList = JSONUtils.toList(localParams, Property.class);\n \n                 Map<String, Object> localParamsMap = new HashMap<>();\n-                localParamsMap.put(\"taskType\", taskNode.getType());\n-                localParamsMap.put(\"localParamsList\", localParamsList);\n+                localParamsMap.put(TASK_TYPE, taskDefinitionLog.getTaskType());\n+                localParamsMap.put(LOCAL_PARAMS_LIST, localParamsList);\n                 if (CollectionUtils.isNotEmpty(localParamsList)) {\n-                    localUserDefParams.put(taskNode.getName(), localParamsMap);\n+                    localUserDefParams.put(taskDefinitionLog.getName(), localParamsMap);\n                 }\n             }\n \n         }\n-\n-        Map<String, Object> resultMap = new HashMap<>();\n-\n-        resultMap.put(GLOBAL_PARAMS, globalParams);\n-        resultMap.put(LOCAL_PARAMS, localUserDefParams);\n-\n-        result.put(DATA_LIST, resultMap);\n-        putMsg(result, Status.SUCCESS);\n-        return result;\n+        return localUserDefParams;\n     }\n \n     /**\n", "next_change": {"commit": "dc55b5ba6faffc3587ed0a2b78b2ceaf891844f5", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 21ba828d2..914eb2dfe 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -608,76 +136,7 @@ public class ProcessInstanceService extends BaseService {\n      * @param processInstanceId process instance id\n      * @return variables data\n      */\n-    public Map<String, Object> viewVariables(Integer processInstanceId) {\n-        Map<String, Object> result = new HashMap<>();\n-\n-        ProcessInstance processInstance = processInstanceMapper.queryDetailById(processInstanceId);\n-\n-        if (processInstance == null) {\n-            throw new RuntimeException(\"workflow instance is null\");\n-        }\n-\n-        Map<String, String> timeParams = BusinessTimeUtils\n-                .getBusinessTime(processInstance.getCmdTypeIfComplement(),\n-                        processInstance.getScheduleTime());\n-        String userDefinedParams = processInstance.getGlobalParams();\n-        // global params\n-        List<Property> globalParams = new ArrayList<>();\n-\n-        // global param string\n-        String globalParamStr = ParameterUtils.convertParameterPlaceholders(JSONUtils.toJsonString(globalParams), timeParams);\n-        globalParams = JSONUtils.toList(globalParamStr, Property.class);\n-        for (Property property : globalParams) {\n-            timeParams.put(property.getProp(), property.getValue());\n-        }\n-\n-        if (userDefinedParams != null && userDefinedParams.length() > 0) {\n-            globalParams = JSONUtils.toList(userDefinedParams, Property.class);\n-        }\n-\n-        Map<String, Map<String, Object>> localUserDefParams = getLocalParams(processInstance, timeParams);\n-\n-        Map<String, Object> resultMap = new HashMap<>();\n-\n-        resultMap.put(GLOBAL_PARAMS, globalParams);\n-        resultMap.put(LOCAL_PARAMS, localUserDefParams);\n-\n-        result.put(DATA_LIST, resultMap);\n-        putMsg(result, Status.SUCCESS);\n-        return result;\n-    }\n-\n-    /**\n-     * get local params\n-     *\n-     * @param processInstance\n-     * @param timeParams\n-     * @return\n-     */\n-    private Map<String, Map<String, Object>> getLocalParams(ProcessInstance processInstance, Map<String, String> timeParams) {\n-        Map<String, Map<String, Object>> localUserDefParams = new HashMap<>();\n-        List<TaskInstance> taskInstanceList = taskInstanceMapper.findValidTaskListByProcessId(processInstance.getId(), Flag.YES);\n-        for (TaskInstance taskInstance : taskInstanceList) {\n-            TaskDefinitionLog taskDefinitionLog = taskDefinitionLogMapper.queryByDefinitionCodeAndVersion(\n-                    taskInstance.getTaskCode(), taskInstance.getTaskDefinitionVersion());\n-            String parameter = taskDefinitionLog.getTaskParams();\n-            Map<String, String> map = JSONUtils.toMap(parameter);\n-            String localParams = map.get(LOCAL_PARAMS);\n-            if (localParams != null && !localParams.isEmpty()) {\n-                localParams = ParameterUtils.convertParameterPlaceholders(localParams, timeParams);\n-                List<Property> localParamsList = JSONUtils.toList(localParams, Property.class);\n-\n-                Map<String, Object> localParamsMap = new HashMap<>();\n-                localParamsMap.put(TASK_TYPE, taskDefinitionLog.getTaskType());\n-                localParamsMap.put(LOCAL_PARAMS_LIST, localParamsList);\n-                if (CollectionUtils.isNotEmpty(localParamsList)) {\n-                    localUserDefParams.put(taskDefinitionLog.getName(), localParamsMap);\n-                }\n-            }\n-\n-        }\n-        return localUserDefParams;\n-    }\n+    Map<String, Object> viewVariables(Integer processInstanceId);\n \n     /**\n      * encapsulation gantt structure\n", "next_change": {"commit": "8ebe060658edb7075bdcf123f9ad5bb3d0fc9ceb", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 914eb2dfe..073e1f381 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -85,82 +101,102 @@ public interface ProcessInstanceService {\n      * query sub process instance detail info by task id\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param taskId task id\n      * @return sub process instance detail\n      */\n-    Map<String, Object> querySubProcessInstanceByTaskId(User loginUser, String projectName, Integer taskId);\n+    Map<String, Object> querySubProcessInstanceByTaskId(User loginUser,\n+                                                        long projectCode,\n+                                                        Integer taskId);\n \n     /**\n      * update process instance\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n-     * @param processInstanceJson process instance json\n+     * @param projectCode project code\n+     * @param taskRelationJson process task relation json\n+     * @param taskDefinitionJson taskDefinitionJson\n      * @param processInstanceId process instance id\n      * @param scheduleTime schedule time\n      * @param syncDefine sync define\n-     * @param flag flag\n-     * @param locations locations\n-     * @param connects connects\n+     * @param globalParams global params\n+     * @param locations locations for nodes\n+     * @param timeout timeout\n+     * @param tenantCode tenantCode\n      * @return update result code\n-     * @throws ParseException parse exception for json parse\n      */\n-    Map<String, Object> updateProcessInstance(User loginUser, String projectName, Integer processInstanceId,\n-                                              String processInstanceJson, String scheduleTime, Boolean syncDefine,\n-                                              Flag flag, String locations, String connects) throws ParseException;\n+    Map<String, Object> updateProcessInstance(User loginUser,\n+                                              long projectCode,\n+                                              Integer processInstanceId,\n+                                              String taskRelationJson,\n+                                              String taskDefinitionJson,\n+                                              String scheduleTime,\n+                                              Boolean syncDefine,\n+                                              String globalParams,\n+                                              String locations,\n+                                              int timeout,\n+                                              String tenantCode);\n \n     /**\n      * query parent process instance detail info by sub process instance id\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param subId sub process id\n      * @return parent instance detail\n      */\n-    Map<String, Object> queryParentInstanceBySubId(User loginUser, String projectName, Integer subId);\n+    Map<String, Object> queryParentInstanceBySubId(User loginUser,\n+                                                   long projectCode,\n+                                                   Integer subId);\n \n     /**\n      * delete process instance by id, at the same time\uff0cdelete task instance and their mapping relation data\n      *\n      * @param loginUser login user\n-     * @param projectName project name\n+     * @param projectCode project code\n      * @param processInstanceId process instance id\n      * @return delete result code\n      */\n-    Map<String, Object> deleteProcessInstanceById(User loginUser, String projectName, Integer processInstanceId);\n+    Map<String, Object> deleteProcessInstanceById(User loginUser,\n+                                                  long projectCode,\n+                                                  Integer processInstanceId);\n \n     /**\n      * view process instance variables\n      *\n+     * @param projectCode project code\n      * @param processInstanceId process instance id\n      * @return variables data\n      */\n-    Map<String, Object> viewVariables(Integer processInstanceId);\n+    Map<String, Object> viewVariables(long projectCode, Integer processInstanceId);\n \n     /**\n      * encapsulation gantt structure\n      *\n+     * @param projectCode project code\n      * @param processInstanceId process instance id\n      * @return gantt tree data\n      * @throws Exception exception when json parse\n      */\n-    Map<String, Object> viewGantt(Integer processInstanceId) throws Exception;\n+    Map<String, Object> viewGantt(long projectCode, Integer processInstanceId) throws Exception;\n \n     /**\n-     * query process instance by processDefinitionId and stateArray\n-     * @param processDefinitionId processDefinitionId\n+     * query process instance by processDefinitionCode and stateArray\n+     *\n+     * @param processDefinitionCode processDefinitionCode\n      * @param states states array\n      * @return process instance list\n      */\n-    List<ProcessInstance> queryByProcessDefineIdAndStatus(int processDefinitionId, int[] states);\n+    List<ProcessInstance> queryByProcessDefineCodeAndStatus(Long processDefinitionCode,\n+                                                            int[] states);\n \n     /**\n-     * query process instance by processDefinitionId\n-     * @param processDefinitionId processDefinitionId\n+     * query process instance by processDefinitionCode\n+     *\n+     * @param processDefinitionCode processDefinitionCode\n      * @param size size\n      * @return process instance list\n      */\n-    List<ProcessInstance> queryByProcessDefineId(int processDefinitionId,int size);\n-\n-}\n+    List<ProcessInstance> queryByProcessDefineCode(Long processDefinitionCode,\n+                                                   int size);\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "d46e4659d917e1994bc9045c57fe3b865a308352", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 073e1f381..d84ca5d3c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -199,4 +201,4 @@ public interface ProcessInstanceService {\n      */\n     List<ProcessInstance> queryByProcessDefineCode(Long processDefinitionCode,\n                                                    int size);\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "a074f7e2e6cccc0370e817e784022e86fc2cef04", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex d84ca5d3c..5b8bab32c 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -201,4 +221,9 @@ public interface ProcessInstanceService {\n      */\n     List<ProcessInstance> queryByProcessDefineCode(Long processDefinitionCode,\n                                                    int size);\n+\n+    void deleteProcessInstanceByWorkflowDefinitionCode(long workflowDefinitionCode);\n+\n+    void deleteProcessInstanceById(int workflowInstanceId);\n+\n }\n", "next_change": {"commit": "8be32d4145c851a01d7300cd5a854be9b4a27055", "changed_code": [{"header": "diff --git a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\nindex 5b8bab32c..eb760722f 100644\n--- a/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n+++ b/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProcessInstanceService.java\n", "chunk": "@@ -222,6 +222,16 @@ public interface ProcessInstanceService {\n     List<ProcessInstance> queryByProcessDefineCode(Long processDefinitionCode,\n                                                    int size);\n \n+    /**\n+     * query process instance list bt trigger code\n+     *\n+     * @param loginUser\n+     * @param projectCode\n+     * @param triggerCode\n+     * @return\n+     */\n+    Map<String, Object> queryByTriggerCode(User loginUser, long projectCode, Long triggerCode);\n+\n     void deleteProcessInstanceByWorkflowDefinitionCode(long workflowDefinitionCode);\n \n     void deleteProcessInstanceById(int workflowInstanceId);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3Nzk3OA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436677978", "body": "why remove the 'throws JSONException', I think it's better not remove", "bodyText": "why remove the 'throws JSONException', I think it's better not remove", "bodyHTML": "<p dir=\"auto\">why remove the 'throws JSONException', I think it's better not remove</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:03:39Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java", "diffHunk": "@@ -408,9 +406,8 @@ public boolean isYarnEnabled() {\n      *\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n-     * @throws JSONException json exception\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) throws JSONException {\n+    public ExecutionStatus getApplicationStatus(String applicationId)  {", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 360f4514b..e57201d74 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -407,7 +408,7 @@ public class HadoopUtils implements Closeable {\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId)  {\n+    public ExecutionStatus getApplicationStatus(String applicationId) throws NullPointerException {\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex e57201d74..94f83acb5 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -408,7 +409,7 @@ public class HadoopUtils implements Closeable {\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) throws NullPointerException {\n+    public ExecutionStatus getApplicationStatus(String applicationId) {\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n", "next_change": {"commit": "620ecffa7299b87228c54a8e50a99a96a2cb1cba", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 94f83acb5..b4eebd6fc 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -408,31 +400,19 @@ public class HadoopUtils implements Closeable {\n      *\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n+     * @throws JSONException json exception\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) {\n+    public ExecutionStatus getApplicationStatus(String applicationId) throws Exception {\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n \n-        String result = Constants.FAILED;\n         String applicationUrl = getApplicationUrl(applicationId);\n-        logger.info(\"applicationUrl={}\", applicationUrl);\n \n         String responseContent = HttpUtils.get(applicationUrl);\n-        if (responseContent != null) {\n-            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n-            result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n-        } else {\n-            //may be in job history\n-            String jobHistoryUrl = getJobHistoryUrl(applicationId);\n-            logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n-            responseContent = HttpUtils.get(jobHistoryUrl);\n-            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n-            if (!jsonObject.has(\"job\")){\n-                return ExecutionStatus.FAILURE;\n-            }\n-            result = jsonObject.path(\"job\").path(\"state\").asText();\n-        }\n+\n+        JSONObject jsonObject = JSON.parseObject(responseContent);\n+        String result = jsonObject.getJSONObject(\"app\").getString(\"finalStatus\");\n \n         switch (result) {\n             case Constants.ACCEPTED:\n", "next_change": {"commit": "73cae7f0460698420370a294aa17f511101b0e22", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex b4eebd6fc..10fa0b6db 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -400,19 +406,31 @@ public class HadoopUtils implements Closeable {\n      *\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n-     * @throws JSONException json exception\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) throws Exception {\n+    public ExecutionStatus getApplicationStatus(String applicationId) throws Exception{\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n \n+        String result = Constants.FAILED;\n         String applicationUrl = getApplicationUrl(applicationId);\n+        logger.info(\"applicationUrl={}\", applicationUrl);\n \n         String responseContent = HttpUtils.get(applicationUrl);\n-\n-        JSONObject jsonObject = JSON.parseObject(responseContent);\n-        String result = jsonObject.getJSONObject(\"app\").getString(\"finalStatus\");\n+        if (responseContent != null) {\n+            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n+        } else {\n+            //may be in job history\n+            String jobHistoryUrl = getJobHistoryUrl(applicationId);\n+            logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n+            responseContent = HttpUtils.get(jobHistoryUrl);\n+            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            if (!jsonObject.has(\"job\")){\n+                return ExecutionStatus.FAILURE;\n+            }\n+            result = jsonObject.path(\"job\").path(\"state\").asText();\n+        }\n \n         switch (result) {\n             case Constants.ACCEPTED:\n", "next_change": {"commit": "ba3adbd34b8b260f01e92b25612cfdb5c2370f6e", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 10fa0b6db..68d03506c 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -416,20 +417,33 @@ public class HadoopUtils implements Closeable {\n         String applicationUrl = getApplicationUrl(applicationId);\n         logger.info(\"applicationUrl={}\", applicationUrl);\n \n-        String responseContent = HttpUtils.get(applicationUrl);\n+        String responseContent;\n+        if (PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false)) {\n+            responseContent = KerberosHttpClient.get(applicationUrl);\n+        } else {\n+            responseContent = HttpUtils.get(applicationUrl);\n+        }\n         if (responseContent != null) {\n             ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            if (!jsonObject.has(\"app\")) {\n+                return ExecutionStatus.FAILURE;\n+            }\n             result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n+\n         } else {\n             //may be in job history\n             String jobHistoryUrl = getJobHistoryUrl(applicationId);\n             logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n             responseContent = HttpUtils.get(jobHistoryUrl);\n-            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n-            if (!jsonObject.has(\"job\")){\n+            if (null != responseContent) {\n+                ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+                if (!jsonObject.has(\"job\")) {\n+                    return ExecutionStatus.FAILURE;\n+                }\n+                result = jsonObject.path(\"job\").path(\"state\").asText();\n+            } else {\n                 return ExecutionStatus.FAILURE;\n             }\n-            result = jsonObject.path(\"job\").path(\"state\").asText();\n         }\n \n         switch (result) {\n", "next_change": {"commit": "2dc09c627fe1d32c63e9a7551390540581916d7d", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 68d03506c..aab69e092 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -450,6 +453,7 @@ public class HadoopUtils implements Closeable {\n             case Constants.ACCEPTED:\n                 return ExecutionStatus.SUBMITTED_SUCCESS;\n             case Constants.SUCCEEDED:\n+            case Constants.ENDED:\n                 return ExecutionStatus.SUCCESS;\n             case Constants.NEW:\n             case Constants.NEW_SAVING:\n", "next_change": {"commit": "0e3cafec1d0a6529c6bb5371429a9b51bd60fd5a", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex aab69e092..41fa66933 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -462,7 +489,6 @@ public class HadoopUtils implements Closeable {\n                 return ExecutionStatus.FAILURE;\n             case Constants.KILLED:\n                 return ExecutionStatus.KILL;\n-\n             case Constants.RUNNING:\n             default:\n                 return ExecutionStatus.RUNNING_EXECUTION;\n", "next_change": {"commit": "877441519711c729951ba811f91cdb088d4f1e96", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 41fa66933..8d7e4c2a6 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -434,64 +454,66 @@ public class HadoopUtils implements Closeable, StorageOperate {\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) throws BaseException {\n+    public TaskExecutionStatus getApplicationStatus(String applicationId) throws BaseException {\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n \n         String result;\n         String applicationUrl = getApplicationUrl(applicationId);\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"generate yarn application url, applicationUrl={}\", applicationUrl);\n-        }\n+        logger.debug(\"generate yarn application url, applicationUrl={}\", applicationUrl);\n \n-        String responseContent = Boolean.TRUE.equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false)) ? KerberosHttpClient.get(applicationUrl) : HttpUtils.get(applicationUrl);\n+        String responseContent = Boolean.TRUE\n+                .equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false))\n+                        ? KerberosHttpClient.get(applicationUrl)\n+                        : HttpUtils.get(applicationUrl);\n         if (responseContent != null) {\n             ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n             if (!jsonObject.has(\"app\")) {\n-                return ExecutionStatus.FAILURE;\n+                return TaskExecutionStatus.FAILURE;\n             }\n             result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n \n         } else {\n-            //may be in job history\n+            // may be in job history\n             String jobHistoryUrl = getJobHistoryUrl(applicationId);\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"generate yarn job history application url, jobHistoryUrl={}\", jobHistoryUrl);\n-            }\n-            responseContent = Boolean.TRUE.equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false)) ? KerberosHttpClient.get(jobHistoryUrl) : HttpUtils.get(jobHistoryUrl);\n+            logger.debug(\"generate yarn job history application url, jobHistoryUrl={}\", jobHistoryUrl);\n+            responseContent = Boolean.TRUE\n+                    .equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false))\n+                            ? KerberosHttpClient.get(jobHistoryUrl)\n+                            : HttpUtils.get(jobHistoryUrl);\n \n             if (null != responseContent) {\n                 ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n                 if (!jsonObject.has(\"job\")) {\n-                    return ExecutionStatus.FAILURE;\n+                    return TaskExecutionStatus.FAILURE;\n                 }\n                 result = jsonObject.path(\"job\").path(\"state\").asText();\n             } else {\n-                return ExecutionStatus.FAILURE;\n+                return TaskExecutionStatus.FAILURE;\n             }\n         }\n \n         return getExecutionStatus(result);\n     }\n \n-    private ExecutionStatus getExecutionStatus(String result) {\n+    private TaskExecutionStatus getExecutionStatus(String result) {\n         switch (result) {\n             case Constants.ACCEPTED:\n-                return ExecutionStatus.SUBMITTED_SUCCESS;\n+                return TaskExecutionStatus.SUBMITTED_SUCCESS;\n             case Constants.SUCCEEDED:\n             case Constants.ENDED:\n-                return ExecutionStatus.SUCCESS;\n+                return TaskExecutionStatus.SUCCESS;\n             case Constants.NEW:\n             case Constants.NEW_SAVING:\n             case Constants.SUBMITTED:\n             case Constants.FAILED:\n-                return ExecutionStatus.FAILURE;\n+                return TaskExecutionStatus.FAILURE;\n             case Constants.KILLED:\n-                return ExecutionStatus.KILL;\n+                return TaskExecutionStatus.KILL;\n             case Constants.RUNNING:\n             default:\n-                return ExecutionStatus.RUNNING_EXECUTION;\n+                return TaskExecutionStatus.RUNNING_EXECUTION;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MzMxOA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436683318", "body": "result = jsonObject.path(\"job\").path(\"state\").asText() always assign a value to result ,which empty string indicating a null value . In original logic ,null value will throw NPE in the following switch. Now the result is empty string ,then getApplicationStatus method will return ExecutionStatus.RUNNING_EXEUTION. I think you'd better optimize the switch logic. only a suggestion", "bodyText": "result = jsonObject.path(\"job\").path(\"state\").asText() always assign a value to result ,which empty string indicating a null value . In original logic ,null value will throw NPE in the following switch. Now the result is empty string ,then getApplicationStatus method will return ExecutionStatus.RUNNING_EXEUTION. I think you'd better optimize the switch logic. only a suggestion", "bodyHTML": "<p dir=\"auto\">result = jsonObject.path(\"job\").path(\"state\").asText() always assign a value to result ,which empty string indicating a null value . In original logic ,null value will throw NPE in the following switch. Now the result is empty string ,then getApplicationStatus method will return ExecutionStatus.RUNNING_EXEUTION. I think you'd better optimize the switch logic. only a suggestion</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:09:28Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java", "diffHunk": "@@ -421,15 +418,15 @@ public ExecutionStatus getApplicationStatus(String applicationId) throws JSONExc\n \n         String responseContent = HttpUtils.get(applicationUrl);\n         if (responseContent != null) {\n-            JSONObject jsonObject = JSON.parseObject(responseContent);\n-            result = jsonObject.getJSONObject(\"app\").getString(\"finalStatus\");\n+            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n         } else {\n             //may be in job history\n             String jobHistoryUrl = getJobHistoryUrl(applicationId);\n             logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n             responseContent = HttpUtils.get(jobHistoryUrl);\n-            JSONObject jsonObject = JSONObject.parseObject(responseContent);\n-            result = jsonObject.getJSONObject(\"job\").getString(\"state\");\n+            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            result = jsonObject.path(\"job\").path(\"state\").asText();", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 360f4514b..e57201d74 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -426,6 +427,9 @@ public class HadoopUtils implements Closeable {\n             logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n             responseContent = HttpUtils.get(jobHistoryUrl);\n             ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            if (!jsonObject.has(\"job\")){\n+                throw new NullPointerException();\n+            }\n             result = jsonObject.path(\"job\").path(\"state\").asText();\n         }\n \n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex e57201d74..94f83acb5 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -428,7 +429,7 @@ public class HadoopUtils implements Closeable {\n             responseContent = HttpUtils.get(jobHistoryUrl);\n             ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n             if (!jsonObject.has(\"job\")){\n-                throw new NullPointerException();\n+                return ExecutionStatus.FAILURE;\n             }\n             result = jsonObject.path(\"job\").path(\"state\").asText();\n         }\n", "next_change": {"commit": "620ecffa7299b87228c54a8e50a99a96a2cb1cba", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 94f83acb5..b4eebd6fc 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -408,31 +400,19 @@ public class HadoopUtils implements Closeable {\n      *\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n+     * @throws JSONException json exception\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) {\n+    public ExecutionStatus getApplicationStatus(String applicationId) throws Exception {\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n \n-        String result = Constants.FAILED;\n         String applicationUrl = getApplicationUrl(applicationId);\n-        logger.info(\"applicationUrl={}\", applicationUrl);\n \n         String responseContent = HttpUtils.get(applicationUrl);\n-        if (responseContent != null) {\n-            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n-            result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n-        } else {\n-            //may be in job history\n-            String jobHistoryUrl = getJobHistoryUrl(applicationId);\n-            logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n-            responseContent = HttpUtils.get(jobHistoryUrl);\n-            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n-            if (!jsonObject.has(\"job\")){\n-                return ExecutionStatus.FAILURE;\n-            }\n-            result = jsonObject.path(\"job\").path(\"state\").asText();\n-        }\n+\n+        JSONObject jsonObject = JSON.parseObject(responseContent);\n+        String result = jsonObject.getJSONObject(\"app\").getString(\"finalStatus\");\n \n         switch (result) {\n             case Constants.ACCEPTED:\n", "next_change": {"commit": "73cae7f0460698420370a294aa17f511101b0e22", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex b4eebd6fc..10fa0b6db 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -400,19 +406,31 @@ public class HadoopUtils implements Closeable {\n      *\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n-     * @throws JSONException json exception\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) throws Exception {\n+    public ExecutionStatus getApplicationStatus(String applicationId) throws Exception{\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n \n+        String result = Constants.FAILED;\n         String applicationUrl = getApplicationUrl(applicationId);\n+        logger.info(\"applicationUrl={}\", applicationUrl);\n \n         String responseContent = HttpUtils.get(applicationUrl);\n-\n-        JSONObject jsonObject = JSON.parseObject(responseContent);\n-        String result = jsonObject.getJSONObject(\"app\").getString(\"finalStatus\");\n+        if (responseContent != null) {\n+            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n+        } else {\n+            //may be in job history\n+            String jobHistoryUrl = getJobHistoryUrl(applicationId);\n+            logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n+            responseContent = HttpUtils.get(jobHistoryUrl);\n+            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            if (!jsonObject.has(\"job\")){\n+                return ExecutionStatus.FAILURE;\n+            }\n+            result = jsonObject.path(\"job\").path(\"state\").asText();\n+        }\n \n         switch (result) {\n             case Constants.ACCEPTED:\n", "next_change": {"commit": "ba3adbd34b8b260f01e92b25612cfdb5c2370f6e", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 10fa0b6db..68d03506c 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -416,20 +417,33 @@ public class HadoopUtils implements Closeable {\n         String applicationUrl = getApplicationUrl(applicationId);\n         logger.info(\"applicationUrl={}\", applicationUrl);\n \n-        String responseContent = HttpUtils.get(applicationUrl);\n+        String responseContent;\n+        if (PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false)) {\n+            responseContent = KerberosHttpClient.get(applicationUrl);\n+        } else {\n+            responseContent = HttpUtils.get(applicationUrl);\n+        }\n         if (responseContent != null) {\n             ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+            if (!jsonObject.has(\"app\")) {\n+                return ExecutionStatus.FAILURE;\n+            }\n             result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n+\n         } else {\n             //may be in job history\n             String jobHistoryUrl = getJobHistoryUrl(applicationId);\n             logger.info(\"jobHistoryUrl={}\", jobHistoryUrl);\n             responseContent = HttpUtils.get(jobHistoryUrl);\n-            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n-            if (!jsonObject.has(\"job\")){\n+            if (null != responseContent) {\n+                ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n+                if (!jsonObject.has(\"job\")) {\n+                    return ExecutionStatus.FAILURE;\n+                }\n+                result = jsonObject.path(\"job\").path(\"state\").asText();\n+            } else {\n                 return ExecutionStatus.FAILURE;\n             }\n-            result = jsonObject.path(\"job\").path(\"state\").asText();\n         }\n \n         switch (result) {\n", "next_change": {"commit": "2dc09c627fe1d32c63e9a7551390540581916d7d", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 68d03506c..aab69e092 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -450,6 +453,7 @@ public class HadoopUtils implements Closeable {\n             case Constants.ACCEPTED:\n                 return ExecutionStatus.SUBMITTED_SUCCESS;\n             case Constants.SUCCEEDED:\n+            case Constants.ENDED:\n                 return ExecutionStatus.SUCCESS;\n             case Constants.NEW:\n             case Constants.NEW_SAVING:\n", "next_change": {"commit": "0e3cafec1d0a6529c6bb5371429a9b51bd60fd5a", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex aab69e092..41fa66933 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -462,7 +489,6 @@ public class HadoopUtils implements Closeable {\n                 return ExecutionStatus.FAILURE;\n             case Constants.KILLED:\n                 return ExecutionStatus.KILL;\n-\n             case Constants.RUNNING:\n             default:\n                 return ExecutionStatus.RUNNING_EXECUTION;\n", "next_change": {"commit": "877441519711c729951ba811f91cdb088d4f1e96", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 41fa66933..8d7e4c2a6 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -434,64 +454,66 @@ public class HadoopUtils implements Closeable, StorageOperate {\n      * @param applicationId application id\n      * @return the return may be null or there may be other parse exceptions\n      */\n-    public ExecutionStatus getApplicationStatus(String applicationId) throws BaseException {\n+    public TaskExecutionStatus getApplicationStatus(String applicationId) throws BaseException {\n         if (StringUtils.isEmpty(applicationId)) {\n             return null;\n         }\n \n         String result;\n         String applicationUrl = getApplicationUrl(applicationId);\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"generate yarn application url, applicationUrl={}\", applicationUrl);\n-        }\n+        logger.debug(\"generate yarn application url, applicationUrl={}\", applicationUrl);\n \n-        String responseContent = Boolean.TRUE.equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false)) ? KerberosHttpClient.get(applicationUrl) : HttpUtils.get(applicationUrl);\n+        String responseContent = Boolean.TRUE\n+                .equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false))\n+                        ? KerberosHttpClient.get(applicationUrl)\n+                        : HttpUtils.get(applicationUrl);\n         if (responseContent != null) {\n             ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n             if (!jsonObject.has(\"app\")) {\n-                return ExecutionStatus.FAILURE;\n+                return TaskExecutionStatus.FAILURE;\n             }\n             result = jsonObject.path(\"app\").path(\"finalStatus\").asText();\n \n         } else {\n-            //may be in job history\n+            // may be in job history\n             String jobHistoryUrl = getJobHistoryUrl(applicationId);\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"generate yarn job history application url, jobHistoryUrl={}\", jobHistoryUrl);\n-            }\n-            responseContent = Boolean.TRUE.equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false)) ? KerberosHttpClient.get(jobHistoryUrl) : HttpUtils.get(jobHistoryUrl);\n+            logger.debug(\"generate yarn job history application url, jobHistoryUrl={}\", jobHistoryUrl);\n+            responseContent = Boolean.TRUE\n+                    .equals(PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false))\n+                            ? KerberosHttpClient.get(jobHistoryUrl)\n+                            : HttpUtils.get(jobHistoryUrl);\n \n             if (null != responseContent) {\n                 ObjectNode jsonObject = JSONUtils.parseObject(responseContent);\n                 if (!jsonObject.has(\"job\")) {\n-                    return ExecutionStatus.FAILURE;\n+                    return TaskExecutionStatus.FAILURE;\n                 }\n                 result = jsonObject.path(\"job\").path(\"state\").asText();\n             } else {\n-                return ExecutionStatus.FAILURE;\n+                return TaskExecutionStatus.FAILURE;\n             }\n         }\n \n         return getExecutionStatus(result);\n     }\n \n-    private ExecutionStatus getExecutionStatus(String result) {\n+    private TaskExecutionStatus getExecutionStatus(String result) {\n         switch (result) {\n             case Constants.ACCEPTED:\n-                return ExecutionStatus.SUBMITTED_SUCCESS;\n+                return TaskExecutionStatus.SUBMITTED_SUCCESS;\n             case Constants.SUCCEEDED:\n             case Constants.ENDED:\n-                return ExecutionStatus.SUCCESS;\n+                return TaskExecutionStatus.SUCCESS;\n             case Constants.NEW:\n             case Constants.NEW_SAVING:\n             case Constants.SUBMITTED:\n             case Constants.FAILED:\n-                return ExecutionStatus.FAILURE;\n+                return TaskExecutionStatus.FAILURE;\n             case Constants.KILLED:\n-                return ExecutionStatus.KILL;\n+                return TaskExecutionStatus.KILL;\n             case Constants.RUNNING:\n             default:\n-                return ExecutionStatus.RUNNING_EXECUTION;\n+                return TaskExecutionStatus.RUNNING_EXECUTION;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NjM0Mg==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436686342", "body": "jsonObject.get(\"clusterInfo\") will throw NPE", "bodyText": "jsonObject.get(\"clusterInfo\") will throw NPE", "bodyHTML": "<p dir=\"auto\">jsonObject.get(\"clusterInfo\") will throw NPE</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:12:39Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java", "diffHunk": "@@ -669,10 +667,10 @@ public static String getRMState(String url) {\n                 return null;\n             }\n             //to json\n-            JSONObject jsonObject = JSON.parseObject(retStr);\n+            ObjectNode jsonObject = JSONUtils.parseObject(retStr);\n \n             //get ResourceManager state\n-            return jsonObject.getJSONObject(\"clusterInfo\").getString(\"haState\");\n+            return jsonObject.get(\"clusterInfo\").path(\"haState\").asText();", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 360f4514b..e57201d74 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -670,6 +674,9 @@ public class HadoopUtils implements Closeable {\n             ObjectNode jsonObject = JSONUtils.parseObject(retStr);\n \n             //get ResourceManager state\n+            if (!jsonObject.has(\"clusterInfo\")){\n+                return null;\n+            }\n             return jsonObject.get(\"clusterInfo\").path(\"haState\").asText();\n         }\n \n", "next_change": {"commit": "620ecffa7299b87228c54a8e50a99a96a2cb1cba", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex e57201d74..b4eebd6fc 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -671,13 +650,10 @@ public class HadoopUtils implements Closeable {\n                 return null;\n             }\n             //to json\n-            ObjectNode jsonObject = JSONUtils.parseObject(retStr);\n+            JSONObject jsonObject = JSON.parseObject(retStr);\n \n             //get ResourceManager state\n-            if (!jsonObject.has(\"clusterInfo\")){\n-                return null;\n-            }\n-            return jsonObject.get(\"clusterInfo\").path(\"haState\").asText();\n+            return jsonObject.getJSONObject(\"clusterInfo\").getString(\"haState\");\n         }\n \n     }\n", "next_change": {"commit": "73cae7f0460698420370a294aa17f511101b0e22", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex b4eebd6fc..10fa0b6db 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -650,10 +670,13 @@ public class HadoopUtils implements Closeable {\n                 return null;\n             }\n             //to json\n-            JSONObject jsonObject = JSON.parseObject(retStr);\n+            ObjectNode jsonObject = JSONUtils.parseObject(retStr);\n \n             //get ResourceManager state\n-            return jsonObject.getJSONObject(\"clusterInfo\").getString(\"haState\");\n+            if (!jsonObject.has(\"clusterInfo\")){\n+                return null;\n+            }\n+            return jsonObject.get(\"clusterInfo\").path(\"haState\").asText();\n         }\n \n     }\n", "next_change": {"commit": "ba3adbd34b8b260f01e92b25612cfdb5c2370f6e", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 10fa0b6db..68d03506c 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -673,7 +687,7 @@ public class HadoopUtils implements Closeable {\n             ObjectNode jsonObject = JSONUtils.parseObject(retStr);\n \n             //get ResourceManager state\n-            if (!jsonObject.has(\"clusterInfo\")){\n+            if (!jsonObject.has(\"clusterInfo\")) {\n                 return null;\n             }\n             return jsonObject.get(\"clusterInfo\").path(\"haState\").asText();\n", "next_change": {"commit": "7af20ca3afe858f29abdd9ad9cb5013d8fd33d65", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex 68d03506c..fe9ac932c 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -694,4 +698,5 @@ public class HadoopUtils implements Closeable {\n         }\n \n     }\n+\n }\n", "next_change": {"commit": "0e3cafec1d0a6529c6bb5371429a9b51bd60fd5a", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\nindex fe9ac932c..41fa66933 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java\n", "chunk": "@@ -699,4 +714,18 @@ public class HadoopUtils implements Closeable {\n \n     }\n \n+    @Override\n+    public void deleteTenant(String tenantCode) throws Exception {\n+        String tenantPath = getHdfsDataBasePath() + FOLDER_SEPARATOR + tenantCode;\n+\n+        if (exists(tenantCode, tenantPath)) {\n+            delete(tenantCode, tenantPath, true);\n+\n+        }\n+    }\n+\n+    @Override\n+    public ResUploadType returnStorageType() {\n+        return ResUploadType.HDFS;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4OTk3NQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436689975", "body": "don't use getMapper directly", "bodyText": "don't use getMapper directly", "bodyHTML": "<p dir=\"auto\">don't use getMapper directly</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:16:35Z", "path": "dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java", "diffHunk": "@@ -271,7 +279,16 @@ public String getGlobalParams() {\n     }\n \n     public void setGlobalParams(String globalParams) {\n-        this.globalParamList = JSON.parseArray(globalParams, Property.class);\n+        if (globalParams == null){\n+            this.globalParamList = new ArrayList<>();\n+        }else {\n+            try {\n+                this.globalParamList = JSONUtils.getMapper().readValue(globalParams, new TypeReference<List<Property>>() {", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 2eb65b126..6b4a83dfd 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -282,12 +285,7 @@ public class ProcessDefinition {\n         if (globalParams == null){\n             this.globalParamList = new ArrayList<>();\n         }else {\n-            try {\n-                this.globalParamList = JSONUtils.getMapper().readValue(globalParams, new TypeReference<List<Property>>() {\n-                });\n-            } catch (IOException e) {\n-                logger.error(\"json parse exception!\", e);\n-            }\n+            this.globalParamList = JSONUtils.toList(globalParams, Property.class);\n         }\n         this.globalParams = globalParams;\n     }\n", "next_change": {"commit": "93660f4d617d750d803cc3a7f68fe06c6f694463", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 6b4a83dfd..56f6cfe90 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -282,9 +278,9 @@ public class ProcessDefinition {\n     }\n \n     public void setGlobalParams(String globalParams) {\n-        if (globalParams == null){\n+        if (globalParams == null) {\n             this.globalParamList = new ArrayList<>();\n-        }else {\n+        } else {\n             this.globalParamList = JSONUtils.toList(globalParams, Property.class);\n         }\n         this.globalParams = globalParams;\n", "next_change": {"commit": "9ca51cf0e6a108923a703097ee74a41bdcb6404e", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 56f6cfe90..60fd4b26e 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -272,16 +283,14 @@ public class ProcessDefinition {\n         this.projectName = projectName;\n     }\n \n-\n     public String getGlobalParams() {\n         return globalParams;\n     }\n \n     public void setGlobalParams(String globalParams) {\n-        if (globalParams == null) {\n+        this.globalParamList = JSONUtils.toList(globalParams, Property.class);\n+        if (this.globalParamList == null) {\n             this.globalParamList = new ArrayList<>();\n-        } else {\n-            this.globalParamList = JSONUtils.toList(globalParams, Property.class);\n         }\n         this.globalParams = globalParams;\n     }\n", "next_change": {"commit": "d833a28b2e312c9becd3d356f71f124317bad7f9", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 60fd4b26e..6e7414c28 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -203,90 +210,6 @@ public class ProcessDefinition {\n         this.flag = Flag.YES;\n     }\n \n-    public String getName() {\n-        return name;\n-    }\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public int getVersion() {\n-        return version;\n-    }\n-\n-    public void setVersion(int version) {\n-        this.version = version;\n-    }\n-\n-    public int getId() {\n-        return id;\n-    }\n-\n-    public void setId(int id) {\n-        this.id = id;\n-    }\n-\n-    public ReleaseState getReleaseState() {\n-        return releaseState;\n-    }\n-\n-    public void setReleaseState(ReleaseState releaseState) {\n-        this.releaseState = releaseState;\n-    }\n-\n-    public Date getCreateTime() {\n-        return createTime;\n-    }\n-\n-    public void setCreateTime(Date createTime) {\n-        this.createTime = createTime;\n-    }\n-\n-    public Date getUpdateTime() {\n-        return updateTime;\n-    }\n-\n-    public void setUpdateTime(Date updateTime) {\n-        this.updateTime = updateTime;\n-    }\n-\n-    public Flag getFlag() {\n-        return flag;\n-    }\n-\n-    public void setFlag(Flag flag) {\n-        this.flag = flag;\n-    }\n-\n-    public int getUserId() {\n-        return userId;\n-    }\n-\n-    public void setUserId(int userId) {\n-        this.userId = userId;\n-    }\n-\n-    public String getUserName() {\n-        return userName;\n-    }\n-\n-    public void setUserName(String userName) {\n-        this.userName = userName;\n-    }\n-\n-    public String getProjectName() {\n-        return projectName;\n-    }\n-\n-    public void setProjectName(String projectName) {\n-        this.projectName = projectName;\n-    }\n-\n-    public String getGlobalParams() {\n-        return globalParams;\n-    }\n-\n     public void setGlobalParams(String globalParams) {\n         this.globalParamList = JSONUtils.toList(globalParams, Property.class);\n         if (this.globalParamList == null) {\n", "next_change": null}, {"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 60fd4b26e..6e7414c28 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -295,16 +218,8 @@ public class ProcessDefinition {\n         this.globalParams = globalParams;\n     }\n \n-    public List<Property> getGlobalParamList() {\n-        return globalParamList;\n-    }\n-\n-    public void setGlobalParamList(List<Property> globalParamList) {\n-        this.globalParamList = globalParamList;\n-    }\n-\n     public Map<String, String> getGlobalParamMap() {\n-        if (globalParamMap == null && StringUtils.isNotEmpty(globalParams)) {\n+        if (globalParamMap == null && !Strings.isNullOrEmpty(globalParams)) {\n             List<Property> propList = JSONUtils.toList(globalParams, Property.class);\n             globalParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n         }\n", "next_change": {"commit": "e27c79974d93d0d4181a0f5dbe45159084e224d3", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 6e7414c28..27df7bd57 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -226,5 +226,4 @@ public class ProcessDefinition {\n \n         return globalParamMap;\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MDQ0Mw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436690443", "body": "don't use getMapper directly", "bodyText": "don't use getMapper directly", "bodyHTML": "<p dir=\"auto\">don't use getMapper directly</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:17:06Z", "path": "dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java", "diffHunk": "@@ -280,15 +297,21 @@ public void setGlobalParams(String globalParams) {\n     }\n \n     public void setGlobalParamList(List<Property> globalParamList) {\n-        this.globalParams = JSON.toJSONString(globalParamList);\n+        this.globalParams = JSONUtils.toJsonString(globalParamList);\n         this.globalParamList = globalParamList;\n     }\n \n     public Map<String, String> getGlobalParamMap() {\n-        List<Property> propList;\n+        List<Property> propList = new ArrayList<> ();\n \n         if (globalParamMap == null && StringUtils.isNotEmpty(globalParams)) {\n-            propList = JSON.parseArray(globalParams, Property.class);\n+            try {\n+                propList = JSONUtils.getMapper().readValue(globalParams, new TypeReference<List<Property>>() {", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 2eb65b126..6b4a83dfd 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -305,13 +303,7 @@ public class ProcessDefinition {\n         List<Property> propList = new ArrayList<> ();\n \n         if (globalParamMap == null && StringUtils.isNotEmpty(globalParams)) {\n-            try {\n-                propList = JSONUtils.getMapper().readValue(globalParams, new TypeReference<List<Property>>() {\n-                });\n-            } catch (IOException e) {\n-                logger.error(\"json parse exception!\", e);\n-            }\n-\n+            propList = JSONUtils.toList(globalParams,Property.class);\n             globalParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n         }\n \n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 6b4a83dfd..364848299 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -300,10 +294,8 @@ public class ProcessDefinition {\n     }\n \n     public Map<String, String> getGlobalParamMap() {\n-        List<Property> propList = new ArrayList<> ();\n-\n         if (globalParamMap == null && StringUtils.isNotEmpty(globalParams)) {\n-            propList = JSONUtils.toList(globalParams,Property.class);\n+            List<Property> propList = JSONUtils.toList(globalParams,Property.class);\n             globalParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n         }\n \n", "next_change": {"commit": "93660f4d617d750d803cc3a7f68fe06c6f694463", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 364848299..56f6cfe90 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -295,7 +297,7 @@ public class ProcessDefinition {\n \n     public Map<String, String> getGlobalParamMap() {\n         if (globalParamMap == null && StringUtils.isNotEmpty(globalParams)) {\n-            List<Property> propList = JSONUtils.toList(globalParams,Property.class);\n+            List<Property> propList = JSONUtils.toList(globalParams, Property.class);\n             globalParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n         }\n \n", "next_change": {"commit": "d80cf21456265c9d84e642bdb4db4067c7577fc6", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 56f6cfe90..80331db34 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -291,12 +304,11 @@ public class ProcessDefinition {\n     }\n \n     public void setGlobalParamList(List<Property> globalParamList) {\n-        this.globalParams = JSONUtils.toJsonString(globalParamList);\n         this.globalParamList = globalParamList;\n     }\n \n     public Map<String, String> getGlobalParamMap() {\n-        if (globalParamMap == null && StringUtils.isNotEmpty(globalParams)) {\n+        if (globalParamMap == null && !Strings.isNullOrEmpty(globalParams)) {\n             List<Property> propList = JSONUtils.toList(globalParams, Property.class);\n             globalParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n         }\n", "next_change": {"commit": "d833a28b2e312c9becd3d356f71f124317bad7f9", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 80331db34..6e7414c28 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -299,14 +218,6 @@ public class ProcessDefinition {\n         this.globalParams = globalParams;\n     }\n \n-    public List<Property> getGlobalParamList() {\n-        return globalParamList;\n-    }\n-\n-    public void setGlobalParamList(List<Property> globalParamList) {\n-        this.globalParamList = globalParamList;\n-    }\n-\n     public Map<String, String> getGlobalParamMap() {\n         if (globalParamMap == null && !Strings.isNullOrEmpty(globalParams)) {\n             List<Property> propList = JSONUtils.toList(globalParams, Property.class);\n", "next_change": {"commit": "e27c79974d93d0d4181a0f5dbe45159084e224d3", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 6e7414c28..27df7bd57 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -226,5 +226,4 @@ public class ProcessDefinition {\n \n         return globalParamMap;\n     }\n-\n }\n", "next_change": null}]}}, {"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 80331db34..6e7414c28 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -316,146 +227,4 @@ public class ProcessDefinition {\n         return globalParamMap;\n     }\n \n-    public void setGlobalParamMap(Map<String, String> globalParamMap) {\n-        this.globalParamMap = globalParamMap;\n-    }\n-\n-    public String getLocations() {\n-        return locations;\n-    }\n-\n-    public void setLocations(String locations) {\n-        this.locations = locations;\n-    }\n-\n-    public ReleaseState getScheduleReleaseState() {\n-        return scheduleReleaseState;\n-    }\n-\n-    public void setScheduleReleaseState(ReleaseState scheduleReleaseState) {\n-        this.scheduleReleaseState = scheduleReleaseState;\n-    }\n-\n-    public int getTimeout() {\n-        return timeout;\n-    }\n-\n-    public void setTimeout(int timeout) {\n-        this.timeout = timeout;\n-    }\n-\n-    public int getTenantId() {\n-        return tenantId;\n-    }\n-\n-    public void setTenantId(int tenantId) {\n-        this.tenantId = tenantId;\n-    }\n-\n-    public String getTenantCode() {\n-        return tenantCode;\n-    }\n-\n-    public void setTenantCode(String tenantCode) {\n-        this.tenantCode = tenantCode;\n-    }\n-\n-    public String getDescription() {\n-        return description;\n-    }\n-\n-    public void setDescription(String description) {\n-        this.description = description;\n-    }\n-\n-    public String getModifyBy() {\n-        return modifyBy;\n-    }\n-\n-    public void setModifyBy(String modifyBy) {\n-        this.modifyBy = modifyBy;\n-    }\n-\n-    public long getCode() {\n-        return code;\n-    }\n-\n-    public void setCode(long code) {\n-        this.code = code;\n-    }\n-\n-    public long getProjectCode() {\n-        return projectCode;\n-    }\n-\n-    public void setProjectCode(long projectCode) {\n-        this.projectCode = projectCode;\n-    }\n-\n-    public int getWarningGroupId() {\n-        return warningGroupId;\n-    }\n-\n-    public void setWarningGroupId(int warningGroupId) {\n-        this.warningGroupId = warningGroupId;\n-    }\n-\n-    public ProcessExecutionTypeEnum getExecutionType() {\n-        return executionType;\n-    }\n-\n-    public void setExecutionType(ProcessExecutionTypeEnum executionType) {\n-        this.executionType = executionType;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        ProcessDefinition that = (ProcessDefinition) o;\n-        return projectCode == that.projectCode\n-            && userId == that.userId\n-            && timeout == that.timeout\n-            && tenantId == that.tenantId\n-            && Objects.equals(name, that.name)\n-            && releaseState == that.releaseState\n-            && Objects.equals(description, that.description)\n-            && Objects.equals(globalParams, that.globalParams)\n-            && flag == that.flag\n-            && executionType == that.executionType\n-            && Objects.equals(locations, that.locations);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"ProcessDefinition{\"\n-            + \"id=\" + id\n-            + \", code=\" + code\n-            + \", name='\" + name + '\\''\n-            + \", version=\" + version\n-            + \", releaseState=\" + releaseState\n-            + \", projectCode=\" + projectCode\n-            + \", description='\" + description + '\\''\n-            + \", globalParams='\" + globalParams + '\\''\n-            + \", globalParamList=\" + globalParamList\n-            + \", globalParamMap=\" + globalParamMap\n-            + \", createTime=\" + createTime\n-            + \", updateTime=\" + updateTime\n-            + \", flag=\" + flag\n-            + \", userId=\" + userId\n-            + \", userName='\" + userName + '\\''\n-            + \", projectName='\" + projectName + '\\''\n-            + \", locations='\" + locations + '\\''\n-            + \", scheduleReleaseState=\" + scheduleReleaseState\n-            + \", timeout=\" + timeout\n-            + \", tenantId=\" + tenantId\n-            + \", tenantCode='\" + tenantCode + '\\''\n-            + \", modifyBy='\" + modifyBy + '\\''\n-            + \", warningGroupId=\" + warningGroupId\n-            + '}';\n-    }\n }\n", "next_change": {"commit": "e27c79974d93d0d4181a0f5dbe45159084e224d3", "changed_code": [{"header": "diff --git a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\nindex 6e7414c28..27df7bd57 100644\n--- a/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n+++ b/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/ProcessDefinition.java\n", "chunk": "@@ -226,5 +226,4 @@ public class ProcessDefinition {\n \n         return globalParamMap;\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5Mjg2NQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436692865", "body": "wow, what's format of this file!", "bodyText": "wow, what's format of this file!", "bodyHTML": "<p dir=\"auto\">wow, what's format of this file!</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:19:44Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteRequestCommand implements Serializable {\r\r    /**\r     *  task execution context\r     */\r    private String taskExecutionContext;\r\r    public String getTaskExecutionContext() {\r        return taskExecutionContext;\r    }\r\r    public void setTaskExecutionContext(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    public TaskExecuteRequestCommand() {\r    }\r\r    public TaskExecuteRequestCommand(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_REQUEST);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteRequestCommand{\" +\r                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\r\rimport java.io.Serializable;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteRequestCommand implements Serializable {\r\r    /**\r     *  task execution context\r     */\r    private String taskExecutionContext;\r\r    public String getTaskExecutionContext() {\r        return taskExecutionContext;\r    }\r\r    public void setTaskExecutionContext(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    public TaskExecuteRequestCommand() {\r    }\r\r    public TaskExecuteRequestCommand(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_REQUEST);\r        byte[] body = JacksonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteRequestCommand{\" +\r                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\r                '}';\r    }\r}\r", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java\nindex affa17c08..603f8a088 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java\n", "chunk": "@@ -1 +1 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\n\nimport java.io.Serializable;\n\n/**\n *  execute task request command\n */\npublic class TaskExecuteRequestCommand implements Serializable {\n\n    /**\n     *  task execution context\n     */\n    private String taskExecutionContext;\n\n    public String getTaskExecutionContext() {\n        return taskExecutionContext;\n    }\n\n    public void setTaskExecutionContext(String taskExecutionContext) {\n        this.taskExecutionContext = taskExecutionContext;\n    }\n\n    public TaskExecuteRequestCommand() {\n    }\n\n    public TaskExecuteRequestCommand(String taskExecutionContext) {\n        this.taskExecutionContext = taskExecutionContext;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_REQUEST);\n        byte[] body = JacksonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteRequestCommand{\" +\n                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\n\n/**\n *  execute task request command\n */\npublic class TaskExecuteRequestCommand implements Serializable {\n\n    /**\n     *  task execution context\n     */\n    private String taskExecutionContext;\n\n    public String getTaskExecutionContext() {\n        return taskExecutionContext;\n    }\n\n    public void setTaskExecutionContext(String taskExecutionContext) {\n        this.taskExecutionContext = taskExecutionContext;\n    }\n\n    public TaskExecuteRequestCommand() {\n    }\n\n    public TaskExecuteRequestCommand(String taskExecutionContext) {\n        this.taskExecutionContext = taskExecutionContext;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_REQUEST);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteRequestCommand{\" +\n                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MzE2MA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436693160", "body": "wow, what's format of this file!", "bodyText": "wow, what's format of this file!", "bodyHTML": "<p dir=\"auto\">wow, what's format of this file!</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:20:02Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteAckCommand implements Serializable {\r\r    /**\r     * taskInstanceId\r     */\r    private int taskInstanceId;\r\r    /**\r     * startTime\r     */\r    private Date startTime;\r\r    /**\r     * host\r     */\r    private String host;\r\r    /**\r     * status\r     */\r    private int status;\r\r    /**\r     * logPath\r     */\r    private String logPath;\r\r    /**\r     * executePath\r     */\r    private String executePath;\r\r    public Date getStartTime() {\r        return startTime;\r    }\r\r    public void setStartTime(Date startTime) {\r        this.startTime = startTime;\r    }\r\r    public String getHost() {\r        return host;\r    }\r\r    public void setHost(String host) {\r        this.host = host;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public String getLogPath() {\r        return logPath;\r    }\r\r    public void setLogPath(String logPath) {\r        this.logPath = logPath;\r    }\r\r    public String getExecutePath() {\r        return executePath;\r    }\r\r    public void setExecutePath(String executePath) {\r        this.executePath = executePath;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_ACK);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteAckCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", startTime=\" + startTime +\r                \", host='\" + host + '\\'' +\r                \", status=\" + status +\r                \", logPath='\" + logPath + '\\'' +\r                \", executePath='\" + executePath + '\\'' +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteAckCommand implements Serializable {\r\r    /**\r     * taskInstanceId\r     */\r    private int taskInstanceId;\r\r    /**\r     * startTime\r     */\r    private Date startTime;\r\r    /**\r     * host\r     */\r    private String host;\r\r    /**\r     * status\r     */\r    private int status;\r\r    /**\r     * logPath\r     */\r    private String logPath;\r\r    /**\r     * executePath\r     */\r    private String executePath;\r\r    public Date getStartTime() {\r        return startTime;\r    }\r\r    public void setStartTime(Date startTime) {\r        this.startTime = startTime;\r    }\r\r    public String getHost() {\r        return host;\r    }\r\r    public void setHost(String host) {\r        this.host = host;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public String getLogPath() {\r        return logPath;\r    }\r\r    public void setLogPath(String logPath) {\r        this.logPath = logPath;\r    }\r\r    public String getExecutePath() {\r        return executePath;\r    }\r\r    public void setExecutePath(String executePath) {\r        this.executePath = executePath;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_ACK);\r        byte[] body = JacksonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteAckCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", startTime=\" + startTime +\r                \", host='\" + host + '\\'' +\r                \", status=\" + status +\r                \", logPath='\" + logPath + '\\'' +\r                \", executePath='\" + executePath + '\\'' +\r                '}';\r    }\r}\r", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java\nindex a965849ca..796e4dc35 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java\n", "chunk": "@@ -1 +1 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n *  execute task request command\n */\npublic class TaskExecuteAckCommand implements Serializable {\n\n    /**\n     * taskInstanceId\n     */\n    private int taskInstanceId;\n\n    /**\n     * startTime\n     */\n    private Date startTime;\n\n    /**\n     * host\n     */\n    private String host;\n\n    /**\n     * status\n     */\n    private int status;\n\n    /**\n     * logPath\n     */\n    private String logPath;\n\n    /**\n     * executePath\n     */\n    private String executePath;\n\n    public Date getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(Date startTime) {\n        this.startTime = startTime;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public String getLogPath() {\n        return logPath;\n    }\n\n    public void setLogPath(String logPath) {\n        this.logPath = logPath;\n    }\n\n    public String getExecutePath() {\n        return executePath;\n    }\n\n    public void setExecutePath(String executePath) {\n        this.executePath = executePath;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_ACK);\n        byte[] body = JacksonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteAckCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", startTime=\" + startTime +\n                \", host='\" + host + '\\'' +\n                \", status=\" + status +\n                \", logPath='\" + logPath + '\\'' +\n                \", executePath='\" + executePath + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n *  execute task request command\n */\npublic class TaskExecuteAckCommand implements Serializable {\n\n    /**\n     * taskInstanceId\n     */\n    private int taskInstanceId;\n\n    /**\n     * startTime\n     */\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\n    private Date startTime;\n\n    /**\n     * host\n     */\n    private String host;\n\n    /**\n     * status\n     */\n    private int status;\n\n    /**\n     * logPath\n     */\n    private String logPath;\n\n    /**\n     * executePath\n     */\n    private String executePath;\n\n    public Date getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(Date startTime) {\n        this.startTime = startTime;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public String getLogPath() {\n        return logPath;\n    }\n\n    public void setLogPath(String logPath) {\n        this.logPath = logPath;\n    }\n\n    public String getExecutePath() {\n        return executePath;\n    }\n\n    public void setExecutePath(String executePath) {\n        this.executePath = executePath;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_ACK);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteAckCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", startTime=\" + startTime +\n                \", host='\" + host + '\\'' +\n                \", status=\" + status +\n                \", logPath='\" + logPath + '\\'' +\n                \", executePath='\" + executePath + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NDcxMg==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436694712", "body": "wow, what's format of this file! ", "bodyText": "wow, what's format of this file!", "bodyHTML": "<p dir=\"auto\">wow, what's format of this file!</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:21:41Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task response command\r */\rpublic class TaskExecuteResponseCommand implements Serializable {\r\r\r    public TaskExecuteResponseCommand() {\r    }\r\r    public TaskExecuteResponseCommand(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    /**\r     *  task instance id\r     */\r    private int taskInstanceId;\r\r    /**\r     *  status\r     */\r    private int status;\r\r\r    /**\r     *  end time\r     */\r    private Date endTime;\r\r\r    /**\r     * processId\r     */\r    private int processId;\r\r    /**\r     * appIds\r     */\r    private String appIds;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public Date getEndTime() {\r        return endTime;\r    }\r\r    public void setEndTime(Date endTime) {\r        this.endTime = endTime;\r    }\r\r    public int getProcessId() {\r        return processId;\r    }\r\r    public void setProcessId(int processId) {\r        this.processId = processId;\r    }\r\r    public String getAppIds() {\r        return appIds;\r    }\r\r    public void setAppIds(String appIds) {\r        this.appIds = appIds;\r    }\r\r    /**\r     * package response command\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteResponseCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", status=\" + status +\r                \", endTime=\" + endTime +\r                \", processId=\" + processId +\r                \", appIds='\" + appIds + '\\'' +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task response command\r */\rpublic class TaskExecuteResponseCommand implements Serializable {\r\r\r    public TaskExecuteResponseCommand() {\r    }\r\r    public TaskExecuteResponseCommand(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    /**\r     *  task instance id\r     */\r    private int taskInstanceId;\r\r    /**\r     *  status\r     */\r    private int status;\r\r\r    /**\r     *  end time\r     */\r    private Date endTime;\r\r\r    /**\r     * processId\r     */\r    private int processId;\r\r    /**\r     * appIds\r     */\r    private String appIds;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public Date getEndTime() {\r        return endTime;\r    }\r\r    public void setEndTime(Date endTime) {\r        this.endTime = endTime;\r    }\r\r    public int getProcessId() {\r        return processId;\r    }\r\r    public void setProcessId(int processId) {\r        this.processId = processId;\r    }\r\r    public String getAppIds() {\r        return appIds;\r    }\r\r    public void setAppIds(String appIds) {\r        this.appIds = appIds;\r    }\r\r    /**\r     * package response command\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\r        byte[] body = JacksonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteResponseCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", status=\" + status +\r                \", endTime=\" + endTime +\r                \", processId=\" + processId +\r                \", appIds='\" + appIds + '\\'' +\r                '}';\r    }\r}\r", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java\nindex 4ac4bbb36..0ea34fe39 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java\n", "chunk": "@@ -1 +1 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n *  execute task response command\n */\npublic class TaskExecuteResponseCommand implements Serializable {\n\n\n    public TaskExecuteResponseCommand() {\n    }\n\n    public TaskExecuteResponseCommand(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    /**\n     *  task instance id\n     */\n    private int taskInstanceId;\n\n    /**\n     *  status\n     */\n    private int status;\n\n\n    /**\n     *  end time\n     */\n    private Date endTime;\n\n\n    /**\n     * processId\n     */\n    private int processId;\n\n    /**\n     * appIds\n     */\n    private String appIds;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public Date getEndTime() {\n        return endTime;\n    }\n\n    public void setEndTime(Date endTime) {\n        this.endTime = endTime;\n    }\n\n    public int getProcessId() {\n        return processId;\n    }\n\n    public void setProcessId(int processId) {\n        this.processId = processId;\n    }\n\n    public String getAppIds() {\n        return appIds;\n    }\n\n    public void setAppIds(String appIds) {\n        this.appIds = appIds;\n    }\n\n    /**\n     * package response command\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\n        byte[] body = JacksonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteResponseCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", status=\" + status +\n                \", endTime=\" + endTime +\n                \", processId=\" + processId +\n                \", appIds='\" + appIds + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n *  execute task response command\n */\npublic class TaskExecuteResponseCommand implements Serializable {\n\n\n    public TaskExecuteResponseCommand() {\n    }\n\n    public TaskExecuteResponseCommand(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    /**\n     *  task instance id\n     */\n    private int taskInstanceId;\n\n    /**\n     *  status\n     */\n    private int status;\n\n\n    /**\n     *  end time\n     */\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\n    private Date endTime;\n\n\n    /**\n     * processId\n     */\n    private int processId;\n\n    /**\n     * appIds\n     */\n    private String appIds;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public Date getEndTime() {\n        return endTime;\n    }\n\n    public void setEndTime(Date endTime) {\n        this.endTime = endTime;\n    }\n\n    public int getProcessId() {\n        return processId;\n    }\n\n    public void setProcessId(int processId) {\n        this.processId = processId;\n    }\n\n    public String getAppIds() {\n        return appIds;\n    }\n\n    public void setAppIds(String appIds) {\n        this.appIds = appIds;\n    }\n\n    /**\n     * package response command\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteResponseCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", status=\" + status +\n                \", endTime=\" + endTime +\n                \", processId=\" + processId +\n                \", appIds='\" + appIds + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NTAwNw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436695007", "body": "wow, what's format of this file!", "bodyText": "wow, what's format of this file!", "bodyHTML": "<p dir=\"auto\">wow, what's format of this file!</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:21:58Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillRequestCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\r\r/**\r *  kill task request command\r */\rpublic class TaskKillRequestCommand implements Serializable {\r\r    /**\r     *  task id\r     */\r    private int taskInstanceId;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_KILL_REQUEST);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskKillRequestCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\r\rimport java.io.Serializable;\r\r/**\r *  kill task request command\r */\rpublic class TaskKillRequestCommand implements Serializable {\r\r    /**\r     *  task id\r     */\r    private int taskInstanceId;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_KILL_REQUEST);\r        byte[] body = JacksonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskKillRequestCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                '}';\r    }\r}\r", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillRequestCommand.java\nindex d1855e42e..092e462a1 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillRequestCommand.java\n", "chunk": "@@ -1 +1 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\n\nimport java.io.Serializable;\n\n/**\n *  kill task request command\n */\npublic class TaskKillRequestCommand implements Serializable {\n\n    /**\n     *  task id\n     */\n    private int taskInstanceId;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_KILL_REQUEST);\n        byte[] body = JacksonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskKillRequestCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\n\n/**\n *  kill task request command\n */\npublic class TaskKillRequestCommand implements Serializable {\n\n    /**\n     *  task id\n     */\n    private int taskInstanceId;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_KILL_REQUEST);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskKillRequestCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                '}';\n    }\n}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NTIyNg==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436695226", "body": "wow, what's format of this file!", "bodyText": "wow, what's format of this file!", "bodyHTML": "<p dir=\"auto\">wow, what's format of this file!</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:22:12Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillResponseCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\rimport java.util.List;\r\r/**\r *  kill task response command\r */\rpublic class TaskKillResponseCommand implements Serializable {\r\r    /**\r     * taskInstanceId\r     */\r    private int taskInstanceId;\r\r    /**\r     * host\r     */\r    private String host;\r\r    /**\r     * status\r     */\r    private int status;\r\r\r    /**\r     * processId\r     */\r    private int processId;\r\r    /**\r     * other resource manager appId , for example : YARN etc\r     */\r    protected List<String> appIds;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public String getHost() {\r        return host;\r    }\r\r    public void setHost(String host) {\r        this.host = host;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public int getProcessId() {\r        return processId;\r    }\r\r    public void setProcessId(int processId) {\r        this.processId = processId;\r    }\r\r    public List<String> getAppIds() {\r        return appIds;\r    }\r\r    public void setAppIds(List<String> appIds) {\r        this.appIds = appIds;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_KILL_RESPONSE);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskKillResponseCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", host='\" + host + '\\'' +\r                \", status=\" + status +\r                \", processId=\" + processId +\r                \", appIds=\" + appIds +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\r\rimport java.io.Serializable;\rimport java.util.List;\r\r/**\r *  kill task response command\r */\rpublic class TaskKillResponseCommand implements Serializable {\r\r    /**\r     * taskInstanceId\r     */\r    private int taskInstanceId;\r\r    /**\r     * host\r     */\r    private String host;\r\r    /**\r     * status\r     */\r    private int status;\r\r\r    /**\r     * processId\r     */\r    private int processId;\r\r    /**\r     * other resource manager appId , for example : YARN etc\r     */\r    protected List<String> appIds;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public String getHost() {\r        return host;\r    }\r\r    public void setHost(String host) {\r        this.host = host;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public int getProcessId() {\r        return processId;\r    }\r\r    public void setProcessId(int processId) {\r        this.processId = processId;\r    }\r\r    public List<String> getAppIds() {\r        return appIds;\r    }\r\r    public void setAppIds(List<String> appIds) {\r        this.appIds = appIds;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_KILL_RESPONSE);\r        byte[] body = JacksonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskKillResponseCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", host='\" + host + '\\'' +\r                \", status=\" + status +\r                \", processId=\" + processId +\r                \", appIds=\" + appIds +\r                '}';\r    }\r}\r", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillResponseCommand.java\nindex 2f35e5892..9dc0c541d 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskKillResponseCommand.java\n", "chunk": "@@ -1 +1 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JacksonSerializer;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n *  kill task response command\n */\npublic class TaskKillResponseCommand implements Serializable {\n\n    /**\n     * taskInstanceId\n     */\n    private int taskInstanceId;\n\n    /**\n     * host\n     */\n    private String host;\n\n    /**\n     * status\n     */\n    private int status;\n\n\n    /**\n     * processId\n     */\n    private int processId;\n\n    /**\n     * other resource manager appId , for example : YARN etc\n     */\n    protected List<String> appIds;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public int getProcessId() {\n        return processId;\n    }\n\n    public void setProcessId(int processId) {\n        this.processId = processId;\n    }\n\n    public List<String> getAppIds() {\n        return appIds;\n    }\n\n    public void setAppIds(List<String> appIds) {\n        this.appIds = appIds;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_KILL_RESPONSE);\n        byte[] body = JacksonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskKillResponseCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", host='\" + host + '\\'' +\n                \", status=\" + status +\n                \", processId=\" + processId +\n                \", appIds=\" + appIds +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n *  kill task response command\n */\npublic class TaskKillResponseCommand implements Serializable {\n\n    /**\n     * taskInstanceId\n     */\n    private int taskInstanceId;\n\n    /**\n     * host\n     */\n    private String host;\n\n    /**\n     * status\n     */\n    private int status;\n\n\n    /**\n     * processId\n     */\n    private int processId;\n\n    /**\n     * other resource manager appId , for example : YARN etc\n     */\n    protected List<String> appIds;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public int getProcessId() {\n        return processId;\n    }\n\n    public void setProcessId(int processId) {\n        this.processId = processId;\n    }\n\n    public List<String> getAppIds() {\n        return appIds;\n    }\n\n    public void setAppIds(List<String> appIds) {\n        this.appIds = appIds;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_KILL_RESPONSE);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskKillResponseCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", host='\" + host + '\\'' +\n                \", status=\" + status +\n                \", processId=\" + processId +\n                \", appIds=\" + appIds +\n                '}';\n    }\n}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NzAzNg==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436697036", "body": "It's better to rename JacksonSerialize to JsonSerializer", "bodyText": "It's better to rename JacksonSerialize to JsonSerializer", "bodyHTML": "<p dir=\"auto\">It's better to rename JacksonSerialize to JsonSerializer</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:24:12Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java", "diffHunk": "@@ -56,7 +56,7 @@ public void setPath(String path) {\n     public Command convert2Command(){\n         Command command = new Command();\n         command.setType(CommandType.GET_LOG_BYTES_REQUEST);\n-        byte[] body = FastJsonSerializer.serialize(this);\n+        byte[] body = JacksonSerializer.serialize(this);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java\nindex 4dc9af486..e4b21e2f8 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java\n", "chunk": "@@ -56,7 +56,7 @@ public class GetLogBytesRequestCommand implements Serializable {\n     public Command convert2Command(){\n         Command command = new Command();\n         command.setType(CommandType.GET_LOG_BYTES_REQUEST);\n-        byte[] body = JacksonSerializer.serialize(this);\n+        byte[] body = JsonSerializer.serialize(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": {"commit": "4b502e361fa0d41d142b1f2c0845d64d1dcc1abd", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java\nindex e4b21e2f8..ef71e07cd 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesRequestCommand.java\n", "chunk": "@@ -53,10 +53,10 @@ public class GetLogBytesRequestCommand implements Serializable {\n      *\n      * @return command\n      */\n-    public Command convert2Command(){\n+    public Command convert2Command() {\n         Command command = new Command();\n         command.setType(CommandType.GET_LOG_BYTES_REQUEST);\n-        byte[] body = JsonSerializer.serialize(this);\n+        byte[] body = JSONUtils.toJsonByteArray(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NzQ5Ng==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436697496", "body": "It's better to rename JacksonSerialize to JsonSerializer", "bodyText": "It's better to rename JacksonSerialize to JsonSerializer", "bodyHTML": "<p dir=\"auto\">It's better to rename JacksonSerialize to JsonSerializer</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:24:38Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java", "diffHunk": "@@ -57,7 +57,7 @@ public void setData(byte[] data) {\n     public Command convert2Command(long opaque){\n         Command command = new Command(opaque);\n         command.setType(CommandType.GET_LOG_BYTES_RESPONSE);\n-        byte[] body = FastJsonSerializer.serialize(this);\n+        byte[] body = JacksonSerializer.serialize(this);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java\nindex 32d1a5bea..349ec0385 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java\n", "chunk": "@@ -57,7 +57,7 @@ public class GetLogBytesResponseCommand implements Serializable {\n     public Command convert2Command(long opaque){\n         Command command = new Command(opaque);\n         command.setType(CommandType.GET_LOG_BYTES_RESPONSE);\n-        byte[] body = JacksonSerializer.serialize(this);\n+        byte[] body = JsonSerializer.serialize(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": {"commit": "4b502e361fa0d41d142b1f2c0845d64d1dcc1abd", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java\nindex 349ec0385..e8e3eb2a1 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/GetLogBytesResponseCommand.java\n", "chunk": "@@ -54,10 +54,10 @@ public class GetLogBytesResponseCommand implements Serializable {\n      * @param opaque request unique identification\n      * @return command\n      */\n-    public Command convert2Command(long opaque){\n+    public Command convert2Command(long opaque) {\n         Command command = new Command(opaque);\n         command.setType(CommandType.GET_LOG_BYTES_RESPONSE);\n-        byte[] body = JsonSerializer.serialize(this);\n+        byte[] body = JSONUtils.toJsonByteArray(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NzY0NA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436697644", "body": "It's better to rename JacksonSerialize to JsonSerializer", "bodyText": "It's better to rename JacksonSerialize to JsonSerializer", "bodyHTML": "<p dir=\"auto\">It's better to rename JacksonSerialize to JsonSerializer</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:24:48Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java", "diffHunk": "@@ -84,7 +84,7 @@ public void setLimit(int limit) {\n     public Command convert2Command(){\n         Command command = new Command();\n         command.setType(CommandType.ROLL_VIEW_LOG_REQUEST);\n-        byte[] body = FastJsonSerializer.serialize(this);\n+        byte[] body = JacksonSerializer.serialize(this);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java\nindex eeccc5860..00129c7e7 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java\n", "chunk": "@@ -84,7 +84,7 @@ public class RollViewLogRequestCommand implements Serializable {\n     public Command convert2Command(){\n         Command command = new Command();\n         command.setType(CommandType.ROLL_VIEW_LOG_REQUEST);\n-        byte[] body = JacksonSerializer.serialize(this);\n+        byte[] body = JsonSerializer.serialize(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": {"commit": "4b502e361fa0d41d142b1f2c0845d64d1dcc1abd", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java\nindex 00129c7e7..4afee09e6 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogRequestCommand.java\n", "chunk": "@@ -81,10 +81,10 @@ public class RollViewLogRequestCommand implements Serializable {\n      *\n      * @return command\n      */\n-    public Command convert2Command(){\n+    public Command convert2Command() {\n         Command command = new Command();\n         command.setType(CommandType.ROLL_VIEW_LOG_REQUEST);\n-        byte[] body = JsonSerializer.serialize(this);\n+        byte[] body = JSONUtils.toJsonByteArray(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NzgxNQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436697815", "body": "It's better to rename JacksonSerialize to JsonSerializer", "bodyText": "It's better to rename JacksonSerialize to JsonSerializer", "bodyHTML": "<p dir=\"auto\">It's better to rename JacksonSerialize to JsonSerializer</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:24:59Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java", "diffHunk": "@@ -57,7 +57,7 @@ public void setMsg(String msg) {\n     public Command convert2Command(long opaque){\n         Command command = new Command(opaque);\n         command.setType(CommandType.ROLL_VIEW_LOG_RESPONSE);\n-        byte[] body = FastJsonSerializer.serialize(this);\n+        byte[] body = JacksonSerializer.serialize(this);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java\nindex dca2feed2..a4f4f86c9 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java\n", "chunk": "@@ -57,7 +57,7 @@ public class RollViewLogResponseCommand implements Serializable {\n     public Command convert2Command(long opaque){\n         Command command = new Command(opaque);\n         command.setType(CommandType.ROLL_VIEW_LOG_RESPONSE);\n-        byte[] body = JacksonSerializer.serialize(this);\n+        byte[] body = JsonSerializer.serialize(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": {"commit": "4b502e361fa0d41d142b1f2c0845d64d1dcc1abd", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java\nindex a4f4f86c9..0e9e44a87 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/RollViewLogResponseCommand.java\n", "chunk": "@@ -54,10 +54,10 @@ public class RollViewLogResponseCommand implements Serializable {\n      * @param opaque request unique identification\n      * @return command\n      */\n-    public Command convert2Command(long opaque){\n+    public Command convert2Command(long opaque) {\n         Command command = new Command(opaque);\n         command.setType(CommandType.ROLL_VIEW_LOG_RESPONSE);\n-        byte[] body = JsonSerializer.serialize(this);\n+        byte[] body = JSONUtils.toJsonByteArray(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5Nzk5OQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436697999", "body": "It's better to rename JacksonSerialize to JsonSerializer", "bodyText": "It's better to rename JacksonSerialize to JsonSerializer", "bodyHTML": "<p dir=\"auto\">It's better to rename JacksonSerialize to JsonSerializer</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:25:09Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java", "diffHunk": "@@ -56,7 +56,7 @@ public void setPath(String path) {\n     public Command convert2Command(){\n         Command command = new Command();\n         command.setType(CommandType.VIEW_WHOLE_LOG_REQUEST);\n-        byte[] body = FastJsonSerializer.serialize(this);\n+        byte[] body = JacksonSerializer.serialize(this);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java\nindex 646d05c32..1d51653ea 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java\n", "chunk": "@@ -56,7 +56,7 @@ public class ViewLogRequestCommand implements Serializable {\n     public Command convert2Command(){\n         Command command = new Command();\n         command.setType(CommandType.VIEW_WHOLE_LOG_REQUEST);\n-        byte[] body = JacksonSerializer.serialize(this);\n+        byte[] body = JsonSerializer.serialize(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": {"commit": "4b502e361fa0d41d142b1f2c0845d64d1dcc1abd", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java\nindex 1d51653ea..e8094690d 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogRequestCommand.java\n", "chunk": "@@ -53,10 +53,10 @@ public class ViewLogRequestCommand implements Serializable {\n      *\n      * @return command\n      */\n-    public Command convert2Command(){\n+    public Command convert2Command() {\n         Command command = new Command();\n         command.setType(CommandType.VIEW_WHOLE_LOG_REQUEST);\n-        byte[] body = JsonSerializer.serialize(this);\n+        byte[] body = JSONUtils.toJsonByteArray(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5ODE5OQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436698199", "body": "It's better to rename JacksonSerialize to JsonSerializer", "bodyText": "It's better to rename JacksonSerialize to JsonSerializer", "bodyHTML": "<p dir=\"auto\">It's better to rename JacksonSerialize to JsonSerializer</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:25:20Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java", "diffHunk": "@@ -57,7 +57,7 @@ public void setMsg(String msg) {\n     public Command convert2Command(long opaque){\n         Command command = new Command(opaque);\n         command.setType(CommandType.VIEW_WHOLE_LOG_RESPONSE);\n-        byte[] body = FastJsonSerializer.serialize(this);\n+        byte[] body = JacksonSerializer.serialize(this);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java\nindex 970d1c07b..6940104f7 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java\n", "chunk": "@@ -57,7 +57,7 @@ public class ViewLogResponseCommand implements Serializable {\n     public Command convert2Command(long opaque){\n         Command command = new Command(opaque);\n         command.setType(CommandType.VIEW_WHOLE_LOG_RESPONSE);\n-        byte[] body = JacksonSerializer.serialize(this);\n+        byte[] body = JsonSerializer.serialize(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": {"commit": "4b502e361fa0d41d142b1f2c0845d64d1dcc1abd", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java\nindex 6940104f7..33e263087 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/log/ViewLogResponseCommand.java\n", "chunk": "@@ -54,10 +54,10 @@ public class ViewLogResponseCommand implements Serializable {\n      * @param opaque request unique identification\n      * @return command\n      */\n-    public Command convert2Command(long opaque){\n+    public Command convert2Command(long opaque) {\n         Command command = new Command(opaque);\n         command.setType(CommandType.VIEW_WHOLE_LOG_RESPONSE);\n-        byte[] body = JsonSerializer.serialize(this);\n+        byte[] body = JSONUtils.toJsonByteArray(this);\n         command.setBody(body);\n         return command;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwMDY4MQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436700681", "body": "In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker. You'd better make sure about this will not have any impact on invoker.", "bodyText": "In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker. You'd better make sure about this will not have any impact on invoker.", "bodyHTML": "<p dir=\"auto\">In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker. You'd better make sure about this will not have any impact on invoker.</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:28:28Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JacksonSerializer.java", "diffHunk": "@@ -31,7 +39,13 @@\n \t * @return byte array\n \t */\n \tpublic static <T> byte[] serialize(T obj)  {\n-\t\tString json = JSON.toJSONString(obj);\n+        String json = \"\";", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNTU3OQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r437135579", "bodyText": "toJSONString will not throw exceptions", "author": "simon824", "createdAt": "2020-06-09T04:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwMDY4MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwMDc0OA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436700748", "body": "In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker", "bodyText": "In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker", "bodyHTML": "<p dir=\"auto\">In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:28:34Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JacksonSerializer.java", "diffHunk": "@@ -42,7 +56,14 @@\n \t * @return string\n \t */\n \tpublic static <T> String serializeToString(T obj)  {\n-\t\treturn JSON.toJSONString(obj);\n+\t\tString json = \"\";\n+\t\ttry {", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwMDkzOQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436700939", "body": "In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker", "bodyText": "In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker", "bodyHTML": "<p dir=\"auto\">In original logic ,if obj can't format to json ,exceptions throw. However current method return empty string ,which maybe change the logic of the invoker</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:28:50Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JacksonSerializer.java", "diffHunk": "@@ -54,7 +75,15 @@\n \t * @return deserialize type\n \t */\n \tpublic static <T> T deserialize(byte[] src, Class<T> clazz) {\n-\t\treturn JSON.parseObject(src, clazz);\n+\n+        String json = new String(src, StandardCharsets.UTF_8);", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwMjU1Ng==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436702556", "body": "not use getMapper directly", "bodyText": "not use getMapper directly", "bodyHTML": "<p dir=\"auto\">not use getMapper directly</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:31:01Z", "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java", "diffHunk": "@@ -152,7 +153,13 @@ public void run() {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = JSONObject.parseArray(globalParamsStr, Property.class);\n+            List<Property> globalParamsList = new ArrayList<>();\n+\n+            try {", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "009fd01047283ca11d60714b128c3b52d61fc705", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 17b4b1771..d2d783ac8 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -153,13 +162,7 @@ public class TaskExecuteThread implements Runnable {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = new ArrayList<>();\n-\n-            try {\n-                globalParamsList = JSONUtils.getMapper().readValue(globalParamsStr, new TypeReference<List<Property>>() {});\n-            } catch (Exception e) {\n-                logger.error(\"parse list exception!\", e);\n-            }\n+            List<Property> globalParamsList = JSONObject.parseArray(globalParamsStr, Property.class);\n             globalParamsMap.putAll(globalParamsList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue)));\n         }\n         return globalParamsMap;\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex d2d783ac8..b964a7289 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -162,7 +153,8 @@ public class TaskExecuteThread implements Runnable {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = JSONObject.parseArray(globalParamsStr, Property.class);\n+            List<Property> globalParamsList = new ArrayList<>();\n+            globalParamsList = JSONUtils.toList(globalParamsStr, Property.class);\n             globalParamsMap.putAll(globalParamsList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue)));\n         }\n         return globalParamsMap;\n", "next_change": {"commit": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex b964a7289..677f09e11 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -153,8 +153,7 @@ public class TaskExecuteThread implements Runnable {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = new ArrayList<>();\n-            globalParamsList = JSONUtils.toList(globalParamsStr, Property.class);\n+            List<Property> globalParamsList = JSONUtils.toList(globalParamsStr, Property.class);\n             globalParamsMap.putAll(globalParamsList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue)));\n         }\n         return globalParamsMap;\n", "next_change": {"commit": "86ce8f133a42a2464a4916c6e0b42dc74628c70d", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 677f09e11..3263554e3 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -159,54 +233,20 @@ public class TaskExecuteThread implements Runnable {\n         return globalParamsMap;\n     }\n \n-    /**\n-     * set task timeout\n-     * @param taskExecutionContext TaskExecutionContext\n-     * @param taskNode\n-     */\n-    private void setTaskTimeout(TaskExecutionContext taskExecutionContext, TaskNode taskNode) {\n-        // the default timeout is the maximum value of the integer\n-        taskExecutionContext.setTaskTimeout(Integer.MAX_VALUE);\n-        TaskTimeoutParameter taskTimeoutParameter = taskNode.getTaskTimeoutParameter();\n-        if (taskTimeoutParameter.getEnable()){\n-            // get timeout strategy\n-            taskExecutionContext.setTaskTimeoutStrategy(taskTimeoutParameter.getStrategy().getCode());\n-            switch (taskTimeoutParameter.getStrategy()){\n-                case WARN:\n-                    break;\n-                case FAILED:\n-                    if (Integer.MAX_VALUE > taskTimeoutParameter.getInterval() * 60) {\n-                        taskExecutionContext.setTaskTimeout(taskTimeoutParameter.getInterval() * 60);\n-                    }\n-                    break;\n-                case WARNFAILED:\n-                    if (Integer.MAX_VALUE > taskTimeoutParameter.getInterval() * 60) {\n-                        taskExecutionContext.setTaskTimeout(taskTimeoutParameter.getInterval() * 60);\n-                    }\n-                    break;\n-                default:\n-                    logger.error(\"not support task timeout strategy: {}\", taskTimeoutParameter.getStrategy());\n-                    throw new IllegalArgumentException(\"not support task timeout strategy\");\n-\n-            }\n-        }\n-    }\n-\n \n     /**\n-     *  kill task\n+     * kill task\n      */\n-    public void kill(){\n-        if (task != null){\n+    public void kill() {\n+        if (task != null) {\n             try {\n                 task.cancelApplication(true);\n-            }catch (Exception e){\n+            } catch (Exception e) {\n                 logger.error(e.getMessage(),e);\n             }\n         }\n     }\n \n-\n     /**\n      * download resource file\n      *\n", "next_change": {"commit": "f7a06a033d2fac494594d16bb3031504dc068b6d", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 3263554e3..6fd4f34b2 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -250,13 +245,11 @@ public class TaskExecuteThread implements Runnable, Delayed {\n     /**\n      * download resource file\n      *\n-     * @param execLocalPath\n-     * @param projectRes\n-     * @param logger\n+     * @param execLocalPath execLocalPath\n+     * @param projectRes projectRes\n+     * @param logger logger\n      */\n-    private void downloadResource(String execLocalPath,\n-                                  Map<String, String> projectRes,\n-                                  Logger logger) throws Exception {\n+    private void downloadResource(String execLocalPath, Map<String, String> projectRes, Logger logger) {\n         if (MapUtils.isEmpty(projectRes)) {\n             return;\n         }\n", "next_change": {"commit": "7029062f4c2f247e9eac333e28e36e66b03fb435", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 6fd4f34b2..5a164e887 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -256,7 +276,7 @@ public class TaskExecuteThread implements Runnable, Delayed {\n \n         Set<Map.Entry<String, String>> resEntries = projectRes.entrySet();\n \n-        for (Map.Entry<String,String> resource : resEntries) {\n+        for (Map.Entry<String, String> resource : resEntries) {\n             String fullName = resource.getKey();\n             String tenantCode = resource.getValue();\n             File resFile = new File(execLocalPath, fullName);\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwODMwNQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436708305", "body": "better abstract this logic to one method of JSONUtils which put array to ObjectNode", "bodyText": "better abstract this logic to one method of JSONUtils which put array to ObjectNode", "bodyHTML": "<p dir=\"auto\">better abstract this logic to one method of JSONUtils which put array to ObjectNode</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:39:49Z", "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java", "diffHunk": "@@ -236,64 +222,90 @@ private String buildDataxJsonFile()\n \n     /**\n      * build datax job config\n-     * \n+     *\n      * @return collection of datax job config JSONObject\n      * @throws SQLException if error throws SQLException\n      */\n-    private List<JSONObject> buildDataxJobContentJson() throws SQLException {\n-        DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n+    private List<ObjectNode> buildDataxJobContentJson() throws SQLException {\n \n+        DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n \n         BaseDataSource dataSourceCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n                 dataxTaskExecutionContext.getSourceConnectionParams());\n \n         BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n                 dataxTaskExecutionContext.getTargetConnectionParams());\n \n-        List<JSONObject> readerConnArr = new ArrayList<>();\n-        JSONObject readerConn = new JSONObject();\n-        readerConn.put(\"querySql\", new String[] {dataXParameters.getSql()});\n-        readerConn.put(\"jdbcUrl\", new String[] {dataSourceCfg.getJdbcUrl()});\n+        List<ObjectNode> readerConnArr = new ArrayList<>();\n+        ObjectNode readerConn = JSONUtils.createObjectNode();\n+\n+        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n+        for (String sql : new String[]{dataXParameters.getSql()}) {\n+            sqlArr.add(sql);\n+        }\n+\n+        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n+        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n+            urlArr.add(url);\n+        }\n+\n         readerConnArr.add(readerConn);\n \n-        JSONObject readerParam = new JSONObject();\n+        ObjectNode readerParam = JSONUtils.createObjectNode();\n         readerParam.put(\"username\", dataSourceCfg.getUser());\n         readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.put(\"connection\", readerConnArr);\n+        readerParam.putArray(\"connection\").addAll(readerConnArr);\n \n-        JSONObject reader = new JSONObject();\n+\n+        ObjectNode reader = JSONUtils.createObjectNode();\n         reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.put(\"parameter\", readerParam);\n+        reader.set(\"parameter\", readerParam);\n+\n+        List<ObjectNode> writerConnArr = new ArrayList<>();\n+        ObjectNode writerConn = JSONUtils.createObjectNode();", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f6554ab9c0c74e8010c756d0200377d37931fbf", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex f85dfb8a3..9589a305c 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -222,90 +236,64 @@ public class DataxTask extends AbstractTask {\n \n     /**\n      * build datax job config\n-     *\n+     * \n      * @return collection of datax job config JSONObject\n      * @throws SQLException if error throws SQLException\n      */\n-    private List<ObjectNode> buildDataxJobContentJson() throws SQLException {\n-\n+    private List<JSONObject> buildDataxJobContentJson() throws SQLException {\n         DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n \n+\n         BaseDataSource dataSourceCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n                 dataxTaskExecutionContext.getSourceConnectionParams());\n \n         BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n                 dataxTaskExecutionContext.getTargetConnectionParams());\n \n-        List<ObjectNode> readerConnArr = new ArrayList<>();\n-        ObjectNode readerConn = JSONUtils.createObjectNode();\n-\n-        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n-        for (String sql : new String[]{dataXParameters.getSql()}) {\n-            sqlArr.add(sql);\n-        }\n-\n-        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n-        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n-            urlArr.add(url);\n-        }\n-\n+        List<JSONObject> readerConnArr = new ArrayList<>();\n+        JSONObject readerConn = new JSONObject();\n+        readerConn.put(\"querySql\", new String[] {dataXParameters.getSql()});\n+        readerConn.put(\"jdbcUrl\", new String[] {dataSourceCfg.getJdbcUrl()});\n         readerConnArr.add(readerConn);\n \n-        ObjectNode readerParam = JSONUtils.createObjectNode();\n+        JSONObject readerParam = new JSONObject();\n         readerParam.put(\"username\", dataSourceCfg.getUser());\n         readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.putArray(\"connection\").addAll(readerConnArr);\n+        readerParam.put(\"connection\", readerConnArr);\n \n-\n-        ObjectNode reader = JSONUtils.createObjectNode();\n+        JSONObject reader = new JSONObject();\n         reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.set(\"parameter\", readerParam);\n-\n-        List<ObjectNode> writerConnArr = new ArrayList<>();\n-        ObjectNode writerConn = JSONUtils.createObjectNode();\n-        ArrayNode tableArr = writerConn.putArray(\"table\");\n-        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n-            tableArr.add(table);\n-        }\n+        reader.put(\"parameter\", readerParam);\n \n+        List<JSONObject> writerConnArr = new ArrayList<>();\n+        JSONObject writerConn = new JSONObject();\n+        writerConn.put(\"table\", new String[] {dataXParameters.getTargetTable()});\n         writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n         writerConnArr.add(writerConn);\n \n-        ObjectNode writerParam = JSONUtils.createObjectNode();\n+        JSONObject writerParam = new JSONObject();\n         writerParam.put(\"username\", dataTargetCfg.getUser());\n         writerParam.put(\"password\", dataTargetCfg.getPassword());\n-\n-        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                dataSourceCfg, dataXParameters.getSql());\n-        ArrayNode columnArr = writerParam.putArray(\"column\");\n-        for (String column : columns) {\n-            columnArr.add(column);\n-        }\n-        writerParam.putArray(\"connection\").addAll(writerConnArr);\n-\n+        writerParam.put(\"column\",\n+            parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n+                    DbType.of(dataxTaskExecutionContext.getTargetType()),\n+                    dataSourceCfg, dataXParameters.getSql()));\n+        writerParam.put(\"connection\", writerConnArr);\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPreStatements())) {\n-            ArrayNode preSqlArr = writerParam.putArray(\"preSql\");\n-            for (String preSql : dataXParameters.getPreStatements()) {\n-                preSqlArr.add(preSql);\n-            }\n-\n+            writerParam.put(\"preSql\", dataXParameters.getPreStatements());\n         }\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPostStatements())) {\n-            ArrayNode postSqlArr = writerParam.putArray(\"postSql\");\n-            for (String postSql : dataXParameters.getPostStatements()) {\n-                postSqlArr.add(postSql);\n-            }\n+            writerParam.put(\"postSql\", dataXParameters.getPostStatements());\n         }\n \n-        ObjectNode writer = JSONUtils.createObjectNode();\n+        JSONObject writer = new JSONObject();\n         writer.put(\"name\", DataxUtils.getWriterPluginName(DbType.of(dataxTaskExecutionContext.getTargetType())));\n-        writer.set(\"parameter\", writerParam);\n+        writer.put(\"parameter\", writerParam);\n \n-        List<ObjectNode> contentList = new ArrayList<>();\n-        ObjectNode content = JSONUtils.createObjectNode();\n+        List<JSONObject> contentList = new ArrayList<>();\n+        JSONObject content = new JSONObject();\n         content.put(\"reader\", reader);\n         content.put(\"writer\", writer);\n         contentList.add(content);\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex 9589a305c..723ded4f2 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -250,50 +233,78 @@ public class DataxTask extends AbstractTask {\n         BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n                 dataxTaskExecutionContext.getTargetConnectionParams());\n \n-        List<JSONObject> readerConnArr = new ArrayList<>();\n-        JSONObject readerConn = new JSONObject();\n-        readerConn.put(\"querySql\", new String[] {dataXParameters.getSql()});\n-        readerConn.put(\"jdbcUrl\", new String[] {dataSourceCfg.getJdbcUrl()});\n+        List<ObjectNode> readerConnArr = new ArrayList<>();\n+        ObjectNode readerConn = JSONUtils.createObjectNode();\n+\n+        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n+        for (String sql : new String[]{dataXParameters.getSql()}) {\n+            sqlArr.add(sql);\n+        }\n+\n+        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n+        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n+            urlArr.add(url);\n+        }\n+\n         readerConnArr.add(readerConn);\n \n-        JSONObject readerParam = new JSONObject();\n+        ObjectNode readerParam = JSONUtils.createObjectNode();\n         readerParam.put(\"username\", dataSourceCfg.getUser());\n         readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.put(\"connection\", readerConnArr);\n+        readerParam.putArray(\"connection\").addAll(readerConnArr);\n \n-        JSONObject reader = new JSONObject();\n+\n+        ObjectNode reader = JSONUtils.createObjectNode();\n         reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.put(\"parameter\", readerParam);\n+        reader.set(\"parameter\", readerParam);\n+\n+        List<ObjectNode> writerConnArr = new ArrayList<>();\n+        ObjectNode writerConn = JSONUtils.createObjectNode();\n+        ArrayNode tableArr = writerConn.putArray(\"table\");\n+        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n+            tableArr.add(table);\n+        }\n \n-        List<JSONObject> writerConnArr = new ArrayList<>();\n-        JSONObject writerConn = new JSONObject();\n-        writerConn.put(\"table\", new String[] {dataXParameters.getTargetTable()});\n         writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n         writerConnArr.add(writerConn);\n \n-        JSONObject writerParam = new JSONObject();\n+        ObjectNode writerParam = JSONUtils.createObjectNode();\n         writerParam.put(\"username\", dataTargetCfg.getUser());\n         writerParam.put(\"password\", dataTargetCfg.getPassword());\n-        writerParam.put(\"column\",\n-            parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                    DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                    dataSourceCfg, dataXParameters.getSql()));\n-        writerParam.put(\"connection\", writerConnArr);\n+\n+        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n+                DbType.of(dataxTaskExecutionContext.getTargetType()),\n+                dataSourceCfg, dataXParameters.getSql());\n+\n+        ArrayNode columnArr = writerParam.putArray(\"column\");\n+        columnArr.addAll()\n+        for (String column : columns) {\n+            columnArr.add(column);\n+        }\n+        writerParam.putArray(\"connection\").addAll(writerConnArr);\n+\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPreStatements())) {\n-            writerParam.put(\"preSql\", dataXParameters.getPreStatements());\n+            ArrayNode preSqlArr = writerParam.putArray(\"preSql\");\n+            for (String preSql : dataXParameters.getPreStatements()) {\n+                preSqlArr.add(preSql);\n+            }\n+\n         }\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPostStatements())) {\n-            writerParam.put(\"postSql\", dataXParameters.getPostStatements());\n+            ArrayNode postSqlArr = writerParam.putArray(\"postSql\");\n+            for (String postSql : dataXParameters.getPostStatements()) {\n+                postSqlArr.add(postSql);\n+            }\n         }\n \n-        JSONObject writer = new JSONObject();\n+        ObjectNode writer = JSONUtils.createObjectNode();\n         writer.put(\"name\", DataxUtils.getWriterPluginName(DbType.of(dataxTaskExecutionContext.getTargetType())));\n-        writer.put(\"parameter\", writerParam);\n+        writer.set(\"parameter\", writerParam);\n \n-        List<JSONObject> contentList = new ArrayList<>();\n-        JSONObject content = new JSONObject();\n+        List<ObjectNode> contentList = new ArrayList<>();\n+        ObjectNode content = JSONUtils.createObjectNode();\n         content.put(\"reader\", reader);\n         content.put(\"writer\", writer);\n         contentList.add(content);\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex 723ded4f2..5a8b8d670 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -305,8 +304,8 @@ public class DataxTask extends AbstractTask {\n \n         List<ObjectNode> contentList = new ArrayList<>();\n         ObjectNode content = JSONUtils.createObjectNode();\n-        content.put(\"reader\", reader);\n-        content.put(\"writer\", writer);\n+        content.put(\"reader\", reader.toString());\n+        content.put(\"writer\", reader.toString());\n         contentList.add(content);\n \n         return contentList;\n", "next_change": {"commit": "65953fe2573d4358c4bbc023cf8f04f6343345bb", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex 5a8b8d670..a14a5d64f 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -305,7 +305,7 @@ public class DataxTask extends AbstractTask {\n         List<ObjectNode> contentList = new ArrayList<>();\n         ObjectNode content = JSONUtils.createObjectNode();\n         content.put(\"reader\", reader.toString());\n-        content.put(\"writer\", reader.toString());\n+        content.put(\"writer\", writer.toString());\n         contentList.add(content);\n \n         return contentList;\n", "next_change": {"commit": "cc7a4446f50a247f054a9671648e948c654dfe65", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex a14a5d64f..8f80963f8 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -304,8 +310,8 @@ public class DataxTask extends AbstractTask {\n \n         List<ObjectNode> contentList = new ArrayList<>();\n         ObjectNode content = JSONUtils.createObjectNode();\n-        content.put(\"reader\", reader.toString());\n-        content.put(\"writer\", writer.toString());\n+        content.set(\"reader\", reader);\n+        content.set(\"writer\", writer);\n         contentList.add(content);\n \n         return contentList;\n", "next_change": {"commit": "4715de11fc0996588a91f8b09da81158c844432e", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\ndeleted file mode 100755\nindex 8f80963f8..000000000\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ /dev/null\n", "chunk": "@@ -1,566 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.dolphinscheduler.server.worker.task.datax;\n-\n-import org.apache.dolphinscheduler.common.Constants;\n-import org.apache.dolphinscheduler.common.enums.CommandType;\n-import org.apache.dolphinscheduler.common.enums.DbType;\n-import org.apache.dolphinscheduler.common.enums.Flag;\n-import org.apache.dolphinscheduler.common.process.Property;\n-import org.apache.dolphinscheduler.common.task.AbstractParameters;\n-import org.apache.dolphinscheduler.common.task.datax.DataxParameters;\n-import org.apache.dolphinscheduler.common.utils.CollectionUtils;\n-import org.apache.dolphinscheduler.common.utils.JSONUtils;\n-import org.apache.dolphinscheduler.common.utils.OSUtils;\n-import org.apache.dolphinscheduler.common.utils.ParameterUtils;\n-import org.apache.dolphinscheduler.dao.datasource.BaseDataSource;\n-import org.apache.dolphinscheduler.dao.datasource.DataSourceFactory;\n-import org.apache.dolphinscheduler.server.entity.DataxTaskExecutionContext;\n-import org.apache.dolphinscheduler.server.entity.TaskExecutionContext;\n-import org.apache.dolphinscheduler.server.utils.DataxUtils;\n-import org.apache.dolphinscheduler.server.utils.ParamUtils;\n-import org.apache.dolphinscheduler.server.worker.task.AbstractTask;\n-import org.apache.dolphinscheduler.server.worker.task.CommandExecuteResult;\n-import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n-\n-import org.apache.commons.io.FileUtils;\n-\n-import java.io.File;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.nio.file.attribute.FileAttribute;\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.sql.Connection;\n-import java.sql.DriverManager;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.ResultSetMetaData;\n-import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.slf4j.Logger;\n-\n-import com.alibaba.druid.sql.ast.SQLStatement;\n-import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLPropertyExpr;\n-import com.alibaba.druid.sql.ast.statement.SQLSelect;\n-import com.alibaba.druid.sql.ast.statement.SQLSelectItem;\n-import com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock;\n-import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;\n-import com.alibaba.druid.sql.ast.statement.SQLUnionQuery;\n-import com.alibaba.druid.sql.parser.SQLStatementParser;\n-import com.fasterxml.jackson.databind.node.ArrayNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-\n-/**\n- * DataX task\n- */\n-public class DataxTask extends AbstractTask {\n-\n-    /**\n-     * jvm parameters\n-     */\n-    public static final String JVM_PARAM = \" --jvm=\\\"-Xms%sG -Xmx%sG\\\" \";\n-    /**\n-     * python process(datax only supports version 2.7 by default)\n-     */\n-    private static final String DATAX_PYTHON = \"python2.7\";\n-    /**\n-     * datax path\n-     */\n-    private static final String DATAX_PATH = \"${DATAX_HOME}/bin/datax.py\";\n-    /**\n-     * datax channel count\n-     */\n-    private static final int DATAX_CHANNEL_COUNT = 1;\n-\n-    /**\n-     * datax parameters\n-     */\n-    private DataxParameters dataXParameters;\n-\n-    /**\n-     * shell command executor\n-     */\n-    private ShellCommandExecutor shellCommandExecutor;\n-\n-    /**\n-     * taskExecutionContext\n-     */\n-    private TaskExecutionContext taskExecutionContext;\n-\n-    /**\n-     * constructor\n-     *\n-     * @param taskExecutionContext taskExecutionContext\n-     * @param logger logger\n-     */\n-    public DataxTask(TaskExecutionContext taskExecutionContext, Logger logger) {\n-        super(taskExecutionContext, logger);\n-        this.taskExecutionContext = taskExecutionContext;\n-\n-        this.shellCommandExecutor = new ShellCommandExecutor(this::logHandle,\n-                taskExecutionContext, logger);\n-    }\n-\n-    /**\n-     * init DataX config\n-     */\n-    @Override\n-    public void init() {\n-        logger.info(\"datax task params {}\", taskExecutionContext.getTaskParams());\n-        dataXParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), DataxParameters.class);\n-\n-        if (!dataXParameters.checkParameters()) {\n-            throw new RuntimeException(\"datax task params is not valid\");\n-        }\n-    }\n-\n-    /**\n-     * run DataX process\n-     *\n-     * @throws Exception if error throws Exception\n-     */\n-    @Override\n-    public void handle() throws Exception {\n-        try {\n-            // set the name of the current thread\n-            String threadLoggerInfoName = String.format(\"TaskLogInfo-%s\", taskExecutionContext.getTaskAppId());\n-            Thread.currentThread().setName(threadLoggerInfoName);\n-\n-            // combining local and global parameters\n-            Map<String, Property> paramsMap = ParamUtils.convert(ParamUtils.getUserDefParamsMap(taskExecutionContext.getDefinedParams()),\n-                    taskExecutionContext.getDefinedParams(),\n-                    dataXParameters.getLocalParametersMap(),\n-                    CommandType.of(taskExecutionContext.getCmdTypeIfComplement()),\n-                    taskExecutionContext.getScheduleTime());\n-\n-            // run datax procesDataSourceService.s\n-            String jsonFilePath = buildDataxJsonFile(paramsMap);\n-            String shellCommandFilePath = buildShellCommandFile(jsonFilePath, paramsMap);\n-            CommandExecuteResult commandExecuteResult = shellCommandExecutor.run(shellCommandFilePath);\n-\n-            setExitStatusCode(commandExecuteResult.getExitStatusCode());\n-            setAppIds(commandExecuteResult.getAppIds());\n-            setProcessId(commandExecuteResult.getProcessId());\n-        } catch (Exception e) {\n-            setExitStatusCode(Constants.EXIT_CODE_FAILURE);\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * cancel DataX process\n-     *\n-     * @param cancelApplication cancelApplication\n-     * @throws Exception if error throws Exception\n-     */\n-    @Override\n-    public void cancelApplication(boolean cancelApplication)\n-            throws Exception {\n-        // cancel process\n-        shellCommandExecutor.cancelApplication();\n-    }\n-\n-    /**\n-     * build datax configuration file\n-     *\n-     * @return datax json file name\n-     * @throws Exception if error throws Exception\n-     */\n-    private String buildDataxJsonFile(Map<String, Property> paramsMap)\n-            throws Exception {\n-        // generate json\n-        String fileName = String.format(\"%s/%s_job.json\",\n-                taskExecutionContext.getExecutePath(),\n-                taskExecutionContext.getTaskAppId());\n-        String json;\n-\n-        Path path = new File(fileName).toPath();\n-        if (Files.exists(path)) {\n-            return fileName;\n-        }\n-\n-        if (dataXParameters.getCustomConfig() == Flag.YES.ordinal()) {\n-            json = dataXParameters.getJson().replaceAll(\"\\\\r\\\\n\", \"\\n\");\n-        } else {\n-            ObjectNode job = JSONUtils.createObjectNode();\n-            job.putArray(\"content\").addAll(buildDataxJobContentJson());\n-            job.set(\"setting\", buildDataxJobSettingJson());\n-\n-            ObjectNode root = JSONUtils.createObjectNode();\n-            root.set(\"job\", job);\n-            root.set(\"core\", buildDataxCoreJson());\n-            json = root.toString();\n-        }\n-\n-        // replace placeholder\n-        json = ParameterUtils.convertParameterPlaceholders(json, ParamUtils.convert(paramsMap));\n-\n-        logger.debug(\"datax job json : {}\", json);\n-\n-        // create datax json file\n-        FileUtils.writeStringToFile(new File(fileName), json, StandardCharsets.UTF_8);\n-        return fileName;\n-    }\n-\n-    /**\n-     * build datax job config\n-     *\n-     * @return collection of datax job config JSONObject\n-     * @throws SQLException if error throws SQLException\n-     */\n-    private List<ObjectNode> buildDataxJobContentJson() {\n-\n-        DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n-\n-        BaseDataSource dataSourceCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                dataxTaskExecutionContext.getSourceConnectionParams());\n-\n-        BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                dataxTaskExecutionContext.getTargetConnectionParams());\n-\n-        List<ObjectNode> readerConnArr = new ArrayList<>();\n-        ObjectNode readerConn = JSONUtils.createObjectNode();\n-\n-        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n-        for (String sql : new String[]{dataXParameters.getSql()}) {\n-            sqlArr.add(sql);\n-        }\n-\n-        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n-        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n-            urlArr.add(url);\n-        }\n-\n-        readerConnArr.add(readerConn);\n-\n-        ObjectNode readerParam = JSONUtils.createObjectNode();\n-        readerParam.put(\"username\", dataSourceCfg.getUser());\n-        readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.putArray(\"connection\").addAll(readerConnArr);\n-\n-        ObjectNode reader = JSONUtils.createObjectNode();\n-        reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.set(\"parameter\", readerParam);\n-\n-        List<ObjectNode> writerConnArr = new ArrayList<>();\n-        ObjectNode writerConn = JSONUtils.createObjectNode();\n-        ArrayNode tableArr = writerConn.putArray(\"table\");\n-        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n-            tableArr.add(table);\n-        }\n-\n-        writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n-        writerConnArr.add(writerConn);\n-\n-        ObjectNode writerParam = JSONUtils.createObjectNode();\n-        writerParam.put(\"username\", dataTargetCfg.getUser());\n-        writerParam.put(\"password\", dataTargetCfg.getPassword());\n-\n-        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                dataSourceCfg, dataXParameters.getSql());\n-\n-        ArrayNode columnArr = writerParam.putArray(\"column\");\n-        for (String column : columns) {\n-            columnArr.add(column);\n-        }\n-        writerParam.putArray(\"connection\").addAll(writerConnArr);\n-\n-        if (CollectionUtils.isNotEmpty(dataXParameters.getPreStatements())) {\n-            ArrayNode preSqlArr = writerParam.putArray(\"preSql\");\n-            for (String preSql : dataXParameters.getPreStatements()) {\n-                preSqlArr.add(preSql);\n-            }\n-\n-        }\n-\n-        if (CollectionUtils.isNotEmpty(dataXParameters.getPostStatements())) {\n-            ArrayNode postSqlArr = writerParam.putArray(\"postSql\");\n-            for (String postSql : dataXParameters.getPostStatements()) {\n-                postSqlArr.add(postSql);\n-            }\n-        }\n-\n-        ObjectNode writer = JSONUtils.createObjectNode();\n-        writer.put(\"name\", DataxUtils.getWriterPluginName(DbType.of(dataxTaskExecutionContext.getTargetType())));\n-        writer.set(\"parameter\", writerParam);\n-\n-        List<ObjectNode> contentList = new ArrayList<>();\n-        ObjectNode content = JSONUtils.createObjectNode();\n-        content.set(\"reader\", reader);\n-        content.set(\"writer\", writer);\n-        contentList.add(content);\n-\n-        return contentList;\n-    }\n-\n-    /**\n-     * build datax setting config\n-     *\n-     * @return datax setting config JSONObject\n-     */\n-    private ObjectNode buildDataxJobSettingJson() {\n-\n-        ObjectNode speed = JSONUtils.createObjectNode();\n-\n-        speed.put(\"channel\", DATAX_CHANNEL_COUNT);\n-\n-        if (dataXParameters.getJobSpeedByte() > 0) {\n-            speed.put(\"byte\", dataXParameters.getJobSpeedByte());\n-        }\n-\n-        if (dataXParameters.getJobSpeedRecord() > 0) {\n-            speed.put(\"record\", dataXParameters.getJobSpeedRecord());\n-        }\n-\n-        ObjectNode errorLimit = JSONUtils.createObjectNode();\n-        errorLimit.put(\"record\", 0);\n-        errorLimit.put(\"percentage\", 0);\n-\n-        ObjectNode setting = JSONUtils.createObjectNode();\n-        setting.set(\"speed\", speed);\n-        setting.set(\"errorLimit\", errorLimit);\n-\n-        return setting;\n-    }\n-\n-    private ObjectNode buildDataxCoreJson() {\n-\n-        ObjectNode speed = JSONUtils.createObjectNode();\n-        speed.put(\"channel\", DATAX_CHANNEL_COUNT);\n-\n-        if (dataXParameters.getJobSpeedByte() > 0) {\n-            speed.put(\"byte\", dataXParameters.getJobSpeedByte());\n-        }\n-\n-        if (dataXParameters.getJobSpeedRecord() > 0) {\n-            speed.put(\"record\", dataXParameters.getJobSpeedRecord());\n-        }\n-\n-        ObjectNode channel = JSONUtils.createObjectNode();\n-        channel.set(\"speed\", speed);\n-\n-        ObjectNode transport = JSONUtils.createObjectNode();\n-        transport.set(\"channel\", channel);\n-\n-        ObjectNode core = JSONUtils.createObjectNode();\n-        core.set(\"transport\", transport);\n-\n-        return core;\n-    }\n-\n-    /**\n-     * create command\n-     *\n-     * @return shell command file name\n-     * @throws Exception if error throws Exception\n-     */\n-    private String buildShellCommandFile(String jobConfigFilePath, Map<String, Property> paramsMap)\n-            throws Exception {\n-        // generate scripts\n-        String fileName = String.format(\"%s/%s_node.%s\",\n-                taskExecutionContext.getExecutePath(),\n-                taskExecutionContext.getTaskAppId(),\n-                OSUtils.isWindows() ? \"bat\" : \"sh\");\n-\n-        Path path = new File(fileName).toPath();\n-\n-        if (Files.exists(path)) {\n-            return fileName;\n-        }\n-\n-        // datax python command\n-        StringBuilder sbr = new StringBuilder();\n-        sbr.append(DATAX_PYTHON);\n-        sbr.append(\" \");\n-        sbr.append(DATAX_PATH);\n-        sbr.append(\" \");\n-        sbr.append(loadJvmEnv(dataXParameters));\n-        sbr.append(jobConfigFilePath);\n-\n-        // replace placeholder\n-        String dataxCommand = ParameterUtils.convertParameterPlaceholders(sbr.toString(), ParamUtils.convert(paramsMap));\n-\n-        logger.debug(\"raw script : {}\", dataxCommand);\n-\n-        // create shell command file\n-        Set<PosixFilePermission> perms = PosixFilePermissions.fromString(Constants.RWXR_XR_X);\n-        FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perms);\n-\n-        if (OSUtils.isWindows()) {\n-            Files.createFile(path);\n-        } else {\n-            Files.createFile(path, attr);\n-        }\n-\n-        Files.write(path, dataxCommand.getBytes(), StandardOpenOption.APPEND);\n-\n-        return fileName;\n-    }\n-\n-    public String loadJvmEnv(DataxParameters dataXParameters) {\n-        int xms = dataXParameters.getXms() < 1 ? 1 : dataXParameters.getXms();\n-        int xmx = dataXParameters.getXmx() < 1 ? 1 : dataXParameters.getXmx();\n-        return String.format(JVM_PARAM, xms, xmx);\n-    }\n-\n-    /**\n-     * parsing synchronized column names in SQL statements\n-     *\n-     * @param dsType the database type of the data source\n-     * @param dtType the database type of the data target\n-     * @param dataSourceCfg the database connection parameters of the data source\n-     * @param sql sql for data synchronization\n-     * @return Keyword converted column names\n-     */\n-    private String[] parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource dataSourceCfg, String sql) {\n-        String[] columnNames = tryGrammaticalAnalysisSqlColumnNames(dsType, sql);\n-\n-        if (columnNames == null || columnNames.length == 0) {\n-            logger.info(\"try to execute sql analysis query column name\");\n-            columnNames = tryExecuteSqlResolveColumnNames(dataSourceCfg, sql);\n-        }\n-\n-        notNull(columnNames, String.format(\"parsing sql columns failed : %s\", sql));\n-\n-        return DataxUtils.convertKeywordsColumns(dtType, columnNames);\n-    }\n-\n-    /**\n-     * try grammatical parsing column\n-     *\n-     * @param dbType database type\n-     * @param sql sql for data synchronization\n-     * @return column name array\n-     * @throws RuntimeException if error throws RuntimeException\n-     */\n-    private String[] tryGrammaticalAnalysisSqlColumnNames(DbType dbType, String sql) {\n-        String[] columnNames;\n-\n-        try {\n-            SQLStatementParser parser = DataxUtils.getSqlStatementParser(dbType, sql);\n-            if (parser == null) {\n-                logger.warn(\"database driver [{}] is not support grammatical analysis sql\", dbType);\n-                return new String[0];\n-            }\n-\n-            SQLStatement sqlStatement = parser.parseStatement();\n-            SQLSelectStatement sqlSelectStatement = (SQLSelectStatement) sqlStatement;\n-            SQLSelect sqlSelect = sqlSelectStatement.getSelect();\n-\n-            List<SQLSelectItem> selectItemList = null;\n-            if (sqlSelect.getQuery() instanceof SQLSelectQueryBlock) {\n-                SQLSelectQueryBlock block = (SQLSelectQueryBlock) sqlSelect.getQuery();\n-                selectItemList = block.getSelectList();\n-            } else if (sqlSelect.getQuery() instanceof SQLUnionQuery) {\n-                SQLUnionQuery unionQuery = (SQLUnionQuery) sqlSelect.getQuery();\n-                SQLSelectQueryBlock block = (SQLSelectQueryBlock) unionQuery.getRight();\n-                selectItemList = block.getSelectList();\n-            }\n-\n-            notNull(selectItemList,\n-                    String.format(\"select query type [%s] is not support\", sqlSelect.getQuery().toString()));\n-\n-            columnNames = new String[selectItemList.size()];\n-            for (int i = 0; i < selectItemList.size(); i++) {\n-                SQLSelectItem item = selectItemList.get(i);\n-\n-                String columnName = null;\n-\n-                if (item.getAlias() != null) {\n-                    columnName = item.getAlias();\n-                } else if (item.getExpr() != null) {\n-                    if (item.getExpr() instanceof SQLPropertyExpr) {\n-                        SQLPropertyExpr expr = (SQLPropertyExpr) item.getExpr();\n-                        columnName = expr.getName();\n-                    } else if (item.getExpr() instanceof SQLIdentifierExpr) {\n-                        SQLIdentifierExpr expr = (SQLIdentifierExpr) item.getExpr();\n-                        columnName = expr.getName();\n-                    }\n-                } else {\n-                    throw new RuntimeException(\n-                            String.format(\"grammatical analysis sql column [ %s ] failed\", item.toString()));\n-                }\n-\n-                if (columnName == null) {\n-                    throw new RuntimeException(\n-                            String.format(\"grammatical analysis sql column [ %s ] failed\", item.toString()));\n-                }\n-\n-                columnNames[i] = columnName;\n-            }\n-        } catch (Exception e) {\n-            logger.warn(e.getMessage(), e);\n-            return new String[0];\n-        }\n-\n-        return columnNames;\n-    }\n-\n-    /**\n-     * try to execute sql to resolve column names\n-     *\n-     * @param baseDataSource the database connection parameters\n-     * @param sql sql for data synchronization\n-     * @return column name array\n-     */\n-    public String[] tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource, String sql) {\n-        String[] columnNames;\n-        sql = String.format(\"SELECT t.* FROM ( %s ) t WHERE 0 = 1\", sql);\n-        sql = sql.replace(\";\", \"\");\n-\n-        try (\n-                Connection connection = DriverManager.getConnection(baseDataSource.getJdbcUrl(), baseDataSource.getUser(),\n-                        baseDataSource.getPassword());\n-                PreparedStatement stmt = connection.prepareStatement(sql);\n-                ResultSet resultSet = stmt.executeQuery()) {\n-\n-            ResultSetMetaData md = resultSet.getMetaData();\n-            int num = md.getColumnCount();\n-            columnNames = new String[num];\n-            for (int i = 1; i <= num; i++) {\n-                columnNames[i - 1] = md.getColumnName(i);\n-            }\n-        } catch (SQLException e) {\n-            logger.warn(e.getMessage(), e);\n-            return null;\n-        }\n-\n-        return columnNames;\n-    }\n-\n-    @Override\n-    public AbstractParameters getParameters() {\n-        return dataXParameters;\n-    }\n-\n-    private void notNull(Object obj, String message) {\n-        if (obj == null) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwOTE0NQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r436709145", "body": "why not use addAll", "bodyText": "why not use addAll", "bodyHTML": "<p dir=\"auto\">why not use addAll</p>", "author": "gabrywu", "createdAt": "2020-06-08T13:41:03Z", "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java", "diffHunk": "@@ -236,64 +222,90 @@ private String buildDataxJsonFile()\n \n     /**\n      * build datax job config\n-     * \n+     *\n      * @return collection of datax job config JSONObject\n      * @throws SQLException if error throws SQLException\n      */\n-    private List<JSONObject> buildDataxJobContentJson() throws SQLException {\n-        DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n+    private List<ObjectNode> buildDataxJobContentJson() throws SQLException {\n \n+        DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n \n         BaseDataSource dataSourceCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n                 dataxTaskExecutionContext.getSourceConnectionParams());\n \n         BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n                 dataxTaskExecutionContext.getTargetConnectionParams());\n \n-        List<JSONObject> readerConnArr = new ArrayList<>();\n-        JSONObject readerConn = new JSONObject();\n-        readerConn.put(\"querySql\", new String[] {dataXParameters.getSql()});\n-        readerConn.put(\"jdbcUrl\", new String[] {dataSourceCfg.getJdbcUrl()});\n+        List<ObjectNode> readerConnArr = new ArrayList<>();\n+        ObjectNode readerConn = JSONUtils.createObjectNode();\n+\n+        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n+        for (String sql : new String[]{dataXParameters.getSql()}) {\n+            sqlArr.add(sql);\n+        }\n+\n+        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n+        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n+            urlArr.add(url);\n+        }\n+\n         readerConnArr.add(readerConn);\n \n-        JSONObject readerParam = new JSONObject();\n+        ObjectNode readerParam = JSONUtils.createObjectNode();\n         readerParam.put(\"username\", dataSourceCfg.getUser());\n         readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.put(\"connection\", readerConnArr);\n+        readerParam.putArray(\"connection\").addAll(readerConnArr);\n \n-        JSONObject reader = new JSONObject();\n+\n+        ObjectNode reader = JSONUtils.createObjectNode();\n         reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.put(\"parameter\", readerParam);\n+        reader.set(\"parameter\", readerParam);\n+\n+        List<ObjectNode> writerConnArr = new ArrayList<>();\n+        ObjectNode writerConn = JSONUtils.createObjectNode();\n+        ArrayNode tableArr = writerConn.putArray(\"table\");\n+        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n+            tableArr.add(table);\n+        }\n \n-        List<JSONObject> writerConnArr = new ArrayList<>();\n-        JSONObject writerConn = new JSONObject();\n-        writerConn.put(\"table\", new String[] {dataXParameters.getTargetTable()});\n         writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n         writerConnArr.add(writerConn);\n \n-        JSONObject writerParam = new JSONObject();\n+        ObjectNode writerParam = JSONUtils.createObjectNode();\n         writerParam.put(\"username\", dataTargetCfg.getUser());\n         writerParam.put(\"password\", dataTargetCfg.getPassword());\n-        writerParam.put(\"column\",\n-            parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                    DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                    dataSourceCfg, dataXParameters.getSql()));\n-        writerParam.put(\"connection\", writerConnArr);\n+\n+        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n+                DbType.of(dataxTaskExecutionContext.getTargetType()),\n+                dataSourceCfg, dataXParameters.getSql());\n+        ArrayNode columnArr = writerParam.putArray(\"column\");", "originalCommit": "9a92ab79822c1804fe5931ed3c2ec8e2dcb45eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNzY3OQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r437137679", "bodyText": "The type of columns is String[] , addAll() only accept ArrayNode", "author": "simon824", "createdAt": "2020-06-09T04:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwOTE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEyMjk4NA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438122984", "bodyText": "ok", "author": "gabrywu", "createdAt": "2020-06-10T13:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwOTE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f6554ab9c0c74e8010c756d0200377d37931fbf", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex f85dfb8a3..9589a305c 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -222,90 +236,64 @@ public class DataxTask extends AbstractTask {\n \n     /**\n      * build datax job config\n-     *\n+     * \n      * @return collection of datax job config JSONObject\n      * @throws SQLException if error throws SQLException\n      */\n-    private List<ObjectNode> buildDataxJobContentJson() throws SQLException {\n-\n+    private List<JSONObject> buildDataxJobContentJson() throws SQLException {\n         DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n \n+\n         BaseDataSource dataSourceCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n                 dataxTaskExecutionContext.getSourceConnectionParams());\n \n         BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n                 dataxTaskExecutionContext.getTargetConnectionParams());\n \n-        List<ObjectNode> readerConnArr = new ArrayList<>();\n-        ObjectNode readerConn = JSONUtils.createObjectNode();\n-\n-        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n-        for (String sql : new String[]{dataXParameters.getSql()}) {\n-            sqlArr.add(sql);\n-        }\n-\n-        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n-        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n-            urlArr.add(url);\n-        }\n-\n+        List<JSONObject> readerConnArr = new ArrayList<>();\n+        JSONObject readerConn = new JSONObject();\n+        readerConn.put(\"querySql\", new String[] {dataXParameters.getSql()});\n+        readerConn.put(\"jdbcUrl\", new String[] {dataSourceCfg.getJdbcUrl()});\n         readerConnArr.add(readerConn);\n \n-        ObjectNode readerParam = JSONUtils.createObjectNode();\n+        JSONObject readerParam = new JSONObject();\n         readerParam.put(\"username\", dataSourceCfg.getUser());\n         readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.putArray(\"connection\").addAll(readerConnArr);\n+        readerParam.put(\"connection\", readerConnArr);\n \n-\n-        ObjectNode reader = JSONUtils.createObjectNode();\n+        JSONObject reader = new JSONObject();\n         reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.set(\"parameter\", readerParam);\n-\n-        List<ObjectNode> writerConnArr = new ArrayList<>();\n-        ObjectNode writerConn = JSONUtils.createObjectNode();\n-        ArrayNode tableArr = writerConn.putArray(\"table\");\n-        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n-            tableArr.add(table);\n-        }\n+        reader.put(\"parameter\", readerParam);\n \n+        List<JSONObject> writerConnArr = new ArrayList<>();\n+        JSONObject writerConn = new JSONObject();\n+        writerConn.put(\"table\", new String[] {dataXParameters.getTargetTable()});\n         writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n         writerConnArr.add(writerConn);\n \n-        ObjectNode writerParam = JSONUtils.createObjectNode();\n+        JSONObject writerParam = new JSONObject();\n         writerParam.put(\"username\", dataTargetCfg.getUser());\n         writerParam.put(\"password\", dataTargetCfg.getPassword());\n-\n-        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                dataSourceCfg, dataXParameters.getSql());\n-        ArrayNode columnArr = writerParam.putArray(\"column\");\n-        for (String column : columns) {\n-            columnArr.add(column);\n-        }\n-        writerParam.putArray(\"connection\").addAll(writerConnArr);\n-\n+        writerParam.put(\"column\",\n+            parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n+                    DbType.of(dataxTaskExecutionContext.getTargetType()),\n+                    dataSourceCfg, dataXParameters.getSql()));\n+        writerParam.put(\"connection\", writerConnArr);\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPreStatements())) {\n-            ArrayNode preSqlArr = writerParam.putArray(\"preSql\");\n-            for (String preSql : dataXParameters.getPreStatements()) {\n-                preSqlArr.add(preSql);\n-            }\n-\n+            writerParam.put(\"preSql\", dataXParameters.getPreStatements());\n         }\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPostStatements())) {\n-            ArrayNode postSqlArr = writerParam.putArray(\"postSql\");\n-            for (String postSql : dataXParameters.getPostStatements()) {\n-                postSqlArr.add(postSql);\n-            }\n+            writerParam.put(\"postSql\", dataXParameters.getPostStatements());\n         }\n \n-        ObjectNode writer = JSONUtils.createObjectNode();\n+        JSONObject writer = new JSONObject();\n         writer.put(\"name\", DataxUtils.getWriterPluginName(DbType.of(dataxTaskExecutionContext.getTargetType())));\n-        writer.set(\"parameter\", writerParam);\n+        writer.put(\"parameter\", writerParam);\n \n-        List<ObjectNode> contentList = new ArrayList<>();\n-        ObjectNode content = JSONUtils.createObjectNode();\n+        List<JSONObject> contentList = new ArrayList<>();\n+        JSONObject content = new JSONObject();\n         content.put(\"reader\", reader);\n         content.put(\"writer\", writer);\n         contentList.add(content);\n", "next_change": {"commit": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex 9589a305c..723ded4f2 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -250,50 +233,78 @@ public class DataxTask extends AbstractTask {\n         BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n                 dataxTaskExecutionContext.getTargetConnectionParams());\n \n-        List<JSONObject> readerConnArr = new ArrayList<>();\n-        JSONObject readerConn = new JSONObject();\n-        readerConn.put(\"querySql\", new String[] {dataXParameters.getSql()});\n-        readerConn.put(\"jdbcUrl\", new String[] {dataSourceCfg.getJdbcUrl()});\n+        List<ObjectNode> readerConnArr = new ArrayList<>();\n+        ObjectNode readerConn = JSONUtils.createObjectNode();\n+\n+        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n+        for (String sql : new String[]{dataXParameters.getSql()}) {\n+            sqlArr.add(sql);\n+        }\n+\n+        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n+        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n+            urlArr.add(url);\n+        }\n+\n         readerConnArr.add(readerConn);\n \n-        JSONObject readerParam = new JSONObject();\n+        ObjectNode readerParam = JSONUtils.createObjectNode();\n         readerParam.put(\"username\", dataSourceCfg.getUser());\n         readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.put(\"connection\", readerConnArr);\n+        readerParam.putArray(\"connection\").addAll(readerConnArr);\n \n-        JSONObject reader = new JSONObject();\n+\n+        ObjectNode reader = JSONUtils.createObjectNode();\n         reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.put(\"parameter\", readerParam);\n+        reader.set(\"parameter\", readerParam);\n+\n+        List<ObjectNode> writerConnArr = new ArrayList<>();\n+        ObjectNode writerConn = JSONUtils.createObjectNode();\n+        ArrayNode tableArr = writerConn.putArray(\"table\");\n+        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n+            tableArr.add(table);\n+        }\n \n-        List<JSONObject> writerConnArr = new ArrayList<>();\n-        JSONObject writerConn = new JSONObject();\n-        writerConn.put(\"table\", new String[] {dataXParameters.getTargetTable()});\n         writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n         writerConnArr.add(writerConn);\n \n-        JSONObject writerParam = new JSONObject();\n+        ObjectNode writerParam = JSONUtils.createObjectNode();\n         writerParam.put(\"username\", dataTargetCfg.getUser());\n         writerParam.put(\"password\", dataTargetCfg.getPassword());\n-        writerParam.put(\"column\",\n-            parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                    DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                    dataSourceCfg, dataXParameters.getSql()));\n-        writerParam.put(\"connection\", writerConnArr);\n+\n+        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n+                DbType.of(dataxTaskExecutionContext.getTargetType()),\n+                dataSourceCfg, dataXParameters.getSql());\n+\n+        ArrayNode columnArr = writerParam.putArray(\"column\");\n+        columnArr.addAll()\n+        for (String column : columns) {\n+            columnArr.add(column);\n+        }\n+        writerParam.putArray(\"connection\").addAll(writerConnArr);\n+\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPreStatements())) {\n-            writerParam.put(\"preSql\", dataXParameters.getPreStatements());\n+            ArrayNode preSqlArr = writerParam.putArray(\"preSql\");\n+            for (String preSql : dataXParameters.getPreStatements()) {\n+                preSqlArr.add(preSql);\n+            }\n+\n         }\n \n         if (CollectionUtils.isNotEmpty(dataXParameters.getPostStatements())) {\n-            writerParam.put(\"postSql\", dataXParameters.getPostStatements());\n+            ArrayNode postSqlArr = writerParam.putArray(\"postSql\");\n+            for (String postSql : dataXParameters.getPostStatements()) {\n+                postSqlArr.add(postSql);\n+            }\n         }\n \n-        JSONObject writer = new JSONObject();\n+        ObjectNode writer = JSONUtils.createObjectNode();\n         writer.put(\"name\", DataxUtils.getWriterPluginName(DbType.of(dataxTaskExecutionContext.getTargetType())));\n-        writer.put(\"parameter\", writerParam);\n+        writer.set(\"parameter\", writerParam);\n \n-        List<JSONObject> contentList = new ArrayList<>();\n-        JSONObject content = new JSONObject();\n+        List<ObjectNode> contentList = new ArrayList<>();\n+        ObjectNode content = JSONUtils.createObjectNode();\n         content.put(\"reader\", reader);\n         content.put(\"writer\", writer);\n         contentList.add(content);\n", "next_change": {"commit": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex 723ded4f2..5a8b8d670 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -305,8 +304,8 @@ public class DataxTask extends AbstractTask {\n \n         List<ObjectNode> contentList = new ArrayList<>();\n         ObjectNode content = JSONUtils.createObjectNode();\n-        content.put(\"reader\", reader);\n-        content.put(\"writer\", writer);\n+        content.put(\"reader\", reader.toString());\n+        content.put(\"writer\", reader.toString());\n         contentList.add(content);\n \n         return contentList;\n", "next_change": {"commit": "65953fe2573d4358c4bbc023cf8f04f6343345bb", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex 5a8b8d670..a14a5d64f 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -305,7 +305,7 @@ public class DataxTask extends AbstractTask {\n         List<ObjectNode> contentList = new ArrayList<>();\n         ObjectNode content = JSONUtils.createObjectNode();\n         content.put(\"reader\", reader.toString());\n-        content.put(\"writer\", reader.toString());\n+        content.put(\"writer\", writer.toString());\n         contentList.add(content);\n \n         return contentList;\n", "next_change": {"commit": "cc7a4446f50a247f054a9671648e948c654dfe65", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\nindex a14a5d64f..8f80963f8 100755\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n", "chunk": "@@ -304,8 +310,8 @@ public class DataxTask extends AbstractTask {\n \n         List<ObjectNode> contentList = new ArrayList<>();\n         ObjectNode content = JSONUtils.createObjectNode();\n-        content.put(\"reader\", reader.toString());\n-        content.put(\"writer\", writer.toString());\n+        content.set(\"reader\", reader);\n+        content.set(\"writer\", writer);\n         contentList.add(content);\n \n         return contentList;\n", "next_change": {"commit": "4715de11fc0996588a91f8b09da81158c844432e", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\ndeleted file mode 100755\nindex 8f80963f8..000000000\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTask.java\n+++ /dev/null\n", "chunk": "@@ -1,566 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.dolphinscheduler.server.worker.task.datax;\n-\n-import org.apache.dolphinscheduler.common.Constants;\n-import org.apache.dolphinscheduler.common.enums.CommandType;\n-import org.apache.dolphinscheduler.common.enums.DbType;\n-import org.apache.dolphinscheduler.common.enums.Flag;\n-import org.apache.dolphinscheduler.common.process.Property;\n-import org.apache.dolphinscheduler.common.task.AbstractParameters;\n-import org.apache.dolphinscheduler.common.task.datax.DataxParameters;\n-import org.apache.dolphinscheduler.common.utils.CollectionUtils;\n-import org.apache.dolphinscheduler.common.utils.JSONUtils;\n-import org.apache.dolphinscheduler.common.utils.OSUtils;\n-import org.apache.dolphinscheduler.common.utils.ParameterUtils;\n-import org.apache.dolphinscheduler.dao.datasource.BaseDataSource;\n-import org.apache.dolphinscheduler.dao.datasource.DataSourceFactory;\n-import org.apache.dolphinscheduler.server.entity.DataxTaskExecutionContext;\n-import org.apache.dolphinscheduler.server.entity.TaskExecutionContext;\n-import org.apache.dolphinscheduler.server.utils.DataxUtils;\n-import org.apache.dolphinscheduler.server.utils.ParamUtils;\n-import org.apache.dolphinscheduler.server.worker.task.AbstractTask;\n-import org.apache.dolphinscheduler.server.worker.task.CommandExecuteResult;\n-import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n-\n-import org.apache.commons.io.FileUtils;\n-\n-import java.io.File;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.nio.file.attribute.FileAttribute;\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.sql.Connection;\n-import java.sql.DriverManager;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.ResultSetMetaData;\n-import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.slf4j.Logger;\n-\n-import com.alibaba.druid.sql.ast.SQLStatement;\n-import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLPropertyExpr;\n-import com.alibaba.druid.sql.ast.statement.SQLSelect;\n-import com.alibaba.druid.sql.ast.statement.SQLSelectItem;\n-import com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock;\n-import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;\n-import com.alibaba.druid.sql.ast.statement.SQLUnionQuery;\n-import com.alibaba.druid.sql.parser.SQLStatementParser;\n-import com.fasterxml.jackson.databind.node.ArrayNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-\n-/**\n- * DataX task\n- */\n-public class DataxTask extends AbstractTask {\n-\n-    /**\n-     * jvm parameters\n-     */\n-    public static final String JVM_PARAM = \" --jvm=\\\"-Xms%sG -Xmx%sG\\\" \";\n-    /**\n-     * python process(datax only supports version 2.7 by default)\n-     */\n-    private static final String DATAX_PYTHON = \"python2.7\";\n-    /**\n-     * datax path\n-     */\n-    private static final String DATAX_PATH = \"${DATAX_HOME}/bin/datax.py\";\n-    /**\n-     * datax channel count\n-     */\n-    private static final int DATAX_CHANNEL_COUNT = 1;\n-\n-    /**\n-     * datax parameters\n-     */\n-    private DataxParameters dataXParameters;\n-\n-    /**\n-     * shell command executor\n-     */\n-    private ShellCommandExecutor shellCommandExecutor;\n-\n-    /**\n-     * taskExecutionContext\n-     */\n-    private TaskExecutionContext taskExecutionContext;\n-\n-    /**\n-     * constructor\n-     *\n-     * @param taskExecutionContext taskExecutionContext\n-     * @param logger logger\n-     */\n-    public DataxTask(TaskExecutionContext taskExecutionContext, Logger logger) {\n-        super(taskExecutionContext, logger);\n-        this.taskExecutionContext = taskExecutionContext;\n-\n-        this.shellCommandExecutor = new ShellCommandExecutor(this::logHandle,\n-                taskExecutionContext, logger);\n-    }\n-\n-    /**\n-     * init DataX config\n-     */\n-    @Override\n-    public void init() {\n-        logger.info(\"datax task params {}\", taskExecutionContext.getTaskParams());\n-        dataXParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), DataxParameters.class);\n-\n-        if (!dataXParameters.checkParameters()) {\n-            throw new RuntimeException(\"datax task params is not valid\");\n-        }\n-    }\n-\n-    /**\n-     * run DataX process\n-     *\n-     * @throws Exception if error throws Exception\n-     */\n-    @Override\n-    public void handle() throws Exception {\n-        try {\n-            // set the name of the current thread\n-            String threadLoggerInfoName = String.format(\"TaskLogInfo-%s\", taskExecutionContext.getTaskAppId());\n-            Thread.currentThread().setName(threadLoggerInfoName);\n-\n-            // combining local and global parameters\n-            Map<String, Property> paramsMap = ParamUtils.convert(ParamUtils.getUserDefParamsMap(taskExecutionContext.getDefinedParams()),\n-                    taskExecutionContext.getDefinedParams(),\n-                    dataXParameters.getLocalParametersMap(),\n-                    CommandType.of(taskExecutionContext.getCmdTypeIfComplement()),\n-                    taskExecutionContext.getScheduleTime());\n-\n-            // run datax procesDataSourceService.s\n-            String jsonFilePath = buildDataxJsonFile(paramsMap);\n-            String shellCommandFilePath = buildShellCommandFile(jsonFilePath, paramsMap);\n-            CommandExecuteResult commandExecuteResult = shellCommandExecutor.run(shellCommandFilePath);\n-\n-            setExitStatusCode(commandExecuteResult.getExitStatusCode());\n-            setAppIds(commandExecuteResult.getAppIds());\n-            setProcessId(commandExecuteResult.getProcessId());\n-        } catch (Exception e) {\n-            setExitStatusCode(Constants.EXIT_CODE_FAILURE);\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * cancel DataX process\n-     *\n-     * @param cancelApplication cancelApplication\n-     * @throws Exception if error throws Exception\n-     */\n-    @Override\n-    public void cancelApplication(boolean cancelApplication)\n-            throws Exception {\n-        // cancel process\n-        shellCommandExecutor.cancelApplication();\n-    }\n-\n-    /**\n-     * build datax configuration file\n-     *\n-     * @return datax json file name\n-     * @throws Exception if error throws Exception\n-     */\n-    private String buildDataxJsonFile(Map<String, Property> paramsMap)\n-            throws Exception {\n-        // generate json\n-        String fileName = String.format(\"%s/%s_job.json\",\n-                taskExecutionContext.getExecutePath(),\n-                taskExecutionContext.getTaskAppId());\n-        String json;\n-\n-        Path path = new File(fileName).toPath();\n-        if (Files.exists(path)) {\n-            return fileName;\n-        }\n-\n-        if (dataXParameters.getCustomConfig() == Flag.YES.ordinal()) {\n-            json = dataXParameters.getJson().replaceAll(\"\\\\r\\\\n\", \"\\n\");\n-        } else {\n-            ObjectNode job = JSONUtils.createObjectNode();\n-            job.putArray(\"content\").addAll(buildDataxJobContentJson());\n-            job.set(\"setting\", buildDataxJobSettingJson());\n-\n-            ObjectNode root = JSONUtils.createObjectNode();\n-            root.set(\"job\", job);\n-            root.set(\"core\", buildDataxCoreJson());\n-            json = root.toString();\n-        }\n-\n-        // replace placeholder\n-        json = ParameterUtils.convertParameterPlaceholders(json, ParamUtils.convert(paramsMap));\n-\n-        logger.debug(\"datax job json : {}\", json);\n-\n-        // create datax json file\n-        FileUtils.writeStringToFile(new File(fileName), json, StandardCharsets.UTF_8);\n-        return fileName;\n-    }\n-\n-    /**\n-     * build datax job config\n-     *\n-     * @return collection of datax job config JSONObject\n-     * @throws SQLException if error throws SQLException\n-     */\n-    private List<ObjectNode> buildDataxJobContentJson() {\n-\n-        DataxTaskExecutionContext dataxTaskExecutionContext = taskExecutionContext.getDataxTaskExecutionContext();\n-\n-        BaseDataSource dataSourceCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                dataxTaskExecutionContext.getSourceConnectionParams());\n-\n-        BaseDataSource dataTargetCfg = DataSourceFactory.getDatasource(DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                dataxTaskExecutionContext.getTargetConnectionParams());\n-\n-        List<ObjectNode> readerConnArr = new ArrayList<>();\n-        ObjectNode readerConn = JSONUtils.createObjectNode();\n-\n-        ArrayNode sqlArr = readerConn.putArray(\"querySql\");\n-        for (String sql : new String[]{dataXParameters.getSql()}) {\n-            sqlArr.add(sql);\n-        }\n-\n-        ArrayNode urlArr = readerConn.putArray(\"jdbcUrl\");\n-        for (String url : new String[]{dataSourceCfg.getJdbcUrl()}) {\n-            urlArr.add(url);\n-        }\n-\n-        readerConnArr.add(readerConn);\n-\n-        ObjectNode readerParam = JSONUtils.createObjectNode();\n-        readerParam.put(\"username\", dataSourceCfg.getUser());\n-        readerParam.put(\"password\", dataSourceCfg.getPassword());\n-        readerParam.putArray(\"connection\").addAll(readerConnArr);\n-\n-        ObjectNode reader = JSONUtils.createObjectNode();\n-        reader.put(\"name\", DataxUtils.getReaderPluginName(DbType.of(dataxTaskExecutionContext.getSourcetype())));\n-        reader.set(\"parameter\", readerParam);\n-\n-        List<ObjectNode> writerConnArr = new ArrayList<>();\n-        ObjectNode writerConn = JSONUtils.createObjectNode();\n-        ArrayNode tableArr = writerConn.putArray(\"table\");\n-        for (String table : new String[]{dataXParameters.getTargetTable()}) {\n-            tableArr.add(table);\n-        }\n-\n-        writerConn.put(\"jdbcUrl\", dataTargetCfg.getJdbcUrl());\n-        writerConnArr.add(writerConn);\n-\n-        ObjectNode writerParam = JSONUtils.createObjectNode();\n-        writerParam.put(\"username\", dataTargetCfg.getUser());\n-        writerParam.put(\"password\", dataTargetCfg.getPassword());\n-\n-        String[] columns = parsingSqlColumnNames(DbType.of(dataxTaskExecutionContext.getSourcetype()),\n-                DbType.of(dataxTaskExecutionContext.getTargetType()),\n-                dataSourceCfg, dataXParameters.getSql());\n-\n-        ArrayNode columnArr = writerParam.putArray(\"column\");\n-        for (String column : columns) {\n-            columnArr.add(column);\n-        }\n-        writerParam.putArray(\"connection\").addAll(writerConnArr);\n-\n-        if (CollectionUtils.isNotEmpty(dataXParameters.getPreStatements())) {\n-            ArrayNode preSqlArr = writerParam.putArray(\"preSql\");\n-            for (String preSql : dataXParameters.getPreStatements()) {\n-                preSqlArr.add(preSql);\n-            }\n-\n-        }\n-\n-        if (CollectionUtils.isNotEmpty(dataXParameters.getPostStatements())) {\n-            ArrayNode postSqlArr = writerParam.putArray(\"postSql\");\n-            for (String postSql : dataXParameters.getPostStatements()) {\n-                postSqlArr.add(postSql);\n-            }\n-        }\n-\n-        ObjectNode writer = JSONUtils.createObjectNode();\n-        writer.put(\"name\", DataxUtils.getWriterPluginName(DbType.of(dataxTaskExecutionContext.getTargetType())));\n-        writer.set(\"parameter\", writerParam);\n-\n-        List<ObjectNode> contentList = new ArrayList<>();\n-        ObjectNode content = JSONUtils.createObjectNode();\n-        content.set(\"reader\", reader);\n-        content.set(\"writer\", writer);\n-        contentList.add(content);\n-\n-        return contentList;\n-    }\n-\n-    /**\n-     * build datax setting config\n-     *\n-     * @return datax setting config JSONObject\n-     */\n-    private ObjectNode buildDataxJobSettingJson() {\n-\n-        ObjectNode speed = JSONUtils.createObjectNode();\n-\n-        speed.put(\"channel\", DATAX_CHANNEL_COUNT);\n-\n-        if (dataXParameters.getJobSpeedByte() > 0) {\n-            speed.put(\"byte\", dataXParameters.getJobSpeedByte());\n-        }\n-\n-        if (dataXParameters.getJobSpeedRecord() > 0) {\n-            speed.put(\"record\", dataXParameters.getJobSpeedRecord());\n-        }\n-\n-        ObjectNode errorLimit = JSONUtils.createObjectNode();\n-        errorLimit.put(\"record\", 0);\n-        errorLimit.put(\"percentage\", 0);\n-\n-        ObjectNode setting = JSONUtils.createObjectNode();\n-        setting.set(\"speed\", speed);\n-        setting.set(\"errorLimit\", errorLimit);\n-\n-        return setting;\n-    }\n-\n-    private ObjectNode buildDataxCoreJson() {\n-\n-        ObjectNode speed = JSONUtils.createObjectNode();\n-        speed.put(\"channel\", DATAX_CHANNEL_COUNT);\n-\n-        if (dataXParameters.getJobSpeedByte() > 0) {\n-            speed.put(\"byte\", dataXParameters.getJobSpeedByte());\n-        }\n-\n-        if (dataXParameters.getJobSpeedRecord() > 0) {\n-            speed.put(\"record\", dataXParameters.getJobSpeedRecord());\n-        }\n-\n-        ObjectNode channel = JSONUtils.createObjectNode();\n-        channel.set(\"speed\", speed);\n-\n-        ObjectNode transport = JSONUtils.createObjectNode();\n-        transport.set(\"channel\", channel);\n-\n-        ObjectNode core = JSONUtils.createObjectNode();\n-        core.set(\"transport\", transport);\n-\n-        return core;\n-    }\n-\n-    /**\n-     * create command\n-     *\n-     * @return shell command file name\n-     * @throws Exception if error throws Exception\n-     */\n-    private String buildShellCommandFile(String jobConfigFilePath, Map<String, Property> paramsMap)\n-            throws Exception {\n-        // generate scripts\n-        String fileName = String.format(\"%s/%s_node.%s\",\n-                taskExecutionContext.getExecutePath(),\n-                taskExecutionContext.getTaskAppId(),\n-                OSUtils.isWindows() ? \"bat\" : \"sh\");\n-\n-        Path path = new File(fileName).toPath();\n-\n-        if (Files.exists(path)) {\n-            return fileName;\n-        }\n-\n-        // datax python command\n-        StringBuilder sbr = new StringBuilder();\n-        sbr.append(DATAX_PYTHON);\n-        sbr.append(\" \");\n-        sbr.append(DATAX_PATH);\n-        sbr.append(\" \");\n-        sbr.append(loadJvmEnv(dataXParameters));\n-        sbr.append(jobConfigFilePath);\n-\n-        // replace placeholder\n-        String dataxCommand = ParameterUtils.convertParameterPlaceholders(sbr.toString(), ParamUtils.convert(paramsMap));\n-\n-        logger.debug(\"raw script : {}\", dataxCommand);\n-\n-        // create shell command file\n-        Set<PosixFilePermission> perms = PosixFilePermissions.fromString(Constants.RWXR_XR_X);\n-        FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perms);\n-\n-        if (OSUtils.isWindows()) {\n-            Files.createFile(path);\n-        } else {\n-            Files.createFile(path, attr);\n-        }\n-\n-        Files.write(path, dataxCommand.getBytes(), StandardOpenOption.APPEND);\n-\n-        return fileName;\n-    }\n-\n-    public String loadJvmEnv(DataxParameters dataXParameters) {\n-        int xms = dataXParameters.getXms() < 1 ? 1 : dataXParameters.getXms();\n-        int xmx = dataXParameters.getXmx() < 1 ? 1 : dataXParameters.getXmx();\n-        return String.format(JVM_PARAM, xms, xmx);\n-    }\n-\n-    /**\n-     * parsing synchronized column names in SQL statements\n-     *\n-     * @param dsType the database type of the data source\n-     * @param dtType the database type of the data target\n-     * @param dataSourceCfg the database connection parameters of the data source\n-     * @param sql sql for data synchronization\n-     * @return Keyword converted column names\n-     */\n-    private String[] parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource dataSourceCfg, String sql) {\n-        String[] columnNames = tryGrammaticalAnalysisSqlColumnNames(dsType, sql);\n-\n-        if (columnNames == null || columnNames.length == 0) {\n-            logger.info(\"try to execute sql analysis query column name\");\n-            columnNames = tryExecuteSqlResolveColumnNames(dataSourceCfg, sql);\n-        }\n-\n-        notNull(columnNames, String.format(\"parsing sql columns failed : %s\", sql));\n-\n-        return DataxUtils.convertKeywordsColumns(dtType, columnNames);\n-    }\n-\n-    /**\n-     * try grammatical parsing column\n-     *\n-     * @param dbType database type\n-     * @param sql sql for data synchronization\n-     * @return column name array\n-     * @throws RuntimeException if error throws RuntimeException\n-     */\n-    private String[] tryGrammaticalAnalysisSqlColumnNames(DbType dbType, String sql) {\n-        String[] columnNames;\n-\n-        try {\n-            SQLStatementParser parser = DataxUtils.getSqlStatementParser(dbType, sql);\n-            if (parser == null) {\n-                logger.warn(\"database driver [{}] is not support grammatical analysis sql\", dbType);\n-                return new String[0];\n-            }\n-\n-            SQLStatement sqlStatement = parser.parseStatement();\n-            SQLSelectStatement sqlSelectStatement = (SQLSelectStatement) sqlStatement;\n-            SQLSelect sqlSelect = sqlSelectStatement.getSelect();\n-\n-            List<SQLSelectItem> selectItemList = null;\n-            if (sqlSelect.getQuery() instanceof SQLSelectQueryBlock) {\n-                SQLSelectQueryBlock block = (SQLSelectQueryBlock) sqlSelect.getQuery();\n-                selectItemList = block.getSelectList();\n-            } else if (sqlSelect.getQuery() instanceof SQLUnionQuery) {\n-                SQLUnionQuery unionQuery = (SQLUnionQuery) sqlSelect.getQuery();\n-                SQLSelectQueryBlock block = (SQLSelectQueryBlock) unionQuery.getRight();\n-                selectItemList = block.getSelectList();\n-            }\n-\n-            notNull(selectItemList,\n-                    String.format(\"select query type [%s] is not support\", sqlSelect.getQuery().toString()));\n-\n-            columnNames = new String[selectItemList.size()];\n-            for (int i = 0; i < selectItemList.size(); i++) {\n-                SQLSelectItem item = selectItemList.get(i);\n-\n-                String columnName = null;\n-\n-                if (item.getAlias() != null) {\n-                    columnName = item.getAlias();\n-                } else if (item.getExpr() != null) {\n-                    if (item.getExpr() instanceof SQLPropertyExpr) {\n-                        SQLPropertyExpr expr = (SQLPropertyExpr) item.getExpr();\n-                        columnName = expr.getName();\n-                    } else if (item.getExpr() instanceof SQLIdentifierExpr) {\n-                        SQLIdentifierExpr expr = (SQLIdentifierExpr) item.getExpr();\n-                        columnName = expr.getName();\n-                    }\n-                } else {\n-                    throw new RuntimeException(\n-                            String.format(\"grammatical analysis sql column [ %s ] failed\", item.toString()));\n-                }\n-\n-                if (columnName == null) {\n-                    throw new RuntimeException(\n-                            String.format(\"grammatical analysis sql column [ %s ] failed\", item.toString()));\n-                }\n-\n-                columnNames[i] = columnName;\n-            }\n-        } catch (Exception e) {\n-            logger.warn(e.getMessage(), e);\n-            return new String[0];\n-        }\n-\n-        return columnNames;\n-    }\n-\n-    /**\n-     * try to execute sql to resolve column names\n-     *\n-     * @param baseDataSource the database connection parameters\n-     * @param sql sql for data synchronization\n-     * @return column name array\n-     */\n-    public String[] tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource, String sql) {\n-        String[] columnNames;\n-        sql = String.format(\"SELECT t.* FROM ( %s ) t WHERE 0 = 1\", sql);\n-        sql = sql.replace(\";\", \"\");\n-\n-        try (\n-                Connection connection = DriverManager.getConnection(baseDataSource.getJdbcUrl(), baseDataSource.getUser(),\n-                        baseDataSource.getPassword());\n-                PreparedStatement stmt = connection.prepareStatement(sql);\n-                ResultSet resultSet = stmt.executeQuery()) {\n-\n-            ResultSetMetaData md = resultSet.getMetaData();\n-            int num = md.getColumnCount();\n-            columnNames = new String[num];\n-            for (int i = 1; i <= num; i++) {\n-                columnNames[i - 1] = md.getColumnName(i);\n-            }\n-        } catch (SQLException e) {\n-            logger.warn(e.getMessage(), e);\n-            return null;\n-        }\n-\n-        return columnNames;\n-    }\n-\n-    @Override\n-    public AbstractParameters getParameters() {\n-        return dataXParameters;\n-    }\n-\n-    private void notNull(Object obj, String message) {\n-        if (obj == null) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "6e907f150c3b06a6fc11e0eee8ca0f403d101962", "url": "https://github.com/apache/dolphinscheduler/commit/6e907f150c3b06a6fc11e0eee8ca0f403d101962", "message": "1. specified jackson Date format.\n2. remove getMapper method,replace with toList()\n3. rewrite toList method,support constructCollectionType.\n4. parseObject(resp, Map.class) replace to toMap() method\n5. rename JacksonSerialize to JsonSerializer\n\nrewrite createArrayNode,createObjectNode method will Affect too many lines \uff0ci will fix it in the next pr.", "committedDate": "2020-06-09T05:02:50Z", "type": "commit"}, {"oid": "2c590450ab579b6c4db74222ac08a3a7892480b9", "url": "https://github.com/apache/dolphinscheduler/commit/2c590450ab579b6c4db74222ac08a3a7892480b9", "message": "Merge pull request #1 from apache/dev\n\nmerge", "committedDate": "2020-06-09T06:08:39Z", "type": "commit"}, {"oid": "8cabb7a907f408d46b442e9f2635d6e97454aac3", "url": "https://github.com/apache/dolphinscheduler/commit/8cabb7a907f408d46b442e9f2635d6e97454aac3", "message": "1. specified jackson Date format.\n2. remove getMapper method,replace with toList()\n3. rewrite toList method,support constructCollectionType.\n4. parseObject(resp, Map.class) replace to toMap() method\n5. rename JacksonSerialize to JsonSerializer\n\nrewrite createArrayNode,createObjectNode method will Affect too many lines \uff0ci will fix it in the next pr.", "committedDate": "2020-06-09T06:15:13Z", "type": "commit"}, {"oid": "c5b3f35bd4f217df31cd1fba8eb605e52909f972", "url": "https://github.com/apache/dolphinscheduler/commit/c5b3f35bd4f217df31cd1fba8eb605e52909f972", "message": "replace fastjson annotation", "committedDate": "2020-06-09T06:37:16Z", "type": "commit"}, {"oid": "fad09075f9dd4542ded0be6a490bfe83415dedd5", "url": "https://github.com/apache/dolphinscheduler/commit/fad09075f9dd4542ded0be6a490bfe83415dedd5", "message": "remove fastjson maven dependence", "committedDate": "2020-06-10T01:16:28Z", "type": "commit"}, {"oid": "7d45e116bb98776c42f817c484172eabc8cac441", "url": "https://github.com/apache/dolphinscheduler/commit/7d45e116bb98776c42f817c484172eabc8cac441", "message": "remove fastjson license", "committedDate": "2020-06-10T01:29:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5ODE3MA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438098170", "body": "please change windows new line 'CR' to linux new line 'LF'", "bodyText": "please change windows new line 'CR' to linux new line 'LF'", "bodyHTML": "<p dir=\"auto\">please change windows new line 'CR' to linux new line 'LF'</p>", "author": "gabrywu", "createdAt": "2020-06-10T12:54:26Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteAckCommand implements Serializable {\r\r    /**\r     * taskInstanceId\r     */\r    private int taskInstanceId;\r\r    /**\r     * startTime\r     */\r    private Date startTime;\r\r    /**\r     * host\r     */\r    private String host;\r\r    /**\r     * status\r     */\r    private int status;\r\r    /**\r     * logPath\r     */\r    private String logPath;\r\r    /**\r     * executePath\r     */\r    private String executePath;\r\r    public Date getStartTime() {\r        return startTime;\r    }\r\r    public void setStartTime(Date startTime) {\r        this.startTime = startTime;\r    }\r\r    public String getHost() {\r        return host;\r    }\r\r    public void setHost(String host) {\r        this.host = host;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public String getLogPath() {\r        return logPath;\r    }\r\r    public void setLogPath(String logPath) {\r        this.logPath = logPath;\r    }\r\r    public String getExecutePath() {\r        return executePath;\r    }\r\r    public void setExecutePath(String executePath) {\r        this.executePath = executePath;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_ACK);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteAckCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", startTime=\" + startTime +\r                \", host='\" + host + '\\'' +\r                \", status=\" + status +\r                \", logPath='\" + logPath + '\\'' +\r                \", executePath='\" + executePath + '\\'' +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport com.fasterxml.jackson.annotation.JsonFormat;\rimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteAckCommand implements Serializable {\r\r    /**\r     * taskInstanceId\r     */\r    private int taskInstanceId;\r\r    /**\r     * startTime\r     */\r    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\r    private Date startTime;\r\r    /**\r     * host\r     */\r    private String host;\r\r    /**\r     * status\r     */\r    private int status;\r\r    /**\r     * logPath\r     */\r    private String logPath;\r\r    /**\r     * executePath\r     */\r    private String executePath;\r\r    public Date getStartTime() {\r        return startTime;\r    }\r\r    public void setStartTime(Date startTime) {\r        this.startTime = startTime;\r    }\r\r    public String getHost() {\r        return host;\r    }\r\r    public void setHost(String host) {\r        this.host = host;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public String getLogPath() {\r        return logPath;\r    }\r\r    public void setLogPath(String logPath) {\r        this.logPath = logPath;\r    }\r\r    public String getExecutePath() {\r        return executePath;\r    }\r\r    public void setExecutePath(String executePath) {\r        this.executePath = executePath;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_ACK);\r        byte[] body = JsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteAckCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", startTime=\" + startTime +\r                \", host='\" + host + '\\'' +\r                \", status=\" + status +\r                \", logPath='\" + logPath + '\\'' +\r                \", executePath='\" + executePath + '\\'' +\r                '}';\r    }\r}\r", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java\nindex 796e4dc35..135c14975 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteAckCommand.java\n", "chunk": "@@ -1 +1,133 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n *  execute task request command\n */\npublic class TaskExecuteAckCommand implements Serializable {\n\n    /**\n     * taskInstanceId\n     */\n    private int taskInstanceId;\n\n    /**\n     * startTime\n     */\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\n    private Date startTime;\n\n    /**\n     * host\n     */\n    private String host;\n\n    /**\n     * status\n     */\n    private int status;\n\n    /**\n     * logPath\n     */\n    private String logPath;\n\n    /**\n     * executePath\n     */\n    private String executePath;\n\n    public Date getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(Date startTime) {\n        this.startTime = startTime;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public String getLogPath() {\n        return logPath;\n    }\n\n    public void setLogPath(String logPath) {\n        this.logPath = logPath;\n    }\n\n    public String getExecutePath() {\n        return executePath;\n    }\n\n    public void setExecutePath(String executePath) {\n        this.executePath = executePath;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_ACK);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteAckCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", startTime=\" + startTime +\n                \", host='\" + host + '\\'' +\n                \", status=\" + status +\n                \", logPath='\" + logPath + '\\'' +\n                \", executePath='\" + executePath + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.remote.command;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+/**\n+ *  execute task request command\n+ */\n+public class TaskExecuteAckCommand implements Serializable {\n+\n+    /**\n+     * taskInstanceId\n+     */\n+    private int taskInstanceId;\n+\n+    /**\n+     * startTime\n+     */\n+    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\n+    private Date startTime;\n+\n+    /**\n+     * host\n+     */\n+    private String host;\n+\n+    /**\n+     * status\n+     */\n+    private int status;\n+\n+    /**\n+     * logPath\n+     */\n+    private String logPath;\n+\n+    /**\n+     * executePath\n+     */\n+    private String executePath;\n+\n+    public Date getStartTime() {\n+        return startTime;\n+    }\n+\n+    public void setStartTime(Date startTime) {\n+        this.startTime = startTime;\n+    }\n+\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    public int getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(int status) {\n+        this.status = status;\n+    }\n+\n+    public int getTaskInstanceId() {\n+        return taskInstanceId;\n+    }\n+\n+    public void setTaskInstanceId(int taskInstanceId) {\n+        this.taskInstanceId = taskInstanceId;\n+    }\n+\n+    public String getLogPath() {\n+        return logPath;\n+    }\n+\n+    public void setLogPath(String logPath) {\n+        this.logPath = logPath;\n+    }\n+\n+    public String getExecutePath() {\n+        return executePath;\n+    }\n+\n+    public void setExecutePath(String executePath) {\n+        this.executePath = executePath;\n+    }\n+\n+    /**\n+     *  package request command\n+     *\n+     * @return command\n+     */\n+    public Command convert2Command(){\n+        Command command = new Command();\n+        command.setType(CommandType.TASK_EXECUTE_ACK);\n+        byte[] body = JsonSerializer.serialize(this);\n+        command.setBody(body);\n+        return command;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TaskExecuteAckCommand{\" +\n+                \"taskInstanceId=\" + taskInstanceId +\n+                \", startTime=\" + startTime +\n+                \", host='\" + host + '\\'' +\n+                \", status=\" + status +\n+                \", logPath='\" + logPath + '\\'' +\n+                \", executePath='\" + executePath + '\\'' +\n+                '}';\n+    }\n+}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5ODI4Ng==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438098286", "body": "please change windows new line 'CR' to linux new line 'LF'", "bodyText": "please change windows new line 'CR' to linux new line 'LF'", "bodyHTML": "<p dir=\"auto\">please change windows new line 'CR' to linux new line 'LF'</p>", "author": "gabrywu", "createdAt": "2020-06-10T12:54:39Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteRequestCommand implements Serializable {\r\r    /**\r     *  task execution context\r     */\r    private String taskExecutionContext;\r\r    public String getTaskExecutionContext() {\r        return taskExecutionContext;\r    }\r\r    public void setTaskExecutionContext(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    public TaskExecuteRequestCommand() {\r    }\r\r    public TaskExecuteRequestCommand(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_REQUEST);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteRequestCommand{\" +\r                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\r\rimport java.io.Serializable;\r\r/**\r *  execute task request command\r */\rpublic class TaskExecuteRequestCommand implements Serializable {\r\r    /**\r     *  task execution context\r     */\r    private String taskExecutionContext;\r\r    public String getTaskExecutionContext() {\r        return taskExecutionContext;\r    }\r\r    public void setTaskExecutionContext(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    public TaskExecuteRequestCommand() {\r    }\r\r    public TaskExecuteRequestCommand(String taskExecutionContext) {\r        this.taskExecutionContext = taskExecutionContext;\r    }\r\r    /**\r     *  package request command\r     *\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_REQUEST);\r        byte[] body = JsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteRequestCommand{\" +\r                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\r                '}';\r    }\r}\r", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java\nindex 603f8a088..4ae28e3ca 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteRequestCommand.java\n", "chunk": "@@ -1 +1,67 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\n\n/**\n *  execute task request command\n */\npublic class TaskExecuteRequestCommand implements Serializable {\n\n    /**\n     *  task execution context\n     */\n    private String taskExecutionContext;\n\n    public String getTaskExecutionContext() {\n        return taskExecutionContext;\n    }\n\n    public void setTaskExecutionContext(String taskExecutionContext) {\n        this.taskExecutionContext = taskExecutionContext;\n    }\n\n    public TaskExecuteRequestCommand() {\n    }\n\n    public TaskExecuteRequestCommand(String taskExecutionContext) {\n        this.taskExecutionContext = taskExecutionContext;\n    }\n\n    /**\n     *  package request command\n     *\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_REQUEST);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteRequestCommand{\" +\n                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.remote.command;\n+\n+import org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ *  execute task request command\n+ */\n+public class TaskExecuteRequestCommand implements Serializable {\n+\n+    /**\n+     *  task execution context\n+     */\n+    private String taskExecutionContext;\n+\n+    public String getTaskExecutionContext() {\n+        return taskExecutionContext;\n+    }\n+\n+    public void setTaskExecutionContext(String taskExecutionContext) {\n+        this.taskExecutionContext = taskExecutionContext;\n+    }\n+\n+    public TaskExecuteRequestCommand() {\n+    }\n+\n+    public TaskExecuteRequestCommand(String taskExecutionContext) {\n+        this.taskExecutionContext = taskExecutionContext;\n+    }\n+\n+    /**\n+     *  package request command\n+     *\n+     * @return command\n+     */\n+    public Command convert2Command(){\n+        Command command = new Command();\n+        command.setType(CommandType.TASK_EXECUTE_REQUEST);\n+        byte[] body = JsonSerializer.serialize(this);\n+        command.setBody(body);\n+        return command;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TaskExecuteRequestCommand{\" +\n+                \"taskExecutionContext='\" + taskExecutionContext + '\\'' +\n+                '}';\n+    }\n+}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5OTAxNw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438099017", "body": "please change windows new line 'CR' to linux new line 'LF'", "bodyText": "please change windows new line 'CR' to linux new line 'LF'", "bodyHTML": "<p dir=\"auto\">please change windows new line 'CR' to linux new line 'LF'</p>", "author": "gabrywu", "createdAt": "2020-06-10T12:55:49Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java", "diffHunk": "@@ -1 +1 @@\n-/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport org.apache.dolphinscheduler.remote.utils.FastJsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task response command\r */\rpublic class TaskExecuteResponseCommand implements Serializable {\r\r\r    public TaskExecuteResponseCommand() {\r    }\r\r    public TaskExecuteResponseCommand(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    /**\r     *  task instance id\r     */\r    private int taskInstanceId;\r\r    /**\r     *  status\r     */\r    private int status;\r\r\r    /**\r     *  end time\r     */\r    private Date endTime;\r\r\r    /**\r     * processId\r     */\r    private int processId;\r\r    /**\r     * appIds\r     */\r    private String appIds;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public Date getEndTime() {\r        return endTime;\r    }\r\r    public void setEndTime(Date endTime) {\r        this.endTime = endTime;\r    }\r\r    public int getProcessId() {\r        return processId;\r    }\r\r    public void setProcessId(int processId) {\r        this.processId = processId;\r    }\r\r    public String getAppIds() {\r        return appIds;\r    }\r\r    public void setAppIds(String appIds) {\r        this.appIds = appIds;\r    }\r\r    /**\r     * package response command\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\r        byte[] body = FastJsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteResponseCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", status=\" + status +\r                \", endTime=\" + endTime +\r                \", processId=\" + processId +\r                \", appIds='\" + appIds + '\\'' +\r                '}';\r    }\r}\r\n\\ No newline at end of file\n+/*\r * Licensed to the Apache Software Foundation (ASF) under one or more\r * contributor license agreements.  See the NOTICE file distributed with\r * this work for additional information regarding copyright ownership.\r * The ASF licenses this file to You under the Apache License, Version 2.0\r * (the \"License\"); you may not use this file except in compliance with\r * the License.  You may obtain a copy of the License at\r *\r *    http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\rpackage org.apache.dolphinscheduler.remote.command;\r\rimport com.fasterxml.jackson.annotation.JsonFormat;\rimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\r\rimport java.io.Serializable;\rimport java.util.Date;\r\r/**\r *  execute task response command\r */\rpublic class TaskExecuteResponseCommand implements Serializable {\r\r\r    public TaskExecuteResponseCommand() {\r    }\r\r    public TaskExecuteResponseCommand(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    /**\r     *  task instance id\r     */\r    private int taskInstanceId;\r\r    /**\r     *  status\r     */\r    private int status;\r\r\r    /**\r     *  end time\r     */\r    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\r    private Date endTime;\r\r\r    /**\r     * processId\r     */\r    private int processId;\r\r    /**\r     * appIds\r     */\r    private String appIds;\r\r\r    public int getTaskInstanceId() {\r        return taskInstanceId;\r    }\r\r    public void setTaskInstanceId(int taskInstanceId) {\r        this.taskInstanceId = taskInstanceId;\r    }\r\r    public int getStatus() {\r        return status;\r    }\r\r    public void setStatus(int status) {\r        this.status = status;\r    }\r\r    public Date getEndTime() {\r        return endTime;\r    }\r\r    public void setEndTime(Date endTime) {\r        this.endTime = endTime;\r    }\r\r    public int getProcessId() {\r        return processId;\r    }\r\r    public void setProcessId(int processId) {\r        this.processId = processId;\r    }\r\r    public String getAppIds() {\r        return appIds;\r    }\r\r    public void setAppIds(String appIds) {\r        this.appIds = appIds;\r    }\r\r    /**\r     * package response command\r     * @return command\r     */\r    public Command convert2Command(){\r        Command command = new Command();\r        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\r        byte[] body = JsonSerializer.serialize(this);\r        command.setBody(body);\r        return command;\r    }\r\r    @Override\r    public String toString() {\r        return \"TaskExecuteResponseCommand{\" +\r                \"taskInstanceId=\" + taskInstanceId +\r                \", status=\" + status +\r                \", endTime=\" + endTime +\r                \", processId=\" + processId +\r                \", appIds='\" + appIds + '\\'' +\r                '}';\r    }\r}\r", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java\nindex 0ea34fe39..e559334f4 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/command/TaskExecuteResponseCommand.java\n", "chunk": "@@ -1 +1,129 @@\n-/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dolphinscheduler.remote.command;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n *  execute task response command\n */\npublic class TaskExecuteResponseCommand implements Serializable {\n\n\n    public TaskExecuteResponseCommand() {\n    }\n\n    public TaskExecuteResponseCommand(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    /**\n     *  task instance id\n     */\n    private int taskInstanceId;\n\n    /**\n     *  status\n     */\n    private int status;\n\n\n    /**\n     *  end time\n     */\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\n    private Date endTime;\n\n\n    /**\n     * processId\n     */\n    private int processId;\n\n    /**\n     * appIds\n     */\n    private String appIds;\n\n\n    public int getTaskInstanceId() {\n        return taskInstanceId;\n    }\n\n    public void setTaskInstanceId(int taskInstanceId) {\n        this.taskInstanceId = taskInstanceId;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public Date getEndTime() {\n        return endTime;\n    }\n\n    public void setEndTime(Date endTime) {\n        this.endTime = endTime;\n    }\n\n    public int getProcessId() {\n        return processId;\n    }\n\n    public void setProcessId(int processId) {\n        this.processId = processId;\n    }\n\n    public String getAppIds() {\n        return appIds;\n    }\n\n    public void setAppIds(String appIds) {\n        this.appIds = appIds;\n    }\n\n    /**\n     * package response command\n     * @return command\n     */\n    public Command convert2Command(){\n        Command command = new Command();\n        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\n        byte[] body = JsonSerializer.serialize(this);\n        command.setBody(body);\n        return command;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskExecuteResponseCommand{\" +\n                \"taskInstanceId=\" + taskInstanceId +\n                \", status=\" + status +\n                \", endTime=\" + endTime +\n                \", processId=\" + processId +\n                \", appIds='\" + appIds + '\\'' +\n                '}';\n    }\n}\n\\ No newline at end of file\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.remote.command;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import org.apache.dolphinscheduler.remote.utils.JsonSerializer;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+/**\n+ *  execute task response command\n+ */\n+public class TaskExecuteResponseCommand implements Serializable {\n+\n+\n+    public TaskExecuteResponseCommand() {\n+    }\n+\n+    public TaskExecuteResponseCommand(int taskInstanceId) {\n+        this.taskInstanceId = taskInstanceId;\n+    }\n+\n+    /**\n+     *  task instance id\n+     */\n+    private int taskInstanceId;\n+\n+    /**\n+     *  status\n+     */\n+    private int status;\n+\n+\n+    /**\n+     *  end time\n+     */\n+    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\")\n+    private Date endTime;\n+\n+\n+    /**\n+     * processId\n+     */\n+    private int processId;\n+\n+    /**\n+     * appIds\n+     */\n+    private String appIds;\n+\n+\n+    public int getTaskInstanceId() {\n+        return taskInstanceId;\n+    }\n+\n+    public void setTaskInstanceId(int taskInstanceId) {\n+        this.taskInstanceId = taskInstanceId;\n+    }\n+\n+    public int getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(int status) {\n+        this.status = status;\n+    }\n+\n+    public Date getEndTime() {\n+        return endTime;\n+    }\n+\n+    public void setEndTime(Date endTime) {\n+        this.endTime = endTime;\n+    }\n+\n+    public int getProcessId() {\n+        return processId;\n+    }\n+\n+    public void setProcessId(int processId) {\n+        this.processId = processId;\n+    }\n+\n+    public String getAppIds() {\n+        return appIds;\n+    }\n+\n+    public void setAppIds(String appIds) {\n+        this.appIds = appIds;\n+    }\n+\n+    /**\n+     * package response command\n+     * @return command\n+     */\n+    public Command convert2Command(){\n+        Command command = new Command();\n+        command.setType(CommandType.TASK_EXECUTE_RESPONSE);\n+        byte[] body = JsonSerializer.serialize(this);\n+        command.setBody(body);\n+        return command;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TaskExecuteResponseCommand{\" +\n+                \"taskInstanceId=\" + taskInstanceId +\n+                \", status=\" + status +\n+                \", endTime=\" + endTime +\n+                \", processId=\" + processId +\n+                \", appIds='\" + appIds + '\\'' +\n+                '}';\n+    }\n+}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwMjIwMQ==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438102201", "body": "why not user JsonUtils tool class ,just suggestion ,nonstrict", "bodyText": "why not user JsonUtils tool class ,just suggestion ,nonstrict", "bodyHTML": "<p dir=\"auto\">why not user JsonUtils tool class ,just suggestion ,nonstrict</p>", "author": "gabrywu", "createdAt": "2020-06-10T13:00:26Z", "path": "dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java", "diffHunk": "@@ -42,7 +56,14 @@\n \t * @return string\n \t */\n \tpublic static <T> String serializeToString(T obj)  {\n-\t\treturn JSON.toJSONString(obj);\n+\t\tString json = \"\";\n+\t\ttry {\n+\t\t\t json = objectMapper.writeValueAsString(obj);", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d553603ee95d166811fc45edadd736aa1853af3", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java\nindex a23dec4a7..e183289f7 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java\n", "chunk": "@@ -46,35 +52,36 @@ public class JsonSerializer {\n             logger.error(\"serializeToString exception!\", e);\n         }\n \n-\t\treturn json.getBytes(Constants.UTF8);\n-\t}\n+        return json.getBytes(Constants.UTF8);\n+    }\n \n-\t/**\n-\t *  serialize to string\n-\t * @param obj object\n-\t * @param <T> object type\n-\t * @return string\n-\t */\n-\tpublic static <T> String serializeToString(T obj)  {\n-\t\tString json = \"\";\n-\t\ttry {\n-\t\t\t json = objectMapper.writeValueAsString(obj);\n-\t\t} catch (JsonProcessingException e) {\n-\t\t\tlogger.error(\"serializeToString exception!\", e);\n-\t\t}\n+    /**\n+     * serialize to string\n+     *\n+     * @param obj object\n+     * @param <T> object type\n+     * @return string\n+     */\n+    public static <T> String serializeToString(T obj) {\n+        String json = \"\";\n+        try {\n+            json = objectMapper.writeValueAsString(obj);\n+        } catch (JsonProcessingException e) {\n+            logger.error(\"serializeToString exception!\", e);\n+        }\n \n-\t\treturn json;\n-\t}\n+        return json;\n+    }\n \n-\t/**\n-\t *  deserialize\n-\t *\n-\t * @param src byte array\n-\t * @param clazz class\n-\t * @param <T> deserialize type\n-\t * @return deserialize type\n-\t */\n-\tpublic static <T> T deserialize(byte[] src, Class<T> clazz) {\n+    /**\n+     * deserialize\n+     *\n+     * @param src byte array\n+     * @param clazz class\n+     * @param <T> deserialize type\n+     * @return deserialize type\n+     */\n+    public static <T> T deserialize(byte[] src, Class<T> clazz) {\n \n         String json = new String(src, StandardCharsets.UTF_8);\n         try {\n", "next_change": {"commit": "8d12dc0702622783a48f178e7028cbc7ef5b82e1", "changed_code": [{"header": "diff --git a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java\nindex e183289f7..193c8ae60 100644\n--- a/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java\n+++ b/dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/remote/utils/JsonSerializer.java\n", "chunk": "@@ -87,7 +86,7 @@ public class JsonSerializer {\n         try {\n             return objectMapper.readValue(json, clazz);\n         } catch (IOException e) {\n-            logger.error(\"deserialize exception!\", e);\n+            log.error(\"deserialize exception!\", e);\n             return null;\n         }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNTAxNw==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438105017", "body": "better use Collections.EMPTY_LIST", "bodyText": "better use Collections.EMPTY_LIST", "bodyHTML": "<p dir=\"auto\">better use Collections.EMPTY_LIST</p>", "author": "gabrywu", "createdAt": "2020-06-10T13:04:39Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java", "diffHunk": "@@ -107,11 +121,13 @@ public static String toJson(Object object) {\n         if (StringUtils.isEmpty(json)) {\n             return new ArrayList<>();", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cfecfb799b91459e825c2104ab6fa25d07e4f7f1", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex c78ceb2d5..20209c0a9 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -119,7 +119,7 @@ public class JSONUtils {\n      */\n     public static <T> List<T> toList(String json, Class<T> clazz) {\n         if (StringUtils.isEmpty(json)) {\n-            return new ArrayList<>();\n+            return Collections.emptyList();\n         }\n \n         try {\n", "next_change": {"commit": "ee4e64a9a05751a5bccd7ef729c97a75d08033c1", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 20209c0a9..0b1edec6d 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -123,7 +159,6 @@ public class JSONUtils {\n         }\n \n         try {\n-\n             CollectionType listType = objectMapper.getTypeFactory().constructCollectionType(ArrayList.class, clazz);\n             return objectMapper.readValue(json, listType);\n         } catch (Exception e) {\n", "next_change": {"commit": "db1d31915944d2c599593c8a17a0fabd39819f8e", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 0b1edec6d..3fd81942d 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -154,7 +169,7 @@ public class JSONUtils {\n      * @return list\n      */\n     public static <T> List<T> toList(String json, Class<T> clazz) {\n-        if (StringUtils.isEmpty(json)) {\n+        if (Strings.isNullOrEmpty(json)) {\n             return Collections.emptyList();\n         }\n \n", "next_change": {"commit": "8d12dc0702622783a48f178e7028cbc7ef5b82e1", "changed_code": [{"header": "diff --git a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\nindex 3fd81942d..5e216ff27 100644\n--- a/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n+++ b/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/JSONUtils.java\n", "chunk": "@@ -177,7 +181,7 @@ public class JSONUtils {\n             CollectionType listType = objectMapper.getTypeFactory().constructCollectionType(ArrayList.class, clazz);\n             return objectMapper.readValue(json, listType);\n         } catch (Exception e) {\n-            logger.error(\"parse list exception!\", e);\n+            log.error(\"parse list exception!\", e);\n         }\n \n         return Collections.emptyList();\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNjk2MA==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438106960", "body": "why not assign the result of JSONUtils.toList to globalParamsList directly", "bodyText": "why not assign the result of JSONUtils.toList to globalParamsList directly", "bodyHTML": "<p dir=\"auto\">why not assign the result of JSONUtils.toList to globalParamsList directly</p>", "author": "gabrywu", "createdAt": "2020-06-10T13:07:29Z", "path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java", "diffHunk": "@@ -152,7 +153,8 @@ public void run() {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = JSONObject.parseArray(globalParamsStr, Property.class);\n+            List<Property> globalParamsList = new ArrayList<>();", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "009fd01047283ca11d60714b128c3b52d61fc705", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex b964a7289..d2d783ac8 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -153,8 +162,7 @@ public class TaskExecuteThread implements Runnable {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = new ArrayList<>();\n-            globalParamsList = JSONUtils.toList(globalParamsStr, Property.class);\n+            List<Property> globalParamsList = JSONObject.parseArray(globalParamsStr, Property.class);\n             globalParamsMap.putAll(globalParamsList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue)));\n         }\n         return globalParamsMap;\n", "next_change": {"commit": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex d2d783ac8..677f09e11 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -162,7 +153,7 @@ public class TaskExecuteThread implements Runnable {\n         // global params string\n         String globalParamsStr = taskExecutionContext.getGlobalParams();\n         if (globalParamsStr != null) {\n-            List<Property> globalParamsList = JSONObject.parseArray(globalParamsStr, Property.class);\n+            List<Property> globalParamsList = JSONUtils.toList(globalParamsStr, Property.class);\n             globalParamsMap.putAll(globalParamsList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue)));\n         }\n         return globalParamsMap;\n", "next_change": {"commit": "86ce8f133a42a2464a4916c6e0b42dc74628c70d", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 677f09e11..3263554e3 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -159,54 +233,20 @@ public class TaskExecuteThread implements Runnable {\n         return globalParamsMap;\n     }\n \n-    /**\n-     * set task timeout\n-     * @param taskExecutionContext TaskExecutionContext\n-     * @param taskNode\n-     */\n-    private void setTaskTimeout(TaskExecutionContext taskExecutionContext, TaskNode taskNode) {\n-        // the default timeout is the maximum value of the integer\n-        taskExecutionContext.setTaskTimeout(Integer.MAX_VALUE);\n-        TaskTimeoutParameter taskTimeoutParameter = taskNode.getTaskTimeoutParameter();\n-        if (taskTimeoutParameter.getEnable()){\n-            // get timeout strategy\n-            taskExecutionContext.setTaskTimeoutStrategy(taskTimeoutParameter.getStrategy().getCode());\n-            switch (taskTimeoutParameter.getStrategy()){\n-                case WARN:\n-                    break;\n-                case FAILED:\n-                    if (Integer.MAX_VALUE > taskTimeoutParameter.getInterval() * 60) {\n-                        taskExecutionContext.setTaskTimeout(taskTimeoutParameter.getInterval() * 60);\n-                    }\n-                    break;\n-                case WARNFAILED:\n-                    if (Integer.MAX_VALUE > taskTimeoutParameter.getInterval() * 60) {\n-                        taskExecutionContext.setTaskTimeout(taskTimeoutParameter.getInterval() * 60);\n-                    }\n-                    break;\n-                default:\n-                    logger.error(\"not support task timeout strategy: {}\", taskTimeoutParameter.getStrategy());\n-                    throw new IllegalArgumentException(\"not support task timeout strategy\");\n-\n-            }\n-        }\n-    }\n-\n \n     /**\n-     *  kill task\n+     * kill task\n      */\n-    public void kill(){\n-        if (task != null){\n+    public void kill() {\n+        if (task != null) {\n             try {\n                 task.cancelApplication(true);\n-            }catch (Exception e){\n+            } catch (Exception e) {\n                 logger.error(e.getMessage(),e);\n             }\n         }\n     }\n \n-\n     /**\n      * download resource file\n      *\n", "next_change": {"commit": "f7a06a033d2fac494594d16bb3031504dc068b6d", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 3263554e3..6fd4f34b2 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -250,13 +245,11 @@ public class TaskExecuteThread implements Runnable, Delayed {\n     /**\n      * download resource file\n      *\n-     * @param execLocalPath\n-     * @param projectRes\n-     * @param logger\n+     * @param execLocalPath execLocalPath\n+     * @param projectRes projectRes\n+     * @param logger logger\n      */\n-    private void downloadResource(String execLocalPath,\n-                                  Map<String, String> projectRes,\n-                                  Logger logger) throws Exception {\n+    private void downloadResource(String execLocalPath, Map<String, String> projectRes, Logger logger) {\n         if (MapUtils.isEmpty(projectRes)) {\n             return;\n         }\n", "next_change": {"commit": "7029062f4c2f247e9eac333e28e36e66b03fb435", "changed_code": [{"header": "diff --git a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\nindex 6fd4f34b2..5a164e887 100644\n--- a/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n+++ b/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/TaskExecuteThread.java\n", "chunk": "@@ -256,7 +276,7 @@ public class TaskExecuteThread implements Runnable, Delayed {\n \n         Set<Map.Entry<String, String>> resEntries = projectRes.entrySet();\n \n-        for (Map.Entry<String,String> resource : resEntries) {\n+        for (Map.Entry<String, String> resource : resEntries) {\n             String fullName = resource.getKey();\n             String tenantCode = resource.getValue();\n             File resFile = new File(execLocalPath, fullName);\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExMjM5Mg==", "url": "https://github.com/apache/dolphinscheduler/pull/2872#discussion_r438112392", "body": "do you mind move tempObj definition to this position ?", "bodyText": "do you mind move tempObj definition to this position ?", "bodyHTML": "<p dir=\"auto\">do you mind move tempObj definition to this position ?</p>", "author": "gabrywu", "createdAt": "2020-06-10T13:15:56Z", "path": "dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java", "diffHunk": "@@ -205,16 +206,16 @@ public Boolean verifyIsNeedCreateCommand(Command command){\n         CommandType commandType = command.getCommandType();\n \n         if(cmdTypeMap.containsKey(commandType)){\n-            JSONObject cmdParamObj = (JSONObject) JSON.parse(command.getCommandParam());\n-            JSONObject tempObj;\n-            int processInstanceId = cmdParamObj.getInteger(CMDPARAM_RECOVER_PROCESS_ID_STRING);\n+            ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());\n+            ObjectNode tempObj;\n+            int processInstanceId = cmdParamObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt();\n \n             List<Command> commands = commandMapper.selectList(null);\n             // for all commands\n             for (Command tmpCommand:commands){\n                 if(cmdTypeMap.containsKey(tmpCommand.getCommandType())){\n-                    tempObj = (JSONObject) JSON.parse(tmpCommand.getCommandParam());\n-                    if(tempObj != null && processInstanceId == tempObj.getInteger(CMDPARAM_RECOVER_PROCESS_ID_STRING)){\n+                    tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());", "originalCommit": "7d45e116bb98776c42f817c484172eabc8cac441", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d54aab5cd530b2e135a58fbd6b22564583b5abb8", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 127369331..4033b2689 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -206,16 +205,16 @@ public class ProcessService {\n         CommandType commandType = command.getCommandType();\n \n         if(cmdTypeMap.containsKey(commandType)){\n-            ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());\n-            ObjectNode tempObj;\n-            int processInstanceId = cmdParamObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt();\n+            JSONObject cmdParamObj = (JSONObject) JSON.parse(command.getCommandParam());\n+            JSONObject tempObj;\n+            int processInstanceId = cmdParamObj.getInteger(CMDPARAM_RECOVER_PROCESS_ID_STRING);\n \n             List<Command> commands = commandMapper.selectList(null);\n             // for all commands\n             for (Command tmpCommand:commands){\n                 if(cmdTypeMap.containsKey(tmpCommand.getCommandType())){\n-                    tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());\n-                    if(tempObj != null && processInstanceId == tempObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt()){\n+                    tempObj = (JSONObject) JSON.parse(tmpCommand.getCommandParam());\n+                    if(tempObj != null && processInstanceId == tempObj.getInteger(CMDPARAM_RECOVER_PROCESS_ID_STRING)){\n                         isNeedCreate = false;\n                         break;\n                     }\n", "next_change": {"commit": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 4033b2689..237f2a828 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -205,16 +206,15 @@ public class ProcessService {\n         CommandType commandType = command.getCommandType();\n \n         if(cmdTypeMap.containsKey(commandType)){\n-            JSONObject cmdParamObj = (JSONObject) JSON.parse(command.getCommandParam());\n-            JSONObject tempObj;\n-            int processInstanceId = cmdParamObj.getInteger(CMDPARAM_RECOVER_PROCESS_ID_STRING);\n+            ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());\n+            int processInstanceId = cmdParamObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt();\n \n             List<Command> commands = commandMapper.selectList(null);\n             // for all commands\n             for (Command tmpCommand:commands){\n                 if(cmdTypeMap.containsKey(tmpCommand.getCommandType())){\n-                    tempObj = (JSONObject) JSON.parse(tmpCommand.getCommandParam());\n-                    if(tempObj != null && processInstanceId == tempObj.getInteger(CMDPARAM_RECOVER_PROCESS_ID_STRING)){\n+                    ObjectNode tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());\n+                    if(tempObj != null && processInstanceId == tempObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt()){\n                         isNeedCreate = false;\n                         break;\n                     }\n", "next_change": {"commit": "14785f4e390e3f2dcbfa223bd33dbc1907f280d3", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 237f2a828..5dde6d8ce 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -186,59 +244,63 @@ public class ProcessService {\n \n     /**\n      * find one command from queue list\n+     *\n      * @return command\n      */\n-    public Command findOneCommand(){\n+    public Command findOneCommand() {\n         return commandMapper.getOneToRun();\n     }\n \n     /**\n      * check the input command exists in queue list\n+     *\n      * @param command command\n      * @return create command result\n      */\n-    public Boolean verifyIsNeedCreateCommand(Command command){\n+    public Boolean verifyIsNeedCreateCommand(Command command) {\n         Boolean isNeedCreate = true;\n-        Map<CommandType,Integer> cmdTypeMap = new HashMap<CommandType,Integer>();\n-        cmdTypeMap.put(CommandType.REPEAT_RUNNING,1);\n-        cmdTypeMap.put(CommandType.RECOVER_SUSPENDED_PROCESS,1);\n-        cmdTypeMap.put(CommandType.START_FAILURE_TASK_PROCESS,1);\n+        Map<CommandType, Integer> cmdTypeMap = new HashMap<CommandType, Integer>();\n+        cmdTypeMap.put(CommandType.REPEAT_RUNNING, 1);\n+        cmdTypeMap.put(CommandType.RECOVER_SUSPENDED_PROCESS, 1);\n+        cmdTypeMap.put(CommandType.START_FAILURE_TASK_PROCESS, 1);\n         CommandType commandType = command.getCommandType();\n \n-        if(cmdTypeMap.containsKey(commandType)){\n+        if (cmdTypeMap.containsKey(commandType)) {\n             ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());\n             int processInstanceId = cmdParamObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt();\n \n             List<Command> commands = commandMapper.selectList(null);\n             // for all commands\n-            for (Command tmpCommand:commands){\n-                if(cmdTypeMap.containsKey(tmpCommand.getCommandType())){\n+            for (Command tmpCommand : commands) {\n+                if (cmdTypeMap.containsKey(tmpCommand.getCommandType())) {\n                     ObjectNode tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());\n-                    if(tempObj != null && processInstanceId == tempObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt()){\n+                    if (tempObj != null && processInstanceId == tempObj.path(CMDPARAM_RECOVER_PROCESS_ID_STRING).asInt()) {\n                         isNeedCreate = false;\n                         break;\n                     }\n                 }\n             }\n         }\n-        return  isNeedCreate;\n+        return isNeedCreate;\n     }\n \n     /**\n      * find process instance detail by id\n+     *\n      * @param processId processId\n      * @return process instance\n      */\n-    public ProcessInstance findProcessInstanceDetailById(int processId){\n+    public ProcessInstance findProcessInstanceDetailById(int processId) {\n         return processInstanceMapper.queryDetailById(processId);\n     }\n \n     /**\n      * get task node list by definitionId\n+     *\n      * @param defineId\n      * @return\n      */\n-    public  List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId){\n+    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n             logger.info(\"process define not exists\");\n", "next_change": {"commit": "4d553603ee95d166811fc45edadd736aa1853af3", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 5dde6d8ce..3b0d0bdd0 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -296,9 +295,6 @@ public class ProcessService {\n \n     /**\n      * get task node list by definitionId\n-     *\n-     * @param defineId\n-     * @return\n      */\n     public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n", "next_change": {"commit": "73b0eaa99928f01c512b2feaa87d23b4a14f3485", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 3b0d0bdd0..cfe649d74 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -295,6 +296,9 @@ public class ProcessService {\n \n     /**\n      * get task node list by definitionId\n+     *\n+     * @param defineId\n+     * @return\n      */\n     public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n", "next_change": {"commit": "e083e28720a5cd5f4b2c1f8916c26a6089e7fa4e", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex cfe649d74..7c305097f 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -296,9 +297,6 @@ public class ProcessService {\n \n     /**\n      * get task node list by definitionId\n-     *\n-     * @param defineId\n-     * @return\n      */\n     public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n", "next_change": {"commit": "62e961e3f1bab666781df982d2284720db434461", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 7c305097f..cc8284466 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -301,20 +341,22 @@ public class ProcessService {\n     public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.info(\"process define not exists\");\n-            return null;\n-        }\n-\n-        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n-        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n-\n-        //process data check\n-        if (null == processData) {\n-            logger.error(\"process data is null\");\n+            logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n \n-        return processData.getTasks();\n+        List<ProcessTaskRelation> processTaskRelations = getProcessTaskRelationList(processDefinition.getCode(), processDefinition.getVersion());\n+        Map<Long, TaskDefinition> taskDefinitionMap = new HashMap<>();\n+        for (ProcessTaskRelation processTaskRelation : processTaskRelations) {\n+            if (taskDefinitionMap.containsKey(processTaskRelation.getPostTaskCode())) {\n+                TaskDefinition taskDefinition = taskDefinitionMapper.queryByDefinitionCode(processTaskRelation.getPostTaskCode());\n+                taskDefinitionMap.put(processTaskRelation.getPostTaskCode(), taskDefinition);\n+            }\n+        }\n+        return taskDefinitionMap.entrySet()\n+                .stream()\n+                .map(e -> JSONUtils.parseObject(JSONUtils.toJsonString(e.getValue()), TaskNode.class))\n+                .collect(Collectors.toList());\n     }\n \n     /**\n", "next_change": {"commit": "e47e4a70abdeb84fc89be935adce1888a8867f49", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex cc8284466..a759c24e5 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -341,22 +308,20 @@ public class ProcessService {\n     public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.error(\"process define not exists\");\n-            return new ArrayList<>();\n+            logger.info(\"process define not exists\");\n+            return null;\n         }\n \n-        List<ProcessTaskRelation> processTaskRelations = getProcessTaskRelationList(processDefinition.getCode(), processDefinition.getVersion());\n-        Map<Long, TaskDefinition> taskDefinitionMap = new HashMap<>();\n-        for (ProcessTaskRelation processTaskRelation : processTaskRelations) {\n-            if (taskDefinitionMap.containsKey(processTaskRelation.getPostTaskCode())) {\n-                TaskDefinition taskDefinition = taskDefinitionMapper.queryByDefinitionCode(processTaskRelation.getPostTaskCode());\n-                taskDefinitionMap.put(processTaskRelation.getPostTaskCode(), taskDefinition);\n-            }\n+        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n+        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n+\n+        //process data check\n+        if (null == processData) {\n+            logger.error(\"process data is null\");\n+            return new ArrayList<>();\n         }\n-        return taskDefinitionMap.entrySet()\n-                .stream()\n-                .map(e -> JSONUtils.parseObject(JSONUtils.toJsonString(e.getValue()), TaskNode.class))\n-                .collect(Collectors.toList());\n+\n+        return processData.getTasks();\n     }\n \n     /**\n", "next_change": {"commit": "fd7aa53fd3c7dbaf9be984e7d80b8a45593f6cd8", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex a759c24e5..01df13c90 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -308,20 +347,22 @@ public class ProcessService {\n     public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.info(\"process define not exists\");\n-            return null;\n-        }\n-\n-        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n-        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n-\n-        //process data check\n-        if (null == processData) {\n-            logger.error(\"process data is null\");\n+            logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n \n-        return processData.getTasks();\n+        List<ProcessTaskRelation> processTaskRelations = getProcessTaskRelationList(processDefinition.getCode(), processDefinition.getVersion());\n+        Map<Long, TaskDefinition> taskDefinitionMap = new HashMap<>();\n+        for (ProcessTaskRelation processTaskRelation : processTaskRelations) {\n+            if (taskDefinitionMap.containsKey(processTaskRelation.getPostTaskCode())) {\n+                TaskDefinition taskDefinition = taskDefinitionMapper.queryByDefinitionCode(processTaskRelation.getPostTaskCode());\n+                taskDefinitionMap.put(processTaskRelation.getPostTaskCode(), taskDefinition);\n+            }\n+        }\n+        return taskDefinitionMap.entrySet()\n+                .stream()\n+                .map(e -> JSONUtils.parseObject(JSONUtils.toJsonString(e.getValue()), TaskNode.class))\n+                .collect(Collectors.toList());\n     }\n \n     /**\n", "next_change": {"commit": "929655fdbe57e649ac8dc72a87af15fa3c5ef718", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 01df13c90..83cc50bca 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -344,25 +344,23 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n             logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n-\n         List<ProcessTaskRelation> processTaskRelations = getProcessTaskRelationList(processDefinition.getCode(), processDefinition.getVersion());\n         Map<Long, TaskDefinition> taskDefinitionMap = new HashMap<>();\n         for (ProcessTaskRelation processTaskRelation : processTaskRelations) {\n             if (taskDefinitionMap.containsKey(processTaskRelation.getPostTaskCode())) {\n-                TaskDefinition taskDefinition = taskDefinitionMapper.queryByDefinitionCode(processTaskRelation.getPostTaskCode());\n+                TaskDefinition taskDefinition = taskDefinitionLogMapper.queryByDefinitionCodeAndVersion(\n+                        processTaskRelation.getPostTaskCode(), processTaskRelation.getPostNodeVersion());\n                 taskDefinitionMap.put(processTaskRelation.getPostTaskCode(), taskDefinition);\n             }\n         }\n-        return taskDefinitionMap.entrySet()\n-                .stream()\n-                .map(e -> JSONUtils.parseObject(JSONUtils.toJsonString(e.getValue()), TaskNode.class))\n-                .collect(Collectors.toList());\n+        return new ArrayList<>(taskDefinitionMap.values());\n+\n     }\n \n     /**\n", "next_change": {"commit": "779596cf0583e1810466d0156a09dba3dcebbbb7", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 83cc50bca..981767a38 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -350,17 +350,15 @@ public class ProcessService {\n             logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n-        List<ProcessTaskRelation> processTaskRelations = getProcessTaskRelationList(processDefinition.getCode(), processDefinition.getVersion());\n-        Map<Long, TaskDefinition> taskDefinitionMap = new HashMap<>();\n-        for (ProcessTaskRelation processTaskRelation : processTaskRelations) {\n-            if (taskDefinitionMap.containsKey(processTaskRelation.getPostTaskCode())) {\n-                TaskDefinition taskDefinition = taskDefinitionLogMapper.queryByDefinitionCodeAndVersion(\n-                        processTaskRelation.getPostTaskCode(), processTaskRelation.getPostNodeVersion());\n-                taskDefinitionMap.put(processTaskRelation.getPostTaskCode(), taskDefinition);\n+        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n+        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n+        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n+            if (processTaskRelation.getPostTaskCode() > 0) {\n+                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostNodeVersion()));\n             }\n         }\n-        return new ArrayList<>(taskDefinitionMap.values());\n-\n+        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n+        return new ArrayList<>(taskDefinitionLogs);\n     }\n \n     /**\n", "next_change": {"commit": "f24ecff840da133e1ef1d26ff6bf27c2fb112737", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 981767a38..13eb7266c 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -354,7 +354,7 @@ public class ProcessService {\n         Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n         for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n             if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostNodeVersion()));\n+                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n             }\n         }\n         List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n", "next_change": {"commit": "29d42fd92d6720a8a0641e37923c6e6f38a5ae85", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 13eb7266c..fe73eaedf 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -344,21 +306,23 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.error(\"process define not exists\");\n-            return new ArrayList<>();\n+            logger.info(\"process define not exists\");\n+            return null;\n         }\n-        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n-        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n-        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n-            if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n-            }\n+\n+        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n+        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n+\n+        //process data check\n+        if (null == processData) {\n+            logger.error(\"process data is null\");\n+            return new ArrayList<>();\n         }\n-        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-        return new ArrayList<>(taskDefinitionLogs);\n+\n+        return processData.getTasks();\n     }\n \n     /**\n", "next_change": {"commit": "010b49c9332c5638d0b9d2bb9402dd2f579bd5a8", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex fe73eaedf..5a12c6e13 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -306,23 +349,21 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.info(\"process define not exists\");\n-            return null;\n-        }\n-\n-        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n-        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n-\n-        //process data check\n-        if (null == processData) {\n-            logger.error(\"process data is null\");\n+            logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n-\n-        return processData.getTasks();\n+        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n+        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n+        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n+            if (processTaskRelation.getPostTaskCode() > 0) {\n+                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n+            }\n+        }\n+        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n+        return new ArrayList<>(taskDefinitionLogs);\n     }\n \n     /**\n", "next_change": {"commit": "6dbbf6d55d105485b04d2b12533dbbc6e4c9a68f", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 5a12c6e13..7a02d70b1 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -349,21 +310,23 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.error(\"process define not exists\");\n-            return new ArrayList<>();\n+            logger.info(\"process define not exists\");\n+            return null;\n         }\n-        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n-        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n-        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n-            if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n-            }\n+\n+        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n+        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n+\n+        //process data check\n+        if (null == processData) {\n+            logger.error(\"process data is null\");\n+            return new ArrayList<>();\n         }\n-        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-        return new ArrayList<>(taskDefinitionLogs);\n+\n+        return processData.getTasks();\n     }\n \n     /**\n", "next_change": {"commit": "f7a06a033d2fac494594d16bb3031504dc068b6d", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 7a02d70b1..20c88a841 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -310,23 +352,21 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.info(\"process define not exists\");\n-            return null;\n-        }\n-\n-        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n-        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n-\n-        //process data check\n-        if (null == processData) {\n-            logger.error(\"process data is null\");\n+            logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n-\n-        return processData.getTasks();\n+        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n+        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n+        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n+            if (processTaskRelation.getPostTaskCode() > 0) {\n+                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n+            }\n+        }\n+        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n+        return new ArrayList<>(taskDefinitionLogs);\n     }\n \n     /**\n", "next_change": {"commit": "513eb769196971956f15665640aefd782b9f69f3", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 20c88a841..1f4882132 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -352,21 +310,23 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.error(\"process define not exists\");\n-            return new ArrayList<>();\n+            logger.info(\"process define not exists\");\n+            return null;\n         }\n-        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n-        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n-        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n-            if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n-            }\n+\n+        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n+        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n+\n+        //process data check\n+        if (null == processData) {\n+            logger.error(\"process data is null\");\n+            return new ArrayList<>();\n         }\n-        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-        return new ArrayList<>(taskDefinitionLogs);\n+\n+        return processData.getTasks();\n     }\n \n     /**\n", "next_change": {"commit": "49b234609ac733219bcca2191f69a659fdbd6977", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 1f4882132..44fa49484 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -310,23 +352,21 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.info(\"process define not exists\");\n-            return null;\n-        }\n-\n-        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n-        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n-\n-        //process data check\n-        if (null == processData) {\n-            logger.error(\"process data is null\");\n+            logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n-\n-        return processData.getTasks();\n+        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n+        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n+        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n+            if (processTaskRelation.getPostTaskCode() > 0) {\n+                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n+            }\n+        }\n+        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n+        return new ArrayList<>(taskDefinitionLogs);\n     }\n \n     /**\n", "next_change": {"commit": "e12a26289bce0b38bd65ac74a3349ecadd8a9141", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 44fa49484..49c64bea4 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -352,21 +310,23 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.error(\"process define not exists\");\n-            return new ArrayList<>();\n+            logger.info(\"process define not exists\");\n+            return null;\n         }\n-        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n-        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n-        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n-            if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n-            }\n+\n+        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n+        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n+\n+        //process data check\n+        if (null == processData) {\n+            logger.error(\"process data is null\");\n+            return new ArrayList<>();\n         }\n-        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-        return new ArrayList<>(taskDefinitionLogs);\n+\n+        return processData.getTasks();\n     }\n \n     /**\n", "next_change": {"commit": "862565a7c7d404845a43fb5db3eda28fc5cbf05a", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 49c64bea4..74338240c 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -310,23 +352,21 @@ public class ProcessService {\n     /**\n      * get task node list by definitionId\n      */\n-    public List<TaskNode> getTaskNodeListByDefinitionId(Integer defineId) {\n+    public List<TaskDefinition> getTaskNodeListByDefinitionId(Integer defineId) {\n         ProcessDefinition processDefinition = processDefineMapper.selectById(defineId);\n         if (processDefinition == null) {\n-            logger.info(\"process define not exists\");\n-            return null;\n-        }\n-\n-        String processDefinitionJson = processDefinition.getProcessDefinitionJson();\n-        ProcessData processData = JSONUtils.parseObject(processDefinitionJson, ProcessData.class);\n-\n-        //process data check\n-        if (null == processData) {\n-            logger.error(\"process data is null\");\n+            logger.error(\"process define not exists\");\n             return new ArrayList<>();\n         }\n-\n-        return processData.getTasks();\n+        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n+        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n+        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n+            if (processTaskRelation.getPostTaskCode() > 0) {\n+                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n+            }\n+        }\n+        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n+        return new ArrayList<>(taskDefinitionLogs);\n     }\n \n     /**\n", "next_change": {"commit": "2792c35d68517ab293cc19416cfcf9218c02f984", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 74338240c..c3ee5c873 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -365,8 +424,11 @@ public class ProcessService {\n                 taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n             }\n         }\n+        if (taskDefinitionSet.isEmpty()) {\n+            return Lists.newArrayList();\n+        }\n         List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-        return new ArrayList<>(taskDefinitionLogs);\n+        return Lists.newArrayList(taskDefinitionLogs);\n     }\n \n     /**\n", "next_change": {"commit": "5ef3f9d6681d8d150bfee5b77b7929f306fbdc8a", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex c3ee5c873..395aa3166 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -75,2628 +44,256 @@ import org.apache.dolphinscheduler.dao.entity.Resource;\n import org.apache.dolphinscheduler.dao.entity.Schedule;\n import org.apache.dolphinscheduler.dao.entity.TaskDefinition;\n import org.apache.dolphinscheduler.dao.entity.TaskDefinitionLog;\n-import org.apache.dolphinscheduler.dao.entity.TaskGroup;\n import org.apache.dolphinscheduler.dao.entity.TaskGroupQueue;\n import org.apache.dolphinscheduler.dao.entity.TaskInstance;\n import org.apache.dolphinscheduler.dao.entity.Tenant;\n import org.apache.dolphinscheduler.dao.entity.UdfFunc;\n import org.apache.dolphinscheduler.dao.entity.User;\n-import org.apache.dolphinscheduler.dao.mapper.CommandMapper;\n-import org.apache.dolphinscheduler.dao.mapper.DataSourceMapper;\n-import org.apache.dolphinscheduler.dao.mapper.EnvironmentMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ErrorCommandMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProcessDefinitionLogMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProcessDefinitionMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProcessInstanceMapMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProcessInstanceMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProcessTaskRelationLogMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProcessTaskRelationMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ProjectMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ResourceMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ResourceUserMapper;\n-import org.apache.dolphinscheduler.dao.mapper.ScheduleMapper;\n-import org.apache.dolphinscheduler.dao.mapper.TaskDefinitionLogMapper;\n-import org.apache.dolphinscheduler.dao.mapper.TaskDefinitionMapper;\n-import org.apache.dolphinscheduler.dao.mapper.TaskGroupMapper;\n-import org.apache.dolphinscheduler.dao.mapper.TaskGroupQueueMapper;\n-import org.apache.dolphinscheduler.dao.mapper.TaskInstanceMapper;\n-import org.apache.dolphinscheduler.dao.mapper.TenantMapper;\n-import org.apache.dolphinscheduler.dao.mapper.UdfFuncMapper;\n-import org.apache.dolphinscheduler.dao.mapper.UserMapper;\n-import org.apache.dolphinscheduler.dao.utils.DagHelper;\n-import org.apache.dolphinscheduler.remote.command.StateEventChangeCommand;\n-import org.apache.dolphinscheduler.remote.command.TaskEventChangeCommand;\n-import org.apache.dolphinscheduler.remote.processor.StateEventCallbackService;\n-import org.apache.dolphinscheduler.remote.utils.Host;\n-import org.apache.dolphinscheduler.service.bean.SpringApplicationContext;\n-import org.apache.dolphinscheduler.service.exceptions.ServiceException;\n-import org.apache.dolphinscheduler.service.log.LogClientService;\n-import org.apache.dolphinscheduler.service.quartz.cron.CronUtils;\n+import org.apache.dolphinscheduler.plugin.task.api.enums.ExecutionStatus;\n+import org.apache.dolphinscheduler.plugin.task.api.model.DateInterval;\n import org.apache.dolphinscheduler.spi.enums.ResourceType;\n+import org.slf4j.Logger;\n+import org.springframework.transaction.annotation.Transactional;\n \n-import org.apache.commons.collections.CollectionUtils;\n-import org.apache.commons.lang.StringUtils;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Date;\n-import java.util.EnumMap;\n-import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-import org.springframework.transaction.annotation.Transactional;\n+public interface ProcessService {\n+    @Transactional\n+    ProcessInstance handleCommand(Logger logger, String host, Command command);\n \n-import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.google.common.collect.Lists;\n+    void moveToErrorCommand(Command command, String message);\n \n-/**\n- * process relative dao that some mappers in this.\n- */\n-@Component\n-public class ProcessService {\n+    int createCommand(Command command);\n \n-    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    List<Command> findCommandPage(int pageSize, int pageNumber);\n \n-    private final int[] stateArray = new int[]{ExecutionStatus.SUBMITTED_SUCCESS.ordinal(),\n-            ExecutionStatus.RUNNING_EXECUTION.ordinal(),\n-            ExecutionStatus.DELAY_EXECUTION.ordinal(),\n-            ExecutionStatus.READY_PAUSE.ordinal(),\n-            ExecutionStatus.READY_STOP.ordinal()};\n+    List<Command> findCommandPageBySlot(int pageSize, int pageNumber, int masterCount, int thisMasterSlot);\n \n-    @Autowired\n-    private UserMapper userMapper;\n+    boolean verifyIsNeedCreateCommand(Command command);\n \n-    @Autowired\n-    private ProcessDefinitionMapper processDefineMapper;\n+    ProcessInstance findProcessInstanceDetailById(int processId);\n \n-    @Autowired\n-    private ProcessDefinitionLogMapper processDefineLogMapper;\n+    List<TaskDefinition> getTaskNodeListByDefinition(long defineCode);\n \n-    @Autowired\n-    private ProcessInstanceMapper processInstanceMapper;\n+    ProcessInstance findProcessInstanceById(int processId);\n \n-    @Autowired\n-    private DataSourceMapper dataSourceMapper;\n+    ProcessDefinition findProcessDefineById(int processDefinitionId);\n \n-    @Autowired\n-    private ProcessInstanceMapMapper processInstanceMapMapper;\n+    ProcessDefinition findProcessDefinition(Long processDefinitionCode, int version);\n \n-    @Autowired\n-    private TaskInstanceMapper taskInstanceMapper;\n+    ProcessDefinition findProcessDefinitionByCode(Long processDefinitionCode);\n \n-    @Autowired\n-    private CommandMapper commandMapper;\n+    int deleteWorkProcessInstanceById(int processInstanceId);\n \n-    @Autowired\n-    private ScheduleMapper scheduleMapper;\n+    int deleteAllSubWorkProcessByParentId(int processInstanceId);\n \n-    @Autowired\n-    private UdfFuncMapper udfFuncMapper;\n+    void removeTaskLogFile(Integer processInstanceId);\n \n-    @Autowired\n-    private ResourceMapper resourceMapper;\n+    void deleteWorkTaskInstanceByProcessInstanceId(int processInstanceId);\n \n-    @Autowired\n-    private ResourceUserMapper resourceUserMapper;\n+    void recurseFindSubProcess(long parentCode, List<Long> ids);\n \n-    @Autowired\n-    private ErrorCommandMapper errorCommandMapper;\n+    void createRecoveryWaitingThreadCommand(Command originCommand, ProcessInstance processInstance);\n \n-    @Autowired\n-    private TenantMapper tenantMapper;\n+    Tenant getTenantForProcess(int tenantId, int userId);\n \n-    @Autowired\n-    private ProjectMapper projectMapper;\n+    Environment findEnvironmentByCode(Long environmentCode);\n \n-    @Autowired\n-    private TaskDefinitionMapper taskDefinitionMapper;\n+    void setSubProcessParam(ProcessInstance subProcessInstance);\n \n-    @Autowired\n-    private TaskDefinitionLogMapper taskDefinitionLogMapper;\n+    TaskInstance submitTaskWithRetry(ProcessInstance processInstance, TaskInstance taskInstance, int commitRetryTimes, int commitInterval);\n \n-    @Autowired\n-    private ProcessTaskRelationMapper processTaskRelationMapper;\n+    @Transactional(rollbackFor = Exception.class)\n+    TaskInstance submitTask(ProcessInstance processInstance, TaskInstance taskInstance);\n \n-    @Autowired\n-    private ProcessTaskRelationLogMapper processTaskRelationLogMapper;\n+    void createSubWorkProcess(ProcessInstance parentProcessInstance, TaskInstance task);\n \n+    Map<String, String> getGlobalParamMap(String globalParams);\n \n-    @Autowired\n-    StateEventCallbackService stateEventCallbackService;\n+    Command createSubProcessCommand(ProcessInstance parentProcessInstance,\n+                                    ProcessInstance childInstance,\n+                                    ProcessInstanceMap instanceMap,\n+                                    TaskInstance task);\n \n-    @Autowired\n-    private EnvironmentMapper environmentMapper;\n+    TaskInstance submitTaskInstanceToDB(TaskInstance taskInstance, ProcessInstance processInstance);\n \n-    @Autowired\n-    private TaskGroupQueueMapper taskGroupQueueMapper;\n+    ExecutionStatus getSubmitTaskState(TaskInstance taskInstance, ProcessInstance processInstance);\n \n-    @Autowired\n-    private TaskGroupMapper taskGroupMapper;\n+    void saveProcessInstance(ProcessInstance processInstance);\n+\n+    int saveCommand(Command command);\n+\n+    boolean saveTaskInstance(TaskInstance taskInstance);\n+\n+    boolean createTaskInstance(TaskInstance taskInstance);\n+\n+    boolean updateTaskInstance(TaskInstance taskInstance);\n+\n+    TaskInstance findTaskInstanceById(Integer taskId);\n+\n+    List<TaskInstance> findTaskInstanceByIdList(List<Integer> idList);\n+\n+    void packageTaskInstance(TaskInstance taskInstance, ProcessInstance processInstance);\n+\n+    void updateTaskDefinitionResources(TaskDefinition taskDefinition);\n+\n+    List<Integer> findTaskIdByInstanceState(int instanceId, ExecutionStatus state);\n+\n+    List<TaskInstance> findValidTaskListByProcessId(Integer processInstanceId);\n+\n+    List<TaskInstance> findPreviousTaskListByWorkProcessId(Integer processInstanceId);\n+\n+    int updateWorkProcessInstanceMap(ProcessInstanceMap processInstanceMap);\n+\n+    int createWorkProcessInstanceMap(ProcessInstanceMap processInstanceMap);\n+\n+    ProcessInstanceMap findWorkProcessMapByParent(Integer parentWorkProcessId, Integer parentTaskId);\n+\n+    int deleteWorkProcessMapByParentId(int parentWorkProcessId);\n+\n+    ProcessInstance findSubProcessInstance(Integer parentProcessId, Integer parentTaskId);\n+\n+    ProcessInstance findParentProcessInstance(Integer subProcessId);\n+\n+    int updateProcessInstance(ProcessInstance processInstance);\n+\n+    void changeOutParam(TaskInstance taskInstance);\n+\n+    List<String> convertIntListToString(List<Integer> intList);\n+\n+    Schedule querySchedule(int id);\n+\n+    List<Schedule> queryReleaseSchedulerListByProcessDefinitionCode(long processDefinitionCode);\n+\n+    Map<Long, String> queryWorkerGroupByProcessDefinitionCodes(List<Long> processDefinitionCodeList);\n+\n+    List<DependentProcessDefinition> queryDependentProcessDefinitionByProcessDefinitionCode(long processDefinitionCode);\n+\n+    List<ProcessInstance> queryNeedFailoverProcessInstances(String host);\n+\n+    List<String> queryNeedFailoverProcessInstanceHost();\n \n-    /**\n-     * handle Command (construct ProcessInstance from Command) , wrapped in transaction\n-     *\n-     * @param logger logger\n-     * @param host host\n-     * @param command found command\n-     * @return process instance\n-     */\n-    @Transactional\n-    public ProcessInstance handleCommand(Logger logger, String host, Command command) {\n-        ProcessInstance processInstance = constructProcessInstance(command, host);\n-        // cannot construct process instance, return null\n-        if (processInstance == null) {\n-            logger.error(\"scan command, command parameter is error: {}\", command);\n-            moveToErrorCommand(command, \"process instance is null\");\n-            return null;\n-        }\n-        processInstance.setCommandType(command.getCommandType());\n-        processInstance.addHistoryCmd(command.getCommandType());\n-        //if the processDefination is serial\n-        ProcessDefinition processDefinition = this.findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());\n-        if (processDefinition.getExecutionType().typeIsSerial()) {\n-            saveSerialProcess(processInstance, processDefinition);\n-            if (processInstance.getState() != ExecutionStatus.SUBMITTED_SUCCESS) {\n-                setSubProcessParam(processInstance);\n-                deleteCommandWithCheck(command.getId());\n-                return null;\n-            }\n-        } else {\n-            saveProcessInstance(processInstance);\n-        }\n-        setSubProcessParam(processInstance);\n-        deleteCommandWithCheck(command.getId());\n-        return processInstance;\n-    }\n-\n-    private void saveSerialProcess(ProcessInstance processInstance, ProcessDefinition processDefinition) {\n-        processInstance.setState(ExecutionStatus.SERIAL_WAIT);\n-        saveProcessInstance(processInstance);\n-        //serial wait\n-        //when we get the running instance(or waiting instance) only get the priority instance(by id)\n-        if (processDefinition.getExecutionType().typeIsSerialWait()) {\n-            while (true) {\n-                List<ProcessInstance> runningProcessInstances = this.processInstanceMapper.queryByProcessDefineCodeAndStatusAndNextId(processInstance.getProcessDefinitionCode(),\n-                        Constants.RUNNING_PROCESS_STATE, processInstance.getId());\n-                if (CollectionUtils.isEmpty(runningProcessInstances)) {\n-                    processInstance.setState(ExecutionStatus.SUBMITTED_SUCCESS);\n-                    saveProcessInstance(processInstance);\n-                    return;\n-                }\n-                ProcessInstance runningProcess = runningProcessInstances.get(0);\n-                if (this.processInstanceMapper.updateNextProcessIdById(processInstance.getId(), runningProcess.getId())) {\n-                    return;\n-                }\n-            }\n-        } else if (processDefinition.getExecutionType().typeIsSerialDiscard()) {\n-            List<ProcessInstance> runningProcessInstances = this.processInstanceMapper.queryByProcessDefineCodeAndStatusAndNextId(processInstance.getProcessDefinitionCode(),\n-                    Constants.RUNNING_PROCESS_STATE, processInstance.getId());\n-            if (CollectionUtils.isEmpty(runningProcessInstances)) {\n-                processInstance.setState(ExecutionStatus.STOP);\n-                saveProcessInstance(processInstance);\n-            }\n-        } else if (processDefinition.getExecutionType().typeIsSerialPriority()) {\n-            List<ProcessInstance> runningProcessInstances = this.processInstanceMapper.queryByProcessDefineCodeAndStatusAndNextId(processInstance.getProcessDefinitionCode(),\n-                    Constants.RUNNING_PROCESS_STATE, processInstance.getId());\n-            if (CollectionUtils.isNotEmpty(runningProcessInstances)) {\n-                for (ProcessInstance info : runningProcessInstances) {\n-                    info.setCommandType(CommandType.STOP);\n-                    info.addHistoryCmd(CommandType.STOP);\n-                    info.setState(ExecutionStatus.READY_STOP);\n-                    int update = updateProcessInstance(info);\n-                    // determine whether the process is normal\n-                    if (update > 0) {\n-                        String host = info.getHost();\n-                        String address = host.split(\":\")[0];\n-                        int port = Integer.parseInt(host.split(\":\")[1]);\n-                        StateEventChangeCommand stateEventChangeCommand = new StateEventChangeCommand(\n-                                info.getId(), 0, info.getState(), info.getId(), 0\n-                        );\n-                        try {\n-                            stateEventCallbackService.sendResult(address, port, stateEventChangeCommand.convert2Command());\n-                        } catch (Exception e) {\n-                            logger.error(\"sendResultError\");\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * save error command, and delete original command\n-     *\n-     * @param command command\n-     * @param message message\n-     */\n-    public void moveToErrorCommand(Command command, String message) {\n-        ErrorCommand errorCommand = new ErrorCommand(command, message);\n-        this.errorCommandMapper.insert(errorCommand);\n-        this.commandMapper.deleteById(command.getId());\n-    }\n-\n-    /**\n-     * set process waiting thread\n-     *\n-     * @param command command\n-     * @param processInstance processInstance\n-     * @return process instance\n-     */\n-    private ProcessInstance setWaitingThreadProcess(Command command, ProcessInstance processInstance) {\n-        processInstance.setState(ExecutionStatus.WAITING_THREAD);\n-        if (command.getCommandType() != CommandType.RECOVER_WAITING_THREAD) {\n-            processInstance.addHistoryCmd(command.getCommandType());\n-        }\n-        saveProcessInstance(processInstance);\n-        this.setSubProcessParam(processInstance);\n-        createRecoveryWaitingThreadCommand(command, processInstance);\n-        return null;\n-    }\n-\n-    /**\n-     * insert one command\n-     *\n-     * @param command command\n-     * @return create result\n-     */\n-    public int createCommand(Command command) {\n-        int result = 0;\n-        if (command != null) {\n-            result = commandMapper.insert(command);\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * get command page\n-     */\n-    public List<Command> findCommandPage(int pageSize, int pageNumber) {\n-        return commandMapper.queryCommandPage(pageSize, pageNumber * pageSize);\n-    }\n-\n-    /**\n-     * check the input command exists in queue list\n-     *\n-     * @param command command\n-     * @return create command result\n-     */\n-    public boolean verifyIsNeedCreateCommand(Command command) {\n-        boolean isNeedCreate = true;\n-        EnumMap<CommandType, Integer> cmdTypeMap = new EnumMap<>(CommandType.class);\n-        cmdTypeMap.put(CommandType.REPEAT_RUNNING, 1);\n-        cmdTypeMap.put(CommandType.RECOVER_SUSPENDED_PROCESS, 1);\n-        cmdTypeMap.put(CommandType.START_FAILURE_TASK_PROCESS, 1);\n-        CommandType commandType = command.getCommandType();\n-\n-        if (cmdTypeMap.containsKey(commandType)) {\n-            ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());\n-            int processInstanceId = cmdParamObj.path(CMD_PARAM_RECOVER_PROCESS_ID_STRING).asInt();\n-\n-            List<Command> commands = commandMapper.selectList(null);\n-            // for all commands\n-            for (Command tmpCommand : commands) {\n-                if (cmdTypeMap.containsKey(tmpCommand.getCommandType())) {\n-                    ObjectNode tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());\n-                    if (tempObj != null && processInstanceId == tempObj.path(CMD_PARAM_RECOVER_PROCESS_ID_STRING).asInt()) {\n-                        isNeedCreate = false;\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        return isNeedCreate;\n-    }\n-\n-    /**\n-     * find process instance detail by id\n-     *\n-     * @param processId processId\n-     * @return process instance\n-     */\n-    public ProcessInstance findProcessInstanceDetailById(int processId) {\n-        return processInstanceMapper.queryDetailById(processId);\n-    }\n-\n-    /**\n-     * get task node list by definitionId\n-     */\n-    public List<TaskDefinition> getTaskNodeListByDefinition(long defineCode) {\n-        ProcessDefinition processDefinition = processDefineMapper.queryByCode(defineCode);\n-        if (processDefinition == null) {\n-            logger.error(\"process define not exists\");\n-            return Lists.newArrayList();\n-        }\n-        List<ProcessTaskRelationLog> processTaskRelations = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n-        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n-        for (ProcessTaskRelationLog processTaskRelation : processTaskRelations) {\n-            if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n-            }\n-        }\n-        if (taskDefinitionSet.isEmpty()) {\n-            return Lists.newArrayList();\n-        }\n-        List<TaskDefinitionLog> taskDefinitionLogs = taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-        return Lists.newArrayList(taskDefinitionLogs);\n-    }\n-\n-    /**\n-     * find process instance by id\n-     *\n-     * @param processId processId\n-     * @return process instance\n-     */\n-    public ProcessInstance findProcessInstanceById(int processId) {\n-        return processInstanceMapper.selectById(processId);\n-    }\n-\n-    /**\n-     * find process define by id.\n-     *\n-     * @param processDefinitionId processDefinitionId\n-     * @return process definition\n-     */\n-    public ProcessDefinition findProcessDefineById(int processDefinitionId) {\n-        return processDefineMapper.selectById(processDefinitionId);\n-    }\n-\n-    /**\n-     * find process define by code and version.\n-     *\n-     * @param processDefinitionCode processDefinitionCode\n-     * @return process definition\n-     */\n-    public ProcessDefinition findProcessDefinition(Long processDefinitionCode, int version) {\n-        ProcessDefinition processDefinition = processDefineMapper.queryByCode(processDefinitionCode);\n-        if (processDefinition == null || processDefinition.getVersion() != version) {\n-            processDefinition = processDefineLogMapper.queryByDefinitionCodeAndVersion(processDefinitionCode, version);\n-            if (processDefinition != null) {\n-                processDefinition.setId(0);\n-            }\n-        }\n-        return processDefinition;\n-    }\n-\n-    /**\n-     * find process define by code.\n-     *\n-     * @param processDefinitionCode processDefinitionCode\n-     * @return process definition\n-     */\n-    public ProcessDefinition findProcessDefinitionByCode(Long processDefinitionCode) {\n-        return processDefineMapper.queryByCode(processDefinitionCode);\n-    }\n-\n-    /**\n-     * delete work process instance by id\n-     *\n-     * @param processInstanceId processInstanceId\n-     * @return delete process instance result\n-     */\n-    public int deleteWorkProcessInstanceById(int processInstanceId) {\n-        return processInstanceMapper.deleteById(processInstanceId);\n-    }\n-\n-    /**\n-     * delete all sub process by parent instance id\n-     *\n-     * @param processInstanceId processInstanceId\n-     * @return delete all sub process instance result\n-     */\n-    public int deleteAllSubWorkProcessByParentId(int processInstanceId) {\n-\n-        List<Integer> subProcessIdList = processInstanceMapMapper.querySubIdListByParentId(processInstanceId);\n-\n-        for (Integer subId : subProcessIdList) {\n-            deleteAllSubWorkProcessByParentId(subId);\n-            deleteWorkProcessMapByParentId(subId);\n-            removeTaskLogFile(subId);\n-            deleteWorkProcessInstanceById(subId);\n-        }\n-        return 1;\n-    }\n-\n-    /**\n-     * remove task log file\n-     *\n-     * @param processInstanceId processInstanceId\n-     */\n-    public void removeTaskLogFile(Integer processInstanceId) {\n-        List<TaskInstance> taskInstanceList = findValidTaskListByProcessId(processInstanceId);\n-        if (CollectionUtils.isEmpty(taskInstanceList)) {\n-            return;\n-        }\n-        try (LogClientService logClient = new LogClientService()) {\n-            for (TaskInstance taskInstance : taskInstanceList) {\n-                String taskLogPath = taskInstance.getLogPath();\n-                if (StringUtils.isEmpty(taskInstance.getHost())) {\n-                    continue;\n-                }\n-                int port = PropertyUtils.getInt(Constants.RPC_PORT, 50051);\n-                String ip = \"\";\n-                try {\n-                    ip = Host.of(taskInstance.getHost()).getIp();\n-                } catch (Exception e) {\n-                    // compatible old version\n-                    ip = taskInstance.getHost();\n-                }\n-                // remove task log from loggerserver\n-                logClient.removeTaskLog(ip, port, taskLogPath);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * recursive query sub process definition id by parent id.\n-     *\n-     * @param parentCode parentCode\n-     * @param ids ids\n-     */\n-    public void recurseFindSubProcess(long parentCode, List<Long> ids) {\n-        List<TaskDefinition> taskNodeList = this.getTaskNodeListByDefinition(parentCode);\n-\n-        if (taskNodeList != null && !taskNodeList.isEmpty()) {\n-\n-            for (TaskDefinition taskNode : taskNodeList) {\n-                String parameter = taskNode.getTaskParams();\n-                ObjectNode parameterJson = JSONUtils.parseObject(parameter);\n-                if (parameterJson.get(CMD_PARAM_SUB_PROCESS_DEFINE_CODE) != null) {\n-                    SubProcessParameters subProcessParam = JSONUtils.parseObject(parameter, SubProcessParameters.class);\n-                    ids.add(subProcessParam.getProcessDefinitionCode());\n-                    recurseFindSubProcess(subProcessParam.getProcessDefinitionCode(), ids);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * create recovery waiting thread command when thread pool is not enough for the process instance.\n-     * sub work process instance need not to create recovery command.\n-     * create recovery waiting thread  command and delete origin command at the same time.\n-     * if the recovery command is exists, only update the field update_time\n-     *\n-     * @param originCommand originCommand\n-     * @param processInstance processInstance\n-     */\n-    public void createRecoveryWaitingThreadCommand(Command originCommand, ProcessInstance processInstance) {\n-\n-        // sub process doesnot need to create wait command\n-        if (processInstance.getIsSubProcess() == Flag.YES) {\n-            if (originCommand != null) {\n-                commandMapper.deleteById(originCommand.getId());\n-            }\n-            return;\n-        }\n-        Map<String, String> cmdParam = new HashMap<>();\n-        cmdParam.put(Constants.CMD_PARAM_RECOVERY_WAITING_THREAD, String.valueOf(processInstance.getId()));\n-        // process instance quit by \"waiting thread\" state\n-        if (originCommand == null) {\n-            Command command = new Command(\n-                    CommandType.RECOVER_WAITING_THREAD,\n-                    processInstance.getTaskDependType(),\n-                    processInstance.getFailureStrategy(),\n-                    processInstance.getExecutorId(),\n-                    processInstance.getProcessDefinition().getCode(),\n-                    JSONUtils.toJsonString(cmdParam),\n-                    processInstance.getWarningType(),\n-                    processInstance.getWarningGroupId(),\n-                    processInstance.getScheduleTime(),\n-                    processInstance.getWorkerGroup(),\n-                    processInstance.getEnvironmentCode(),\n-                    processInstance.getProcessInstancePriority(),\n-                    processInstance.getDryRun(),\n-                    processInstance.getId(),\n-                    processInstance.getProcessDefinitionVersion()\n-            );\n-            saveCommand(command);\n-            return;\n-        }\n-\n-        // update the command time if current command if recover from waiting\n-        if (originCommand.getCommandType() == CommandType.RECOVER_WAITING_THREAD) {\n-            originCommand.setUpdateTime(new Date());\n-            saveCommand(originCommand);\n-        } else {\n-            // delete old command and create new waiting thread command\n-            commandMapper.deleteById(originCommand.getId());\n-            originCommand.setId(0);\n-            originCommand.setCommandType(CommandType.RECOVER_WAITING_THREAD);\n-            originCommand.setUpdateTime(new Date());\n-            originCommand.setCommandParam(JSONUtils.toJsonString(cmdParam));\n-            originCommand.setProcessInstancePriority(processInstance.getProcessInstancePriority());\n-            saveCommand(originCommand);\n-        }\n-    }\n-\n-    /**\n-     * get schedule time from command\n-     *\n-     * @param command command\n-     * @param cmdParam cmdParam map\n-     * @return date\n-     */\n-    private Date getScheduleTime(Command command, Map<String, String> cmdParam) {\n-        Date scheduleTime = command.getScheduleTime();\n-        if (scheduleTime == null\n-                && cmdParam != null\n-                && cmdParam.containsKey(CMDPARAM_COMPLEMENT_DATA_START_DATE)) {\n-\n-            Date start = DateUtils.stringToDate(cmdParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE));\n-            Date end = DateUtils.stringToDate(cmdParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE));\n-            List<Schedule> schedules = queryReleaseSchedulerListByProcessDefinitionCode(command.getProcessDefinitionCode());\n-            List<Date> complementDateList = CronUtils.getSelfFireDateList(start, end, schedules);\n-\n-            if (complementDateList.size() > 0) {\n-                scheduleTime = complementDateList.get(0);\n-            } else {\n-                logger.error(\"set scheduler time error: complement date list is empty, command: {}\",\n-                        command.toString());\n-            }\n-        }\n-        return scheduleTime;\n-    }\n-\n-    /**\n-     * generate a new work process instance from command.\n-     *\n-     * @param processDefinition processDefinition\n-     * @param command command\n-     * @param cmdParam cmdParam map\n-     * @return process instance\n-     */\n-    private ProcessInstance generateNewProcessInstance(ProcessDefinition processDefinition,\n-                                                       Command command,\n-                                                       Map<String, String> cmdParam) {\n-        ProcessInstance processInstance = new ProcessInstance(processDefinition);\n-        processInstance.setProcessDefinitionCode(processDefinition.getCode());\n-        processInstance.setProcessDefinitionVersion(processDefinition.getVersion());\n-        processInstance.setState(ExecutionStatus.RUNNING_EXECUTION);\n-        processInstance.setRecovery(Flag.NO);\n-        processInstance.setStartTime(new Date());\n-        processInstance.setRunTimes(1);\n-        processInstance.setMaxTryTimes(0);\n-        processInstance.setCommandParam(command.getCommandParam());\n-        processInstance.setCommandType(command.getCommandType());\n-        processInstance.setIsSubProcess(Flag.NO);\n-        processInstance.setTaskDependType(command.getTaskDependType());\n-        processInstance.setFailureStrategy(command.getFailureStrategy());\n-        processInstance.setExecutorId(command.getExecutorId());\n-        WarningType warningType = command.getWarningType() == null ? WarningType.NONE : command.getWarningType();\n-        processInstance.setWarningType(warningType);\n-        Integer warningGroupId = command.getWarningGroupId() == null ? 0 : command.getWarningGroupId();\n-        processInstance.setWarningGroupId(warningGroupId);\n-        processInstance.setDryRun(command.getDryRun());\n-\n-        if (command.getScheduleTime() != null) {\n-            processInstance.setScheduleTime(command.getScheduleTime());\n-        }\n-        processInstance.setCommandStartTime(command.getStartTime());\n-        processInstance.setLocations(processDefinition.getLocations());\n-\n-        // reset global params while there are start parameters\n-        setGlobalParamIfCommanded(processDefinition, cmdParam);\n-\n-        // curing global params\n-        processInstance.setGlobalParams(ParameterUtils.curingGlobalParams(\n-                processDefinition.getGlobalParamMap(),\n-                processDefinition.getGlobalParamList(),\n-                getCommandTypeIfComplement(processInstance, command),\n-                processInstance.getScheduleTime()));\n-\n-        // set process instance priority\n-        processInstance.setProcessInstancePriority(command.getProcessInstancePriority());\n-        String workerGroup = StringUtils.isBlank(command.getWorkerGroup()) ? Constants.DEFAULT_WORKER_GROUP : command.getWorkerGroup();\n-        processInstance.setWorkerGroup(workerGroup);\n-        processInstance.setEnvironmentCode(Objects.isNull(command.getEnvironmentCode()) ? -1 : command.getEnvironmentCode());\n-        processInstance.setTimeout(processDefinition.getTimeout());\n-        processInstance.setTenantId(processDefinition.getTenantId());\n-        return processInstance;\n-    }\n-\n-    private void setGlobalParamIfCommanded(ProcessDefinition processDefinition, Map<String, String> cmdParam) {\n-        // get start params from command param\n-        Map<String, String> startParamMap = new HashMap<>();\n-        if (cmdParam != null && cmdParam.containsKey(Constants.CMD_PARAM_START_PARAMS)) {\n-            String startParamJson = cmdParam.get(Constants.CMD_PARAM_START_PARAMS);\n-            startParamMap = JSONUtils.toMap(startParamJson);\n-        }\n-        Map<String, String> fatherParamMap = new HashMap<>();\n-        if (cmdParam != null && cmdParam.containsKey(Constants.CMD_PARAM_FATHER_PARAMS)) {\n-            String fatherParamJson = cmdParam.get(Constants.CMD_PARAM_FATHER_PARAMS);\n-            fatherParamMap = JSONUtils.toMap(fatherParamJson);\n-        }\n-        startParamMap.putAll(fatherParamMap);\n-        // set start param into global params\n-        if (startParamMap.size() > 0\n-                && processDefinition.getGlobalParamMap() != null) {\n-            for (Map.Entry<String, String> param : processDefinition.getGlobalParamMap().entrySet()) {\n-                String val = startParamMap.get(param.getKey());\n-                if (val != null) {\n-                    param.setValue(val);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * get process tenant\n-     * there is tenant id in definition, use the tenant of the definition.\n-     * if there is not tenant id in the definiton or the tenant not exist\n-     * use definition creator's tenant.\n-     *\n-     * @param tenantId tenantId\n-     * @param userId userId\n-     * @return tenant\n-     */\n-    public Tenant getTenantForProcess(int tenantId, int userId) {\n-        Tenant tenant = null;\n-        if (tenantId >= 0) {\n-            tenant = tenantMapper.queryById(tenantId);\n-        }\n-\n-        if (userId == 0) {\n-            return null;\n-        }\n-\n-        if (tenant == null) {\n-            User user = userMapper.selectById(userId);\n-            tenant = tenantMapper.queryById(user.getTenantId());\n-        }\n-        return tenant;\n-    }\n-\n-    /**\n-     * get an environment\n-     * use the code of the environment to find a environment.\n-     *\n-     * @param environmentCode environmentCode\n-     * @return Environment\n-     */\n-    public Environment findEnvironmentByCode(Long environmentCode) {\n-        Environment environment = null;\n-        if (environmentCode >= 0) {\n-            environment = environmentMapper.queryByEnvironmentCode(environmentCode);\n-        }\n-        return environment;\n-    }\n-\n-    /**\n-     * check command parameters is valid\n-     *\n-     * @param command command\n-     * @param cmdParam cmdParam map\n-     * @return whether command param is valid\n-     */\n-    private Boolean checkCmdParam(Command command, Map<String, String> cmdParam) {\n-        if (command.getTaskDependType() == TaskDependType.TASK_ONLY || command.getTaskDependType() == TaskDependType.TASK_PRE) {\n-            if (cmdParam == null\n-                    || !cmdParam.containsKey(Constants.CMD_PARAM_START_NODES)\n-                    || cmdParam.get(Constants.CMD_PARAM_START_NODES).isEmpty()) {\n-                logger.error(\"command node depend type is {}, but start nodes is null \", command.getTaskDependType());\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * construct process instance according to one command.\n-     *\n-     * @param command command\n-     * @param host host\n-     * @return process instance\n-     */\n-    private ProcessInstance constructProcessInstance(Command command, String host) {\n-        ProcessInstance processInstance;\n-        ProcessDefinition processDefinition;\n-        CommandType commandType = command.getCommandType();\n-\n-        processDefinition = this.findProcessDefinition(command.getProcessDefinitionCode(), command.getProcessDefinitionVersion());\n-        if (processDefinition == null) {\n-            logger.error(\"cannot find the work process define! define code : {}\", command.getProcessDefinitionCode());\n-            return null;\n-        }\n-        Map<String, String> cmdParam = JSONUtils.toMap(command.getCommandParam());\n-        int processInstanceId = command.getProcessInstanceId();\n-        if (processInstanceId == 0) {\n-            processInstance = generateNewProcessInstance(processDefinition, command, cmdParam);\n-        } else {\n-            processInstance = this.findProcessInstanceDetailById(processInstanceId);\n-            if (processInstance == null) {\n-                return processInstance;\n-            }\n-        }\n-        if (cmdParam != null) {\n-            CommandType commandTypeIfComplement = getCommandTypeIfComplement(processInstance, command);\n-            // reset global params while repeat running is needed by cmdParam\n-            if (commandTypeIfComplement == CommandType.REPEAT_RUNNING) {\n-                setGlobalParamIfCommanded(processDefinition, cmdParam);\n-            }\n-\n-            // Recalculate global parameters after rerun.\n-            processInstance.setGlobalParams(ParameterUtils.curingGlobalParams(\n-                    processDefinition.getGlobalParamMap(),\n-                    processDefinition.getGlobalParamList(),\n-                    commandTypeIfComplement,\n-                    processInstance.getScheduleTime()));\n-            processInstance.setProcessDefinition(processDefinition);\n-        }\n-        //reset command parameter\n-        if (processInstance.getCommandParam() != null) {\n-            Map<String, String> processCmdParam = JSONUtils.toMap(processInstance.getCommandParam());\n-            for (Map.Entry<String, String> entry : processCmdParam.entrySet()) {\n-                if (!cmdParam.containsKey(entry.getKey())) {\n-                    cmdParam.put(entry.getKey(), entry.getValue());\n-                }\n-            }\n-        }\n-        // reset command parameter if sub process\n-        if (cmdParam != null && cmdParam.containsKey(Constants.CMD_PARAM_SUB_PROCESS)) {\n-            processInstance.setCommandParam(command.getCommandParam());\n-        }\n-        if (Boolean.FALSE.equals(checkCmdParam(command, cmdParam))) {\n-            logger.error(\"command parameter check failed!\");\n-            return null;\n-        }\n-        if (command.getScheduleTime() != null) {\n-            processInstance.setScheduleTime(command.getScheduleTime());\n-        }\n-        processInstance.setHost(host);\n-        ExecutionStatus runStatus = ExecutionStatus.RUNNING_EXECUTION;\n-        int runTime = processInstance.getRunTimes();\n-        switch (commandType) {\n-            case START_PROCESS:\n-                break;\n-            case START_FAILURE_TASK_PROCESS:\n-                // find failed tasks and init these tasks\n-                List<Integer> failedList = this.findTaskIdByInstanceState(processInstance.getId(), ExecutionStatus.FAILURE);\n-                List<Integer> toleranceList = this.findTaskIdByInstanceState(processInstance.getId(), ExecutionStatus.NEED_FAULT_TOLERANCE);\n-                List<Integer> killedList = this.findTaskIdByInstanceState(processInstance.getId(), ExecutionStatus.KILL);\n-                cmdParam.remove(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING);\n-\n-                failedList.addAll(killedList);\n-                failedList.addAll(toleranceList);\n-                for (Integer taskId : failedList) {\n-                    initTaskInstance(this.findTaskInstanceById(taskId));\n-                }\n-                cmdParam.put(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING,\n-                        String.join(Constants.COMMA, convertIntListToString(failedList)));\n-                processInstance.setCommandParam(JSONUtils.toJsonString(cmdParam));\n-                processInstance.setRunTimes(runTime + 1);\n-                break;\n-            case START_CURRENT_TASK_PROCESS:\n-                break;\n-            case RECOVER_WAITING_THREAD:\n-                break;\n-            case RECOVER_SUSPENDED_PROCESS:\n-                // find pause tasks and init task's state\n-                cmdParam.remove(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING);\n-                List<Integer> suspendedNodeList = this.findTaskIdByInstanceState(processInstance.getId(), ExecutionStatus.PAUSE);\n-                List<Integer> stopNodeList = findTaskIdByInstanceState(processInstance.getId(),\n-                        ExecutionStatus.KILL);\n-                suspendedNodeList.addAll(stopNodeList);\n-                for (Integer taskId : suspendedNodeList) {\n-                    // initialize the pause state\n-                    initTaskInstance(this.findTaskInstanceById(taskId));\n-                }\n-                cmdParam.put(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING, String.join(\",\", convertIntListToString(suspendedNodeList)));\n-                processInstance.setCommandParam(JSONUtils.toJsonString(cmdParam));\n-                processInstance.setRunTimes(runTime + 1);\n-                break;\n-            case RECOVER_TOLERANCE_FAULT_PROCESS:\n-                // recover tolerance fault process\n-                processInstance.setRecovery(Flag.YES);\n-                runStatus = processInstance.getState();\n-                break;\n-            case COMPLEMENT_DATA:\n-                // delete all the valid tasks when complement data if id is not null\n-                if (processInstance.getId() != 0) {\n-                    List<TaskInstance> taskInstanceList = this.findValidTaskListByProcessId(processInstance.getId());\n-                    for (TaskInstance taskInstance : taskInstanceList) {\n-                        taskInstance.setFlag(Flag.NO);\n-                        this.updateTaskInstance(taskInstance);\n-                    }\n-                }\n-                break;\n-            case REPEAT_RUNNING:\n-                // delete the recover task names from command parameter\n-                if (cmdParam.containsKey(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING)) {\n-                    cmdParam.remove(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING);\n-                    processInstance.setCommandParam(JSONUtils.toJsonString(cmdParam));\n-                }\n-                // delete all the valid tasks when repeat running\n-                List<TaskInstance> validTaskList = findValidTaskListByProcessId(processInstance.getId());\n-                for (TaskInstance taskInstance : validTaskList) {\n-                    taskInstance.setFlag(Flag.NO);\n-                    updateTaskInstance(taskInstance);\n-                }\n-                processInstance.setStartTime(new Date());\n-                processInstance.setEndTime(null);\n-                processInstance.setRunTimes(runTime + 1);\n-                initComplementDataParam(processDefinition, processInstance, cmdParam);\n-                break;\n-            case SCHEDULER:\n-                break;\n-            default:\n-                break;\n-        }\n-        processInstance.setState(runStatus);\n-        return processInstance;\n-    }\n-\n-    /**\n-     * get process definition by command\n-     * If it is a fault-tolerant command, get the specified version of ProcessDefinition through ProcessInstance\n-     * Otherwise, get the latest version of ProcessDefinition\n-     *\n-     * @return ProcessDefinition\n-     */\n-    private ProcessDefinition getProcessDefinitionByCommand(long processDefinitionCode, Map<String, String> cmdParam) {\n-        if (cmdParam != null) {\n-            int processInstanceId = 0;\n-            if (cmdParam.containsKey(Constants.CMD_PARAM_RECOVER_PROCESS_ID_STRING)) {\n-                processInstanceId = Integer.parseInt(cmdParam.get(Constants.CMD_PARAM_RECOVER_PROCESS_ID_STRING));\n-            } else if (cmdParam.containsKey(Constants.CMD_PARAM_SUB_PROCESS)) {\n-                processInstanceId = Integer.parseInt(cmdParam.get(Constants.CMD_PARAM_SUB_PROCESS));\n-            } else if (cmdParam.containsKey(Constants.CMD_PARAM_RECOVERY_WAITING_THREAD)) {\n-                processInstanceId = Integer.parseInt(cmdParam.get(Constants.CMD_PARAM_RECOVERY_WAITING_THREAD));\n-            }\n-\n-            if (processInstanceId != 0) {\n-                ProcessInstance processInstance = this.findProcessInstanceDetailById(processInstanceId);\n-                if (processInstance == null) {\n-                    return null;\n-                }\n-\n-                return processDefineLogMapper.queryByDefinitionCodeAndVersion(\n-                        processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());\n-            }\n-        }\n-\n-        return processDefineMapper.queryByCode(processDefinitionCode);\n-    }\n-\n-    /**\n-     * return complement data if the process start with complement data\n-     *\n-     * @param processInstance processInstance\n-     * @param command command\n-     * @return command type\n-     */\n-    private CommandType getCommandTypeIfComplement(ProcessInstance processInstance, Command command) {\n-        if (CommandType.COMPLEMENT_DATA == processInstance.getCmdTypeIfComplement()) {\n-            return CommandType.COMPLEMENT_DATA;\n-        } else {\n-            return command.getCommandType();\n-        }\n-    }\n-\n-    /**\n-     * initialize complement data parameters\n-     *\n-     * @param processDefinition processDefinition\n-     * @param processInstance processInstance\n-     * @param cmdParam cmdParam\n-     */\n-    private void initComplementDataParam(ProcessDefinition processDefinition,\n-                                         ProcessInstance processInstance,\n-                                         Map<String, String> cmdParam) {\n-        if (!processInstance.isComplementData()) {\n-            return;\n-        }\n-\n-        Date start = DateUtils.stringToDate(cmdParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE));\n-        Date end = DateUtils.stringToDate(cmdParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE));\n-        List<Schedule> listSchedules = queryReleaseSchedulerListByProcessDefinitionCode(processInstance.getProcessDefinitionCode());\n-        List<Date> complementDate = CronUtils.getSelfFireDateList(start, end, listSchedules);\n-\n-        if (complementDate.size() > 0\n-                && Flag.NO == processInstance.getIsSubProcess()) {\n-            processInstance.setScheduleTime(complementDate.get(0));\n-        }\n-        processInstance.setGlobalParams(ParameterUtils.curingGlobalParams(\n-                processDefinition.getGlobalParamMap(),\n-                processDefinition.getGlobalParamList(),\n-                CommandType.COMPLEMENT_DATA, processInstance.getScheduleTime()));\n-    }\n-\n-    /**\n-     * set sub work process parameters.\n-     * handle sub work process instance, update relation table and command parameters\n-     * set sub work process flag, extends parent work process command parameters\n-     *\n-     * @param subProcessInstance subProcessInstance\n-     */\n-    public void setSubProcessParam(ProcessInstance subProcessInstance) {\n-        String cmdParam = subProcessInstance.getCommandParam();\n-        if (StringUtils.isEmpty(cmdParam)) {\n-            return;\n-        }\n-        Map<String, String> paramMap = JSONUtils.toMap(cmdParam);\n-        // write sub process id into cmd param.\n-        if (paramMap.containsKey(CMD_PARAM_SUB_PROCESS)\n-                && CMD_PARAM_EMPTY_SUB_PROCESS.equals(paramMap.get(CMD_PARAM_SUB_PROCESS))) {\n-            paramMap.remove(CMD_PARAM_SUB_PROCESS);\n-            paramMap.put(CMD_PARAM_SUB_PROCESS, String.valueOf(subProcessInstance.getId()));\n-            subProcessInstance.setCommandParam(JSONUtils.toJsonString(paramMap));\n-            subProcessInstance.setIsSubProcess(Flag.YES);\n-            this.saveProcessInstance(subProcessInstance);\n-        }\n-        // copy parent instance user def params to sub process..\n-        String parentInstanceId = paramMap.get(CMD_PARAM_SUB_PROCESS_PARENT_INSTANCE_ID);\n-        if (StringUtils.isNotEmpty(parentInstanceId)) {\n-            ProcessInstance parentInstance = findProcessInstanceDetailById(Integer.parseInt(parentInstanceId));\n-            if (parentInstance != null) {\n-                subProcessInstance.setGlobalParams(\n-                        joinGlobalParams(parentInstance.getGlobalParams(), subProcessInstance.getGlobalParams()));\n-                this.saveProcessInstance(subProcessInstance);\n-            } else {\n-                logger.error(\"sub process command params error, cannot find parent instance: {} \", cmdParam);\n-            }\n-        }\n-        ProcessInstanceMap processInstanceMap = JSONUtils.parseObject(cmdParam, ProcessInstanceMap.class);\n-        if (processInstanceMap == null || processInstanceMap.getParentProcessInstanceId() == 0) {\n-            return;\n-        }\n-        // update sub process id to process map table\n-        processInstanceMap.setProcessInstanceId(subProcessInstance.getId());\n-\n-        this.updateWorkProcessInstanceMap(processInstanceMap);\n-    }\n-\n-    /**\n-     * join parent global params into sub process.\n-     * only the keys doesn't in sub process global would be joined.\n-     *\n-     * @param parentGlobalParams parentGlobalParams\n-     * @param subGlobalParams subGlobalParams\n-     * @return global params join\n-     */\n-    private String joinGlobalParams(String parentGlobalParams, String subGlobalParams) {\n-\n-        List<Property> parentPropertyList = JSONUtils.toList(parentGlobalParams, Property.class);\n-        List<Property> subPropertyList = JSONUtils.toList(subGlobalParams, Property.class);\n-\n-        Map<String, String> subMap = subPropertyList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n-\n-        for (Property parent : parentPropertyList) {\n-            if (!subMap.containsKey(parent.getProp())) {\n-                subPropertyList.add(parent);\n-            }\n-        }\n-        return JSONUtils.toJsonString(subPropertyList);\n-    }\n-\n-    /**\n-     * initialize task instance\n-     *\n-     * @param taskInstance taskInstance\n-     */\n-    private void initTaskInstance(TaskInstance taskInstance) {\n-\n-        if (!taskInstance.isSubProcess()\n-                && (taskInstance.getState().typeIsCancel() || taskInstance.getState().typeIsFailure())) {\n-            taskInstance.setFlag(Flag.NO);\n-            updateTaskInstance(taskInstance);\n-            return;\n-        }\n-        taskInstance.setState(ExecutionStatus.SUBMITTED_SUCCESS);\n-        updateTaskInstance(taskInstance);\n-    }\n-\n-    /**\n-     * retry submit task to db\n-     */\n-    public TaskInstance submitTaskWithRetry(ProcessInstance processInstance, TaskInstance taskInstance, int commitRetryTimes, int commitInterval) {\n-        int retryTimes = 1;\n-        TaskInstance task = null;\n-        while (retryTimes <= commitRetryTimes) {\n-            try {\n-                // submit task to db\n-                task = SpringApplicationContext.getBean(ProcessService.class).submitTask(processInstance, taskInstance);\n-                if (task != null && task.getId() != 0) {\n-                    break;\n-                }\n-                logger.error(\"task commit to db failed , taskId {} has already retry {} times, please check the database\", taskInstance.getId(), retryTimes);\n-                Thread.sleep(commitInterval);\n-            } catch (Exception e) {\n-                logger.error(\"task commit to mysql failed\", e);\n-            }\n-            retryTimes += 1;\n-        }\n-        return task;\n-    }\n-\n-    /**\n-     * submit task to db\n-     * submit sub process to command\n-     *\n-     * @param processInstance processInstance\n-     * @param taskInstance taskInstance\n-     * @return task instance\n-     */\n-    @Transactional(rollbackFor = Exception.class)\n-    public TaskInstance submitTask(ProcessInstance processInstance, TaskInstance taskInstance) {\n-        logger.info(\"start submit task : {}, instance id:{}, state: {}\",\n-                taskInstance.getName(), taskInstance.getProcessInstanceId(), processInstance.getState());\n-        //submit to db\n-        TaskInstance task = submitTaskInstanceToDB(taskInstance, processInstance);\n-        if (task == null) {\n-            logger.error(\"end submit task to db error, task name:{}, process id:{} state: {} \",\n-                    taskInstance.getName(), taskInstance.getProcessInstance(), processInstance.getState());\n-            return null;\n-        }\n-\n-        if (!task.getState().typeIsFinished()) {\n-            createSubWorkProcess(processInstance, task);\n-        }\n-\n-        logger.info(\"end submit task to db successfully:{} {} state:{} complete, instance id:{} state: {}  \",\n-                taskInstance.getId(), taskInstance.getName(), task.getState(), processInstance.getId(), processInstance.getState());\n-        return task;\n-    }\n-\n-    /**\n-     * set work process instance map\n-     * consider o\n-     * repeat running  does not generate new sub process instance\n-     * set map {parent instance id, task instance id, 0(child instance id)}\n-     *\n-     * @param parentInstance parentInstance\n-     * @param parentTask parentTask\n-     * @return process instance map\n-     */\n-    private ProcessInstanceMap setProcessInstanceMap(ProcessInstance parentInstance, TaskInstance parentTask) {\n-        ProcessInstanceMap processMap = findWorkProcessMapByParent(parentInstance.getId(), parentTask.getId());\n-        if (processMap != null) {\n-            return processMap;\n-        }\n-        if (parentInstance.getCommandType() == CommandType.REPEAT_RUNNING) {\n-            // update current task id to map\n-            processMap = findPreviousTaskProcessMap(parentInstance, parentTask);\n-            if (processMap != null) {\n-                processMap.setParentTaskInstanceId(parentTask.getId());\n-                updateWorkProcessInstanceMap(processMap);\n-                return processMap;\n-            }\n-        }\n-        // new task\n-        processMap = new ProcessInstanceMap();\n-        processMap.setParentProcessInstanceId(parentInstance.getId());\n-        processMap.setParentTaskInstanceId(parentTask.getId());\n-        createWorkProcessInstanceMap(processMap);\n-        return processMap;\n-    }\n-\n-    /**\n-     * find previous task work process map.\n-     *\n-     * @param parentProcessInstance parentProcessInstance\n-     * @param parentTask parentTask\n-     * @return process instance map\n-     */\n-    private ProcessInstanceMap findPreviousTaskProcessMap(ProcessInstance parentProcessInstance,\n-                                                          TaskInstance parentTask) {\n-\n-        Integer preTaskId = 0;\n-        List<TaskInstance> preTaskList = this.findPreviousTaskListByWorkProcessId(parentProcessInstance.getId());\n-        for (TaskInstance task : preTaskList) {\n-            if (task.getName().equals(parentTask.getName())) {\n-                preTaskId = task.getId();\n-                ProcessInstanceMap map = findWorkProcessMapByParent(parentProcessInstance.getId(), preTaskId);\n-                if (map != null) {\n-                    return map;\n-                }\n-            }\n-        }\n-        logger.info(\"sub process instance is not found,parent task:{},parent instance:{}\",\n-                parentTask.getId(), parentProcessInstance.getId());\n-        return null;\n-    }\n-\n-    /**\n-     * create sub work process command\n-     *\n-     * @param parentProcessInstance parentProcessInstance\n-     * @param task task\n-     */\n-    public void createSubWorkProcess(ProcessInstance parentProcessInstance, TaskInstance task) {\n-        if (!task.isSubProcess()) {\n-            return;\n-        }\n-        //check create sub work flow firstly\n-        ProcessInstanceMap instanceMap = findWorkProcessMapByParent(parentProcessInstance.getId(), task.getId());\n-        if (null != instanceMap && CommandType.RECOVER_TOLERANCE_FAULT_PROCESS == parentProcessInstance.getCommandType()) {\n-            // recover failover tolerance would not create a new command when the sub command already have been created\n-            return;\n-        }\n-        instanceMap = setProcessInstanceMap(parentProcessInstance, task);\n-        ProcessInstance childInstance = null;\n-        if (instanceMap.getProcessInstanceId() != 0) {\n-            childInstance = findProcessInstanceById(instanceMap.getProcessInstanceId());\n-        }\n-        Command subProcessCommand = createSubProcessCommand(parentProcessInstance, childInstance, instanceMap, task);\n-        updateSubProcessDefinitionByParent(parentProcessInstance, subProcessCommand.getProcessDefinitionCode());\n-        initSubInstanceState(childInstance);\n-        createCommand(subProcessCommand);\n-        logger.info(\"sub process command created: {} \", subProcessCommand);\n-    }\n-\n-    /**\n-     * complement data needs transform parent parameter to child.\n-     */\n-    private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {\n-        // set sub work process command\n-        String processMapStr = JSONUtils.toJsonString(instanceMap);\n-        Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);\n-        if (parentProcessInstance.isComplementData()) {\n-            Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());\n-            String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);\n-            String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);\n-            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);\n-            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);\n-            processMapStr = JSONUtils.toJsonString(cmdParam);\n-        }\n-        if (fatherParams.size() != 0) {\n-            cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));\n-            processMapStr = JSONUtils.toJsonString(cmdParam);\n-        }\n-        return processMapStr;\n-    }\n-\n-    public Map<String, String> getGlobalParamMap(String globalParams) {\n-        List<Property> propList;\n-        Map<String, String> globalParamMap = new HashMap<>();\n-        if (StringUtils.isNotEmpty(globalParams)) {\n-            propList = JSONUtils.toList(globalParams, Property.class);\n-            globalParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));\n-        }\n-\n-        return globalParamMap;\n-    }\n-\n-    /**\n-     * create sub work process command\n-     */\n-    public Command createSubProcessCommand(ProcessInstance parentProcessInstance,\n-                                           ProcessInstance childInstance,\n-                                           ProcessInstanceMap instanceMap,\n-                                           TaskInstance task) {\n-        CommandType commandType = getSubCommandType(parentProcessInstance, childInstance);\n-        Map<String, String> subProcessParam = JSONUtils.toMap(task.getTaskParams());\n-        long childDefineCode = 0L;\n-        if (subProcessParam.containsKey(Constants.CMD_PARAM_SUB_PROCESS_DEFINE_CODE)) {\n-            childDefineCode = Long.parseLong(subProcessParam.get(Constants.CMD_PARAM_SUB_PROCESS_DEFINE_CODE));\n-        }\n-        ProcessDefinition subProcessDefinition = processDefineMapper.queryByCode(childDefineCode);\n-\n-        Object localParams = subProcessParam.get(Constants.LOCAL_PARAMS);\n-        List<Property> allParam = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);\n-        Map<String, String> globalMap = this.getGlobalParamMap(parentProcessInstance.getGlobalParams());\n-        Map<String, String> fatherParams = new HashMap<>();\n-        if (CollectionUtils.isNotEmpty(allParam)) {\n-            for (Property info : allParam) {\n-                fatherParams.put(info.getProp(), globalMap.get(info.getProp()));\n-            }\n-        }\n-        String processParam = getSubWorkFlowParam(instanceMap, parentProcessInstance, fatherParams);\n-        int subProcessInstanceId = childInstance == null ? 0 : childInstance.getId();\n-        return new Command(\n-                commandType,\n-                TaskDependType.TASK_POST,\n-                parentProcessInstance.getFailureStrategy(),\n-                parentProcessInstance.getExecutorId(),\n-                subProcessDefinition.getCode(),\n-                processParam,\n-                parentProcessInstance.getWarningType(),\n-                parentProcessInstance.getWarningGroupId(),\n-                parentProcessInstance.getScheduleTime(),\n-                task.getWorkerGroup(),\n-                task.getEnvironmentCode(),\n-                parentProcessInstance.getProcessInstancePriority(),\n-                parentProcessInstance.getDryRun(),\n-                subProcessInstanceId,\n-                subProcessDefinition.getVersion()\n-        );\n-    }\n-\n-    /**\n-     * initialize sub work flow state\n-     * child instance state would be initialized when 'recovery from pause/stop/failure'\n-     */\n-    private void initSubInstanceState(ProcessInstance childInstance) {\n-        if (childInstance != null) {\n-            childInstance.setState(ExecutionStatus.RUNNING_EXECUTION);\n-            updateProcessInstance(childInstance);\n-        }\n-    }\n-\n-    /**\n-     * get sub work flow command type\n-     * child instance exist: child command = fatherCommand\n-     * child instance not exists: child command = fatherCommand[0]\n-     */\n-    private CommandType getSubCommandType(ProcessInstance parentProcessInstance, ProcessInstance childInstance) {\n-        CommandType commandType = parentProcessInstance.getCommandType();\n-        if (childInstance == null) {\n-            String fatherHistoryCommand = parentProcessInstance.getHistoryCmd();\n-            commandType = CommandType.valueOf(fatherHistoryCommand.split(Constants.COMMA)[0]);\n-        }\n-        return commandType;\n-    }\n-\n-    /**\n-     * update sub process definition\n-     *\n-     * @param parentProcessInstance parentProcessInstance\n-     * @param childDefinitionCode childDefinitionId\n-     */\n-    private void updateSubProcessDefinitionByParent(ProcessInstance parentProcessInstance, long childDefinitionCode) {\n-        ProcessDefinition fatherDefinition = this.findProcessDefinition(parentProcessInstance.getProcessDefinitionCode(),\n-                parentProcessInstance.getProcessDefinitionVersion());\n-        ProcessDefinition childDefinition = this.findProcessDefinitionByCode(childDefinitionCode);\n-        if (childDefinition != null && fatherDefinition != null) {\n-            childDefinition.setWarningGroupId(fatherDefinition.getWarningGroupId());\n-            processDefineMapper.updateById(childDefinition);\n-        }\n-    }\n-\n-    /**\n-     * submit task to mysql\n-     *\n-     * @param taskInstance taskInstance\n-     * @param processInstance processInstance\n-     * @return task instance\n-     */\n-    public TaskInstance submitTaskInstanceToDB(TaskInstance taskInstance, ProcessInstance processInstance) {\n-        ExecutionStatus processInstanceState = processInstance.getState();\n-\n-        if (taskInstance.getState().typeIsFailure()) {\n-            if (taskInstance.isSubProcess()) {\n-                taskInstance.setRetryTimes(taskInstance.getRetryTimes() + 1);\n-            } else {\n-                if (processInstanceState != ExecutionStatus.READY_STOP\n-                        && processInstanceState != ExecutionStatus.READY_PAUSE) {\n-                    // failure task set invalid\n-                    taskInstance.setFlag(Flag.NO);\n-                    updateTaskInstance(taskInstance);\n-                    // crate new task instance\n-                    if (taskInstance.getState() != ExecutionStatus.NEED_FAULT_TOLERANCE) {\n-                        taskInstance.setRetryTimes(taskInstance.getRetryTimes() + 1);\n-                    }\n-                    taskInstance.setSubmitTime(null);\n-                    taskInstance.setLogPath(null);\n-                    taskInstance.setExecutePath(null);\n-                    taskInstance.setStartTime(null);\n-                    taskInstance.setEndTime(null);\n-                    taskInstance.setFlag(Flag.YES);\n-                    taskInstance.setHost(null);\n-                    taskInstance.setId(0);\n-                }\n-            }\n-        }\n-        taskInstance.setExecutorId(processInstance.getExecutorId());\n-        taskInstance.setProcessInstancePriority(processInstance.getProcessInstancePriority());\n-        taskInstance.setState(getSubmitTaskState(taskInstance, processInstance));\n-        if (taskInstance.getSubmitTime() == null) {\n-            taskInstance.setSubmitTime(new Date());\n-        }\n-        if (taskInstance.getFirstSubmitTime() == null) {\n-            taskInstance.setFirstSubmitTime(taskInstance.getSubmitTime());\n-        }\n-        boolean saveResult = saveTaskInstance(taskInstance);\n-        if (!saveResult) {\n-            return null;\n-        }\n-        return taskInstance;\n-    }\n-\n-    /**\n-     * get submit task instance state by the work process state\n-     * cannot modify the task state when running/kill/submit success, or this\n-     * task instance is already exists in task queue .\n-     * return pause if work process state is ready pause\n-     * return stop if work process state is ready stop\n-     * if all of above are not satisfied, return submit success\n-     *\n-     * @param taskInstance taskInstance\n-     * @param processInstance processInstance\n-     * @return process instance state\n-     */\n-    public ExecutionStatus getSubmitTaskState(TaskInstance taskInstance, ProcessInstance processInstance) {\n-        ExecutionStatus state = taskInstance.getState();\n-        // running, delayed or killed\n-        // the task already exists in task queue\n-        // return state\n-        if (\n-                state == ExecutionStatus.RUNNING_EXECUTION\n-                        || state == ExecutionStatus.DELAY_EXECUTION\n-                        || state == ExecutionStatus.KILL\n-        ) {\n-            return state;\n-        }\n-        //return pasue /stop if process instance state is ready pause / stop\n-        // or return submit success\n-        if (processInstance.getState() == ExecutionStatus.READY_PAUSE) {\n-            state = ExecutionStatus.PAUSE;\n-        } else if (processInstance.getState() == ExecutionStatus.READY_STOP\n-                || !checkProcessStrategy(taskInstance, processInstance)) {\n-            state = ExecutionStatus.KILL;\n-        } else {\n-            state = ExecutionStatus.SUBMITTED_SUCCESS;\n-        }\n-        return state;\n-    }\n-\n-    /**\n-     * check process instance strategy\n-     *\n-     * @param taskInstance taskInstance\n-     * @return check strategy result\n-     */\n-    private boolean checkProcessStrategy(TaskInstance taskInstance, ProcessInstance processInstance) {\n-        FailureStrategy failureStrategy = processInstance.getFailureStrategy();\n-        if (failureStrategy == FailureStrategy.CONTINUE) {\n-            return true;\n-        }\n-        List<TaskInstance> taskInstances = this.findValidTaskListByProcessId(taskInstance.getProcessInstanceId());\n-\n-        for (TaskInstance task : taskInstances) {\n-            if (task.getState() == ExecutionStatus.FAILURE\n-                    && task.getRetryTimes() >= task.getMaxRetryTimes()) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * insert or update work process instance to data base\n-     *\n-     * @param processInstance processInstance\n-     */\n-    public void saveProcessInstance(ProcessInstance processInstance) {\n-        if (processInstance == null) {\n-            logger.error(\"save error, process instance is null!\");\n-            return;\n-        }\n-        if (processInstance.getId() != 0) {\n-            processInstanceMapper.updateById(processInstance);\n-        } else {\n-            processInstanceMapper.insert(processInstance);\n-        }\n-    }\n-\n-    /**\n-     * insert or update command\n-     *\n-     * @param command command\n-     * @return save command result\n-     */\n-    public int saveCommand(Command command) {\n-        if (command.getId() != 0) {\n-            return commandMapper.updateById(command);\n-        } else {\n-            return commandMapper.insert(command);\n-        }\n-    }\n-\n-    /**\n-     * insert or update task instance\n-     *\n-     * @param taskInstance taskInstance\n-     * @return save task instance result\n-     */\n-    public boolean saveTaskInstance(TaskInstance taskInstance) {\n-        if (taskInstance.getId() != 0) {\n-            return updateTaskInstance(taskInstance);\n-        } else {\n-            return createTaskInstance(taskInstance);\n-        }\n-    }\n-\n-    /**\n-     * insert task instance\n-     *\n-     * @param taskInstance taskInstance\n-     * @return create task instance result\n-     */\n-    public boolean createTaskInstance(TaskInstance taskInstance) {\n-        int count = taskInstanceMapper.insert(taskInstance);\n-        return count > 0;\n-    }\n-\n-    /**\n-     * update task instance\n-     *\n-     * @param taskInstance taskInstance\n-     * @return update task instance result\n-     */\n-    public boolean updateTaskInstance(TaskInstance taskInstance) {\n-        int count = taskInstanceMapper.updateById(taskInstance);\n-        return count > 0;\n-    }\n-\n-    /**\n-     * find task instance by id\n-     *\n-     * @param taskId task id\n-     * @return task intance\n-     */\n-    public TaskInstance findTaskInstanceById(Integer taskId) {\n-        return taskInstanceMapper.selectById(taskId);\n-    }\n-\n-    /**\n-     * package task instance\n-     */\n-    public void packageTaskInstance(TaskInstance taskInstance, ProcessInstance processInstance) {\n-        taskInstance.setProcessInstance(processInstance);\n-        taskInstance.setProcessDefine(processInstance.getProcessDefinition());\n-        TaskDefinition taskDefinition = this.findTaskDefinition(\n-                taskInstance.getTaskCode(),\n-                taskInstance.getTaskDefinitionVersion());\n-        this.updateTaskDefinitionResources(taskDefinition);\n-        taskInstance.setTaskDefine(taskDefinition);\n-    }\n-\n-    /**\n-     * Update {@link ResourceInfo} information in {@link TaskDefinition}\n-     *\n-     * @param taskDefinition the given {@link TaskDefinition}\n-     */\n-    public void updateTaskDefinitionResources(TaskDefinition taskDefinition) {\n-        Map<String, Object> taskParameters = JSONUtils.parseObject(\n-                taskDefinition.getTaskParams(),\n-                new TypeReference<Map<String, Object>>() {\n-                });\n-        if (taskParameters != null) {\n-            // if contains mainJar field, query resource from database\n-            // Flink, Spark, MR\n-            if (taskParameters.containsKey(\"mainJar\")) {\n-                Object mainJarObj = taskParameters.get(\"mainJar\");\n-                ResourceInfo mainJar = JSONUtils.parseObject(\n-                        JSONUtils.toJsonString(mainJarObj),\n-                        ResourceInfo.class);\n-                ResourceInfo resourceInfo = updateResourceInfo(mainJar);\n-                if (resourceInfo != null) {\n-                    taskParameters.put(\"mainJar\", resourceInfo);\n-                }\n-            }\n-            // update resourceList information\n-            if (taskParameters.containsKey(\"resourceList\")) {\n-                String resourceListStr = JSONUtils.toJsonString(taskParameters.get(\"resourceList\"));\n-                List<ResourceInfo> resourceInfos = JSONUtils.toList(resourceListStr, ResourceInfo.class);\n-                List<ResourceInfo> updatedResourceInfos = resourceInfos\n-                        .stream()\n-                        .map(this::updateResourceInfo)\n-                        .filter(Objects::nonNull)\n-                        .collect(Collectors.toList());\n-                taskParameters.put(\"resourceList\", updatedResourceInfos);\n-            }\n-            // set task parameters\n-            taskDefinition.setTaskParams(JSONUtils.toJsonString(taskParameters));\n-        }\n-    }\n-\n-    /**\n-     * update {@link ResourceInfo} by given original ResourceInfo\n-     *\n-     * @param res origin resource info\n-     * @return {@link ResourceInfo}\n-     */\n-    private ResourceInfo updateResourceInfo(ResourceInfo res) {\n-        ResourceInfo resourceInfo = null;\n-        // only if mainJar is not null and does not contains \"resourceName\" field\n-        if (res != null) {\n-            int resourceId = res.getId();\n-            if (resourceId <= 0) {\n-                logger.error(\"invalid resourceId, {}\", resourceId);\n-                return null;\n-            }\n-            resourceInfo = new ResourceInfo();\n-            // get resource from database, only one resource should be returned\n-            Resource resource = getResourceById(resourceId);\n-            resourceInfo.setId(resourceId);\n-            resourceInfo.setRes(resource.getFileName());\n-            resourceInfo.setResourceName(resource.getFullName());\n-            if (logger.isInfoEnabled()) {\n-                logger.info(\"updated resource info {}\",\n-                        JSONUtils.toJsonString(resourceInfo));\n-            }\n-        }\n-        return resourceInfo;\n-    }\n-\n-    /**\n-     * get id list by task state\n-     *\n-     * @param instanceId instanceId\n-     * @param state state\n-     * @return task instance states\n-     */\n-    public List<Integer> findTaskIdByInstanceState(int instanceId, ExecutionStatus state) {\n-        return taskInstanceMapper.queryTaskByProcessIdAndState(instanceId, state.ordinal());\n-    }\n-\n-    /**\n-     * find valid task list by process definition id\n-     *\n-     * @param processInstanceId processInstanceId\n-     * @return task instance list\n-     */\n-    public List<TaskInstance> findValidTaskListByProcessId(Integer processInstanceId) {\n-        return taskInstanceMapper.findValidTaskListByProcessId(processInstanceId, Flag.YES);\n-    }\n-\n-    /**\n-     * find previous task list by work process id\n-     *\n-     * @param processInstanceId processInstanceId\n-     * @return task instance list\n-     */\n-    public List<TaskInstance> findPreviousTaskListByWorkProcessId(Integer processInstanceId) {\n-        return taskInstanceMapper.findValidTaskListByProcessId(processInstanceId, Flag.NO);\n-    }\n-\n-    /**\n-     * update work process instance map\n-     *\n-     * @param processInstanceMap processInstanceMap\n-     * @return update process instance result\n-     */\n-    public int updateWorkProcessInstanceMap(ProcessInstanceMap processInstanceMap) {\n-        return processInstanceMapMapper.updateById(processInstanceMap);\n-    }\n-\n-    /**\n-     * create work process instance map\n-     *\n-     * @param processInstanceMap processInstanceMap\n-     * @return create process instance result\n-     */\n-    public int createWorkProcessInstanceMap(ProcessInstanceMap processInstanceMap) {\n-        int count = 0;\n-        if (processInstanceMap != null) {\n-            return processInstanceMapMapper.insert(processInstanceMap);\n-        }\n-        return count;\n-    }\n-\n-    /**\n-     * find work process map by parent process id and parent task id.\n-     *\n-     * @param parentWorkProcessId parentWorkProcessId\n-     * @param parentTaskId parentTaskId\n-     * @return process instance map\n-     */\n-    public ProcessInstanceMap findWorkProcessMapByParent(Integer parentWorkProcessId, Integer parentTaskId) {\n-        return processInstanceMapMapper.queryByParentId(parentWorkProcessId, parentTaskId);\n-    }\n-\n-    /**\n-     * delete work process map by parent process id\n-     *\n-     * @param parentWorkProcessId parentWorkProcessId\n-     * @return delete process map result\n-     */\n-    public int deleteWorkProcessMapByParentId(int parentWorkProcessId) {\n-        return processInstanceMapMapper.deleteByParentProcessId(parentWorkProcessId);\n-\n-    }\n-\n-    /**\n-     * find sub process instance\n-     *\n-     * @param parentProcessId parentProcessId\n-     * @param parentTaskId parentTaskId\n-     * @return process instance\n-     */\n-    public ProcessInstance findSubProcessInstance(Integer parentProcessId, Integer parentTaskId) {\n-        ProcessInstance processInstance = null;\n-        ProcessInstanceMap processInstanceMap = processInstanceMapMapper.queryByParentId(parentProcessId, parentTaskId);\n-        if (processInstanceMap == null || processInstanceMap.getProcessInstanceId() == 0) {\n-            return processInstance;\n-        }\n-        processInstance = findProcessInstanceById(processInstanceMap.getProcessInstanceId());\n-        return processInstance;\n-    }\n-\n-    /**\n-     * find parent process instance\n-     *\n-     * @param subProcessId subProcessId\n-     * @return process instance\n-     */\n-    public ProcessInstance findParentProcessInstance(Integer subProcessId) {\n-        ProcessInstance processInstance = null;\n-        ProcessInstanceMap processInstanceMap = processInstanceMapMapper.queryBySubProcessId(subProcessId);\n-        if (processInstanceMap == null || processInstanceMap.getProcessInstanceId() == 0) {\n-            return processInstance;\n-        }\n-        processInstance = findProcessInstanceById(processInstanceMap.getParentProcessInstanceId());\n-        return processInstance;\n-    }\n-\n-    /**\n-     * change task state\n-     *\n-     * @param state state\n-     * @param startTime startTime\n-     * @param host host\n-     * @param executePath executePath\n-     * @param logPath logPath\n-     */\n-    public void changeTaskState(TaskInstance taskInstance, ExecutionStatus state, Date startTime, String host,\n-                                String executePath,\n-                                String logPath) {\n-        taskInstance.setState(state);\n-        taskInstance.setStartTime(startTime);\n-        taskInstance.setHost(host);\n-        taskInstance.setExecutePath(executePath);\n-        taskInstance.setLogPath(logPath);\n-        saveTaskInstance(taskInstance);\n-    }\n-\n-    /**\n-     * update process instance\n-     *\n-     * @param processInstance processInstance\n-     * @return update process instance result\n-     */\n-    public int updateProcessInstance(ProcessInstance processInstance) {\n-        return processInstanceMapper.updateById(processInstance);\n-    }\n-\n-    /**\n-     * change task state\n-     *\n-     * @param state state\n-     * @param endTime endTime\n-     * @param varPool varPool\n-     */\n-    public void changeTaskState(TaskInstance taskInstance, ExecutionStatus state,\n-                                Date endTime,\n-                                int processId,\n-                                String appIds,\n-                                String varPool) {\n-        taskInstance.setPid(processId);\n-        taskInstance.setAppLink(appIds);\n-        taskInstance.setState(state);\n-        taskInstance.setEndTime(endTime);\n-        taskInstance.setVarPool(varPool);\n-        changeOutParam(taskInstance);\n-        saveTaskInstance(taskInstance);\n-    }\n-\n-    /**\n-     * for show in page of taskInstance\n-     */\n-    public void changeOutParam(TaskInstance taskInstance) {\n-        if (StringUtils.isEmpty(taskInstance.getVarPool())) {\n-            return;\n-        }\n-        List<Property> properties = JSONUtils.toList(taskInstance.getVarPool(), Property.class);\n-        if (CollectionUtils.isEmpty(properties)) {\n-            return;\n-        }\n-        //if the result more than one line,just get the first .\n-        Map<String, Object> taskParams = JSONUtils.parseObject(taskInstance.getTaskParams(), new TypeReference<Map<String, Object>>() {\n-        });\n-        Object localParams = taskParams.get(LOCAL_PARAMS);\n-        if (localParams == null) {\n-            return;\n-        }\n-        List<Property> allParam = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);\n-        Map<String, String> outProperty = new HashMap<>();\n-        for (Property info : properties) {\n-            if (info.getDirect() == Direct.OUT) {\n-                outProperty.put(info.getProp(), info.getValue());\n-            }\n-        }\n-        for (Property info : allParam) {\n-            if (info.getDirect() == Direct.OUT) {\n-                String paramName = info.getProp();\n-                info.setValue(outProperty.get(paramName));\n-            }\n-        }\n-        taskParams.put(LOCAL_PARAMS, allParam);\n-        taskInstance.setTaskParams(JSONUtils.toJsonString(taskParams));\n-    }\n-\n-    /**\n-     * convert integer list to string list\n-     *\n-     * @param intList intList\n-     * @return string list\n-     */\n-    public List<String> convertIntListToString(List<Integer> intList) {\n-        if (intList == null) {\n-            return new ArrayList<>();\n-        }\n-        List<String> result = new ArrayList<>(intList.size());\n-        for (Integer intVar : intList) {\n-            result.add(String.valueOf(intVar));\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * query schedule by id\n-     *\n-     * @param id id\n-     * @return schedule\n-     */\n-    public Schedule querySchedule(int id) {\n-        return scheduleMapper.selectById(id);\n-    }\n-\n-    /**\n-     * query Schedule by processDefinitionCode\n-     *\n-     * @param processDefinitionCode processDefinitionCode\n-     * @see Schedule\n-     */\n-    public List<Schedule> queryReleaseSchedulerListByProcessDefinitionCode(long processDefinitionCode) {\n-        return scheduleMapper.queryReleaseSchedulerListByProcessDefinitionCode(processDefinitionCode);\n-    }\n-\n-    /**\n-     * query need failover process instance\n-     *\n-     * @param host host\n-     * @return process instance list\n-     */\n-    public List<ProcessInstance> queryNeedFailoverProcessInstances(String host) {\n-        return processInstanceMapper.queryByHostAndStatus(host, stateArray);\n-    }\n-\n-    /**\n-     * process need failover process instance\n-     *\n-     * @param processInstance processInstance\n-     */\n     @Transactional(rollbackFor = RuntimeException.class)\n-    public void processNeedFailoverProcessInstances(ProcessInstance processInstance) {\n-        //1 update processInstance host is null\n-        processInstance.setHost(Constants.NULL);\n-        processInstanceMapper.updateById(processInstance);\n-\n-        ProcessDefinition processDefinition = findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());\n-\n-        //2 insert into recover command\n-        Command cmd = new Command();\n-        cmd.setProcessDefinitionCode(processDefinition.getCode());\n-        cmd.setProcessDefinitionVersion(processDefinition.getVersion());\n-        cmd.setProcessInstanceId(processInstance.getId());\n-        cmd.setCommandParam(String.format(\"{\\\"%s\\\":%d}\", Constants.CMD_PARAM_RECOVER_PROCESS_ID_STRING, processInstance.getId()));\n-        cmd.setExecutorId(processInstance.getExecutorId());\n-        cmd.setCommandType(CommandType.RECOVER_TOLERANCE_FAULT_PROCESS);\n-        createCommand(cmd);\n-    }\n-\n-    /**\n-     * query all need failover task instances by host\n-     *\n-     * @param host host\n-     * @return task instance list\n-     */\n-    public List<TaskInstance> queryNeedFailoverTaskInstances(String host) {\n-        return taskInstanceMapper.queryByHostAndStatus(host,\n-                stateArray);\n-    }\n-\n-    /**\n-     * find data source by id\n-     *\n-     * @param id id\n-     * @return datasource\n-     */\n-    public DataSource findDataSourceById(int id) {\n-        return dataSourceMapper.selectById(id);\n-    }\n-\n-    /**\n-     * update process instance state by id\n-     *\n-     * @param processInstanceId processInstanceId\n-     * @param executionStatus executionStatus\n-     * @return update process result\n-     */\n-    public int updateProcessInstanceState(Integer processInstanceId, ExecutionStatus executionStatus) {\n-        ProcessInstance instance = processInstanceMapper.selectById(processInstanceId);\n-        instance.setState(executionStatus);\n-        return processInstanceMapper.updateById(instance);\n-    }\n-\n-    /**\n-     * find process instance by the task id\n-     *\n-     * @param taskId taskId\n-     * @return process instance\n-     */\n-    public ProcessInstance findProcessInstanceByTaskId(int taskId) {\n-        TaskInstance taskInstance = taskInstanceMapper.selectById(taskId);\n-        if (taskInstance != null) {\n-            return processInstanceMapper.selectById(taskInstance.getProcessInstanceId());\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * find udf function list by id list string\n-     *\n-     * @param ids ids\n-     * @return udf function list\n-     */\n-    public List<UdfFunc> queryUdfFunListByIds(int[] ids) {\n-        return udfFuncMapper.queryUdfByIdStr(ids, null);\n-    }\n-\n-    /**\n-     * find tenant code by resource name\n-     *\n-     * @param resName resource name\n-     * @param resourceType resource type\n-     * @return tenant code\n-     */\n-    public String queryTenantCodeByResName(String resName, ResourceType resourceType) {\n-        // in order to query tenant code successful although the version is older\n-        String fullName = resName.startsWith(\"/\") ? resName : String.format(\"/%s\", resName);\n-\n-        List<Resource> resourceList = resourceMapper.queryResource(fullName, resourceType.ordinal());\n-        if (CollectionUtils.isEmpty(resourceList)) {\n-            return StringUtils.EMPTY;\n-        }\n-        int userId = resourceList.get(0).getUserId();\n-        User user = userMapper.selectById(userId);\n-        if (Objects.isNull(user)) {\n-            return StringUtils.EMPTY;\n-        }\n-        Tenant tenant = tenantMapper.queryById(user.getTenantId());\n-        if (Objects.isNull(tenant)) {\n-            return StringUtils.EMPTY;\n-        }\n-        return tenant.getTenantCode();\n-    }\n-\n-    /**\n-     * find schedule list by process define codes.\n-     *\n-     * @param codes codes\n-     * @return schedule list\n-     */\n-    public List<Schedule> selectAllByProcessDefineCode(long[] codes) {\n-        return scheduleMapper.selectAllByProcessDefineArray(codes);\n-    }\n-\n-    /**\n-     * find last scheduler process instance in the date interval\n-     *\n-     * @param definitionCode definitionCode\n-     * @param dateInterval dateInterval\n-     * @return process instance\n-     */\n-    public ProcessInstance findLastSchedulerProcessInterval(Long definitionCode, DateInterval dateInterval) {\n-        return processInstanceMapper.queryLastSchedulerProcess(definitionCode,\n-                dateInterval.getStartTime(),\n-                dateInterval.getEndTime());\n-    }\n-\n-    /**\n-     * find last manual process instance interval\n-     *\n-     * @param definitionCode process definition code\n-     * @param dateInterval dateInterval\n-     * @return process instance\n-     */\n-    public ProcessInstance findLastManualProcessInterval(Long definitionCode, DateInterval dateInterval) {\n-        return processInstanceMapper.queryLastManualProcess(definitionCode,\n-                dateInterval.getStartTime(),\n-                dateInterval.getEndTime());\n-    }\n-\n-    /**\n-     * find last running process instance\n-     *\n-     * @param definitionCode process definition code\n-     * @param startTime start time\n-     * @param endTime end time\n-     * @return process instance\n-     */\n-    public ProcessInstance findLastRunningProcess(Long definitionCode, Date startTime, Date endTime) {\n-        return processInstanceMapper.queryLastRunningProcess(definitionCode,\n-                startTime,\n-                endTime,\n-                stateArray);\n-    }\n-\n-    /**\n-     * query user queue by process instance\n-     *\n-     * @param processInstance processInstance\n-     * @return queue\n-     */\n-    public String queryUserQueueByProcessInstance(ProcessInstance processInstance) {\n-\n-        String queue = \"\";\n-        if (processInstance == null) {\n-            return queue;\n-        }\n-        User executor = userMapper.selectById(processInstance.getExecutorId());\n-        if (executor != null) {\n-            queue = executor.getQueue();\n-        }\n-        return queue;\n-    }\n-\n-    /**\n-     * query project name and user name by processInstanceId.\n-     *\n-     * @param processInstanceId processInstanceId\n-     * @return projectName and userName\n-     */\n-    public ProjectUser queryProjectWithUserByProcessInstanceId(int processInstanceId) {\n-        return projectMapper.queryProjectWithUserByProcessInstanceId(processInstanceId);\n-    }\n-\n-    /**\n-     * get task worker group\n-     *\n-     * @param taskInstance taskInstance\n-     * @return workerGroupId\n-     */\n-    public String getTaskWorkerGroup(TaskInstance taskInstance) {\n-        String workerGroup = taskInstance.getWorkerGroup();\n-\n-        if (StringUtils.isNotBlank(workerGroup)) {\n-            return workerGroup;\n-        }\n-        int processInstanceId = taskInstance.getProcessInstanceId();\n-        ProcessInstance processInstance = findProcessInstanceById(processInstanceId);\n-\n-        if (processInstance != null) {\n-            return processInstance.getWorkerGroup();\n-        }\n-        logger.info(\"task : {} will use default worker group\", taskInstance.getId());\n-        return Constants.DEFAULT_WORKER_GROUP;\n-    }\n-\n-    /**\n-     * get have perm project list\n-     *\n-     * @param userId userId\n-     * @return project list\n-     */\n-    public List<Project> getProjectListHavePerm(int userId) {\n-        List<Project> createProjects = projectMapper.queryProjectCreatedByUser(userId);\n-        List<Project> authedProjects = projectMapper.queryAuthedProjectListByUserId(userId);\n-\n-        if (createProjects == null) {\n-            createProjects = new ArrayList<>();\n-        }\n-\n-        if (authedProjects != null) {\n-            createProjects.addAll(authedProjects);\n-        }\n-        return createProjects;\n-    }\n-\n-    /**\n-     * list unauthorized udf function\n-     *\n-     * @param userId user id\n-     * @param needChecks data source id array\n-     * @return unauthorized udf function list\n-     */\n-    public <T> List<T> listUnauthorized(int userId, T[] needChecks, AuthorizationType authorizationType) {\n-        List<T> resultList = new ArrayList<>();\n-\n-        if (Objects.nonNull(needChecks) && needChecks.length > 0) {\n-            Set<T> originResSet = new HashSet<>(Arrays.asList(needChecks));\n-\n-            switch (authorizationType) {\n-                case RESOURCE_FILE_ID:\n-                case UDF_FILE:\n-                    List<Resource> ownUdfResources = resourceMapper.listAuthorizedResourceById(userId, needChecks);\n-                    addAuthorizedResources(ownUdfResources, userId);\n-                    Set<Integer> authorizedResourceFiles = ownUdfResources.stream().map(Resource::getId).collect(toSet());\n-                    originResSet.removeAll(authorizedResourceFiles);\n-                    break;\n-                case RESOURCE_FILE_NAME:\n-                    List<Resource> ownResources = resourceMapper.listAuthorizedResource(userId, needChecks);\n-                    addAuthorizedResources(ownResources, userId);\n-                    Set<String> authorizedResources = ownResources.stream().map(Resource::getFullName).collect(toSet());\n-                    originResSet.removeAll(authorizedResources);\n-                    break;\n-                case DATASOURCE:\n-                    Set<Integer> authorizedDatasources = dataSourceMapper.listAuthorizedDataSource(userId, needChecks).stream().map(DataSource::getId).collect(toSet());\n-                    originResSet.removeAll(authorizedDatasources);\n-                    break;\n-                case UDF:\n-                    Set<Integer> authorizedUdfs = udfFuncMapper.listAuthorizedUdfFunc(userId, needChecks).stream().map(UdfFunc::getId).collect(toSet());\n-                    originResSet.removeAll(authorizedUdfs);\n-                    break;\n-                default:\n-                    break;\n-            }\n-\n-            resultList.addAll(originResSet);\n-        }\n-\n-        return resultList;\n-    }\n-\n-    /**\n-     * get user by user id\n-     *\n-     * @param userId user id\n-     * @return User\n-     */\n-    public User getUserById(int userId) {\n-        return userMapper.selectById(userId);\n-    }\n-\n-    /**\n-     * get resource by resource id\n-     *\n-     * @param resourceId resource id\n-     * @return Resource\n-     */\n-    public Resource getResourceById(int resourceId) {\n-        return resourceMapper.selectById(resourceId);\n-    }\n-\n-    /**\n-     * list resources by ids\n-     *\n-     * @param resIds resIds\n-     * @return resource list\n-     */\n-    public List<Resource> listResourceByIds(Integer[] resIds) {\n-        return resourceMapper.listResourceByIds(resIds);\n-    }\n-\n-    /**\n-     * format task app id in task instance\n-     */\n-    public String formatTaskAppId(TaskInstance taskInstance) {\n-        ProcessInstance processInstance = findProcessInstanceById(taskInstance.getProcessInstanceId());\n-        if (processInstance == null) {\n-            return \"\";\n-        }\n-        ProcessDefinition definition = findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());\n-        if (definition == null) {\n-            return \"\";\n-        }\n-        return String.format(\"%s_%s_%s\", definition.getId(), processInstance.getId(), taskInstance.getId());\n-    }\n-\n-    /**\n-     * switch process definition version to process definition log version\n-     */\n-    public int switchVersion(ProcessDefinition processDefinition, ProcessDefinitionLog processDefinitionLog) {\n-        if (null == processDefinition || null == processDefinitionLog) {\n-            return Constants.DEFINITION_FAILURE;\n-        }\n-        processDefinitionLog.setId(processDefinition.getId());\n-        processDefinitionLog.setReleaseState(ReleaseState.OFFLINE);\n-        processDefinitionLog.setFlag(Flag.YES);\n-\n-        int result = processDefineMapper.updateById(processDefinitionLog);\n-        if (result > 0) {\n-            result = switchProcessTaskRelationVersion(processDefinitionLog);\n-            if (result <= 0) {\n-                return Constants.DEFINITION_FAILURE;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    public int switchProcessTaskRelationVersion(ProcessDefinition processDefinition) {\n-        List<ProcessTaskRelation> processTaskRelationList = processTaskRelationMapper.queryByProcessCode(processDefinition.getProjectCode(), processDefinition.getCode());\n-        if (!processTaskRelationList.isEmpty()) {\n-            processTaskRelationMapper.deleteByCode(processDefinition.getProjectCode(), processDefinition.getCode());\n-        }\n-        List<ProcessTaskRelationLog> processTaskRelationLogList = processTaskRelationLogMapper.queryByProcessCodeAndVersion(processDefinition.getCode(), processDefinition.getVersion());\n-        return processTaskRelationMapper.batchInsert(processTaskRelationLogList);\n-    }\n-\n-    /**\n-     * get resource ids\n-     *\n-     * @param taskDefinition taskDefinition\n-     * @return resource ids\n-     */\n-    public String getResourceIds(TaskDefinition taskDefinition) {\n-        Set<Integer> resourceIds = null;\n-        AbstractParameters params = TaskParametersUtils.getParameters(taskDefinition.getTaskType(), taskDefinition.getTaskParams());\n-        if (params != null && CollectionUtils.isNotEmpty(params.getResourceFilesList())) {\n-            resourceIds = params.getResourceFilesList().\n-                    stream()\n-                    .filter(t -> t.getId() != 0)\n-                    .map(ResourceInfo::getId)\n-                    .collect(Collectors.toSet());\n-        }\n-        if (CollectionUtils.isEmpty(resourceIds)) {\n-            return StringUtils.EMPTY;\n-        }\n-        return StringUtils.join(resourceIds, \",\");\n-    }\n-\n-    public int saveTaskDefine(User operator, long projectCode, List<TaskDefinitionLog> taskDefinitionLogs) {\n-        Date now = new Date();\n-        List<TaskDefinitionLog> newTaskDefinitionLogs = new ArrayList<>();\n-        List<TaskDefinitionLog> updateTaskDefinitionLogs = new ArrayList<>();\n-        for (TaskDefinitionLog taskDefinitionLog : taskDefinitionLogs) {\n-            taskDefinitionLog.setProjectCode(projectCode);\n-            taskDefinitionLog.setUpdateTime(now);\n-            taskDefinitionLog.setOperateTime(now);\n-            taskDefinitionLog.setOperator(operator.getId());\n-            taskDefinitionLog.setResourceIds(getResourceIds(taskDefinitionLog));\n-            if (taskDefinitionLog.getCode() > 0 && taskDefinitionLog.getVersion() > 0) {\n-                TaskDefinitionLog definitionCodeAndVersion = taskDefinitionLogMapper\n-                        .queryByDefinitionCodeAndVersion(taskDefinitionLog.getCode(), taskDefinitionLog.getVersion());\n-                if (definitionCodeAndVersion != null) {\n-                    if (!taskDefinitionLog.equals(definitionCodeAndVersion)) {\n-                        taskDefinitionLog.setUserId(definitionCodeAndVersion.getUserId());\n-                        Integer version = taskDefinitionLogMapper.queryMaxVersionForDefinition(taskDefinitionLog.getCode());\n-                        taskDefinitionLog.setVersion(version + 1);\n-                        taskDefinitionLog.setCreateTime(definitionCodeAndVersion.getCreateTime());\n-                        updateTaskDefinitionLogs.add(taskDefinitionLog);\n-                    }\n-                    continue;\n-                }\n-            }\n-            taskDefinitionLog.setUserId(operator.getId());\n-            taskDefinitionLog.setVersion(Constants.VERSION_FIRST);\n-            taskDefinitionLog.setCreateTime(now);\n-            if (taskDefinitionLog.getCode() == 0) {\n-                try {\n-                    taskDefinitionLog.setCode(CodeGenerateUtils.getInstance().genCode());\n-                } catch (CodeGenerateException e) {\n-                    logger.error(\"Task code get error, \", e);\n-                    return Constants.DEFINITION_FAILURE;\n-                }\n-            }\n-            newTaskDefinitionLogs.add(taskDefinitionLog);\n-        }\n-        int insertResult = 0;\n-        int updateResult = 0;\n-        for (TaskDefinitionLog taskDefinitionToUpdate : updateTaskDefinitionLogs) {\n-            TaskDefinition task = taskDefinitionMapper.queryByCode(taskDefinitionToUpdate.getCode());\n-            if (task == null) {\n-                newTaskDefinitionLogs.add(taskDefinitionToUpdate);\n-            } else {\n-                insertResult += taskDefinitionLogMapper.insert(taskDefinitionToUpdate);\n-                taskDefinitionToUpdate.setId(task.getId());\n-                updateResult += taskDefinitionMapper.updateById(taskDefinitionToUpdate);\n-            }\n-        }\n-        if (!newTaskDefinitionLogs.isEmpty()) {\n-            updateResult += taskDefinitionMapper.batchInsert(newTaskDefinitionLogs);\n-            insertResult += taskDefinitionLogMapper.batchInsert(newTaskDefinitionLogs);\n-        }\n-        return (insertResult & updateResult) > 0 ? 1 : Constants.EXIT_CODE_SUCCESS;\n-    }\n-\n-    /**\n-     * save processDefinition (including create or update processDefinition)\n-     */\n-    public int saveProcessDefine(User operator, ProcessDefinition processDefinition, Boolean isFromProcessDefine) {\n-        ProcessDefinitionLog processDefinitionLog = new ProcessDefinitionLog(processDefinition);\n-        Integer version = processDefineLogMapper.queryMaxVersionForDefinition(processDefinition.getCode());\n-        int insertVersion = version == null || version == 0 ? Constants.VERSION_FIRST : version + 1;\n-        processDefinitionLog.setVersion(insertVersion);\n-        processDefinitionLog.setReleaseState(isFromProcessDefine ? ReleaseState.OFFLINE : ReleaseState.ONLINE);\n-        processDefinitionLog.setOperator(operator.getId());\n-        processDefinitionLog.setOperateTime(processDefinition.getUpdateTime());\n-        int insertLog = processDefineLogMapper.insert(processDefinitionLog);\n-        int result;\n-        if (0 == processDefinition.getId()) {\n-            result = processDefineMapper.insert(processDefinitionLog);\n-        } else {\n-            processDefinitionLog.setId(processDefinition.getId());\n-            result = processDefineMapper.updateById(processDefinitionLog);\n-        }\n-        return (insertLog & result) > 0 ? insertVersion : 0;\n-    }\n-\n-    /**\n-     * save task relations\n-     */\n-    public int saveTaskRelation(User operator, long projectCode, long processDefinitionCode, int processDefinitionVersion,\n-                                List<ProcessTaskRelationLog> taskRelationList, List<TaskDefinitionLog> taskDefinitionLogs) {\n-        if (taskRelationList.isEmpty()) {\n-            return Constants.EXIT_CODE_SUCCESS;\n-        }\n-        Map<Long, TaskDefinitionLog> taskDefinitionLogMap = null;\n-        if (CollectionUtils.isNotEmpty(taskDefinitionLogs)) {\n-            taskDefinitionLogMap = taskDefinitionLogs.stream()\n-                    .collect(Collectors.toMap(TaskDefinition::getCode, taskDefinitionLog -> taskDefinitionLog));\n-        }\n-        Date now = new Date();\n-        for (ProcessTaskRelationLog processTaskRelationLog : taskRelationList) {\n-            processTaskRelationLog.setProjectCode(projectCode);\n-            processTaskRelationLog.setProcessDefinitionCode(processDefinitionCode);\n-            processTaskRelationLog.setProcessDefinitionVersion(processDefinitionVersion);\n-            if (taskDefinitionLogMap != null) {\n-                TaskDefinitionLog taskDefinitionLog = taskDefinitionLogMap.get(processTaskRelationLog.getPreTaskCode());\n-                if (taskDefinitionLog != null) {\n-                    processTaskRelationLog.setPreTaskVersion(taskDefinitionLog.getVersion());\n-                }\n-                processTaskRelationLog.setPostTaskVersion(taskDefinitionLogMap.get(processTaskRelationLog.getPostTaskCode()).getVersion());\n-            }\n-            processTaskRelationLog.setCreateTime(now);\n-            processTaskRelationLog.setUpdateTime(now);\n-            processTaskRelationLog.setOperator(operator.getId());\n-            processTaskRelationLog.setOperateTime(now);\n-        }\n-        List<ProcessTaskRelation> processTaskRelationList = processTaskRelationMapper.queryByProcessCode(projectCode, processDefinitionCode);\n-        if (!processTaskRelationList.isEmpty()) {\n-            Set<Integer> processTaskRelationSet = processTaskRelationList.stream().map(ProcessTaskRelation::hashCode).collect(toSet());\n-            Set<Integer> taskRelationSet = taskRelationList.stream().map(ProcessTaskRelationLog::hashCode).collect(toSet());\n-            boolean result = CollectionUtils.isEqualCollection(processTaskRelationSet, taskRelationSet);\n-            if (result) {\n-                return Constants.EXIT_CODE_SUCCESS;\n-            }\n-            processTaskRelationMapper.deleteByCode(projectCode, processDefinitionCode);\n-        }\n-        int result = processTaskRelationMapper.batchInsert(taskRelationList);\n-        int resultLog = processTaskRelationLogMapper.batchInsert(taskRelationList);\n-        return (result & resultLog) > 0 ? Constants.EXIT_CODE_SUCCESS : Constants.EXIT_CODE_FAILURE;\n-    }\n-\n-    public boolean isTaskOnline(long taskCode) {\n-        List<ProcessTaskRelation> processTaskRelationList = processTaskRelationMapper.queryByTaskCode(taskCode);\n-        if (!processTaskRelationList.isEmpty()) {\n-            Set<Long> processDefinitionCodes = processTaskRelationList\n-                    .stream()\n-                    .map(ProcessTaskRelation::getProcessDefinitionCode)\n-                    .collect(Collectors.toSet());\n-            List<ProcessDefinition> processDefinitionList = processDefineMapper.queryByCodes(processDefinitionCodes);\n-            // check process definition is already online\n-            for (ProcessDefinition processDefinition : processDefinitionList) {\n-                if (processDefinition.getReleaseState() == ReleaseState.ONLINE) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Generate the DAG Graph based on the process definition id\n-     *\n-     * @param processDefinition process definition\n-     * @return dag graph\n-     */\n-    public DAG<String, TaskNode, TaskNodeRelation> genDagGraph(ProcessDefinition processDefinition) {\n-        List<ProcessTaskRelation> processTaskRelations = processTaskRelationMapper.queryByProcessCode(processDefinition.getProjectCode(), processDefinition.getCode());\n-        List<TaskNode> taskNodeList = transformTask(processTaskRelations, Lists.newArrayList());\n-        ProcessDag processDag = DagHelper.getProcessDag(taskNodeList, new ArrayList<>(processTaskRelations));\n-        // Generate concrete Dag to be executed\n-        return DagHelper.buildDagGraph(processDag);\n-    }\n-\n-    /**\n-     * generate DagData\n-     */\n-    public DagData genDagData(ProcessDefinition processDefinition) {\n-        List<ProcessTaskRelation> processTaskRelations = processTaskRelationMapper.queryByProcessCode(processDefinition.getProjectCode(), processDefinition.getCode());\n-        List<TaskDefinitionLog> taskDefinitionLogList = genTaskDefineList(processTaskRelations);\n-        List<TaskDefinition> taskDefinitions = taskDefinitionLogList.stream()\n-                .map(taskDefinitionLog -> JSONUtils.parseObject(JSONUtils.toJsonString(taskDefinitionLog), TaskDefinition.class))\n-                .collect(Collectors.toList());\n-        return new DagData(processDefinition, processTaskRelations, taskDefinitions);\n-    }\n-\n-    public List<TaskDefinitionLog> genTaskDefineList(List<ProcessTaskRelation> processTaskRelations) {\n-        Set<TaskDefinition> taskDefinitionSet = new HashSet<>();\n-        for (ProcessTaskRelation processTaskRelation : processTaskRelations) {\n-            if (processTaskRelation.getPreTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPreTaskCode(), processTaskRelation.getPreTaskVersion()));\n-            }\n-            if (processTaskRelation.getPostTaskCode() > 0) {\n-                taskDefinitionSet.add(new TaskDefinition(processTaskRelation.getPostTaskCode(), processTaskRelation.getPostTaskVersion()));\n-            }\n-        }\n-        if (taskDefinitionSet.isEmpty()) {\n-            return Lists.newArrayList();\n-        }\n-        return taskDefinitionLogMapper.queryByTaskDefinitions(taskDefinitionSet);\n-    }\n-\n-    /**\n-     * find task definition by code and version\n-     */\n-    public TaskDefinition findTaskDefinition(long taskCode, int taskDefinitionVersion) {\n-        return taskDefinitionLogMapper.queryByDefinitionCodeAndVersion(taskCode, taskDefinitionVersion);\n-    }\n-\n-    /**\n-     * find process task relation list by projectCode and processDefinitionCode\n-     */\n-    public List<ProcessTaskRelation> findRelationByCode(long projectCode, long processDefinitionCode) {\n-        return processTaskRelationMapper.queryByProcessCode(projectCode, processDefinitionCode);\n-    }\n-\n-    /**\n-     * add authorized resources\n-     *\n-     * @param ownResources own resources\n-     * @param userId userId\n-     */\n-    private void addAuthorizedResources(List<Resource> ownResources, int userId) {\n-        List<Integer> relationResourceIds = resourceUserMapper.queryResourcesIdListByUserIdAndPerm(userId, 7);\n-        List<Resource> relationResources = CollectionUtils.isNotEmpty(relationResourceIds) ? resourceMapper.queryResourceListById(relationResourceIds) : new ArrayList<>();\n-        ownResources.addAll(relationResources);\n-    }\n-\n-    /**\n-     * Use temporarily before refactoring taskNode\n-     */\n-    public List<TaskNode> transformTask(List<ProcessTaskRelation> taskRelationList, List<TaskDefinitionLog> taskDefinitionLogs) {\n-        Map<Long, List<Long>> taskCodeMap = new HashMap<>();\n-        for (ProcessTaskRelation processTaskRelation : taskRelationList) {\n-            taskCodeMap.compute(processTaskRelation.getPostTaskCode(), (k, v) -> {\n-                if (v == null) {\n-                    v = new ArrayList<>();\n-                }\n-                if (processTaskRelation.getPreTaskCode() != 0L) {\n-                    v.add(processTaskRelation.getPreTaskCode());\n-                }\n-                return v;\n-            });\n-        }\n-        if (CollectionUtils.isEmpty(taskDefinitionLogs)) {\n-            taskDefinitionLogs = genTaskDefineList(taskRelationList);\n-        }\n-        Map<Long, TaskDefinitionLog> taskDefinitionLogMap = taskDefinitionLogs.stream()\n-                .collect(Collectors.toMap(TaskDefinitionLog::getCode, taskDefinitionLog -> taskDefinitionLog));\n-        List<TaskNode> taskNodeList = new ArrayList<>();\n-        for (Entry<Long, List<Long>> code : taskCodeMap.entrySet()) {\n-            TaskDefinitionLog taskDefinitionLog = taskDefinitionLogMap.get(code.getKey());\n-            if (taskDefinitionLog != null) {\n-                TaskNode taskNode = new TaskNode();\n-                taskNode.setCode(taskDefinitionLog.getCode());\n-                taskNode.setVersion(taskDefinitionLog.getVersion());\n-                taskNode.setName(taskDefinitionLog.getName());\n-                taskNode.setDesc(taskDefinitionLog.getDescription());\n-                taskNode.setType(taskDefinitionLog.getTaskType().toUpperCase());\n-                taskNode.setRunFlag(taskDefinitionLog.getFlag() == Flag.YES ? Constants.FLOWNODE_RUN_FLAG_NORMAL : Constants.FLOWNODE_RUN_FLAG_FORBIDDEN);\n-                taskNode.setMaxRetryTimes(taskDefinitionLog.getFailRetryTimes());\n-                taskNode.setRetryInterval(taskDefinitionLog.getFailRetryInterval());\n-                Map<String, Object> taskParamsMap = taskNode.taskParamsToJsonObj(taskDefinitionLog.getTaskParams());\n-                taskNode.setConditionResult(JSONUtils.toJsonString(taskParamsMap.get(Constants.CONDITION_RESULT)));\n-                taskNode.setSwitchResult(JSONUtils.toJsonString(taskParamsMap.get(Constants.SWITCH_RESULT)));\n-                taskNode.setDependence(JSONUtils.toJsonString(taskParamsMap.get(Constants.DEPENDENCE)));\n-                taskParamsMap.remove(Constants.CONDITION_RESULT);\n-                taskParamsMap.remove(Constants.DEPENDENCE);\n-                taskNode.setParams(JSONUtils.toJsonString(taskParamsMap));\n-                taskNode.setTaskInstancePriority(taskDefinitionLog.getTaskPriority());\n-                taskNode.setWorkerGroup(taskDefinitionLog.getWorkerGroup());\n-                taskNode.setEnvironmentCode(taskDefinitionLog.getEnvironmentCode());\n-                taskNode.setTimeout(JSONUtils.toJsonString(new TaskTimeoutParameter(taskDefinitionLog.getTimeoutFlag() == TimeoutFlag.OPEN,\n-                        taskDefinitionLog.getTimeoutNotifyStrategy(),\n-                        taskDefinitionLog.getTimeout())));\n-                taskNode.setDelayTime(taskDefinitionLog.getDelayTime());\n-                taskNode.setPreTasks(JSONUtils.toJsonString(code.getValue().stream().map(taskDefinitionLogMap::get).map(TaskDefinition::getCode).collect(Collectors.toList())));\n-                taskNodeList.add(taskNode);\n-            }\n-        }\n-        return taskNodeList;\n-    }\n-\n-    public Map<ProcessInstance, TaskInstance> notifyProcessList(int processId, int taskId) {\n-        HashMap<ProcessInstance, TaskInstance> processTaskMap = new HashMap<>();\n-        //find sub tasks\n-        ProcessInstanceMap processInstanceMap = processInstanceMapMapper.queryBySubProcessId(processId);\n-        if (processInstanceMap == null) {\n-            return processTaskMap;\n-        }\n-        ProcessInstance fatherProcess = this.findProcessInstanceById(processInstanceMap.getParentProcessInstanceId());\n-        TaskInstance fatherTask = this.findTaskInstanceById(processInstanceMap.getParentTaskInstanceId());\n-\n-        if (fatherProcess != null) {\n-            processTaskMap.put(fatherProcess, fatherTask);\n-        }\n-        return processTaskMap;\n-    }\n-\n-    /**\n-     * the first time (when submit the task ) get the resource of the task group\n-     * @param taskId    task id\n-     * @param taskName\n-     * @param groupId\n-     * @param processId\n-     * @param priority\n-     * @return\n-     */\n-    public boolean acquireTaskGroup(int taskId,\n-                                    String taskName, int groupId,\n-                                    int processId, int priority) {\n-        TaskGroup taskGroup = taskGroupMapper.selectById(groupId);\n-        if (taskGroup == null) {\n-            return true;\n-        }\n-        // if task group is not applicable\n-        if (taskGroup.getStatus() == Flag.NO.getCode()) {\n-            return true;\n-        }\n-        TaskGroupQueue taskGroupQueue = this.taskGroupQueueMapper.queryByTaskId(taskId);\n-        if (taskGroupQueue == null) {\n-            taskGroupQueue = insertIntoTaskGroupQueue(taskId, taskName, groupId, processId, priority, TaskGroupQueueStatus.WAIT_QUEUE);\n-        } else {\n-            if (taskGroupQueue.getStatus() == TaskGroupQueueStatus.ACQUIRE_SUCCESS) {\n-                return true;\n-            }\n-            taskGroupQueue.setInQueue(Flag.NO.getCode());\n-            taskGroupQueue.setStatus(TaskGroupQueueStatus.WAIT_QUEUE);\n-            this.taskGroupQueueMapper.updateById(taskGroupQueue);\n-        }\n-        //check priority\n-        List<TaskGroupQueue> highPriorityTasks = taskGroupQueueMapper.queryHighPriorityTasks(groupId, priority, TaskGroupQueueStatus.WAIT_QUEUE.getCode());\n-        if (CollectionUtils.isNotEmpty(highPriorityTasks)) {\n-            this.taskGroupQueueMapper.updateInQueue(Flag.NO.getCode(), taskGroupQueue.getId());\n-            return false;\n-        }\n-        //try to get taskGroup\n-        int count = taskGroupMapper.selectAvailableCountById(groupId);\n-        if (count == 1 && robTaskGroupResouce(taskGroupQueue)) {\n-            return true;\n-        }\n-        this.taskGroupQueueMapper.updateInQueue(Flag.NO.getCode(), taskGroupQueue.getId());\n-        return false;\n-    }\n-\n-    /**\n-     *  try to get the task group resource(when other task release the resource)\n-     * @param taskGroupQueue\n-     * @return\n-     */\n-    public boolean robTaskGroupResouce(TaskGroupQueue taskGroupQueue) {\n-        TaskGroup taskGroup = taskGroupMapper.selectById(taskGroupQueue.getGroupId());\n-        int affectedCount = taskGroupMapper.updateTaskGroupResource(taskGroup.getId(),taskGroupQueue.getId(),\n-                TaskGroupQueueStatus.WAIT_QUEUE.getCode());\n-        if (affectedCount > 0) {\n-            taskGroupQueue.setStatus(TaskGroupQueueStatus.ACQUIRE_SUCCESS);\n-            this.taskGroupQueueMapper.updateById(taskGroupQueue);\n-            this.taskGroupQueueMapper.updateInQueue(Flag.NO.getCode(), taskGroupQueue.getId());\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public boolean acquireTaskGroupAgain(TaskGroupQueue taskGroupQueue) {\n-        return robTaskGroupResouce(taskGroupQueue);\n-    }\n-\n-    public void releaseAllTaskGroup(int processInstanceId) {\n-        List<TaskInstance> taskInstances = this.taskInstanceMapper.loadAllInfosNoRelease(processInstanceId, TaskGroupQueueStatus.ACQUIRE_SUCCESS.getCode());\n-        for (TaskInstance info : taskInstances) {\n-            releaseTaskGroup(info);\n-        }\n-    }\n-\n-    /**\n-     * release the TGQ resource when the corresponding task is finished.\n-     *\n-     * @return the result code and msg\n-     */\n-    public TaskInstance releaseTaskGroup(TaskInstance taskInstance) {\n-\n-        TaskGroup taskGroup = taskGroupMapper.selectById(taskInstance.getTaskGroupId());\n-        if (taskGroup == null) {\n-            return null;\n-        }\n-        TaskGroupQueue thisTaskGroupQueue = this.taskGroupQueueMapper.queryByTaskId(taskInstance.getId());\n-        if (thisTaskGroupQueue.getStatus() == TaskGroupQueueStatus.RELEASE) {\n-            return null;\n-        }\n-        try {\n-            while (taskGroupMapper.releaseTaskGroupResource(taskGroup.getId(), taskGroup.getUseSize()\n-                    , thisTaskGroupQueue.getId(), TaskGroupQueueStatus.ACQUIRE_SUCCESS.getCode()) != 1) {\n-                thisTaskGroupQueue = this.taskGroupQueueMapper.queryByTaskId(taskInstance.getId());\n-                if (thisTaskGroupQueue.getStatus() == TaskGroupQueueStatus.RELEASE) {\n-                    return null;\n-                }\n-                taskGroup = taskGroupMapper.selectById(taskInstance.getTaskGroupId());\n-            }\n-        } catch (Exception e) {\n-            logger.error(\"release the task group error\",e);\n-        }\n-        logger.info(\"updateTask:{}\",taskInstance.getName());\n-        changeTaskGroupQueueStatus(taskInstance.getId(), TaskGroupQueueStatus.RELEASE);\n-        TaskGroupQueue taskGroupQueue = this.taskGroupQueueMapper.queryTheHighestPriorityTasks(taskGroup.getId(),\n-                TaskGroupQueueStatus.WAIT_QUEUE.getCode(), Flag.NO.getCode(), Flag.NO.getCode());\n-        if (taskGroupQueue == null) {\n-            return null;\n-        }\n-        while (this.taskGroupQueueMapper.updateInQueueCAS(Flag.NO.getCode(), Flag.YES.getCode(), taskGroupQueue.getId()) != 1) {\n-            taskGroupQueue = this.taskGroupQueueMapper.queryTheHighestPriorityTasks(taskGroup.getId(),\n-                    TaskGroupQueueStatus.WAIT_QUEUE.getCode(), Flag.NO.getCode(), Flag.NO.getCode());\n-            if (taskGroupQueue == null) {\n-                return null;\n-            }\n-        }\n-        return this.taskInstanceMapper.selectById(taskGroupQueue.getTaskId());\n-    }\n-\n-    /**\n-     * release the TGQ resource when the corresponding task is finished.\n-     *\n-     * @param taskId task id\n-     * @return the result code and msg\n-     */\n-\n-    public void changeTaskGroupQueueStatus(int taskId, TaskGroupQueueStatus status) {\n-        TaskGroupQueue taskGroupQueue = taskGroupQueueMapper.queryByTaskId(taskId);\n-        taskGroupQueue.setStatus(status);\n-        taskGroupQueue.setUpdateTime(new Date(System.currentTimeMillis()));\n-        taskGroupQueueMapper.updateById(taskGroupQueue);\n-    }\n-\n-    /**\n-     * insert into task group queue\n-     *\n-     * @param taskId    task id\n-     * @param taskName  task name\n-     * @param groupId   group id\n-     * @param processId process id\n-     * @param priority  priority\n-     * @return result and msg code\n-     */\n-    public TaskGroupQueue insertIntoTaskGroupQueue(Integer taskId,\n-                                                   String taskName, Integer groupId,\n-                                                   Integer processId, Integer priority, TaskGroupQueueStatus status) {\n-        TaskGroupQueue taskGroupQueue = new TaskGroupQueue(taskId, taskName, groupId, processId, priority, status);\n-        taskGroupQueueMapper.insert(taskGroupQueue);\n-        return taskGroupQueue;\n-    }\n-\n-    public int updateTaskGroupQueueStatus(Integer taskId, int status) {\n-        return taskGroupQueueMapper.updateStatusByTaskId(taskId, status);\n-    }\n-\n-    public int updateTaskGroupQueue(TaskGroupQueue taskGroupQueue) {\n-        return taskGroupQueueMapper.updateById(taskGroupQueue);\n-    }\n-\n-    public TaskGroupQueue loadTaskGroupQueue(int taskId) {\n-        return this.taskGroupQueueMapper.queryByTaskId(taskId);\n-    }\n-\n-    public void sendStartTask2Master(ProcessInstance processInstance,int taskId,\n-                                     org.apache.dolphinscheduler.remote.command.CommandType taskType) {\n-        String host = processInstance.getHost();\n-        String address = host.split(\":\")[0];\n-        int port = Integer.parseInt(host.split(\":\")[1]);\n-        TaskEventChangeCommand taskEventChangeCommand = new TaskEventChangeCommand(\n-                processInstance.getId(), taskId\n-        );\n-        stateEventCallbackService.sendResult(address, port, taskEventChangeCommand.convert2Command(taskType));\n-    }\n-\n-    public ProcessInstance loadNextProcess4Serial(long code, int state) {\n-        return this.processInstanceMapper.loadNextProcess4Serial(code, state);\n-    }\n-\n-    private void deleteCommandWithCheck(int commandId) {\n-        int delete = this.commandMapper.deleteById(commandId);\n-        if (delete != 1) {\n-            throw new ServiceException(\"delete command fail, id:\" + commandId);\n-        }\n-    }\n+    void processNeedFailoverProcessInstances(ProcessInstance processInstance);\n+\n+    List<TaskInstance> queryNeedFailoverTaskInstances(String host);\n+\n+    DataSource findDataSourceById(int id);\n+\n+    int updateProcessInstanceState(Integer processInstanceId, ExecutionStatus executionStatus);\n+\n+    ProcessInstance findProcessInstanceByTaskId(int taskId);\n+\n+    List<UdfFunc> queryUdfFunListByIds(Integer[] ids);\n+\n+    String queryTenantCodeByResName(String resName, ResourceType resourceType);\n+\n+    List<Schedule> selectAllByProcessDefineCode(long[] codes);\n+\n+    ProcessInstance findLastSchedulerProcessInterval(Long definitionCode, DateInterval dateInterval);\n+\n+    ProcessInstance findLastManualProcessInterval(Long definitionCode, DateInterval dateInterval);\n+\n+    ProcessInstance findLastRunningProcess(Long definitionCode, Date startTime, Date endTime);\n+\n+    String queryUserQueueByProcessInstance(ProcessInstance processInstance);\n+\n+    ProjectUser queryProjectWithUserByProcessInstanceId(int processInstanceId);\n+\n+    String getTaskWorkerGroup(TaskInstance taskInstance);\n+\n+    List<Project> getProjectListHavePerm(int userId);\n+\n+    <T> List<T> listUnauthorized(int userId, T[] needChecks, AuthorizationType authorizationType);\n+\n+    User getUserById(int userId);\n+\n+    Resource getResourceById(int resourceId);\n+\n+    List<Resource> listResourceByIds(Integer[] resIds);\n+\n+    String formatTaskAppId(TaskInstance taskInstance);\n+\n+    int switchVersion(ProcessDefinition processDefinition, ProcessDefinitionLog processDefinitionLog);\n+\n+    int switchProcessTaskRelationVersion(ProcessDefinition processDefinition);\n+\n+    int switchTaskDefinitionVersion(long taskCode, int taskVersion);\n+\n+    String getResourceIds(TaskDefinition taskDefinition);\n+\n+    int saveTaskDefine(User operator, long projectCode, List<TaskDefinitionLog> taskDefinitionLogs, Boolean syncDefine);\n+\n+    int saveProcessDefine(User operator, ProcessDefinition processDefinition, Boolean syncDefine, Boolean isFromProcessDefine);\n+\n+    int saveTaskRelation(User operator, long projectCode, long processDefinitionCode, int processDefinitionVersion,\n+                         List<ProcessTaskRelationLog> taskRelationList, List<TaskDefinitionLog> taskDefinitionLogs,\n+                         Boolean syncDefine);\n+\n+    boolean isTaskOnline(long taskCode);\n+\n+    DAG<String, TaskNode, TaskNodeRelation> genDagGraph(ProcessDefinition processDefinition);\n+\n+    DagData genDagData(ProcessDefinition processDefinition);\n+\n+    List<TaskDefinitionLog> genTaskDefineList(List<ProcessTaskRelation> processTaskRelations);\n+\n+    List<TaskDefinitionLog> getTaskDefineLogListByRelation(List<ProcessTaskRelation> processTaskRelations);\n+\n+    TaskDefinition findTaskDefinition(long taskCode, int taskDefinitionVersion);\n+\n+    List<ProcessTaskRelation> findRelationByCode(long processDefinitionCode, int processDefinitionVersion);\n+\n+    List<TaskNode> transformTask(List<ProcessTaskRelation> taskRelationList, List<TaskDefinitionLog> taskDefinitionLogs);\n+\n+    Map<ProcessInstance, TaskInstance> notifyProcessList(int processId);\n+\n+    DqExecuteResult getDqExecuteResultByTaskInstanceId(int taskInstanceId);\n+\n+    int updateDqExecuteResultUserId(int taskInstanceId);\n+\n+    int updateDqExecuteResultState(DqExecuteResult dqExecuteResult);\n+\n+    int deleteDqExecuteResultByTaskInstanceId(int taskInstanceId);\n+\n+    int deleteTaskStatisticsValueByTaskInstanceId(int taskInstanceId);\n+\n+    DqRule getDqRule(int ruleId);\n+\n+    List<DqRuleInputEntry> getRuleInputEntry(int ruleId);\n+\n+    List<DqRuleExecuteSql> getDqExecuteSql(int ruleId);\n+\n+    DqComparisonType getComparisonTypeById(int id);\n+\n+    boolean acquireTaskGroup(int taskId,\n+                             String taskName, int groupId,\n+                             int processId, int priority);\n+\n+    boolean robTaskGroupResouce(TaskGroupQueue taskGroupQueue);\n+\n+    boolean acquireTaskGroupAgain(TaskGroupQueue taskGroupQueue);\n+\n+    void releaseAllTaskGroup(int processInstanceId);\n+\n+    TaskInstance releaseTaskGroup(TaskInstance taskInstance);\n+\n+    void changeTaskGroupQueueStatus(int taskId, TaskGroupQueueStatus status);\n+\n+    TaskGroupQueue insertIntoTaskGroupQueue(Integer taskId,\n+                                            String taskName, Integer groupId,\n+                                            Integer processId, Integer priority, TaskGroupQueueStatus status);\n+\n+    int updateTaskGroupQueueStatus(Integer taskId, int status);\n+\n+    int updateTaskGroupQueue(TaskGroupQueue taskGroupQueue);\n+\n+    TaskGroupQueue loadTaskGroupQueue(int taskId);\n+\n+    void sendStartTask2Master(ProcessInstance processInstance, int taskId,\n+                              org.apache.dolphinscheduler.remote.command.CommandType taskType);\n+\n+    ProcessInstance loadNextProcess4Serial(long code, int state);\n }\n", "next_change": {"commit": "5c0be8a3d78bfb97fb4a599979ce3e77ee429784", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 395aa3166..bf48ab9ce 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -295,5 +295,5 @@ public interface ProcessService {\n     void sendStartTask2Master(ProcessInstance processInstance, int taskId,\n                               org.apache.dolphinscheduler.remote.command.CommandType taskType);\n \n-    ProcessInstance loadNextProcess4Serial(long code, int state);\n+    ProcessInstance loadNextProcess4Serial(long code, int state, int id);\n }\n", "next_change": {"commit": "5bb1eb04fce42dc3e6006d29d595318b1bf15914", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex bf48ab9ce..9ff8689fd 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -296,4 +296,6 @@ public interface ProcessService {\n                               org.apache.dolphinscheduler.remote.command.CommandType taskType);\n \n     ProcessInstance loadNextProcess4Serial(long code, int state, int id);\n+\n+    public String findConfigYamlByName(String clusterName) ;\n }\n", "next_change": {"commit": "e5cca0e79bfe16d07e931bcc68c279643ad45fab", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 9ff8689fd..976fd9098 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -298,4 +299,6 @@ public interface ProcessService {\n     ProcessInstance loadNextProcess4Serial(long code, int state, int id);\n \n     public String findConfigYamlByName(String clusterName) ;\n+\n+    void forceProcessInstanceSuccessByTaskInstanceId(Integer taskInstanceId);\n }\n", "next_change": {"commit": "877441519711c729951ba811f91cdb088d4f1e96", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex 976fd9098..b99a9ad32 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -298,7 +301,7 @@ public interface ProcessService {\n \n     ProcessInstance loadNextProcess4Serial(long code, int state, int id);\n \n-    public String findConfigYamlByName(String clusterName) ;\n+    public String findConfigYamlByName(String clusterName);\n \n     void forceProcessInstanceSuccessByTaskInstanceId(Integer taskInstanceId);\n }\n", "next_change": {"commit": "5b384f3fab8bc8fbe61cbd3bcb687efd4f34b5a1", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex b99a9ad32..e04e32545 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -304,4 +298,6 @@ public interface ProcessService {\n     public String findConfigYamlByName(String clusterName);\n \n     void forceProcessInstanceSuccessByTaskInstanceId(Integer taskInstanceId);\n+\n+    Integer queryTestDataSourceId(Integer onlineDataSourceId);\n }\n", "next_change": {"commit": "8be32d4145c851a01d7300cd5a854be9b4a27055", "changed_code": [{"header": "diff --git a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\nindex e04e32545..48689909d 100644\n--- a/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n+++ b/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java\n", "chunk": "@@ -300,4 +241,6 @@ public interface ProcessService {\n     void forceProcessInstanceSuccessByTaskInstanceId(Integer taskInstanceId);\n \n     Integer queryTestDataSourceId(Integer onlineDataSourceId);\n+\n+    void saveCommandTrigger(Integer commandId, Integer processInstanceId);\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "f643981f489e34dff84f23ffa9d559a7e398cb4b", "url": "https://github.com/apache/dolphinscheduler/commit/f643981f489e34dff84f23ffa9d559a7e398cb4b", "message": "1. change windows new line 'CR' to linux new line 'LF'\n2. Format code", "committedDate": "2020-06-11T02:14:15Z", "type": "commit"}, {"oid": "4e37be68af658f4b79cd9744e7e0aea8d538188f", "url": "https://github.com/apache/dolphinscheduler/commit/4e37be68af658f4b79cd9744e7e0aea8d538188f", "message": "Update SqoopTaskTest.java", "committedDate": "2020-06-12T01:18:00Z", "type": "commit"}, {"oid": "094d09ba74062dc8a828d87ba8e9d3d9a14c42a8", "url": "https://github.com/apache/dolphinscheduler/commit/094d09ba74062dc8a828d87ba8e9d3d9a14c42a8", "message": "Update pom.xml", "committedDate": "2020-06-12T01:20:28Z", "type": "commit"}, {"oid": "b5a296f4cdf991ec22544ef1cde8b8dbf8a2cdd5", "url": "https://github.com/apache/dolphinscheduler/commit/b5a296f4cdf991ec22544ef1cde8b8dbf8a2cdd5", "message": "Update pom.xml", "committedDate": "2020-06-12T01:21:07Z", "type": "commit"}, {"oid": "71619ed29bc9ff3f34a5308576711d86779392a6", "url": "https://github.com/apache/dolphinscheduler/commit/71619ed29bc9ff3f34a5308576711d86779392a6", "message": "Update pom.xml", "committedDate": "2020-06-12T01:22:44Z", "type": "commit"}, {"oid": "0b11275880a52a67ff1b77b0c51c48fa2d3211c1", "url": "https://github.com/apache/dolphinscheduler/commit/0b11275880a52a67ff1b77b0c51c48fa2d3211c1", "message": "Merge pull request #2 from apache/dev\n\nmerge", "committedDate": "2020-06-12T01:22:58Z", "type": "commit"}, {"oid": "65841a5709aa681e7b3df6d8cdc10b575fdb9d7b", "url": "https://github.com/apache/dolphinscheduler/commit/65841a5709aa681e7b3df6d8cdc10b575fdb9d7b", "message": "1. change windows new line 'CR' to linux new line 'LF'\n2. solve conflict", "committedDate": "2020-06-12T01:31:04Z", "type": "commit"}, {"oid": "cfecfb799b91459e825c2104ab6fa25d07e4f7f1", "url": "https://github.com/apache/dolphinscheduler/commit/cfecfb799b91459e825c2104ab6fa25d07e4f7f1", "message": "1. change windows new line 'CR' to linux new line 'LF'\n2. solve conflict", "committedDate": "2020-06-12T01:59:40Z", "type": "commit"}, {"oid": "24120a4641c014a4c9dcdb36cfa787f2b660822e", "url": "https://github.com/apache/dolphinscheduler/commit/24120a4641c014a4c9dcdb36cfa787f2b660822e", "message": "fix the bad code smell", "committedDate": "2020-06-12T03:27:42Z", "type": "commit"}, {"oid": "65953fe2573d4358c4bbc023cf8f04f6343345bb", "url": "https://github.com/apache/dolphinscheduler/commit/65953fe2573d4358c4bbc023cf8f04f6343345bb", "message": "fix testBuildDataxJobContentJson", "committedDate": "2020-06-12T04:10:17Z", "type": "commit"}, {"oid": "1b7d8ee236990747ecfc40726092cb352cd91f36", "url": "https://github.com/apache/dolphinscheduler/commit/1b7d8ee236990747ecfc40726092cb352cd91f36", "message": "fix the bad code smell", "committedDate": "2020-06-12T04:35:18Z", "type": "commit"}]}