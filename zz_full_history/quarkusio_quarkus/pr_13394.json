{"pr_number": 13394, "pr_title": "Configure label in Spring Cloud Config Client extension", "pr_author": "pukkaone", "pr_createdAt": "2020-11-20T01:23:18Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13394", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ4NDAzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/13394#discussion_r527484031", "body": "We generally try to avoid having lambdas in code that executes at runtime.\r\nCan you please replace it with an `if` statement?", "bodyText": "We generally try to avoid having lambdas in code that executes at runtime.\nCan you please replace it with an if statement?", "bodyHTML": "<p dir=\"auto\">We generally try to avoid having lambdas in code that executes at runtime.<br>\nCan you please replace it with an <code>if</code> statement?</p>", "author": "geoand", "createdAt": "2020-11-20T07:15:59Z", "path": "extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java", "diffHunk": "@@ -191,6 +191,7 @@ private URI finalURI(String applicationName, String profile) throws URISyntaxExc\n         List<String> finalPathSegments = new ArrayList<>(result.getPathSegments());\n         finalPathSegments.add(applicationName);\n         finalPathSegments.add(profile);\n+        springCloudConfigClientConfig.label.ifPresent(label -> finalPathSegments.add(label));", "originalCommit": "0af981e647f12a3889bb52683e5fd96892c4724c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg1MTU1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13394#discussion_r527851557", "bodyText": "Okay, replaced the lambda with an if statement.", "author": "pukkaone", "createdAt": "2020-11-20T17:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ4NDAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "00a72e62a3b471522ceb6e06f28d87d85d26395a", "changed_code": [{"header": "diff --git a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java\nindex dba1b933ef6..3dcea9de62e 100644\n--- a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java\n+++ b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java\n", "chunk": "@@ -191,7 +191,9 @@ private URI finalURI(String applicationName, String profile) throws URISyntaxExc\n         List<String> finalPathSegments = new ArrayList<>(result.getPathSegments());\n         finalPathSegments.add(applicationName);\n         finalPathSegments.add(profile);\n-        springCloudConfigClientConfig.label.ifPresent(label -> finalPathSegments.add(label));\n+        if (springCloudConfigClientConfig.label.isPresent()) {\n+            finalPathSegments.add(springCloudConfigClientConfig.label.get());\n+        }\n         result.setPathSegments(finalPathSegments);\n         return result.build();\n     }\n", "next_change": {"commit": "de0f855ac382e216fa0e63b91ab85c0d59b71d16", "changed_code": [{"header": "diff --git a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java\ndeleted file mode 100644\nindex 3dcea9de62e..00000000000\n--- a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DefaultSpringCloudConfigClientGateway.java\n+++ /dev/null\n", "chunk": "@@ -1,252 +0,0 @@\n-package io.quarkus.spring.cloud.config.client.runtime;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.security.KeyManagementException;\n-import java.security.KeyStore;\n-import java.security.KeyStoreException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.UnrecoverableKeyException;\n-import java.security.cert.CertificateException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.apache.http.HttpEntity;\n-import org.apache.http.HttpHost;\n-import org.apache.http.auth.AuthScheme;\n-import org.apache.http.auth.AuthScope;\n-import org.apache.http.auth.UsernamePasswordCredentials;\n-import org.apache.http.client.AuthCache;\n-import org.apache.http.client.CredentialsProvider;\n-import org.apache.http.client.config.RequestConfig;\n-import org.apache.http.client.methods.CloseableHttpResponse;\n-import org.apache.http.client.methods.HttpGet;\n-import org.apache.http.client.protocol.HttpClientContext;\n-import org.apache.http.client.utils.URIBuilder;\n-import org.apache.http.conn.ssl.NoopHostnameVerifier;\n-import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n-import org.apache.http.conn.ssl.TrustAllStrategy;\n-import org.apache.http.impl.auth.BasicScheme;\n-import org.apache.http.impl.client.BasicCredentialsProvider;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClientBuilder;\n-import org.apache.http.ssl.SSLContextBuilder;\n-import org.apache.http.ssl.SSLContexts;\n-import org.apache.http.util.EntityUtils;\n-\n-import com.fasterxml.jackson.databind.DeserializationFeature;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-\n-class DefaultSpringCloudConfigClientGateway implements SpringCloudConfigClientGateway {\n-\n-    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n-            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n-\n-    private final SpringCloudConfigClientConfig springCloudConfigClientConfig;\n-    private final SSLConnectionSocketFactory sslSocketFactory;\n-    private final URI baseURI;\n-\n-    public DefaultSpringCloudConfigClientGateway(SpringCloudConfigClientConfig springCloudConfigClientConfig) {\n-        this.springCloudConfigClientConfig = springCloudConfigClientConfig;\n-        try {\n-            this.baseURI = determineBaseUri(springCloudConfigClientConfig);\n-        } catch (URISyntaxException e) {\n-            throw new IllegalArgumentException(\"Value: '\" + springCloudConfigClientConfig.url\n-                    + \"' of property 'quarkus.spring-cloud-config.url' is invalid\", e);\n-        }\n-\n-        if (springCloudConfigClientConfig.trustStore.isPresent() || springCloudConfigClientConfig.keyStore.isPresent()\n-                || springCloudConfigClientConfig.trustCerts) {\n-            this.sslSocketFactory = createFactoryFromAgentConfig(springCloudConfigClientConfig);\n-        } else {\n-            this.sslSocketFactory = null;\n-        }\n-    }\n-\n-    private URI determineBaseUri(SpringCloudConfigClientConfig springCloudConfigClientConfig) throws URISyntaxException {\n-        String url = springCloudConfigClientConfig.url;\n-        if (null == url || url.isEmpty()) {\n-            throw new IllegalArgumentException(\n-                    \"The 'quarkus.spring-cloud-config.url' property cannot be empty\");\n-        }\n-        if (url.endsWith(\"/\")) {\n-            return new URI(url.substring(0, url.length() - 1));\n-        }\n-        return new URI(url);\n-    }\n-\n-    // The SSL code is basically a copy of the code in the Consul extension\n-    // Normally we would consider moving this code to one place, but as I want\n-    // to stop using Apache HTTP Client when we move to JDK 11, lets not do the\n-    // extra work\n-\n-    private SSLConnectionSocketFactory createFactoryFromAgentConfig(\n-            SpringCloudConfigClientConfig springCloudConfigClientConfig) {\n-        try {\n-            SSLContextBuilder sslContextBuilder = SSLContexts.custom();\n-            if (springCloudConfigClientConfig.trustStore.isPresent()) {\n-                sslContextBuilder = sslContextBuilder\n-                        .loadTrustMaterial(readStore(springCloudConfigClientConfig.trustStore.get(),\n-                                springCloudConfigClientConfig.trustStorePassword), null);\n-            } else if (springCloudConfigClientConfig.trustCerts) {\n-                sslContextBuilder = sslContextBuilder.loadTrustMaterial(TrustAllStrategy.INSTANCE);\n-            }\n-            if (springCloudConfigClientConfig.keyStore.isPresent()) {\n-                String keyPassword = springCloudConfigClientConfig.keyPassword\n-                        .orElse(springCloudConfigClientConfig.keyStorePassword.orElse(\"\"));\n-                sslContextBuilder = sslContextBuilder.loadKeyMaterial(\n-                        readStore(springCloudConfigClientConfig.keyStore.get(), springCloudConfigClientConfig.keyStorePassword),\n-                        keyPassword.toCharArray());\n-            }\n-            return new SSLConnectionSocketFactory(sslContextBuilder.build(), NoopHostnameVerifier.INSTANCE);\n-        } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException | IOException | CertificateException\n-                | UnrecoverableKeyException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static String findKeystoreFileType(Path keyStorePath) {\n-        String pathName = keyStorePath.toString().toLowerCase();\n-        if (pathName.endsWith(\".p12\") || pathName.endsWith(\".pkcs12\") || pathName.endsWith(\".pfx\")) {\n-            return \"PKS12\";\n-        }\n-        return \"JKS\";\n-    }\n-\n-    private static KeyStore readStore(Path keyStorePath, Optional<String> keyStorePassword)\n-            throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {\n-\n-        String keyStoreType = findKeystoreFileType(keyStorePath);\n-\n-        InputStream classPathResource = Thread.currentThread().getContextClassLoader()\n-                .getResourceAsStream(keyStorePath.toString());\n-        if (classPathResource != null) {\n-            try (InputStream is = classPathResource) {\n-                return doReadStore(is, keyStoreType, keyStorePassword);\n-            }\n-        } else {\n-            try (InputStream is = Files.newInputStream(keyStorePath)) {\n-                return doReadStore(is, keyStoreType, keyStorePassword);\n-            }\n-        }\n-    }\n-\n-    private static KeyStore doReadStore(InputStream keyStoreStream, String keyStoreType, Optional<String> keyStorePassword)\n-            throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {\n-        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n-        keyStore.load(keyStoreStream, keyStorePassword.isPresent() ? keyStorePassword.get().toCharArray() : null);\n-        return keyStore;\n-    }\n-\n-    @Override\n-    public Response exchange(String applicationName, String profile) throws Exception {\n-        final RequestConfig requestConfig = RequestConfig.custom()\n-                .setConnectionRequestTimeout((int) springCloudConfigClientConfig.connectionTimeout.toMillis())\n-                .setSocketTimeout((int) springCloudConfigClientConfig.readTimeout.toMillis())\n-                .build();\n-\n-        final HttpClientBuilder httpClientBuilder = HttpClientBuilder.create().setDefaultRequestConfig(requestConfig);\n-        if (sslSocketFactory != null) {\n-            httpClientBuilder.setSSLSocketFactory(sslSocketFactory);\n-        }\n-\n-        try (CloseableHttpClient client = httpClientBuilder.build()) {\n-            final URI finalURI = finalURI(applicationName, profile);\n-            final HttpGet request = new HttpGet(finalURI);\n-            request.addHeader(\"Accept\", \"application/json\");\n-\n-            for (Map.Entry<String, String> entry : springCloudConfigClientConfig.headers.entrySet()) {\n-                request.setHeader(entry.getKey(), entry.getValue());\n-            }\n-\n-            HttpClientContext context = setupContext(finalURI);\n-            try (CloseableHttpResponse response = client.execute(request, context)) {\n-                if (response.getStatusLine().getStatusCode() != 200) {\n-                    throw new RuntimeException(\"Got unexpected HTTP response code \" + response.getStatusLine().getStatusCode()\n-                            + \" from \" + finalURI);\n-                }\n-                final HttpEntity entity = response.getEntity();\n-                if (entity == null) {\n-                    throw new RuntimeException(\"Got empty HTTP response body \" + finalURI);\n-                }\n-\n-                return OBJECT_MAPPER.readValue(EntityUtils.toString(entity), Response.class);\n-            }\n-        }\n-    }\n-\n-    private URI finalURI(String applicationName, String profile) throws URISyntaxException {\n-        URIBuilder result = new URIBuilder(baseURI);\n-        if (result.getPort() == -1) {\n-            // we need to set the port otherwise auth case doesn't match the request\n-            result.setPort(result.getScheme().equalsIgnoreCase(\"http\") ? 80 : 443);\n-        }\n-        List<String> finalPathSegments = new ArrayList<>(result.getPathSegments());\n-        finalPathSegments.add(applicationName);\n-        finalPathSegments.add(profile);\n-        if (springCloudConfigClientConfig.label.isPresent()) {\n-            finalPathSegments.add(springCloudConfigClientConfig.label.get());\n-        }\n-        result.setPathSegments(finalPathSegments);\n-        return result.build();\n-    }\n-\n-    private HttpClientContext setupContext(URI finalURI) {\n-        final HttpClientContext context = HttpClientContext.create();\n-        if ((baseURI.getUserInfo() != null) || springCloudConfigClientConfig.usernameAndPasswordSet()) {\n-            final AuthCache authCache = InMemoryAuthCache.INSTANCE;\n-            authCache.put(new HttpHost(finalURI.getHost(), finalURI.getPort(), finalURI.getScheme()), new BasicScheme());\n-            context.setAuthCache(authCache);\n-            if (springCloudConfigClientConfig.usernameAndPasswordSet()) {\n-                final CredentialsProvider provider = new BasicCredentialsProvider();\n-                final UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(\n-                        springCloudConfigClientConfig.username.get(), springCloudConfigClientConfig.password.get());\n-                provider.setCredentials(AuthScope.ANY, credentials);\n-                context.setCredentialsProvider(provider);\n-            }\n-        }\n-        return context;\n-    }\n-\n-    /**\n-     * We need this class in order to avoid the serialization that Apache HTTP client does by default\n-     * and that does not work in GraalVM.\n-     * We don't care about caching the auth result since one call is only ever going to be made in any case\n-     */\n-    private static class InMemoryAuthCache implements AuthCache {\n-\n-        static final InMemoryAuthCache INSTANCE = new InMemoryAuthCache();\n-\n-        private final Map<HttpHost, AuthScheme> map = new ConcurrentHashMap<>();\n-\n-        private InMemoryAuthCache() {\n-        }\n-\n-        @Override\n-        public void put(HttpHost host, AuthScheme authScheme) {\n-            map.put(host, authScheme);\n-        }\n-\n-        @Override\n-        public AuthScheme get(HttpHost host) {\n-            return map.get(host);\n-        }\n-\n-        @Override\n-        public void remove(HttpHost host) {\n-            map.remove(host);\n-        }\n-\n-        @Override\n-        public void clear() {\n-            map.clear();\n-        }\n-    };\n-}\n", "next_change": null}]}}]}}, {"oid": "00a72e62a3b471522ceb6e06f28d87d85d26395a", "url": "https://github.com/quarkusio/quarkus/commit/00a72e62a3b471522ceb6e06f28d87d85d26395a", "message": "Configure label in Spring Cloud Config Client extension\n\nAdd configuration property quarkus.spring-cloud-config.label to request\na specific label rather than let Spring Cloud Config Server apply a\ndefault label.\n\nFixes #11211", "committedDate": "2020-11-20T17:29:39Z", "type": "commit"}, {"oid": "00a72e62a3b471522ceb6e06f28d87d85d26395a", "url": "https://github.com/quarkusio/quarkus/commit/00a72e62a3b471522ceb6e06f28d87d85d26395a", "message": "Configure label in Spring Cloud Config Client extension\n\nAdd configuration property quarkus.spring-cloud-config.label to request\na specific label rather than let Spring Cloud Config Server apply a\ndefault label.\n\nFixes #11211", "committedDate": "2020-11-20T17:29:39Z", "type": "forcePushed"}]}