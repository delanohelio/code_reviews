{"pr_number": 1045, "pr_title": "Cherry pick fixes to support macros in joiner plugin", "pr_author": "rmstar", "pr_createdAt": "2020-03-22T00:23:25Z", "pr_url": "https://github.com/cdapio/hydrator-plugins/pull/1045", "timeline": [{"oid": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "url": "https://github.com/cdapio/hydrator-plugins/commit/c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "message": "Cherry pick fixes to support macros in joiner plugin", "committedDate": "2020-03-24T22:44:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMzgyNQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397513825", "body": "unused?", "bodyText": "unused?", "bodyHTML": "<p dir=\"auto\">unused?</p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:03:36Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -68,11 +64,14 @@\n   static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n   static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n \n+\n   private final JoinerConfig conf;\n   private Schema outputSchema;\n-  private Map<String, StageKeyInfo> stageKeyInfos;\n+  private Map<String, List<String>> perStageJoinKeys;\n   private Table<String, String, String> perStageSelectedFields;\n+  private Multimap<String, String> duplicateFields = ArrayListMultimap.create();", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0NjE4Nw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397546187", "bodyText": "Good catch; removed.", "author": "rmstar", "createdAt": "2020-03-25T00:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMzgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -60,18 +59,16 @@ import java.util.Set;\n   \"inputs, outer join will be performed\")\n public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, StructuredRecord> {\n \n-  static final String JOIN_OPERATION_DESCRIPTION = \"Used as a key in a join\";\n-  static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n-  static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n-\n+  public static final String JOIN_OPERATION_DESCRIPTION = \"Used as a key in a join\";\n+  public static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n+  public static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n \n   private final JoinerConfig conf;\n   private Schema outputSchema;\n   private Map<String, List<String>> perStageJoinKeys;\n   private Table<String, String, String> perStageSelectedFields;\n+  private Set<String> requiredInputs;\n   private Multimap<String, String> duplicateFields = ArrayListMultimap.create();\n-  private JoinConfig joinConfig;\n-  private Map<String, Schema> keySchemas = new HashMap<>();\n \n   public Joiner(JoinerConfig conf) {\n     this.conf = conf;\n", "next_change": {"commit": "9c6a15ea0d57aa8c2b33aa9dca2780e3b001e5bc", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..21eceecd 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -69,6 +69,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   private Table<String, String, String> perStageSelectedFields;\n   private Set<String> requiredInputs;\n   private Multimap<String, String> duplicateFields = ArrayListMultimap.create();\n+  private Map<String, Schema> keySchemas = new HashMap<>();\n \n   public Joiner(JoinerConfig conf) {\n     this.conf = conf;\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 21eceecd..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -57,41 +60,83 @@ import java.util.Set;\n   \"required inputs, inner join will be performed. Otherwise inner join will be performed on required inputs and \" +\n   \"records from non-required inputs will only be present if they match join criteria. If there are no required \" +\n   \"inputs, outer join will be performed\")\n-public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, StructuredRecord> {\n+public class Joiner extends BatchAutoJoiner {\n \n   public static final String JOIN_OPERATION_DESCRIPTION = \"Used as a key in a join\";\n   public static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n   public static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n \n   private final JoinerConfig conf;\n-  private Schema outputSchema;\n-  private Map<String, List<String>> perStageJoinKeys;\n-  private Table<String, String, String> perStageSelectedFields;\n-  private Set<String> requiredInputs;\n-  private Multimap<String, String> duplicateFields = ArrayListMultimap.create();\n-  private Map<String, Schema> keySchemas = new HashMap<>();\n \n   public Joiner(JoinerConfig conf) {\n     this.conf = conf;\n   }\n \n+  @Nullable\n   @Override\n-  public void configurePipeline(MultiInputPipelineConfigurer pipelineConfigurer) {\n-    MultiInputStageConfigurer stageConfigurer = pipelineConfigurer.getMultiInputStageConfigurer();\n-    Map<String, Schema> inputSchemas = stageConfigurer.getInputSchemas();\n-    FailureCollector collector = pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector();\n-    init(inputSchemas, collector);\n-    collector.getOrThrowException();\n-    if (!conf.inputSchemasAvailable(inputSchemas) && !conf.containsMacro(conf.OUTPUT_SCHEMA) &&\n+  public JoinDefinition define(AutoJoinerContext context) {\n+    FailureCollector collector = context.getFailureCollector();\n+\n+    boolean hasUnknownInputSchema = context.getInputStages().values().stream().anyMatch(Objects::isNull);\n+    if (hasUnknownInputSchema && !conf.containsMacro(JoinerConfig.OUTPUT_SCHEMA) &&\n       conf.getOutputSchema(collector) == null) {\n       // If input schemas are unknown, an output schema must be provided.\n-      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(conf.OUTPUT_SCHEMA);\n-    }\n-\n-    Schema outputSchema = getOutputSchema(inputSchemas, collector);\n-    if (outputSchema != null) {\n-      // Set output schema if it's not a macro.\n-      stageConfigurer.setOutputSchema(outputSchema);\n+      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(JoinerConfig.OUTPUT_SCHEMA);\n+    }\n+\n+    if (conf.requiredPropertiesContainMacros()) {\n+      return null;\n+    }\n+\n+    Set<String> requiredStages = conf.getRequiredInputs();\n+    Set<String> broadcastStages = conf.getBroadcastInputs();\n+    List<JoinStage> inputs = new ArrayList<>(context.getInputStages().size());\n+    boolean useOutputSchema = false;\n+    for (JoinStage joinStage : context.getInputStages().values()) {\n+      inputs.add(JoinStage.builder(joinStage)\n+        .setRequired(requiredStages.contains(joinStage.getStageName()))\n+        .setBroadcast(broadcastStages.contains(joinStage.getStageName()))\n+        .build());\n+      useOutputSchema = useOutputSchema || joinStage.getSchema() == null;\n+    }\n+\n+    try {\n+      JoinDefinition.Builder joinBuilder = JoinDefinition.builder()\n+        .select(conf.getSelectedFields(collector))\n+        .from(inputs)\n+        .on(JoinCondition.onKeys()\n+              .setKeys(conf.getJoinKeys(collector))\n+              .setNullSafe(conf.isNullSafe())\n+              .build());\n+      if (useOutputSchema) {\n+        joinBuilder.setOutputSchema(conf.getOutputSchema(collector));\n+      } else {\n+        joinBuilder.setOutputSchemaName(\"join.output\");\n+      }\n+      return joinBuilder.build();\n+    } catch (InvalidJoinException e) {\n+      if (e.getErrors().isEmpty()) {\n+        collector.addFailure(e.getMessage(), null);\n+      }\n+      for (JoinError error : e.getErrors()) {\n+        ValidationFailure failure = collector.addFailure(error.getMessage(), error.getCorrectiveAction());\n+        switch (error.getType()) {\n+          case JOIN_KEY:\n+          case JOIN_KEY_FIELD:\n+            failure.withConfigProperty(JoinerConfig.JOIN_KEYS);\n+            break;\n+          case SELECTED_FIELD:\n+            JoinField badField = ((SelectedFieldError) error).getField();\n+            failure.withConfigElement(\n+              JoinerConfig.SELECTED_FIELDS,\n+              String.format(\"%s.%s as %s\", badField.getStageName(), badField.getFieldName(), badField.getAlias()));\n+            break;\n+          case OUTPUT_SCHEMA:\n+            OutputSchemaError schemaError = (OutputSchemaError) error;\n+            failure.withOutputSchemaField(schemaError.getField());\n+        }\n+      }\n+      throw collector.getOrThrowException();\n     }\n   }\n \n", "next_change": {"commit": "d559bbd6b9b37cec2e36a6139932da239a7a8d46", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -134,6 +140,16 @@ public class Joiner extends BatchAutoJoiner {\n           case OUTPUT_SCHEMA:\n             OutputSchemaError schemaError = (OutputSchemaError) error;\n             failure.withOutputSchemaField(schemaError.getField());\n+            break;\n+          case DISTRIBUTION_SIZE:\n+            failure.withConfigProperty(JoinerConfig.DISTRIBUTION_FACTOR);\n+            break;\n+          case DISTRIBUTION_STAGE:\n+            failure.withConfigProperty(JoinerConfig.DISTRIBUTION_STAGE);\n+            break;\n+          case BROADCAST:\n+            failure.withConfigProperty(JoinerConfig.MEMORY_INPUTS);\n+            break;\n         }\n       }\n       throw collector.getOrThrowException();\n", "next_change": {"commit": "474dd52f224342bd7c70bb622a78436c7e25fe68", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 883f4156..14b4dc71 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -150,6 +154,8 @@ public class Joiner extends BatchAutoJoiner {\n           case BROADCAST:\n             failure.withConfigProperty(JoinerConfig.MEMORY_INPUTS);\n             break;\n+          case INVALID_CONDITION:\n+            failure.withConfigProperty(JoinerConfig.CONDITION_EXPR);\n         }\n       }\n       throw collector.getOrThrowException();\n", "next_change": null}]}}, {"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -144,6 +160,10 @@ public class Joiner extends BatchAutoJoiner {\n   public void prepareRun(BatchJoinerContext context) {\n     if (conf.getNumPartitions() != null) {\n       context.setNumPartitions(conf.getNumPartitions());\n+      if (conf.getDistributionFactor() != null && conf.getDistributionFactor() < conf.getNumPartitions()) {\n+        LOG.warn(\"Number of partitions ({}) should be greater than or equal to distribution factor ({}) for optimal \"\n+                   + \"results.\", conf.getNumPartitions(), conf.getDistributionFactor());\n+      }\n     }\n     FailureCollector collector = context.getFailureCollector();\n     context.record(createFieldOperations(conf.getSelectedFields(collector),\n", "next_change": {"commit": "474dd52f224342bd7c70bb622a78436c7e25fe68", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 883f4156..14b4dc71 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -166,8 +172,10 @@ public class Joiner extends BatchAutoJoiner {\n       }\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    context.record(createFieldOperations(conf.getSelectedFields(collector),\n-                                         conf.getJoinKeys(collector)));\n+    JoinCondition.Op conditionType = conf.getCondition(collector).getOp();\n+    Set<JoinKey> keys = conditionType == JoinCondition.Op.KEY_EQUALITY ?\n+      conf.getJoinKeys(collector) : Collections.emptySet();\n+    context.record(createFieldOperations(conf.getSelectedFields(collector), keys));\n   }\n \n   /**\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDEyOA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397514128", "body": "nit: `JoinerConfig.OUTPUT_SCHEMA`", "bodyText": "nit: JoinerConfig.OUTPUT_SCHEMA", "bodyHTML": "<p dir=\"auto\">nit: <code>JoinerConfig.OUTPUT_SCHEMA</code></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:04:24Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -82,24 +81,39 @@ public Joiner(JoinerConfig conf) {\n   public void configurePipeline(MultiInputPipelineConfigurer pipelineConfigurer) {\n     MultiInputStageConfigurer stageConfigurer = pipelineConfigurer.getMultiInputStageConfigurer();\n     Map<String, Schema> inputSchemas = stageConfigurer.getInputSchemas();\n-    FailureCollector collector = init(inputSchemas,\n-                                      pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector());\n+    FailureCollector collector = pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector();\n+    init(inputSchemas, collector);\n     collector.getOrThrowException();\n-    //validate the input schema and get the output schema for it\n-    stageConfigurer.setOutputSchema(getOutputSchema(inputSchemas, collector));\n+    if (!conf.inputSchemasAvailable(inputSchemas) && !conf.containsMacro(conf.OUTPUT_SCHEMA) &&", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMTYyNw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397521627", "bodyText": "Can we move this check to init as well?", "author": "CuriousVini", "createdAt": "2020-03-24T23:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0NzE0Mw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397547143", "bodyText": "Fixed conf.OUTPUT_SCHEMA -> JoinerConfig.OUTPUT_SCHEMA.\nThe check doesn't belong in init because init is called from:\n\nhere, i.e. configurePipeline\nprepareRun\ninitialize\n\nMaking this check at configure time is sufficient; IMO we don't need to check this again in other places.", "author": "rmstar", "createdAt": "2020-03-25T00:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -84,17 +81,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     FailureCollector collector = pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector();\n     init(inputSchemas, collector);\n     collector.getOrThrowException();\n-    if (!conf.inputSchemasAvailable(inputSchemas) && !conf.containsMacro(conf.OUTPUT_SCHEMA) &&\n-      conf.getOutputSchema(collector) == null) {\n-      // If input schemas are unknown, an output schema must be provided.\n-      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(conf.OUTPUT_SCHEMA);\n-    }\n-\n-    Schema outputSchema = getOutputSchema(inputSchemas, collector);\n-    if (outputSchema != null) {\n-      // Set output schema if it's not a macro.\n-      stageConfigurer.setOutputSchema(outputSchema);\n-    }\n+    //validate the input schema and get the output schema for it\n+    stageConfigurer.setOutputSchema(getOutputSchema(inputSchemas, collector));\n   }\n \n   @Override\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -82,7 +82,11 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     init(inputSchemas, collector);\n     collector.getOrThrowException();\n     //validate the input schema and get the output schema for it\n-    stageConfigurer.setOutputSchema(getOutputSchema(inputSchemas, collector));\n+    Schema outputSchema = getOutputSchema(inputSchemas, collector);\n+    if (outputSchema != null) {\n+      // Set output schema if it's not a macro.\n+      stageConfigurer.setOutputSchema(outputSchema);\n+    }\n   }\n \n   @Override\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -95,9 +100,15 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       context.setNumPartitions(conf.getNumPartitions());\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    init(context.getInputSchemas(), collector);\n+    Map<String, Schema> inputSchemas = context.getInputSchemas();\n+    if (!conf.inputSchemasAvailable(inputSchemas)) {\n+      // inputSchemas will be empty if the output schema of a previous node is a macro\n+      return;\n+    }\n+\n+    init(inputSchemas, collector);\n     collector.getOrThrowException();\n-    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(context.getInputSchemas(), collector);\n+    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, collector);\n     collector.getOrThrowException();\n     context.record(createFieldOperations(outputFieldInfos, perStageJoinKeys));\n   }\n", "next_change": {"commit": "da8b4e295145a36fed29df6074a748da0b7309e2", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..be36a977 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -101,14 +103,15 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     }\n     FailureCollector collector = context.getFailureCollector();\n     Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    if (!conf.inputSchemasAvailable(inputSchemas)) {\n+    List<String> inputStages = context.getInputStages();\n+    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n       // inputSchemas will be empty if the output schema of a previous node is a macro\n       return;\n     }\n \n-    init(inputSchemas, collector);\n+    init(inputSchemas, inputStages, collector);\n     collector.getOrThrowException();\n-    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, collector);\n+    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, inputStages, collector);\n     collector.getOrThrowException();\n     context.record(createFieldOperations(outputFieldInfos, perStageJoinKeys));\n   }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex be36a977..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -102,18 +146,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       context.setNumPartitions(conf.getNumPartitions());\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // inputSchemas will be empty if the output schema of a previous node is a macro\n-      return;\n-    }\n-\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    context.record(createFieldOperations(outputFieldInfos, perStageJoinKeys));\n+    context.record(createFieldOperations(conf.getSelectedFields(collector),\n+                                         conf.getJoinKeys(collector)));\n   }\n \n   /**\n", "next_change": {"commit": "d559bbd6b9b37cec2e36a6139932da239a7a8d46", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -144,6 +160,10 @@ public class Joiner extends BatchAutoJoiner {\n   public void prepareRun(BatchJoinerContext context) {\n     if (conf.getNumPartitions() != null) {\n       context.setNumPartitions(conf.getNumPartitions());\n+      if (conf.getDistributionFactor() != null && conf.getDistributionFactor() < conf.getNumPartitions()) {\n+        LOG.warn(\"Number of partitions ({}) should be greater than or equal to distribution factor ({}) for optimal \"\n+                   + \"results.\", conf.getNumPartitions(), conf.getDistributionFactor());\n+      }\n     }\n     FailureCollector collector = context.getFailureCollector();\n     context.record(createFieldOperations(conf.getSelectedFields(collector),\n", "next_change": {"commit": "474dd52f224342bd7c70bb622a78436c7e25fe68", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 883f4156..14b4dc71 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -166,8 +172,10 @@ public class Joiner extends BatchAutoJoiner {\n       }\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    context.record(createFieldOperations(conf.getSelectedFields(collector),\n-                                         conf.getJoinKeys(collector)));\n+    JoinCondition.Op conditionType = conf.getCondition(collector).getOp();\n+    Set<JoinKey> keys = conditionType == JoinCondition.Op.KEY_EQUALITY ?\n+      conf.getJoinKeys(collector) : Collections.emptySet();\n+    context.record(createFieldOperations(conf.getSelectedFields(collector), keys));\n   }\n \n   /**\n", "next_change": null}]}}, {"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -151,18 +171,17 @@ public class Joiner extends BatchAutoJoiner {\n   }\n \n   /**\n-   * Create the field operations from the provided OutputFieldInfo instances and join keys.\n-   * For join we record several types of transformation; Join, Identity, and Rename.\n-   * For each of these transformations, if the input field is directly coming from the schema\n-   * of one of the stage, the field is added as {@code stage_name.field_name}. We keep track of fields\n-   * outputted by operation (in {@code outputsSoFar set}, so that any operation uses that field as\n-   * input later, we add it without the stage name.\n+   * Create the field operations from the provided OutputFieldInfo instances and join keys. For join we record several\n+   * types of transformation; Join, Identity, and Rename. For each of these transformations, if the input field is\n+   * directly coming from the schema of one of the stage, the field is added as {@code stage_name.field_name}. We keep\n+   * track of fields outputted by operation (in {@code outputsSoFar set}, so that any operation uses that field as input\n+   * later, we add it without the stage name.\n    * <p>\n-   * Join transform operation is added with join keys as input tagged with the stage name, and join keys\n-   * without stage name as output.\n+   * Join transform operation is added with join keys as input tagged with the stage name, and join keys without stage\n+   * name as output.\n    * <p>\n-   * For other fields which are not renamed in join, Identity transform is added, while for fields which\n-   * are renamed Rename transform is added.\n+   * For other fields which are not renamed in join, Identity transform is added, while for fields which are renamed\n+   * Rename transform is added.\n    *\n    * @param outputFields collection of output fields along with information such as stage name, alias\n    * @param joinKeys join keys\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDIyMQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397514221", "body": "same here: `JoinerConfig.OUTPUT_SCHEMA`", "bodyText": "same here: JoinerConfig.OUTPUT_SCHEMA", "bodyHTML": "<p dir=\"auto\">same here: <code>JoinerConfig.OUTPUT_SCHEMA</code></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:04:40Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -82,24 +81,39 @@ public Joiner(JoinerConfig conf) {\n   public void configurePipeline(MultiInputPipelineConfigurer pipelineConfigurer) {\n     MultiInputStageConfigurer stageConfigurer = pipelineConfigurer.getMultiInputStageConfigurer();\n     Map<String, Schema> inputSchemas = stageConfigurer.getInputSchemas();\n-    FailureCollector collector = init(inputSchemas,\n-                                      pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector());\n+    FailureCollector collector = pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector();\n+    init(inputSchemas, collector);\n     collector.getOrThrowException();\n-    //validate the input schema and get the output schema for it\n-    stageConfigurer.setOutputSchema(getOutputSchema(inputSchemas, collector));\n+    if (!conf.inputSchemasAvailable(inputSchemas) && !conf.containsMacro(conf.OUTPUT_SCHEMA) &&\n+      conf.getOutputSchema(collector) == null) {\n+      // If input schemas are unknown, an output schema must be provided.\n+      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(conf.OUTPUT_SCHEMA);", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0NzE2Mw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397547163", "bodyText": "fixed.", "author": "rmstar", "createdAt": "2020-03-25T00:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -84,17 +81,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     FailureCollector collector = pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector();\n     init(inputSchemas, collector);\n     collector.getOrThrowException();\n-    if (!conf.inputSchemasAvailable(inputSchemas) && !conf.containsMacro(conf.OUTPUT_SCHEMA) &&\n-      conf.getOutputSchema(collector) == null) {\n-      // If input schemas are unknown, an output schema must be provided.\n-      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(conf.OUTPUT_SCHEMA);\n-    }\n-\n-    Schema outputSchema = getOutputSchema(inputSchemas, collector);\n-    if (outputSchema != null) {\n-      // Set output schema if it's not a macro.\n-      stageConfigurer.setOutputSchema(outputSchema);\n-    }\n+    //validate the input schema and get the output schema for it\n+    stageConfigurer.setOutputSchema(getOutputSchema(inputSchemas, collector));\n   }\n \n   @Override\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -82,7 +82,11 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     init(inputSchemas, collector);\n     collector.getOrThrowException();\n     //validate the input schema and get the output schema for it\n-    stageConfigurer.setOutputSchema(getOutputSchema(inputSchemas, collector));\n+    Schema outputSchema = getOutputSchema(inputSchemas, collector);\n+    if (outputSchema != null) {\n+      // Set output schema if it's not a macro.\n+      stageConfigurer.setOutputSchema(outputSchema);\n+    }\n   }\n \n   @Override\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -95,9 +100,15 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       context.setNumPartitions(conf.getNumPartitions());\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    init(context.getInputSchemas(), collector);\n+    Map<String, Schema> inputSchemas = context.getInputSchemas();\n+    if (!conf.inputSchemasAvailable(inputSchemas)) {\n+      // inputSchemas will be empty if the output schema of a previous node is a macro\n+      return;\n+    }\n+\n+    init(inputSchemas, collector);\n     collector.getOrThrowException();\n-    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(context.getInputSchemas(), collector);\n+    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, collector);\n     collector.getOrThrowException();\n     context.record(createFieldOperations(outputFieldInfos, perStageJoinKeys));\n   }\n", "next_change": {"commit": "da8b4e295145a36fed29df6074a748da0b7309e2", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..be36a977 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -101,14 +103,15 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     }\n     FailureCollector collector = context.getFailureCollector();\n     Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    if (!conf.inputSchemasAvailable(inputSchemas)) {\n+    List<String> inputStages = context.getInputStages();\n+    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n       // inputSchemas will be empty if the output schema of a previous node is a macro\n       return;\n     }\n \n-    init(inputSchemas, collector);\n+    init(inputSchemas, inputStages, collector);\n     collector.getOrThrowException();\n-    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, collector);\n+    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, inputStages, collector);\n     collector.getOrThrowException();\n     context.record(createFieldOperations(outputFieldInfos, perStageJoinKeys));\n   }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex be36a977..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -102,18 +146,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       context.setNumPartitions(conf.getNumPartitions());\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // inputSchemas will be empty if the output schema of a previous node is a macro\n-      return;\n-    }\n-\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    Collection<OutputFieldInfo> outputFieldInfos = createOutputFieldInfos(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    context.record(createFieldOperations(outputFieldInfos, perStageJoinKeys));\n+    context.record(createFieldOperations(conf.getSelectedFields(collector),\n+                                         conf.getJoinKeys(collector)));\n   }\n \n   /**\n", "next_change": {"commit": "d559bbd6b9b37cec2e36a6139932da239a7a8d46", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -144,6 +160,10 @@ public class Joiner extends BatchAutoJoiner {\n   public void prepareRun(BatchJoinerContext context) {\n     if (conf.getNumPartitions() != null) {\n       context.setNumPartitions(conf.getNumPartitions());\n+      if (conf.getDistributionFactor() != null && conf.getDistributionFactor() < conf.getNumPartitions()) {\n+        LOG.warn(\"Number of partitions ({}) should be greater than or equal to distribution factor ({}) for optimal \"\n+                   + \"results.\", conf.getNumPartitions(), conf.getDistributionFactor());\n+      }\n     }\n     FailureCollector collector = context.getFailureCollector();\n     context.record(createFieldOperations(conf.getSelectedFields(collector),\n", "next_change": {"commit": "474dd52f224342bd7c70bb622a78436c7e25fe68", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 883f4156..14b4dc71 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -166,8 +172,10 @@ public class Joiner extends BatchAutoJoiner {\n       }\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    context.record(createFieldOperations(conf.getSelectedFields(collector),\n-                                         conf.getJoinKeys(collector)));\n+    JoinCondition.Op conditionType = conf.getCondition(collector).getOp();\n+    Set<JoinKey> keys = conditionType == JoinCondition.Op.KEY_EQUALITY ?\n+      conf.getJoinKeys(collector) : Collections.emptySet();\n+    context.record(createFieldOperations(conf.getSelectedFields(collector), keys));\n   }\n \n   /**\n", "next_change": null}]}}, {"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -151,18 +171,17 @@ public class Joiner extends BatchAutoJoiner {\n   }\n \n   /**\n-   * Create the field operations from the provided OutputFieldInfo instances and join keys.\n-   * For join we record several types of transformation; Join, Identity, and Rename.\n-   * For each of these transformations, if the input field is directly coming from the schema\n-   * of one of the stage, the field is added as {@code stage_name.field_name}. We keep track of fields\n-   * outputted by operation (in {@code outputsSoFar set}, so that any operation uses that field as\n-   * input later, we add it without the stage name.\n+   * Create the field operations from the provided OutputFieldInfo instances and join keys. For join we record several\n+   * types of transformation; Join, Identity, and Rename. For each of these transformations, if the input field is\n+   * directly coming from the schema of one of the stage, the field is added as {@code stage_name.field_name}. We keep\n+   * track of fields outputted by operation (in {@code outputsSoFar set}, so that any operation uses that field as input\n+   * later, we add it without the stage name.\n    * <p>\n-   * Join transform operation is added with join keys as input tagged with the stage name, and join keys\n-   * without stage name as output.\n+   * Join transform operation is added with join keys as input tagged with the stage name, and join keys without stage\n+   * name as output.\n    * <p>\n-   * For other fields which are not renamed in join, Identity transform is added, while for fields which\n-   * are renamed Rename transform is added.\n+   * For other fields which are not renamed in join, Identity transform is added, while for fields which are renamed\n+   * Rename transform is added.\n    *\n    * @param outputFields collection of output fields along with information such as stage name, alias\n    * @param joinKeys join keys\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDQ5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397514490", "body": "nit: Mark this as @VisibleForTesting", "bodyText": "nit: Mark this as @VisibleForTesting", "bodyHTML": "<p dir=\"auto\">nit: Mark this as <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/VisibleForTesting/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/VisibleForTesting\">@VisibleForTesting</a></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:05:28Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -215,31 +259,57 @@ public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<Str\n   }\n \n   FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDI2Nw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397524267", "bodyText": "looks like inputSchemasAvailable is called at many places. can we centralize that check in this method?", "author": "CuriousVini", "createdAt": "2020-03-24T23:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0OTAwNQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397549005", "bodyText": "Added @VisibleForTesting annotation.\ninputSchemasAvailable is called from:\n\nconfigurePipeline - part of check to verify that output schema is provided if input schemas are not known\nprepareRun - don't record lineage if input schemas are not available\ncreateOutputFieldInfos - bail out if input schemas are not available\nJoinerConfig.validateJoinKeySchemas - part of check to skip validation if input schemas are not available or joinKeys is a macro.\n\nSince it's used in many different contexts, I don't think it makes sense to centralize the check in init().", "author": "rmstar", "createdAt": "2020-03-25T00:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDQ5MA=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -258,17 +228,21 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     return outRecordBuilder.build();\n   }\n \n-  FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n-    joinConfig = new JoinConfig(conf.getInputs());\n+  void init(Map<String, Schema> inputSchemas, FailureCollector collector) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n+    requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n-    return failureCollector;\n   }\n \n   void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n                               FailureCollector collector) {\n     perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n+\n+    if (perStageJoinKeys.size() != inputSchemas.size()) {\n+      collector.addFailure(\"There should be join keys present from each stage.\",\n+                           \"Ensure join keys are present from each stage.\")\n+        .withConfigProperty(conf.JOIN_KEYS);\n+    }\n \n     List<Schema> prevSchemaList = null;\n     for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -237,12 +241,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n                               FailureCollector collector) {\n     perStageJoinKeys = joinKeys;\n-\n-    if (perStageJoinKeys.size() != inputSchemas.size()) {\n-      collector.addFailure(\"There should be join keys present from each stage.\",\n-                           \"Ensure join keys are present from each stage.\")\n-        .withConfigProperty(conf.JOIN_KEYS);\n-    }\n+    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n \n     List<Schema> prevSchemaList = null;\n     for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -250,8 +267,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       Schema schema = inputSchemas.get(stageName);\n       if (schema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n       }\n \n       for (String joinKey : entry.getValue()) {\n", "next_change": {"commit": "be56392ba1be52b96d361ee0083b9a9e6484c687", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..23d43b7f 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -276,7 +286,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n         if (field == null) {\n           collector.addFailure(\n             String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n+            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n         }\n         schemaList.add(field.getSchema());\n       }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 23d43b7f..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,308 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema.\", inputFieldName, stageName), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(JoinerConfig.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDYxMA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397514610", "body": "we can make this method private", "bodyText": "we can make this method private", "bodyHTML": "<p dir=\"auto\">we can make this method private</p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:05:50Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -215,31 +259,57 @@ public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<Str\n   }\n \n   FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    Map<String, StageKeyInfo> keyInfos = new HashMap<>();\n-    StageKeyInfo prevKeyInfo = null;\n-    for (Map.Entry<String, List<String>> entry : conf.getPerStageJoinKeys().entrySet()) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n+    joinConfig = new JoinConfig(conf.getInputs());\n+    perStageSelectedFields = conf.getPerStageSelectedFields();\n+    return failureCollector;\n+  }\n+\n+  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0NzE4MQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397547181", "bodyText": "fixed", "author": "rmstar", "createdAt": "2020-03-25T00:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -258,17 +228,21 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     return outRecordBuilder.build();\n   }\n \n-  FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n-    joinConfig = new JoinConfig(conf.getInputs());\n+  void init(Map<String, Schema> inputSchemas, FailureCollector collector) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n+    requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n-    return failureCollector;\n   }\n \n   void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n                               FailureCollector collector) {\n     perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n+\n+    if (perStageJoinKeys.size() != inputSchemas.size()) {\n+      collector.addFailure(\"There should be join keys present from each stage.\",\n+                           \"Ensure join keys are present from each stage.\")\n+        .withConfigProperty(conf.JOIN_KEYS);\n+    }\n \n     List<Schema> prevSchemaList = null;\n     for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -237,12 +241,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n                               FailureCollector collector) {\n     perStageJoinKeys = joinKeys;\n-\n-    if (perStageJoinKeys.size() != inputSchemas.size()) {\n-      collector.addFailure(\"There should be join keys present from each stage.\",\n-                           \"Ensure join keys are present from each stage.\")\n-        .withConfigProperty(conf.JOIN_KEYS);\n-    }\n+    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n \n     List<Schema> prevSchemaList = null;\n     for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -250,8 +267,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       Schema schema = inputSchemas.get(stageName);\n       if (schema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n       }\n \n       for (String joinKey : entry.getValue()) {\n", "next_change": {"commit": "be56392ba1be52b96d361ee0083b9a9e6484c687", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..23d43b7f 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -276,7 +286,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n         if (field == null) {\n           collector.addFailure(\n             String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n+            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n         }\n         schemaList.add(field.getSchema());\n       }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 23d43b7f..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,308 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema.\", inputFieldName, stageName), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(JoinerConfig.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDg1Mg==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397514852", "body": "Annotate this with @VisibleForTesting", "bodyText": "Annotate this with @VisibleForTesting", "bodyHTML": "<p dir=\"auto\">Annotate this with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/VisibleForTesting/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/VisibleForTesting\">@VisibleForTesting</a></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:06:38Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -215,31 +259,57 @@ public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<Str\n   }\n \n   FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    Map<String, StageKeyInfo> keyInfos = new HashMap<>();\n-    StageKeyInfo prevKeyInfo = null;\n-    for (Map.Entry<String, List<String>> entry : conf.getPerStageJoinKeys().entrySet()) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n+    joinConfig = new JoinConfig(conf.getInputs());\n+    perStageSelectedFields = conf.getPerStageSelectedFields();\n+    return failureCollector;\n+  }\n+\n+  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n+                              FailureCollector collector) {\n+    perStageJoinKeys = joinKeys;\n+    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n+\n+    List<Schema> prevSchemaList = null;\n+    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n+      ArrayList<Schema> schemaList = new ArrayList<>();\n       String stageName = entry.getKey();\n-      StageKeyInfo keyInfo = new StageKeyInfo(stageName, inputSchemas.get(stageName),\n-                                              entry.getValue(), failureCollector);\n-      if (prevKeyInfo != null && !prevKeyInfo.getSchema().equals(keyInfo.getSchema())) {\n-        failureCollector.addFailure(\n+\n+      Schema schema = inputSchemas.get(stageName);\n+      if (schema == null) {\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n+      }\n+\n+      for (String joinKey : entry.getValue()) {\n+        Schema.Field field = schema.getField(joinKey);\n+        if (field == null) {\n+          collector.addFailure(\n+            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n+            .withConfigProperty(conf.JOIN_KEYS);\n+        }\n+        schemaList.add(field.getSchema());\n+      }\n+      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n+        collector.addFailure(\n           String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevKeyInfo.getFieldSchemas(), keyInfo.getFieldSchemas()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      } else {\n-        prevKeyInfo = keyInfo;\n+                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n+          .withConfigProperty(conf.JOIN_KEYS);\n       }\n-      keyInfos.put(stageName, keyInfo);\n+      prevSchemaList = schemaList;\n     }\n-\n-    stageKeyInfos = Collections.unmodifiableMap(keyInfos);\n-    joinConfig = new JoinConfig(conf.getInputs());\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-    return failureCollector;\n   }\n \n   Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0OTAyNg==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397549026", "bodyText": "fixed.", "author": "rmstar", "createdAt": "2020-03-25T00:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNDg1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -293,7 +267,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n         collector.addFailure(\n           String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n+                          stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n           .withConfigProperty(conf.JOIN_KEYS);\n       }\n       prevSchemaList = schemaList;\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -267,7 +266,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n         collector.addFailure(\n           String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                          stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n+                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n           .withConfigProperty(conf.JOIN_KEYS);\n       }\n       prevSchemaList = schemaList;\n", "next_change": {"commit": "9c6a15ea0d57aa8c2b33aa9dca2780e3b001e5bc", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..21eceecd 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -274,13 +298,13 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   }\n \n   Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n     requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n     duplicateFields = ArrayListMultimap.create();\n     List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n     if (outputFields.isEmpty()) {\n-      return null;\n+      // Could not derive output schema from input schema. Try to get output schema from config.\n+      return conf.getOutputSchema(collector);\n     } else {\n       return Schema.recordOf(\"join.output\", outputFields);\n     }\n", "next_change": {"commit": "da8b4e295145a36fed29df6074a748da0b7309e2", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 21eceecd..be36a977 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -297,22 +300,19 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     }\n   }\n \n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-    duplicateFields = ArrayListMultimap.create();\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n-    if (outputFields.isEmpty()) {\n-      // Could not derive output schema from input schema. Try to get output schema from config.\n+  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n+    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n+      // Cannot derive output schema from input schema. Try to get it from config.\n       return conf.getOutputSchema(collector);\n-    } else {\n-      return Schema.recordOf(\"join.output\", outputFields);\n     }\n+    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n+    return Schema.recordOf(\"join.output\", outputFields);\n   }\n \n   private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n+                                                             List<String> inputStages,\n                                                              FailureCollector collector) {\n-    validateRequiredInputs(inputSchemas, collector);\n+    validateRequiredInputs(inputStages, collector);\n     collector.getOrThrowException();\n \n     // stage name to input schema\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex be36a977..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,309 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(conf.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema '%s'.\",\n-                        inputFieldName, stageName, inputSchema), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(conf.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -301,15 +275,11 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   }\n \n   Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n+    requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n     duplicateFields = ArrayListMultimap.create();\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n-    if (outputFields.isEmpty()) {\n-      // Could not derive output schema from input schema. Try to get output schema from config.\n-      return conf.getOutputSchema(collector);\n-    } else {\n-      return Schema.recordOf(\"join.output\", outputFields);\n-    }\n+    return Schema.recordOf(\"join.output\", getOutputFields(createOutputFieldInfos(inputSchemas, collector)));\n   }\n \n   private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -279,7 +278,12 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n     duplicateFields = ArrayListMultimap.create();\n-    return Schema.recordOf(\"join.output\", getOutputFields(createOutputFieldInfos(inputSchemas, collector)));\n+    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n+    if (outputFields.isEmpty()) {\n+      return null;\n+    } else {\n+      return Schema.recordOf(\"join.output\", outputFields);\n+    }\n   }\n \n   private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -280,7 +297,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     duplicateFields = ArrayListMultimap.create();\n     List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n     if (outputFields.isEmpty()) {\n-      return null;\n+      // Could not derive output schema from input schema. Try to get output schema from config.\n+      return conf.getOutputSchema(collector);\n     } else {\n       return Schema.recordOf(\"join.output\", outputFields);\n     }\n", "next_change": {"commit": "da8b4e295145a36fed29df6074a748da0b7309e2", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..be36a977 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -290,23 +300,19 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     }\n   }\n \n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-    duplicateFields = ArrayListMultimap.create();\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n-    if (outputFields.isEmpty()) {\n-      // Could not derive output schema from input schema. Try to get output schema from config.\n+  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n+    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n+      // Cannot derive output schema from input schema. Try to get it from config.\n       return conf.getOutputSchema(collector);\n-    } else {\n-      return Schema.recordOf(\"join.output\", outputFields);\n     }\n+    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n+    return Schema.recordOf(\"join.output\", outputFields);\n   }\n \n   private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n+                                                             List<String> inputStages,\n                                                              FailureCollector collector) {\n-    validateRequiredInputs(inputSchemas, collector);\n+    validateRequiredInputs(inputStages, collector);\n     collector.getOrThrowException();\n \n     // stage name to input schema\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex be36a977..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,309 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(conf.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema '%s'.\",\n-                        inputFieldName, stageName, inputSchema), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(conf.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTI4NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397515285", "body": "nit: `JoinerConfig.JOIN_KEYS`", "bodyText": "nit: JoinerConfig.JOIN_KEYS", "bodyHTML": "<p dir=\"auto\">nit: <code>JoinerConfig.JOIN_KEYS</code></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:07:49Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -215,31 +259,57 @@ public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<Str\n   }\n \n   FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    Map<String, StageKeyInfo> keyInfos = new HashMap<>();\n-    StageKeyInfo prevKeyInfo = null;\n-    for (Map.Entry<String, List<String>> entry : conf.getPerStageJoinKeys().entrySet()) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n+    joinConfig = new JoinConfig(conf.getInputs());\n+    perStageSelectedFields = conf.getPerStageSelectedFields();\n+    return failureCollector;\n+  }\n+\n+  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n+                              FailureCollector collector) {\n+    perStageJoinKeys = joinKeys;\n+    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n+\n+    List<Schema> prevSchemaList = null;\n+    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n+      ArrayList<Schema> schemaList = new ArrayList<>();\n       String stageName = entry.getKey();\n-      StageKeyInfo keyInfo = new StageKeyInfo(stageName, inputSchemas.get(stageName),\n-                                              entry.getValue(), failureCollector);\n-      if (prevKeyInfo != null && !prevKeyInfo.getSchema().equals(keyInfo.getSchema())) {\n-        failureCollector.addFailure(\n+\n+      Schema schema = inputSchemas.get(stageName);\n+      if (schema == null) {\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n+      }\n+\n+      for (String joinKey : entry.getValue()) {\n+        Schema.Field field = schema.getField(joinKey);\n+        if (field == null) {\n+          collector.addFailure(\n+            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n+            .withConfigProperty(conf.JOIN_KEYS);\n+        }\n+        schemaList.add(field.getSchema());\n+      }\n+      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n+        collector.addFailure(\n           String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevKeyInfo.getFieldSchemas(), keyInfo.getFieldSchemas()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      } else {\n-        prevKeyInfo = keyInfo;\n+                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n+          .withConfigProperty(conf.JOIN_KEYS);", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0OTA0Ng==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397549046", "bodyText": "fixed.", "author": "rmstar", "createdAt": "2020-03-25T00:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -293,7 +267,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n         collector.addFailure(\n           String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n+                          stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n           .withConfigProperty(conf.JOIN_KEYS);\n       }\n       prevSchemaList = schemaList;\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -267,7 +266,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n       if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n         collector.addFailure(\n           String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                          stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n+                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n           .withConfigProperty(conf.JOIN_KEYS);\n       }\n       prevSchemaList = schemaList;\n", "next_change": {"commit": "9c6a15ea0d57aa8c2b33aa9dca2780e3b001e5bc", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..21eceecd 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -274,13 +298,13 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   }\n \n   Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n     requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n     duplicateFields = ArrayListMultimap.create();\n     List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n     if (outputFields.isEmpty()) {\n-      return null;\n+      // Could not derive output schema from input schema. Try to get output schema from config.\n+      return conf.getOutputSchema(collector);\n     } else {\n       return Schema.recordOf(\"join.output\", outputFields);\n     }\n", "next_change": {"commit": "da8b4e295145a36fed29df6074a748da0b7309e2", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 21eceecd..be36a977 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -297,22 +300,19 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     }\n   }\n \n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, FailureCollector collector) {\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-    duplicateFields = ArrayListMultimap.create();\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, collector));\n-    if (outputFields.isEmpty()) {\n-      // Could not derive output schema from input schema. Try to get output schema from config.\n+  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n+    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n+      // Cannot derive output schema from input schema. Try to get it from config.\n       return conf.getOutputSchema(collector);\n-    } else {\n-      return Schema.recordOf(\"join.output\", outputFields);\n     }\n+    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n+    return Schema.recordOf(\"join.output\", outputFields);\n   }\n \n   private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n+                                                             List<String> inputStages,\n                                                              FailureCollector collector) {\n-    validateRequiredInputs(inputSchemas, collector);\n+    validateRequiredInputs(inputStages, collector);\n     collector.getOrThrowException();\n \n     // stage name to input schema\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex be36a977..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,309 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(conf.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema '%s'.\",\n-                        inputFieldName, stageName, inputSchema), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(conf.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTMwMQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397515301", "body": "nit: `JoinerConfig.JOIN_KEYS`", "bodyText": "nit: JoinerConfig.JOIN_KEYS", "bodyHTML": "<p dir=\"auto\">nit: <code>JoinerConfig.JOIN_KEYS</code></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:07:53Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -215,31 +259,57 @@ public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<Str\n   }\n \n   FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    Map<String, StageKeyInfo> keyInfos = new HashMap<>();\n-    StageKeyInfo prevKeyInfo = null;\n-    for (Map.Entry<String, List<String>> entry : conf.getPerStageJoinKeys().entrySet()) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n+    joinConfig = new JoinConfig(conf.getInputs());\n+    perStageSelectedFields = conf.getPerStageSelectedFields();\n+    return failureCollector;\n+  }\n+\n+  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n+                              FailureCollector collector) {\n+    perStageJoinKeys = joinKeys;\n+    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n+\n+    List<Schema> prevSchemaList = null;\n+    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n+      ArrayList<Schema> schemaList = new ArrayList<>();\n       String stageName = entry.getKey();\n-      StageKeyInfo keyInfo = new StageKeyInfo(stageName, inputSchemas.get(stageName),\n-                                              entry.getValue(), failureCollector);\n-      if (prevKeyInfo != null && !prevKeyInfo.getSchema().equals(keyInfo.getSchema())) {\n-        failureCollector.addFailure(\n+\n+      Schema schema = inputSchemas.get(stageName);\n+      if (schema == null) {\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n+      }\n+\n+      for (String joinKey : entry.getValue()) {\n+        Schema.Field field = schema.getField(joinKey);\n+        if (field == null) {\n+          collector.addFailure(\n+            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n+            .withConfigProperty(conf.JOIN_KEYS);", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0OTA3Nw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397549077", "bodyText": "fixed.", "author": "rmstar", "createdAt": "2020-03-25T00:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -277,8 +251,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       Schema schema = inputSchemas.get(stageName);\n       if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n+        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n+        collector.getOrThrowException();\n       }\n \n       for (String joinKey : entry.getValue()) {\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -251,8 +267,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       Schema schema = inputSchemas.get(stageName);\n       if (schema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n       }\n \n       for (String joinKey : entry.getValue()) {\n", "next_change": {"commit": "be56392ba1be52b96d361ee0083b9a9e6484c687", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..23d43b7f 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -276,7 +286,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n         if (field == null) {\n           collector.addFailure(\n             String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n+            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n         }\n         schemaList.add(field.getSchema());\n       }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 23d43b7f..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,308 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema.\", inputFieldName, stageName), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(JoinerConfig.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjI2MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397516260", "body": "better: `return !inputSchemas.isEmpty() && inputSchemas.values().stream().noneMatch(Objects::isNull);`", "bodyText": "better: return !inputSchemas.isEmpty() && inputSchemas.values().stream().noneMatch(Objects::isNull);", "bodyHTML": "<p dir=\"auto\">better: <code>return !inputSchemas.isEmpty() &amp;&amp; inputSchemas.values().stream().noneMatch(Objects::isNull);</code></p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:10:31Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java", "diffHunk": "@@ -108,11 +121,30 @@ public String getRequiredInputs() {\n     return requiredInputs;\n   }\n \n+  @Nullable\n+  public Schema getOutputSchema(FailureCollector collector) {\n+    try {\n+      return Strings.isNullOrEmpty(schema) ? null : Schema.parseJson(schema);\n+    } catch (IOException e) {\n+      collector.addFailure(\"Invalid schema: \" + e.getMessage(), null).withConfigProperty(OUTPUT_SCHEMA);\n+    }\n+    // if there was an error that was added, it will throw an exception, otherwise, this statement will not be executed\n+    throw collector.getOrThrowException();\n+  }\n+\n+  public boolean inputSchemasAvailable(Map<String, Schema> inputSchemas) {\n+    // TODO: Remove isEmpty() check when CDAP-16351 is fixed\n+    return !inputSchemas.isEmpty() && !inputSchemas.values().stream().anyMatch(v -> v == null);", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM1OA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397516358", "bodyText": "the method can be package private", "author": "CuriousVini", "createdAt": "2020-03-24T23:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0OTE2OQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397549169", "bodyText": "fixed.", "author": "rmstar", "createdAt": "2020-03-25T00:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\nindex fc07a5ec..b09f6ec2 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\n", "chunk": "@@ -121,30 +106,9 @@ public class JoinerConfig extends PluginConfig {\n     return requiredInputs;\n   }\n \n-  @Nullable\n-  public Schema getOutputSchema(FailureCollector collector) {\n-    try {\n-      return Strings.isNullOrEmpty(schema) ? null : Schema.parseJson(schema);\n-    } catch (IOException e) {\n-      collector.addFailure(\"Invalid schema: \" + e.getMessage(), null).withConfigProperty(OUTPUT_SCHEMA);\n-    }\n-    // if there was an error that was added, it will throw an exception, otherwise, this statement will not be executed\n-    throw collector.getOrThrowException();\n-  }\n-\n-  public boolean inputSchemasAvailable(Map<String, Schema> inputSchemas) {\n-    // TODO: Remove isEmpty() check when CDAP-16351 is fixed\n-    return !inputSchemas.isEmpty() && !inputSchemas.values().stream().anyMatch(v -> v == null);\n-  }\n-\n \n   Map<String, List<String>> getPerStageJoinKeys() {\n-    // Use a LinkedHashMap to maintain the ordering as the input config.\n-    // This helps making error report deterministic.\n-    Map<String, List<String>> stageToKey = new LinkedHashMap<>();\n-    if (containsMacro(JoinerConfig.JOIN_KEYS)) {\n-      return stageToKey;\n-    }\n+    Map<String, List<String>> stageToKey = new HashMap<>();\n \n     if (Strings.isNullOrEmpty(joinKeys)) {\n       throw new IllegalArgumentException(\"Join keys can not be empty\");\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\nindex b09f6ec2..4f6b8c4b 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\n", "chunk": "@@ -106,9 +112,11 @@ public class JoinerConfig extends PluginConfig {\n     return requiredInputs;\n   }\n \n-\n   Map<String, List<String>> getPerStageJoinKeys() {\n     Map<String, List<String>> stageToKey = new HashMap<>();\n+    if (containsMacro(JoinerConfig.JOIN_KEYS)) {\n+      return stageToKey;\n+    }\n \n     if (Strings.isNullOrEmpty(joinKeys)) {\n       throw new IllegalArgumentException(\"Join keys can not be empty\");\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\nindex 4f6b8c4b..d2af7d4b 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/JoinerConfig.java\n", "chunk": "@@ -99,33 +122,37 @@ public class JoinerConfig extends PluginConfig {\n     return numPartitions;\n   }\n \n-  public String getSelectedFields() {\n-    return selectedFields;\n-  }\n-\n-  public String getJoinKeys() {\n-    return joinKeys;\n+  @Nullable\n+  public Schema getOutputSchema(FailureCollector collector) {\n+    try {\n+      return Strings.isNullOrEmpty(schema) ? null : Schema.parseJson(schema);\n+    } catch (IOException e) {\n+      collector.addFailure(\"Invalid schema: \" + e.getMessage(), null).withConfigProperty(OUTPUT_SCHEMA);\n+    }\n+    // if there was an error that was added, it will throw an exception, otherwise, this statement will not be executed\n+    throw collector.getOrThrowException();\n   }\n \n-  @Nullable\n-  public String getRequiredInputs() {\n-    return requiredInputs;\n+  boolean requiredPropertiesContainMacros() {\n+    return containsMacro(SELECTED_FIELDS) || containsMacro(REQUIRED_INPUTS) || containsMacro(JOIN_KEYS) ||\n+      containsMacro(OUTPUT_SCHEMA);\n   }\n \n-  Map<String, List<String>> getPerStageJoinKeys() {\n-    Map<String, List<String>> stageToKey = new HashMap<>();\n-    if (containsMacro(JoinerConfig.JOIN_KEYS)) {\n-      return stageToKey;\n-    }\n+  Set<JoinKey> getJoinKeys(FailureCollector failureCollector) {\n+    // Use a LinkedHashMap to maintain the ordering as the input config.\n+    // This helps making error report deterministic.\n+    Map<String, List<String>> stageToKey = new LinkedHashMap<>();\n \n     if (Strings.isNullOrEmpty(joinKeys)) {\n-      throw new IllegalArgumentException(\"Join keys can not be empty\");\n+      failureCollector.addFailure(\"Join keys cannot be empty\", null).withConfigProperty(JOIN_KEYS);\n+      throw failureCollector.getOrThrowException();\n     }\n \n     Iterable<String> multipleJoinKeys = Splitter.on('&').trimResults().omitEmptyStrings().split(joinKeys);\n \n     if (Iterables.isEmpty(multipleJoinKeys)) {\n-      throw new IllegalArgumentException(\"Join keys can not be empty.\");\n+      failureCollector.addFailure(\"Join keys cannot be empty\", null).withConfigProperty(JOIN_KEYS);\n+      throw failureCollector.getOrThrowException();\n     }\n \n     int numJoinKeys = 0;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMzUzMw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397523533", "body": "`!inputSchemas.isEmpty() ` - this is same check as `inputSchemasAvailable` right? ", "bodyText": "!inputSchemas.isEmpty()  - this is same check as inputSchemasAvailable right?", "bodyHTML": "<p dir=\"auto\"><code>!inputSchemas.isEmpty() </code> - this is same check as <code>inputSchemasAvailable</code> right?</p>", "author": "CuriousVini", "createdAt": "2020-03-24T23:30:59Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -477,7 +479,7 @@ public String toString() {\n \n   private void validateRequiredInputs(Map<String, Schema> inputSchemas, FailureCollector collector) {\n     for (String requiredInput : conf.getInputs()) {\n-      if (!inputSchemas.containsKey(requiredInput)) {\n+      if (!inputSchemas.isEmpty() && !inputSchemas.containsKey(requiredInput)) {", "originalCommit": "c08e21e077b35a9dac3203d08d51a5ec47ea29a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU1MDExMw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397550113", "bodyText": "It's a bit different: inputSchemasAvailable returns true if:\n\ninputSchemas is not empty, and\nNone of the values (i.e. schemas) in inputSchemas is null.", "author": "rmstar", "createdAt": "2020-03-25T00:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMzUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU1MjA3Ng==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397552076", "bodyText": "I think we can use inputSchemasAvailable here like you suggested. will fix.", "author": "rmstar", "createdAt": "2020-03-25T01:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMzUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex f102d54c..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -478,10 +443,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   }\n \n   private void validateRequiredInputs(Map<String, Schema> inputSchemas, FailureCollector collector) {\n-    for (String requiredInput : conf.getInputs()) {\n-      if (!inputSchemas.isEmpty() && !inputSchemas.containsKey(requiredInput)) {\n+    for (String requiredInput : requiredInputs) {\n+      if (!inputSchemas.containsKey(requiredInput)) {\n         collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n+          .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n       }\n     }\n   }\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -444,7 +471,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n   private void validateRequiredInputs(Map<String, Schema> inputSchemas, FailureCollector collector) {\n     for (String requiredInput : requiredInputs) {\n-      if (!inputSchemas.containsKey(requiredInput)) {\n+      if (!inputSchemas.isEmpty() && !inputSchemas.containsKey(requiredInput)) {\n         collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n           .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n       }\n", "next_change": {"commit": "da8b4e295145a36fed29df6074a748da0b7309e2", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..be36a977 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -469,9 +475,9 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     }\n   }\n \n-  private void validateRequiredInputs(Map<String, Schema> inputSchemas, FailureCollector collector) {\n+  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n     for (String requiredInput : requiredInputs) {\n-      if (!inputSchemas.isEmpty() && !inputSchemas.containsKey(requiredInput)) {\n+      if (!inputStages.contains(requiredInput)) {\n         collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n           .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n       }\n", "next_change": {"commit": "be56392ba1be52b96d361ee0083b9a9e6484c687", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex be36a977..23d43b7f 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -479,7 +478,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     for (String requiredInput : requiredInputs) {\n       if (!inputStages.contains(requiredInput)) {\n         collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(conf.REQUIRED_INPUTS, requiredInput);\n+          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n       }\n     }\n   }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 23d43b7f..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,308 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema.\", inputFieldName, stageName), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(JoinerConfig.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMTIzNg==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397601236", "body": "nit: extra line", "bodyText": "nit: extra line", "bodyHTML": "<p dir=\"auto\">nit: extra line</p>", "author": "CuriousVini", "createdAt": "2020-03-25T04:18:22Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -68,11 +64,13 @@\n   static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n   static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n \n+", "originalCommit": "2dc61e037c1e02e154e90831a7f8a3f6027629f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwOTU1NA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397609554", "bodyText": "fixed", "author": "rmstar", "createdAt": "2020-03-25T04:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex bad7972a..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -60,17 +59,16 @@ import java.util.Set;\n   \"inputs, outer join will be performed\")\n public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, StructuredRecord> {\n \n-  static final String JOIN_OPERATION_DESCRIPTION = \"Used as a key in a join\";\n-  static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n-  static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n-\n+  public static final String JOIN_OPERATION_DESCRIPTION = \"Used as a key in a join\";\n+  public static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n+  public static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n \n   private final JoinerConfig conf;\n   private Schema outputSchema;\n   private Map<String, List<String>> perStageJoinKeys;\n   private Table<String, String, String> perStageSelectedFields;\n-  private JoinConfig joinConfig;\n-  private Map<String, Schema> keySchemas = new HashMap<>();\n+  private Set<String> requiredInputs;\n+  private Multimap<String, String> duplicateFields = ArrayListMultimap.create();\n \n   public Joiner(JoinerConfig conf) {\n     this.conf = conf;\n", "next_change": {"commit": "9c6a15ea0d57aa8c2b33aa9dca2780e3b001e5bc", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..21eceecd 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -69,6 +69,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   private Table<String, String, String> perStageSelectedFields;\n   private Set<String> requiredInputs;\n   private Multimap<String, String> duplicateFields = ArrayListMultimap.create();\n+  private Map<String, Schema> keySchemas = new HashMap<>();\n \n   public Joiner(JoinerConfig conf) {\n     this.conf = conf;\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 21eceecd..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -57,41 +60,83 @@ import java.util.Set;\n   \"required inputs, inner join will be performed. Otherwise inner join will be performed on required inputs and \" +\n   \"records from non-required inputs will only be present if they match join criteria. If there are no required \" +\n   \"inputs, outer join will be performed\")\n-public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, StructuredRecord> {\n+public class Joiner extends BatchAutoJoiner {\n \n   public static final String JOIN_OPERATION_DESCRIPTION = \"Used as a key in a join\";\n   public static final String IDENTITY_OPERATION_DESCRIPTION = \"Unchanged as part of a join\";\n   public static final String RENAME_OPERATION_DESCRIPTION = \"Renamed as a part of a join\";\n \n   private final JoinerConfig conf;\n-  private Schema outputSchema;\n-  private Map<String, List<String>> perStageJoinKeys;\n-  private Table<String, String, String> perStageSelectedFields;\n-  private Set<String> requiredInputs;\n-  private Multimap<String, String> duplicateFields = ArrayListMultimap.create();\n-  private Map<String, Schema> keySchemas = new HashMap<>();\n \n   public Joiner(JoinerConfig conf) {\n     this.conf = conf;\n   }\n \n+  @Nullable\n   @Override\n-  public void configurePipeline(MultiInputPipelineConfigurer pipelineConfigurer) {\n-    MultiInputStageConfigurer stageConfigurer = pipelineConfigurer.getMultiInputStageConfigurer();\n-    Map<String, Schema> inputSchemas = stageConfigurer.getInputSchemas();\n-    FailureCollector collector = pipelineConfigurer.getMultiInputStageConfigurer().getFailureCollector();\n-    init(inputSchemas, collector);\n-    collector.getOrThrowException();\n-    if (!conf.inputSchemasAvailable(inputSchemas) && !conf.containsMacro(conf.OUTPUT_SCHEMA) &&\n+  public JoinDefinition define(AutoJoinerContext context) {\n+    FailureCollector collector = context.getFailureCollector();\n+\n+    boolean hasUnknownInputSchema = context.getInputStages().values().stream().anyMatch(Objects::isNull);\n+    if (hasUnknownInputSchema && !conf.containsMacro(JoinerConfig.OUTPUT_SCHEMA) &&\n       conf.getOutputSchema(collector) == null) {\n       // If input schemas are unknown, an output schema must be provided.\n-      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(conf.OUTPUT_SCHEMA);\n-    }\n-\n-    Schema outputSchema = getOutputSchema(inputSchemas, collector);\n-    if (outputSchema != null) {\n-      // Set output schema if it's not a macro.\n-      stageConfigurer.setOutputSchema(outputSchema);\n+      collector.addFailure(\"Output schema must be specified\", null).withConfigProperty(JoinerConfig.OUTPUT_SCHEMA);\n+    }\n+\n+    if (conf.requiredPropertiesContainMacros()) {\n+      return null;\n+    }\n+\n+    Set<String> requiredStages = conf.getRequiredInputs();\n+    Set<String> broadcastStages = conf.getBroadcastInputs();\n+    List<JoinStage> inputs = new ArrayList<>(context.getInputStages().size());\n+    boolean useOutputSchema = false;\n+    for (JoinStage joinStage : context.getInputStages().values()) {\n+      inputs.add(JoinStage.builder(joinStage)\n+        .setRequired(requiredStages.contains(joinStage.getStageName()))\n+        .setBroadcast(broadcastStages.contains(joinStage.getStageName()))\n+        .build());\n+      useOutputSchema = useOutputSchema || joinStage.getSchema() == null;\n+    }\n+\n+    try {\n+      JoinDefinition.Builder joinBuilder = JoinDefinition.builder()\n+        .select(conf.getSelectedFields(collector))\n+        .from(inputs)\n+        .on(JoinCondition.onKeys()\n+              .setKeys(conf.getJoinKeys(collector))\n+              .setNullSafe(conf.isNullSafe())\n+              .build());\n+      if (useOutputSchema) {\n+        joinBuilder.setOutputSchema(conf.getOutputSchema(collector));\n+      } else {\n+        joinBuilder.setOutputSchemaName(\"join.output\");\n+      }\n+      return joinBuilder.build();\n+    } catch (InvalidJoinException e) {\n+      if (e.getErrors().isEmpty()) {\n+        collector.addFailure(e.getMessage(), null);\n+      }\n+      for (JoinError error : e.getErrors()) {\n+        ValidationFailure failure = collector.addFailure(error.getMessage(), error.getCorrectiveAction());\n+        switch (error.getType()) {\n+          case JOIN_KEY:\n+          case JOIN_KEY_FIELD:\n+            failure.withConfigProperty(JoinerConfig.JOIN_KEYS);\n+            break;\n+          case SELECTED_FIELD:\n+            JoinField badField = ((SelectedFieldError) error).getField();\n+            failure.withConfigElement(\n+              JoinerConfig.SELECTED_FIELDS,\n+              String.format(\"%s.%s as %s\", badField.getStageName(), badField.getFieldName(), badField.getAlias()));\n+            break;\n+          case OUTPUT_SCHEMA:\n+            OutputSchemaError schemaError = (OutputSchemaError) error;\n+            failure.withOutputSchemaField(schemaError.getField());\n+        }\n+      }\n+      throw collector.getOrThrowException();\n     }\n   }\n \n", "next_change": {"commit": "d559bbd6b9b37cec2e36a6139932da239a7a8d46", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -134,6 +140,16 @@ public class Joiner extends BatchAutoJoiner {\n           case OUTPUT_SCHEMA:\n             OutputSchemaError schemaError = (OutputSchemaError) error;\n             failure.withOutputSchemaField(schemaError.getField());\n+            break;\n+          case DISTRIBUTION_SIZE:\n+            failure.withConfigProperty(JoinerConfig.DISTRIBUTION_FACTOR);\n+            break;\n+          case DISTRIBUTION_STAGE:\n+            failure.withConfigProperty(JoinerConfig.DISTRIBUTION_STAGE);\n+            break;\n+          case BROADCAST:\n+            failure.withConfigProperty(JoinerConfig.MEMORY_INPUTS);\n+            break;\n         }\n       }\n       throw collector.getOrThrowException();\n", "next_change": {"commit": "474dd52f224342bd7c70bb622a78436c7e25fe68", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 883f4156..14b4dc71 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -150,6 +154,8 @@ public class Joiner extends BatchAutoJoiner {\n           case BROADCAST:\n             failure.withConfigProperty(JoinerConfig.MEMORY_INPUTS);\n             break;\n+          case INVALID_CONDITION:\n+            failure.withConfigProperty(JoinerConfig.CONDITION_EXPR);\n         }\n       }\n       throw collector.getOrThrowException();\n", "next_change": null}]}}, {"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..883f4156 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -144,6 +160,10 @@ public class Joiner extends BatchAutoJoiner {\n   public void prepareRun(BatchJoinerContext context) {\n     if (conf.getNumPartitions() != null) {\n       context.setNumPartitions(conf.getNumPartitions());\n+      if (conf.getDistributionFactor() != null && conf.getDistributionFactor() < conf.getNumPartitions()) {\n+        LOG.warn(\"Number of partitions ({}) should be greater than or equal to distribution factor ({}) for optimal \"\n+                   + \"results.\", conf.getNumPartitions(), conf.getDistributionFactor());\n+      }\n     }\n     FailureCollector collector = context.getFailureCollector();\n     context.record(createFieldOperations(conf.getSelectedFields(collector),\n", "next_change": {"commit": "474dd52f224342bd7c70bb622a78436c7e25fe68", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 883f4156..14b4dc71 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -166,8 +172,10 @@ public class Joiner extends BatchAutoJoiner {\n       }\n     }\n     FailureCollector collector = context.getFailureCollector();\n-    context.record(createFieldOperations(conf.getSelectedFields(collector),\n-                                         conf.getJoinKeys(collector)));\n+    JoinCondition.Op conditionType = conf.getCondition(collector).getOp();\n+    Set<JoinKey> keys = conditionType == JoinCondition.Op.KEY_EQUALITY ?\n+      conf.getJoinKeys(collector) : Collections.emptySet();\n+    context.record(createFieldOperations(conf.getSelectedFields(collector), keys));\n   }\n \n   /**\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjA1MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397606050", "body": "nit: indentation", "bodyText": "nit: indentation", "bodyHTML": "<p dir=\"auto\">nit: indentation</p>", "author": "CuriousVini", "createdAt": "2020-03-25T04:40:57Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java", "diffHunk": "@@ -214,32 +257,59 @@ public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<Str\n     return outRecordBuilder.build();\n   }\n \n+  @VisibleForTesting\n   FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    Map<String, StageKeyInfo> keyInfos = new HashMap<>();\n-    StageKeyInfo prevKeyInfo = null;\n-    for (Map.Entry<String, List<String>> entry : conf.getPerStageJoinKeys().entrySet()) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n+    joinConfig = new JoinConfig(conf.getInputs());\n+    perStageSelectedFields = conf.getPerStageSelectedFields();\n+    return failureCollector;\n+  }\n+\n+  private void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n+                              FailureCollector collector) {", "originalCommit": "2dc61e037c1e02e154e90831a7f8a3f6027629f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwOTU3Mw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1045#discussion_r397609573", "bodyText": "fixed", "author": "rmstar", "createdAt": "2020-03-25T04:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjA1MA=="}], "type": "inlineReview", "revised_code": {"commit": "4fe64954e64347a7aa81a3f3e59ea2919654f245", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex bad7972a..a1b4b35a 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -257,18 +228,21 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n     return outRecordBuilder.build();\n   }\n \n-  @VisibleForTesting\n-  FailureCollector init(Map<String, Schema> inputSchemas, FailureCollector failureCollector) {\n-    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), failureCollector);\n-    joinConfig = new JoinConfig(conf.getInputs());\n+  void init(Map<String, Schema> inputSchemas, FailureCollector collector) {\n+    validateJoinKeySchemas(inputSchemas, conf.getPerStageJoinKeys(), collector);\n+    requiredInputs = conf.getInputs();\n     perStageSelectedFields = conf.getPerStageSelectedFields();\n-    return failureCollector;\n   }\n \n-  private void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n+  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n                               FailureCollector collector) {\n     perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n+\n+    if (perStageJoinKeys.size() != inputSchemas.size()) {\n+      collector.addFailure(\"There should be join keys present from each stage.\",\n+                           \"Ensure join keys are present from each stage.\")\n+        .withConfigProperty(conf.JOIN_KEYS);\n+    }\n \n     List<Schema> prevSchemaList = null;\n     for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n", "next_change": {"commit": "e5a53606f061e500b59b7adb0c36e3e5432bb4e8", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex a1b4b35a..95194c42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -237,12 +241,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n   void validateJoinKeySchemas(Map<String, Schema> inputSchemas, Map<String, List<String>> joinKeys,\n                               FailureCollector collector) {\n     perStageJoinKeys = joinKeys;\n-\n-    if (perStageJoinKeys.size() != inputSchemas.size()) {\n-      collector.addFailure(\"There should be join keys present from each stage.\",\n-                           \"Ensure join keys are present from each stage.\")\n-        .withConfigProperty(conf.JOIN_KEYS);\n-    }\n+    conf.validateJoinKeySchemas(inputSchemas, joinKeys, collector);\n \n     List<Schema> prevSchemaList = null;\n     for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n", "next_change": {"commit": "73104a9073184a47d607ad5d890c9614b46a1480", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 95194c42..d3758786 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -250,8 +267,8 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       Schema schema = inputSchemas.get(stageName);\n       if (schema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n+        // Input schema will be null if the output schema of the previous node is a macro\n+        return;\n       }\n \n       for (String joinKey : entry.getValue()) {\n", "next_change": {"commit": "be56392ba1be52b96d361ee0083b9a9e6484c687", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex d3758786..23d43b7f 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -276,7 +286,7 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n         if (field == null) {\n           collector.addFailure(\n             String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(conf.JOIN_KEYS);\n+            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n         }\n         schemaList.add(field.getSchema());\n       }\n", "next_change": {"commit": "2db3d7cc38f28bb9f4690fa660df2f5d6741cfda", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 23d43b7f..1296491d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -178,308 +214,10 @@ public class Joiner extends BatchJoiner<StructuredRecord, StructuredRecord, Stru\n \n       FieldOperation transform = new FieldTransformOperation(operationName, RENAME_OPERATION_DESCRIPTION,\n                                                              Collections.singletonList(stagedInputField),\n-                                                             outputFieldInfo.name);\n+                                                             outputFieldName);\n       operations.add(transform);\n     }\n \n     return operations;\n   }\n-\n-  @Override\n-  public void initialize(BatchJoinerRuntimeContext context) {\n-    FailureCollector collector = context.getFailureCollector();\n-    Map<String, Schema> inputSchemas = context.getInputSchemas();\n-    List<String> inputStages = context.getInputStages();\n-    init(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-    outputSchema = getOutputSchema(inputSchemas, inputStages, collector);\n-    collector.getOrThrowException();\n-  }\n-\n-  @Override\n-  public StructuredRecord joinOn(String stageName, StructuredRecord record) {\n-    Schema keySchema;\n-    List<String> joinKeys = perStageJoinKeys.get(stageName);\n-\n-    if (keySchemas.containsKey(stageName)) {\n-      keySchema = keySchemas.get(stageName);\n-    } else {\n-      List<Schema.Field> fields = new ArrayList<>();\n-      Schema schema = record.getSchema();\n-\n-      int i = 1;\n-      for (String joinKey : joinKeys) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          throw new IllegalArgumentException(String.format(\"Join key field '%s' does not exist in schema from '%s'.\",\n-                  joinKey, stageName));\n-        }\n-        Schema.Field joinField = Schema.Field.of(String.valueOf(i++), field.getSchema());\n-        fields.add(joinField);\n-      }\n-      keySchema = Schema.recordOf(\"join.key\", fields);\n-      keySchemas.put(stageName, keySchema);\n-    }\n-    StructuredRecord.Builder keyRecordBuilder = StructuredRecord.builder(keySchema);\n-    int i = 1;\n-    for (String joinKey : joinKeys) {\n-      keyRecordBuilder.set(String.valueOf(i++), record.get(joinKey));\n-    }\n-\n-    return keyRecordBuilder.build();\n-  }\n-\n-  @Override\n-  public JoinConfig getJoinConfig() {\n-    return new JoinConfig(requiredInputs);\n-  }\n-\n-  @Override\n-  public StructuredRecord merge(StructuredRecord joinKey, Iterable<JoinElement<StructuredRecord>> joinRow) {\n-    StructuredRecord.Builder outRecordBuilder = StructuredRecord.builder(outputSchema);\n-\n-    for (JoinElement<StructuredRecord> joinElement : joinRow) {\n-      String stageName = joinElement.getStageName();\n-      StructuredRecord record = joinElement.getInputRecord();\n-\n-      Map<String, String> selectedFields = perStageSelectedFields.row(stageName);\n-\n-      for (Schema.Field field : record.getSchema().getFields()) {\n-        String inputFieldName = field.getName();\n-\n-        // drop the field if not part of fieldsToRename\n-        if (!selectedFields.containsKey(inputFieldName)) {\n-          continue;\n-        }\n-\n-        String outputFieldName = selectedFields.get(inputFieldName);\n-        outRecordBuilder.set(outputFieldName, record.get(inputFieldName));\n-      }\n-    }\n-    return outRecordBuilder.build();\n-  }\n-\n-  void init(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    validateJoinKeySchemas(inputSchemas, inputStages, conf.getPerStageJoinKeys(), collector);\n-    requiredInputs = conf.getInputs();\n-    perStageSelectedFields = conf.getPerStageSelectedFields();\n-  }\n-\n-  void validateJoinKeySchemas(Map<String, Schema> inputSchemas, List<String> inputStages,\n-                              Map<String, List<String>> joinKeys, FailureCollector collector) {\n-    perStageJoinKeys = joinKeys;\n-    conf.validateJoinKeySchemas(inputSchemas, inputStages, joinKeys, collector);\n-\n-    List<Schema> prevSchemaList = null;\n-    for (Map.Entry<String, List<String>> entry : perStageJoinKeys.entrySet()) {\n-      ArrayList<Schema> schemaList = new ArrayList<>();\n-      String stageName = entry.getKey();\n-\n-      Schema schema = inputSchemas.get(stageName);\n-      if (schema == null) {\n-        // Input schema will be null if the output schema of the previous node is a macro\n-        return;\n-      }\n-\n-      for (String joinKey : entry.getValue()) {\n-        Schema.Field field = schema.getField(joinKey);\n-        if (field == null) {\n-          collector.addFailure(\n-            String.format(\"Join key field '%s' is not present in input stage of '%s'.\", joinKey, stageName), null)\n-            .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-        }\n-        schemaList.add(field.getSchema());\n-      }\n-      if (prevSchemaList != null && !prevSchemaList.equals(schemaList)) {\n-        collector.addFailure(\n-          String.format(\"For stage '%s', Schemas of join keys '%s' are expected to be: '%s', but found: '%s'.\",\n-                        stageName, entry.getValue(), prevSchemaList.toString(), schemaList.toString()), null)\n-          .withConfigProperty(JoinerConfig.JOIN_KEYS);\n-      }\n-      prevSchemaList = schemaList;\n-    }\n-  }\n-\n-  Schema getOutputSchema(Map<String, Schema> inputSchemas, List<String> inputStages, FailureCollector collector) {\n-    if (!inputSchemasAvailable(inputSchemas, inputStages)) {\n-      // Cannot derive output schema from input schema. Try to get it from config.\n-      return conf.getOutputSchema(collector);\n-    }\n-    List<Schema.Field> outputFields = getOutputFields(createOutputFieldInfos(inputSchemas, inputStages, collector));\n-    return Schema.recordOf(\"join.output\", outputFields);\n-  }\n-\n-  private Collection<OutputFieldInfo> createOutputFieldInfos(Map<String, Schema> inputSchemas,\n-                                                             List<String> inputStages,\n-                                                             FailureCollector collector) {\n-    validateRequiredInputs(inputStages, collector);\n-    collector.getOrThrowException();\n-\n-    // stage name to input schema\n-    Map<String, Schema> inputs = new HashMap<>(inputSchemas);\n-    // Selected Field name to output field info\n-    Map<String, OutputFieldInfo> outputFieldInfo = new LinkedHashMap<>();\n-    List<String> duplicateAliases = new ArrayList<>();\n-\n-    // order of fields in output schema will be same as order of selectedFields\n-    Set<Table.Cell<String, String, String>> rows = perStageSelectedFields.cellSet();\n-    for (Table.Cell<String, String, String> row : rows) {\n-      String stageName = row.getRowKey();\n-      String inputFieldName = row.getColumnKey();\n-      String alias = row.getValue();\n-      Schema inputSchema = inputs.get(stageName);\n-\n-      if (inputSchema == null) {\n-        collector.addFailure(String.format(\"Input schema for input stage '%s' cannot be null.\", stageName), null);\n-        collector.getOrThrowException();\n-      }\n-\n-      if (outputFieldInfo.containsKey(alias)) {\n-        OutputFieldInfo outInfo = outputFieldInfo.get(alias);\n-        if (duplicateAliases.add(alias)) {\n-          duplicateFields.put(outInfo.getStageName(), outInfo.getInputFieldName());\n-        }\n-        duplicateFields.put(stageName, inputFieldName);\n-        continue;\n-      }\n-\n-      Schema.Field inputField = inputSchema.getField(inputFieldName);\n-      if (inputField == null) {\n-        collector.addFailure(\n-          String.format(\"Field '%s' of stage '%s' must be present in input schema.\", inputFieldName, stageName), null)\n-          .withConfigElement(\"selectedFields\",\n-                             String.format(\"%s.%s as %s\", stageName, inputFieldName, alias));\n-      } else if (requiredInputs.contains(stageName) || inputField.getSchema().isNullable()) {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias, inputField.getSchema())));\n-      } else {\n-        outputFieldInfo.put(alias, new OutputFieldInfo(alias, stageName, inputFieldName,\n-                                                       Schema.Field.of(alias,\n-                                                                       Schema.nullableOf(inputField.getSchema()))));\n-      }\n-    }\n-\n-    if (!duplicateFields.isEmpty()) {\n-      collector.addFailure(String.format(\"Output schema must not contain duplicate fields: '%s' for aliases: '%s'.\",\n-                                         duplicateFields, duplicateAliases), null)\n-        .withConfigProperty(JoinerConfig.SELECTED_FIELDS);\n-      collector.getOrThrowException();\n-    }\n-\n-    return outputFieldInfo.values();\n-  }\n-\n-  private List<Schema.Field> getOutputFields(Collection<OutputFieldInfo> fieldsInfo) {\n-    List<Schema.Field> outputFields = new ArrayList<>();\n-    for (OutputFieldInfo fieldInfo : fieldsInfo) {\n-      outputFields.add(fieldInfo.getField());\n-    }\n-    return outputFields;\n-  }\n-\n-  private boolean inputSchemasAvailable(Map<String, Schema> inputSchemas, List<String> inputStages) {\n-    return inputSchemas.keySet().containsAll(inputStages) &&\n-      inputSchemas.values().stream().noneMatch(Objects::isNull);\n-  }\n-\n-  /**\n-   * Class to hold information about output fields\n-   */\n-  @VisibleForTesting\n-  static class OutputFieldInfo {\n-    private String name;\n-    private String stageName;\n-    private String inputFieldName;\n-    private Schema.Field field;\n-\n-    OutputFieldInfo(String name, String stageName, String inputFieldName, Schema.Field field) {\n-      this.name = name;\n-      this.stageName = stageName;\n-      this.inputFieldName = inputFieldName;\n-      this.field = field;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-\n-    public void setName(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getStageName() {\n-      return stageName;\n-    }\n-\n-    public void setStageName(String stageName) {\n-      this.stageName = stageName;\n-    }\n-\n-    public String getInputFieldName() {\n-      return inputFieldName;\n-    }\n-\n-    public void setInputFieldName(String inputFieldName) {\n-      this.inputFieldName = inputFieldName;\n-    }\n-\n-    public Schema.Field getField() {\n-      return field;\n-    }\n-\n-    public void setField(Schema.Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      OutputFieldInfo that = (OutputFieldInfo) o;\n-\n-      if (!name.equals(that.name)) {\n-        return false;\n-      }\n-      if (!stageName.equals(that.stageName)) {\n-        return false;\n-      }\n-      if (!inputFieldName.equals(that.inputFieldName)) {\n-        return false;\n-      }\n-      return field.equals(that.field);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      int result = name.hashCode();\n-      result = 31 * result + stageName.hashCode();\n-      result = 31 * result + inputFieldName.hashCode();\n-      result = 31 * result + field.hashCode();\n-      return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return \"OutputFieldInfo{\" +\n-        \"name='\" + name + '\\'' +\n-        \", stageName='\" + stageName + '\\'' +\n-        \", inputFieldName='\" + inputFieldName + '\\'' +\n-        \", field=\" + field +\n-        '}';\n-    }\n-  }\n-\n-  private void validateRequiredInputs(List<String> inputStages, FailureCollector collector) {\n-    for (String requiredInput : requiredInputs) {\n-      if (!inputStages.contains(requiredInput)) {\n-        collector.addFailure(String.format(\"Provided input '%s' must be an input stage name.\", requiredInput), null)\n-          .withConfigElement(JoinerConfig.REQUIRED_INPUTS, requiredInput);\n-      }\n-    }\n-  }\n }\n", "next_change": {"commit": "193506ee408f9aac4e548f740c57c197d53bfcd6", "changed_code": [{"header": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\nindex 1296491d..99af8634 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/joiner/Joiner.java\n", "chunk": "@@ -220,4 +281,24 @@ public class Joiner extends BatchAutoJoiner {\n \n     return operations;\n   }\n+\n+  /**\n+   * Reorders join stages so the supplied stage name is always first.\n+   * @param stages list of input stages\n+   * @param leftStage stage to move to the first position in the input list.\n+   */\n+  protected void reorderJoinStages(List<JoinStage> stages, String leftStage) {\n+    stages.sort((js1, js2) -> {\n+      String s1 = js1.getStageName();\n+      String s2 = js2.getStageName();\n+\n+      if (!s1.equals(leftStage) && s2.equals(leftStage)) {\n+        return 1;\n+      } else if (s1.equals(leftStage) && !s2.equals(leftStage)) {\n+        return -1;\n+      } else {\n+        return 0;\n+      }\n+    });\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "6f79248b37829f0a26ead6bb961e8b9f7403c084", "url": "https://github.com/cdapio/hydrator-plugins/commit/6f79248b37829f0a26ead6bb961e8b9f7403c084", "message": "Cherry pick fixes to support macros in joiner plugin", "committedDate": "2020-03-25T04:51:42Z", "type": "commit"}, {"oid": "6f79248b37829f0a26ead6bb961e8b9f7403c084", "url": "https://github.com/cdapio/hydrator-plugins/commit/6f79248b37829f0a26ead6bb961e8b9f7403c084", "message": "Cherry pick fixes to support macros in joiner plugin", "committedDate": "2020-03-25T04:51:42Z", "type": "forcePushed"}]}