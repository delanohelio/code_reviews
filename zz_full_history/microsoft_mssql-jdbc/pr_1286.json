{"pr_number": 1286, "pr_title": "Feature | Added support for authentication to Azure Key Vault using Managed Identity", "pr_author": "lilgreenbird", "pr_createdAt": "2020-03-18T02:11:55Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1286", "timeline": [{"oid": "c97b863c95385bdcd1afc897ef39cbebaf495578", "url": "https://github.com/microsoft/mssql-jdbc/commit/c97b863c95385bdcd1afc897ef39cbebaf495578", "message": "Fix AEv2 tests exclude for reqExternalSetup and cleanup (#1247)", "committedDate": "2020-02-05T19:03:48Z", "type": "commit"}, {"oid": "54b5a194e5d46552419c86e0d1f8c800f42d3de8", "url": "https://github.com/microsoft/mssql-jdbc/commit/54b5a194e5d46552419c86e0d1f8c800f42d3de8", "message": "Fix | Add null check for getObject() with LocalTime and LocalDate (#1250)", "committedDate": "2020-02-08T00:19:05Z", "type": "commit"}, {"oid": "672b7d67caae75250c53f82a760e8d3880e62a37", "url": "https://github.com/microsoft/mssql-jdbc/commit/672b7d67caae75250c53f82a760e8d3880e62a37", "message": "added all AKV tests to use reqExternalSetup tag so they will be skipped by default (#1254)\n\n* skip AKV test properly\r\n\r\n* removed enclave properties string to failed errors as enclave tests could be skipped", "committedDate": "2020-02-10T19:04:22Z", "type": "commit"}, {"oid": "32c21f5fef64d28468647f1fbab21aa767d0605f", "url": "https://github.com/microsoft/mssql-jdbc/commit/32c21f5fef64d28468647f1fbab21aa767d0605f", "message": "msi for akv", "committedDate": "2020-03-04T20:48:15Z", "type": "commit"}, {"oid": "b706fb3f0896a086b18a2c4f9edc517dbcb274d1", "url": "https://github.com/microsoft/mssql-jdbc/commit/b706fb3f0896a086b18a2c4f9edc517dbcb274d1", "message": "Merge remote-tracking branch 'upstream/dev' into msi", "committedDate": "2020-03-06T04:52:26Z", "type": "commit"}, {"oid": "9e368a578d2dc0c720c5b34c0a0dfbe2a0c0a2d1", "url": "https://github.com/microsoft/mssql-jdbc/commit/9e368a578d2dc0c720c5b34c0a0dfbe2a0c0a2d1", "message": "msi tests", "committedDate": "2020-03-09T23:36:11Z", "type": "commit"}, {"oid": "28bb1ee936deeef9790810f1cd02b57b81940414", "url": "https://github.com/microsoft/mssql-jdbc/commit/28bb1ee936deeef9790810f1cd02b57b81940414", "message": "added new props for AKV with MSI", "committedDate": "2020-03-12T02:51:07Z", "type": "commit"}, {"oid": "b75ebab8265af84257e21bc455a43ef18a42a845", "url": "https://github.com/microsoft/mssql-jdbc/commit/b75ebab8265af84257e21bc455a43ef18a42a845", "message": "fixed formatting", "committedDate": "2020-03-12T02:54:10Z", "type": "commit"}, {"oid": "3ce5ad896c2a8efbb3901e4c82de8d01c7baf4b2", "url": "https://github.com/microsoft/mssql-jdbc/commit/3ce5ad896c2a8efbb3901e4c82de8d01c7baf4b2", "message": "fixed formatting", "committedDate": "2020-03-12T03:02:47Z", "type": "commit"}, {"oid": "3a9db373a5c65488a8f7f8a0586e49a4b863b234", "url": "https://github.com/microsoft/mssql-jdbc/commit/3a9db373a5c65488a8f7f8a0586e49a4b863b234", "message": "fixed formatting", "committedDate": "2020-03-12T03:10:19Z", "type": "commit"}, {"oid": "5ba68814685fa96b13972e4223f6eb70c4aee4a1", "url": "https://github.com/microsoft/mssql-jdbc/commit/5ba68814685fa96b13972e4223f6eb70c4aee4a1", "message": "fixed formatting", "committedDate": "2020-03-12T03:14:10Z", "type": "commit"}, {"oid": "95948c1fb38755cbd652d290fa5b783610afeedb", "url": "https://github.com/microsoft/mssql-jdbc/commit/95948c1fb38755cbd652d290fa5b783610afeedb", "message": "test fixes", "committedDate": "2020-03-12T07:29:50Z", "type": "commit"}, {"oid": "beac701758c535820082a72f23eabda4b21bb35d", "url": "https://github.com/microsoft/mssql-jdbc/commit/beac701758c535820082a72f23eabda4b21bb35d", "message": "update connection property names", "committedDate": "2020-03-13T07:09:38Z", "type": "commit"}, {"oid": "86b14ee41ce14981ee4db2db556f05a27d199c86", "url": "https://github.com/microsoft/mssql-jdbc/commit/86b14ee41ce14981ee4db2db556f05a27d199c86", "message": "updated tests", "committedDate": "2020-03-16T21:23:27Z", "type": "commit"}, {"oid": "48801af43e5fc90fd3be04826be32ef30b58ac89", "url": "https://github.com/microsoft/mssql-jdbc/commit/48801af43e5fc90fd3be04826be32ef30b58ac89", "message": "removed unused", "committedDate": "2020-03-17T00:36:33Z", "type": "commit"}, {"oid": "7cf8a6889ac99106ef6a2b7bb204cc872730a848", "url": "https://github.com/microsoft/mssql-jdbc/commit/7cf8a6889ac99106ef6a2b7bb204cc872730a848", "message": "ks registration", "committedDate": "2020-03-17T00:48:42Z", "type": "commit"}, {"oid": "a64c9954e8d59c7b61662da94f71cda8a70e0f21", "url": "https://github.com/microsoft/mssql-jdbc/commit/a64c9954e8d59c7b61662da94f71cda8a70e0f21", "message": "debug", "committedDate": "2020-03-17T07:06:23Z", "type": "commit"}, {"oid": "7b013e94c41e6083557d9f439c366abdbeeecb35", "url": "https://github.com/microsoft/mssql-jdbc/commit/7b013e94c41e6083557d9f439c366abdbeeecb35", "message": "debug", "committedDate": "2020-03-17T07:12:57Z", "type": "commit"}, {"oid": "395790ff8d8736085eb45030ca772ff09aaaa272", "url": "https://github.com/microsoft/mssql-jdbc/commit/395790ff8d8736085eb45030ca772ff09aaaa272", "message": "debug", "committedDate": "2020-03-17T07:25:39Z", "type": "commit"}, {"oid": "5bb43139c021086eacd425b33f0c1f15015fc699", "url": "https://github.com/microsoft/mssql-jdbc/commit/5bb43139c021086eacd425b33f0c1f15015fc699", "message": "debug", "committedDate": "2020-03-17T07:30:37Z", "type": "commit"}, {"oid": "065a0f00500d0b0d5b7b57d14245a486c9b9cf27", "url": "https://github.com/microsoft/mssql-jdbc/commit/065a0f00500d0b0d5b7b57d14245a486c9b9cf27", "message": "remove debug", "committedDate": "2020-03-17T07:37:45Z", "type": "commit"}, {"oid": "9ed54ef1b02911ac8ef9c479c979d3d13d9694ca", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ed54ef1b02911ac8ef9c479c979d3d13d9694ca", "message": "remove debug", "committedDate": "2020-03-17T07:57:22Z", "type": "commit"}, {"oid": "48369bc86980cc2e334fddbb268c7523d428c039", "url": "https://github.com/microsoft/mssql-jdbc/commit/48369bc86980cc2e334fddbb268c7523d428c039", "message": "AE connectionstring", "committedDate": "2020-03-17T08:03:08Z", "type": "commit"}, {"oid": "7a43bfdf46be6db7d7e438fa2989954286589ad5", "url": "https://github.com/microsoft/mssql-jdbc/commit/7a43bfdf46be6db7d7e438fa2989954286589ad5", "message": "more tests", "committedDate": "2020-03-17T08:23:48Z", "type": "commit"}, {"oid": "c2120a3bb8c7a0168557cc971ae1210446bba021", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2120a3bb8c7a0168557cc971ae1210446bba021", "message": "more tests", "committedDate": "2020-03-17T08:28:11Z", "type": "commit"}, {"oid": "6dad2e47a5a783977e05bda542d03a322e7d205a", "url": "https://github.com/microsoft/mssql-jdbc/commit/6dad2e47a5a783977e05bda542d03a322e7d205a", "message": "more tests", "committedDate": "2020-03-17T08:34:18Z", "type": "commit"}, {"oid": "564350d7971b619c59791292ceaf5eb55e63e0ab", "url": "https://github.com/microsoft/mssql-jdbc/commit/564350d7971b619c59791292ceaf5eb55e63e0ab", "message": "fixed typo", "committedDate": "2020-03-17T08:44:45Z", "type": "commit"}, {"oid": "855b71babeef78a6398afa9779c7b5d3e381df9b", "url": "https://github.com/microsoft/mssql-jdbc/commit/855b71babeef78a6398afa9779c7b5d3e381df9b", "message": "updated tests", "committedDate": "2020-03-18T01:32:36Z", "type": "commit"}, {"oid": "355729ebebd9aa78efeaeea035f0e91c47e8cdab", "url": "https://github.com/microsoft/mssql-jdbc/commit/355729ebebd9aa78efeaeea035f0e91c47e8cdab", "message": "null check", "committedDate": "2020-03-18T01:43:49Z", "type": "commit"}, {"oid": "6ee6aa2f70d2fa089ad7c8f395c86e1b2a660ba4", "url": "https://github.com/microsoft/mssql-jdbc/commit/6ee6aa2f70d2fa089ad7c8f395c86e1b2a660ba4", "message": "javadoc", "committedDate": "2020-03-18T01:59:36Z", "type": "commit"}, {"oid": "ee800b090cabdf974f7c03cb1990f8872075ffc6", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee800b090cabdf974f7c03cb1990f8872075ffc6", "message": "exclude MSI tests by default", "committedDate": "2020-03-18T07:02:52Z", "type": "commit"}, {"oid": "ca1d9d5b3fc82fc70715e33d77bd55d245617f46", "url": "https://github.com/microsoft/mssql-jdbc/commit/ca1d9d5b3fc82fc70715e33d77bd55d245617f46", "message": "formatting", "committedDate": "2020-03-18T07:48:02Z", "type": "commit"}, {"oid": "14b6efc6138ec631d2c237aaeb2b2f463a0c984e", "url": "https://github.com/microsoft/mssql-jdbc/commit/14b6efc6138ec631d2c237aaeb2b2f463a0c984e", "message": "merged conflicts", "committedDate": "2020-03-19T19:59:58Z", "type": "commit"}, {"oid": "604fcc3ff454df209e78657dc5418519f83a7a1e", "url": "https://github.com/microsoft/mssql-jdbc/commit/604fcc3ff454df209e78657dc5418519f83a7a1e", "message": "renamed", "committedDate": "2020-03-23T19:17:29Z", "type": "commit"}, {"oid": "7e69b3572a523405912f0f0e038a3bb10baf1023", "url": "https://github.com/microsoft/mssql-jdbc/commit/7e69b3572a523405912f0f0e038a3bb10baf1023", "message": "unreg all providers", "committedDate": "2020-03-23T20:19:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MDE2Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r396880167", "body": "Why are we wrapping the exception into a RuntimeException here? Shouldn't we wrap the exception into a SQLServerException instead?", "bodyText": "Why are we wrapping the exception into a RuntimeException here? Shouldn't we wrap the exception into a SQLServerException instead?", "bodyHTML": "<p dir=\"auto\">Why are we wrapping the exception into a RuntimeException here? Shouldn't we wrap the exception into a SQLServerException instead?</p>", "author": "peterbae", "createdAt": "2020-03-24T03:15:10Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -37,11 +55,19 @@\n     }\n \n     public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken;\n+        String accessToken = null;\n         if (null == authenticationCallback) {\n-            AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                    clientKey);\n-            accessToken = token.getAccessToken();\n+            if (null != msiCred) {\n+                try {\n+                    accessToken = msiCred.getToken(resource);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);", "originalCommit": "7e69b3572a523405912f0f0e038a3bb10baf1023", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1ODQxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r397358411", "bodyText": "should we? I used RuntimeException to be consistent with what we're currently doing already.  getAccessTokenFromClientCredentials throws RuntimeException which just gets passed up to the caller here", "author": "lilgreenbird", "createdAt": "2020-03-24T18:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MDE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3MDAzMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r397370031", "bodyText": "ok, I see that it's being done in the other method as well...but I think we usually wrap any exception into SQLServerException. But I'm ok with following the previous code.", "author": "peterbae", "createdAt": "2020-03-24T18:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MDE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex de77eb29..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -57,10 +45,11 @@ class KeyVaultCredential extends KeyVaultCredentials {\n     public String doAuthenticate(String authorization, String resource, String scope) {\n         String accessToken = null;\n         if (null == authenticationCallback) {\n-            if (null != msiCred) {\n+            if (null == clientKey) {\n                 try {\n-                    accessToken = msiCred.getToken(resource);\n-                } catch (IOException e) {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n                     throw new RuntimeException(e);\n                 }\n             } else {\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex ca4f21f6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,90 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n-\n-\n-/**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n- */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n-\n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n-\n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n-    }\n-\n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n-    }\n-\n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n-        }\n-        return accessToken;\n-    }\n-\n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n-        }\n-\n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n-        }\n-        return result;\n-    }\n-}\n", "next_change": null}]}}]}}, {"oid": "ab43dd760eafc1cae84d060ccb4206e3798a6c9f", "url": "https://github.com/microsoft/mssql-jdbc/commit/ab43dd760eafc1cae84d060ccb4206e3798a6c9f", "message": "fixed prop names", "committedDate": "2020-03-24T05:38:05Z", "type": "commit"}, {"oid": "7e662fe741ae99b5c629bdcbab04d691f86c03ab", "url": "https://github.com/microsoft/mssql-jdbc/commit/7e662fe741ae99b5c629bdcbab04d691f86c03ab", "message": "Merge remote-tracking branch 'upstream/dev' into msi", "committedDate": "2020-03-25T19:55:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE4MDg4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r398180889", "body": "Add license header", "bodyText": "Add license header", "bodyHTML": "<p dir=\"auto\">Add license header</p>", "author": "peterbae", "createdAt": "2020-03-25T21:28:01Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r", "originalCommit": "7e662fe741ae99b5c629bdcbab04d691f86c03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b354060a..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n \n import static org.junit.jupiter.api.Assertions.fail;\n", "next_change": {"commit": "947b537df005666c768ba19ed6fb776b68a490de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..552ef201 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -5,6 +5,7 @@\n package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n \n import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import java.sql.Connection;\n import java.sql.ResultSet;\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 552ef201..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -7,6 +7,7 @@ package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n import static org.junit.jupiter.api.Assertions.fail;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import com.microsoft.aad.msal4j.MsalServiceException;\n import java.sql.Connection;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7688b098..306e23e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -7,7 +7,6 @@ package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n import static org.junit.jupiter.api.Assertions.fail;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-import com.microsoft.aad.msal4j.MsalServiceException;\n import java.sql.Connection;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 306e23e0..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -7,16 +7,25 @@ package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n import static org.junit.jupiter.api.Assertions.fail;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.OutputStream;\n import java.sql.Connection;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n \n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n import org.junit.platform.runner.JUnitPlatform;\n import org.junit.runner.RunWith;\n \n+import com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider;\n+import com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionKeyStoreProvider;\n import com.microsoft.sqlserver.jdbc.SQLServerConnection;\n import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\n import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIyNDEwNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r398224106", "body": "put license header here", "bodyText": "put license header here", "bodyHTML": "<p dir=\"auto\">put license header here</p>", "author": "peterbae", "createdAt": "2020-03-25T23:06:19Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/AECommon.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r", "originalCommit": "7e662fe741ae99b5c629bdcbab04d691f86c03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/AECommon.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/AECommon.java\nindex dc704249..8ef5b6aa 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/AECommon.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/AECommon.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n \n import static org.junit.jupiter.api.Assertions.assertTrue;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIyNTg3MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r398225871", "body": "needs @Test tag", "bodyText": "needs @test tag", "bodyHTML": "<p dir=\"auto\">needs <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/test/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/test\">@test</a> tag</p>", "author": "peterbae", "createdAt": "2020-03-25T23:11:03Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+    /*\r\n+     * Test basic MSI auth\r\n+     */\r\n+    @Test\r\n+    public void testAuth() throws SQLException {\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test MSI auth using datasource\r\n+     */\r\n+    @Test\r\n+    public void testDSAuth() throws SQLException {\r\n+        SQLServerDataSource ds = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, ds);\r\n+\r\n+        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with credentials\r\n+     */\r\n+    @Test\r\n+    public void testCharAkvWithCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString,\r\n+                Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\r\n+        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString, Constants.KEYSTORE_PRINCIPALID,\r\n+                keyStorePrincipalId);\r\n+        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString, Constants.KEYSTORE_SECRET,\r\n+                keyStoreSecret);\r\n+        testCharAkv();\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with MSI\r\n+     */\r\n+    public void testCharAkvWithMSI() throws SQLException {\r", "originalCommit": "7e662fe741ae99b5c629bdcbab04d691f86c03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b354060a..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -62,26 +152,63 @@ public class MSITest extends AESetup {\n         SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n \n         // add credentials to connection string\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString,\n-                Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString, Constants.KEYSTORE_PRINCIPALID,\n-                keyStorePrincipalId);\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString, Constants.KEYSTORE_SECRET,\n-                keyStoreSecret);\n-        testCharAkv();\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, keyStoreSecret);\n+        testCharAkv(connStr);\n     }\n \n     /*\n      * Test AKV with MSI\n      */\n+    @Test\n     public void testCharAkvWithMSI() throws SQLException {\n         // unregister the custom providers registered in AESetup\n         SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n \n         // set to use Managed Identity for keystore auth\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString,\n-                Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultManagedIdentity\");\n-        testCharAkv();\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\n+                \"KeyVaultManagedIdentity\");\n+        testCharAkv(connStr);\n+    }\n+\n+    /*\n+     * Test AKV with MSI and and principal id\n+     */\n+    @Test\n+    public void testCharAkvWithMSIandPrincipalId() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        // set to use Managed Identity for keystore auth and principal id\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\n+                \"KeyVaultManagedIdentity\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\n+        testCharAkv(connStr);\n+    }\n+\n+    /*\n+     * Test AKV with with bad credentials\n+     */\n+    @Test\n+    public void testNumericAkvWithBadCred() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        // add credentials to connection string\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, \"bad\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, \"bad\");\n+        try {\n+            testNumericAKV(connStr);\n+            fail(TestResource.getResource(\"R_expectedFailPassed\"));\n+        } catch (Exception e) {\n+            assert (e.getMessage().contains(\"AuthenticationException\"));\n+        }\n     }\n \n     /*\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -207,7 +300,8 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n-            assert (e.getMessage().contains(\"AuthenticationException\"));\n+            // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n+            assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n     }\n \n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7688b098..306e23e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -301,7 +303,7 @@ public class MSITest extends AESetup {\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n-            assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n+            assertTrue(e.getMessage().contains(\"AADSTS700016\"), e.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 306e23e0..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -312,9 +279,6 @@ public class MSITest extends AESetup {\n      */\n     @Test\n     public void testNumericAkvWithCred() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         // add credentials to connection string\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n", "next_change": null}]}}]}}]}}]}}, {"oid": "54832b81645c811844ff2ea117fbc567c7c417fa", "url": "https://github.com/microsoft/mssql-jdbc/commit/54832b81645c811844ff2ea117fbc567c7c417fa", "message": "review updates", "committedDate": "2020-03-26T06:13:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1Njk5Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r398956996", "body": "I think currently your testing might not be testing the correct inputs from the user. This AETestConnectionString is a static variable that keeps getting added more parameters as individual tests get executed, resulting in latter tests having the same connection property defined multiple times. You should reset this variable to the base connection string at the beginning of each test run.", "bodyText": "I think currently your testing might not be testing the correct inputs from the user. This AETestConnectionString is a static variable that keeps getting added more parameters as individual tests get executed, resulting in latter tests having the same connection property defined multiple times. You should reset this variable to the base connection string at the beginning of each test run.", "bodyHTML": "<p dir=\"auto\">I think currently your testing might not be testing the correct inputs from the user. This AETestConnectionString is a static variable that keeps getting added more parameters as individual tests get executed, resulting in latter tests having the same connection property defined multiple times. You should reset this variable to the base connection string at the beginning of each test run.</p>", "author": "peterbae", "createdAt": "2020-03-26T23:45:29Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+    /*\r\n+     * Test basic MSI auth\r\n+     */\r\n+    @Test\r\n+    public void testAuth() throws SQLException {\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test MSI auth using datasource\r\n+     */\r\n+    @Test\r\n+    public void testDSAuth() throws SQLException {\r\n+        SQLServerDataSource ds = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, ds);\r\n+\r\n+        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with credentials\r\n+     */\r\n+    @Test\r\n+    public void testCharAkvWithCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString,\r", "originalCommit": "54832b81645c811844ff2ea117fbc567c7c417fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 85316d42..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -66,13 +152,11 @@ public class MSITest extends AESetup {\n         SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n \n         // add credentials to connection string\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString,\n-                Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString, Constants.KEYSTORE_PRINCIPALID,\n-                keyStorePrincipalId);\n-        AETestConnectionString = TestUtils.addOrOverrideProperty(AETestConnectionString, Constants.KEYSTORE_SECRET,\n-                keyStoreSecret);\n-        testCharAkv();\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, keyStoreSecret);\n+        testCharAkv(connStr);\n     }\n \n     /*\n", "next_change": {"commit": "947b537df005666c768ba19ed6fb776b68a490de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..552ef201 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -159,6 +160,21 @@ public class MSITest extends AESetup {\n         testCharAkv(connStr);\n     }\n \n+    /*\n+     * Test AKV with with credentials using deprecated properties\n+     */\n+    @Test\n+    public void testCharAkvWithCredDeprecated() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        // add deprecated connection properties\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYVAULTPROVIDER_CLIENTID, keyStorePrincipalId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYVAULTPROVIDER_CLIENTKEY, keyStoreSecret);\n+        testCharAkv(connStr);\n+    }\n+\n     /*\n      * Test AKV with MSI\n      */\n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 552ef201..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -180,9 +168,6 @@ public class MSITest extends AESetup {\n      */\n     @Test\n     public void testCharAkvWithMSI() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         // set to use Managed Identity for keystore auth\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\n", "next_change": null}]}}]}}]}}, {"oid": "34784c7625f98e573d680690d2a2ea40939d0063", "url": "https://github.com/microsoft/mssql-jdbc/commit/34784c7625f98e573d680690d2a2ea40939d0063", "message": "review update", "committedDate": "2020-03-27T00:46:09Z", "type": "commit"}, {"oid": "a578f1ede3074e1413711f28cdef5a894e49821b", "url": "https://github.com/microsoft/mssql-jdbc/commit/a578f1ede3074e1413711f28cdef5a894e49821b", "message": "migrate to azure-identity", "committedDate": "2020-03-28T04:38:10Z", "type": "commit"}, {"oid": "5392cc358a266e96a12940ef0e41631d4ef1f557", "url": "https://github.com/microsoft/mssql-jdbc/commit/5392cc358a266e96a12940ef0e41631d4ef1f557", "message": "remove debug lines", "committedDate": "2020-03-28T04:48:35Z", "type": "commit"}, {"oid": "942adcc154cc53dcb99a9065d400a28b625add39", "url": "https://github.com/microsoft/mssql-jdbc/commit/942adcc154cc53dcb99a9065d400a28b625add39", "message": "removed unused", "committedDate": "2020-03-28T05:05:35Z", "type": "commit"}, {"oid": "d14f398f955e27214a5665150be2f7b20905609d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d14f398f955e27214a5665150be2f7b20905609d", "message": "merged with client auth", "committedDate": "2020-03-28T05:42:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczMDAxNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r399730015", "body": "Aren't you adding 2 new connection properties?", "bodyText": "Aren't you adding 2 new connection properties?", "bodyHTML": "<p dir=\"auto\">Aren't you adding 2 new connection properties?</p>", "author": "ulvii", "createdAt": "2020-03-29T01:14:55Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -821,6 +821,21 @@\n      */\n     String getMSIClientId();\n \n+    /**", "originalCommit": "d14f398f955e27214a5665150be2f7b20905609d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MTIzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r399941234", "bodyText": "not anymore, latest discussion with Jakub we're aligning with ODBC so using keyStorePrincipalId (new) and keyStoreSecret (existing)", "author": "lilgreenbird", "createdAt": "2020-03-30T05:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczMDAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 49120388..f6104c6d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,157 +804,35 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n-     * \n-     * @param msiClientId\n-     *        Client ID of User Assigned Managed Identity\n-     */\n-    void setMSIClientId(String msiClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'msiClientId'.\n-     * \n-     * @return msiClientId property value\n-     */\n-    String getMSIClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider user principal id.\n-     * \n-     * @param keyVaultPrincipalId\n-     *        principal Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyStorePrincipalId(String keyVaultPrincipalId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultPrincipalId'.\n-     * \n-     * @return keyVaultPrincipalId\n-     */\n-    String getKeyStorePrincipalId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientId\n-     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultProviderClientId'.\n-     * \n-     * @return keyVaultProviderClientId\n-     */\n-    String getKeyVaultProviderClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientKey\n-     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n-\n-    /**\n-     * Returns the value for the connection property 'domain'.\n-     * \n-     * @return 'domain' property value\n-     */\n-    String getDomain();\n-\n-    /**\n-     * Sets the 'domain' connection property used for NTLM Authentication.\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n      *\n-     * @param domain\n-     *        Windows domain name\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setDomain(String domain);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the current flag value for useFmtOnly.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n      *\n-     * @return 'useFmtOnly' property value.\n+     * @return maximum number of attempts\n      */\n-    boolean getUseFmtOnly();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Specifies the flag to use FMTONLY for parameter metadata queries.\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n      *\n-     * @param useFmtOnly\n-     *        boolean value for 'useFmtOnly'.\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setUseFmtOnly(boolean useFmtOnly);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return enclave attestation URL.\n-     */\n-    String getEnclaveAttestationUrl();\n-\n-    /**\n-     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param url\n-     *        Enclave attestation URL.\n-     */\n-    void setEnclaveAttestationUrl(String url);\n-\n-    /**\n-     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return Enclave attestation protocol.\n-     */\n-    String getEnclaveAttestationProtocol();\n-\n-    /**\n-     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param protocol\n-     *        Enclave attestation protocol.\n-     */\n-    void setEnclaveAttestationProtocol(String protocol);\n-    \n-    /**\n-     * Returns client certificate path for client certificate authentication.\n-     * \n-     * @return Client certificate path.\n-     */\n-    String getClientCertificate();\n-\n-    /**\n-     * Sets client certificate path for client certificate authentication.\n-     * \n-     * @param certPath\n-     *        Client certificate path.\n-     */\n-    void setClientCertificate(String certPath);\n-    \n-    /**\n-     * Returns Private key file path for client certificate authentication.\n-     * \n-     * @return Private key file path.\n-     */\n-    String getClientKey();\n-\n-    /**\n-     * Sets Private key file path for client certificate authentication.\n-     * \n-     * @param keyPath\n-     *        Private key file path.\n-     */\n-    void setClientKey(String keyPath);\n-\n-    /**\n-     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n-     * \n-     * @param password\n-     *        Private key password.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    void setClientKeyPassword(String password);\n-\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d30f3404be0bf4a537455133a96ef35eb9c6b09a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex f6104c6d..866bca0f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,35 +834,142 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the maximum number of attempts to reestablish a broken connection.\n-     *\n-     * @param connectRetryCount\n-     *        maximum number of attempts\n+     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n+     * \n+     * @param msiClientId\n+     *        Client ID of User Assigned Managed Identity\n      */\n-    public void setConnectRetryCount(int connectRetryCount);\n+    void setMSIClientId(String msiClientId);\n \n     /**\n-     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     * Returns the value for the connection property 'msiClientId'.\n+     * \n+     * @return msiClientId property value\n+     */\n+    String getMSIClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientId\n+     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n+\n+    /**\n+     * Returns the value for the connection property 'keyVaultProviderClientId'.\n+     * \n+     * @return keyVaultProviderClientId\n+     */\n+    String getKeyVaultProviderClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientKey\n+     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n+\n+    /**\n+     * Returns the value for the connection property 'domain'.\n+     * \n+     * @return 'domain' property value\n+     */\n+    String getDomain();\n+\n+    /**\n+     * Sets the 'domain' connection property used for NTLM Authentication.\n      *\n-     * @return maximum number of attempts\n+     * @param domain\n+     *        Windows domain name\n      */\n-    public int getConnectRetryCount();\n+    void setDomain(String domain);\n \n     /**\n-     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     * Returns the current flag value for useFmtOnly.\n      *\n-     * @param connectRetryInterval\n-     *        interval in seconds\n+     * @return 'useFmtOnly' property value.\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    boolean getUseFmtOnly();\n \n     /**\n-     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     * Specifies the flag to use FMTONLY for parameter metadata queries.\n      *\n-     * @return interval in seconds\n+     * @param useFmtOnly\n+     *        boolean value for 'useFmtOnly'.\n      */\n-    public int getConnectRetryInterval();\n+    void setUseFmtOnly(boolean useFmtOnly);\n+\n+    /**\n+     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return enclave attestation URL.\n+     */\n+    String getEnclaveAttestationUrl();\n+\n+    /**\n+     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param url\n+     *        Enclave attestation URL.\n+     */\n+    void setEnclaveAttestationUrl(String url);\n+\n+    /**\n+     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return Enclave attestation protocol.\n+     */\n+    String getEnclaveAttestationProtocol();\n+\n+    /**\n+     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param protocol\n+     *        Enclave attestation protocol.\n+     */\n+    void setEnclaveAttestationProtocol(String protocol);\n+\n+    /**\n+     * Returns client certificate path for client certificate authentication.\n+     * \n+     * @return Client certificate path.\n+     */\n+    String getClientCertificate();\n+\n+    /**\n+     * Sets client certificate path for client certificate authentication.\n+     * \n+     * @param certPath\n+     *        Client certificate path.\n+     */\n+    void setClientCertificate(String certPath);\n+\n+    /**\n+     * Returns Private key file path for client certificate authentication.\n+     * \n+     * @return Private key file path.\n+     */\n+    String getClientKey();\n+\n+    /**\n+     * Sets Private key file path for client certificate authentication.\n+     * \n+     * @param keyPath\n+     *        Private key file path.\n+     */\n+    void setClientKey(String keyPath);\n+\n+    /**\n+     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n+     * \n+     * @param password\n+     *        Private key password.\n+     */\n+    void setClientKeyPassword(String password);\n+\n }\n", "next_change": {"commit": "f857e2505aec7b413fbd1f5b722862d915b2b2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 866bca0f..6e401075 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -972,4 +991,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setClientKeyPassword(String password);\n \n+    /**\n+     * Returns the current flag for value sendTemporalDataTypesAsStringForBulkCopy\n+     * \n+     * @return 'sendTemporalDataTypesAsStringForBulkCopy' property value.\n+     */\n+    boolean getSendTemporalDataTypesAsStringForBulkCopy();\n+\n+    /**\n+     * Specifies the flag to send temporal datatypes as String for Bulk Copy.\n+     * \n+     * @param sendTemporalDataTypesAsStringForBulkCopy\n+     *        boolean value for 'sendTemporalDataTypesAsStringForBulkCopy'.\n+     */\n+    void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n+\n }\n", "next_change": {"commit": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 6e401075..9288d59a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1006,4 +1021,34 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n \n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalId'.\n+     *\n+     * @return 'AADSecurePrincipalId' property value.\n+     */\n+    String getAADSecurePrincipalId();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalId' connection property used for Active Directory Service Principal authentication.\n+     *\n+     * @param AADSecurePrincipalId\n+     *        Active Directory Service Principal Id.\n+     */\n+    void setAADSecurePrincipalId(String AADSecurePrincipalId);\n+\n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalSecret'.\n+     *\n+     * @return 'AADSecurePrincipalSecret' property value.\n+     */\n+    String getAADSecurePrincipalSecret();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalSecret' connection property used for Active Directory Service Principal\n+     * authentication.\n+     *\n+     * @param AADSecurePrincipalSecret\n+     *        Active Directory Service Principal secret.\n+     */\n+    void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n }\n", "next_change": {"commit": "d9909748368af7d2944dab4fa382ee513f2b76f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 9288d59a..87152862 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1051,4 +1051,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      *        Active Directory Service Principal secret.\n      */\n     void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n+\n+    /**\n+     * Returns value of 'maxResultBuffer' from Connection String.\n+     *\n+     * @return 'maxResultBuffer' property.\n+     */\n+    String getMaxResultBuffer();\n+\n+    /**\n+     * Specifies value for 'maxResultBuffer' property\n+     *\n+     * @param maxResultBuffer\n+     *        String value for 'maxResultBuffer'\n+     */\n+    void setMaxResultBuffer(String maxResultBuffer);\n }\n", "next_change": {"commit": "af679a5f3754611273caa484fba9867a8e3c777c", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 87152862..1308a5cd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1060,10 +1060,42 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getMaxResultBuffer();\n \n     /**\n-     * Specifies value for 'maxResultBuffer' property\n+     * Sets the value for 'maxResultBuffer' property\n      *\n      * @param maxResultBuffer\n      *        String value for 'maxResultBuffer'\n      */\n     void setMaxResultBuffer(String maxResultBuffer);\n+\n+    /**\n+     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n+     * failure\n+     * \n+     * @param count\n+     *        the number of reconnection attempts if there is a connection failure\n+     */\n+    void setConnectRetryCount(int count);\n+\n+    /**\n+     * Returns the value of 'connectRetryCount' property\n+     * \n+     * @return 'connectRetryCount' property.\n+     */\n+    int getConnectRetryCount();\n+\n+    /**\n+     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n+     * attempt\n+     * \n+     * @param interval\n+     *        the number of seconds between each connection retry attempt\n+     */\n+    void setConnectRetryInterval(int interval);\n+\n+    /**\n+     * Returns the value of 'connectRetryInterval' property\n+     * \n+     * @return 'connectRetryInterval' property.\n+     */\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 1308a5cd..210bb34b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1068,34 +1099,32 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     void setMaxResultBuffer(String maxResultBuffer);\n \n     /**\n-     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n-     * failure\n-     * \n-     * @param count\n-     *        the number of reconnection attempts if there is a connection failure\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setConnectRetryCount(int count);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the value of 'connectRetryCount' property\n-     * \n-     * @return 'connectRetryCount' property.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     *\n+     * @return maximum number of attempts\n      */\n-    int getConnectRetryCount();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n-     * attempt\n-     * \n-     * @param interval\n-     *        the number of seconds between each connection retry attempt\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setConnectRetryInterval(int interval);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the value of 'connectRetryInterval' property\n-     * \n-     * @return 'connectRetryInterval' property.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    int getConnectRetryInterval();\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 210bb34b..e9f55e9b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1119,12 +1119,12 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param connectRetryInterval\n      *        interval in seconds\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n      * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n      *\n      * @return interval in seconds\n      */\n-    public int getConnectRetryInterval();\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex e9f55e9b..76db4be5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1127,4 +1126,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return interval in seconds\n      */\n     int getConnectRetryInterval();\n+\n+    /**\n+     * Sets the behavior for the prepare method. {@link PrepareMethod}\n+     *\n+     * @param prepareMethod\n+     *        Changes the setting as per description\n+     */\n+    void setPrepareMethod(String prepareMethod);\n+\n+    /**\n+     * Returns the value indicating the prepare method. {@link PrepareMethod}\n+     *\n+     * @return prepare method\n+     */\n+    String getPrepareMethod();\n }\n", "next_change": {"commit": "900fe16ffb7b048d8617d79e5891f3ceb2e314e3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 76db4be5..c85bbd26 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1141,4 +1206,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return prepare method\n      */\n     String getPrepareMethod();\n+\n+    /**\n+     * Sets time-to-live for the the cached MSI token\n+     *\n+     * @param timeToLive\n+     *        Changes the setting as per description\n+     */\n+    void setMsiTokenCacheTtl(int timeToLive);\n+\n+    /**\n+     * Gets the time-to-live for the the cached MSI token\n+     *\n+     * @return time-to-live for the cached MSI token\n+     */\n+    int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex c85bbd26..19f98695 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1208,17 +1214,16 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getPrepareMethod();\n \n     /**\n-     * Sets time-to-live for the the cached MSI token\n-     *\n-     * @param timeToLive\n-     *        Changes the setting as per description\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method is a no-op for backwards compatibility only.\n      */\n+    @Deprecated\n     void setMsiTokenCacheTtl(int timeToLive);\n \n     /**\n-     * Gets the time-to-live for the the cached MSI token\n-     *\n-     * @return time-to-live for the cached MSI token\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method will always return 0 and is for backwards compatibility only.\n      */\n+    @Deprecated\n     int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 19f98695..a9ba172d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1223,7 +1226,24 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     /**\n      * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n      * This method will always return 0 and is for backwards compatibility only.\n+     *\n+     * @return Method will always return 0.\n      */\n     @Deprecated\n     int getMsiTokenCacheTtl();\n+\n+    /**\n+     * Sets the {@link SQLServerAccessTokenCallback} delegate.\n+     *\n+     * @param accessTokenCallback\n+     *        Access token callback delegate.\n+     */\n+    void setAccessTokenCallback(SQLServerAccessTokenCallback accessTokenCallback);\n+\n+    /**\n+     * Returns a {@link SQLServerAccessTokenCallback}, the access token callback delegate.\n+     *\n+     * @return Access token callback delegate.\n+     */\n+    SQLServerAccessTokenCallback getAccessTokenCallback();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "70b6a3c1912a003a22a538f72a3be93070e96e99", "url": "https://github.com/microsoft/mssql-jdbc/commit/70b6a3c1912a003a22a538f72a3be93070e96e99", "message": "removed azure-identities dependency", "committedDate": "2020-03-31T00:24:38Z", "type": "commit"}, {"oid": "8b7e3a9f01edc2b9995711222f1f5ec5a0f041cb", "url": "https://github.com/microsoft/mssql-jdbc/commit/8b7e3a9f01edc2b9995711222f1f5ec5a0f041cb", "message": "missed 1 file", "committedDate": "2020-03-31T00:28:22Z", "type": "commit"}, {"oid": "8c56ba6185c746fe03e057e1cc631123dd006e7f", "url": "https://github.com/microsoft/mssql-jdbc/commit/8c56ba6185c746fe03e057e1cc631123dd006e7f", "message": "merged conflicts", "committedDate": "2020-03-31T00:30:38Z", "type": "commit"}, {"oid": "ff179c14be160f612d70e3102c4a4ed8e85dd628", "url": "https://github.com/microsoft/mssql-jdbc/commit/ff179c14be160f612d70e3102c4a4ed8e85dd628", "message": "updated", "committedDate": "2020-03-31T00:36:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NjE4Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r400576182", "body": "This is not necessarily AKV user principal ID. Please align the docs with [ODBC connection property documentation.](https://docs.microsoft.com/en-us/sql/connect/odbc/using-always-encrypted-with-the-odbc-driver?view=sql-server-ver15#using-the-azure-key-vault-provider)", "bodyText": "This is not necessarily AKV user principal ID. Please align the docs with ODBC connection property documentation.", "bodyHTML": "<p dir=\"auto\">This is not necessarily AKV user principal ID. Please align the docs with <a href=\"https://docs.microsoft.com/en-us/sql/connect/odbc/using-always-encrypted-with-the-odbc-driver?view=sql-server-ver15#using-the-azure-key-vault-provider\" rel=\"nofollow\">ODBC connection property documentation.</a></p>", "author": "ulvii", "createdAt": "2020-03-31T00:39:46Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -821,6 +821,21 @@\n      */\n     String getMSIClientId();\n \n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider user principal id.", "originalCommit": "ff179c14be160f612d70e3102c4a4ed8e85dd628", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 49120388..f6104c6d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,157 +804,35 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n-     * \n-     * @param msiClientId\n-     *        Client ID of User Assigned Managed Identity\n-     */\n-    void setMSIClientId(String msiClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'msiClientId'.\n-     * \n-     * @return msiClientId property value\n-     */\n-    String getMSIClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider user principal id.\n-     * \n-     * @param keyVaultPrincipalId\n-     *        principal Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyStorePrincipalId(String keyVaultPrincipalId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultPrincipalId'.\n-     * \n-     * @return keyVaultPrincipalId\n-     */\n-    String getKeyStorePrincipalId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientId\n-     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultProviderClientId'.\n-     * \n-     * @return keyVaultProviderClientId\n-     */\n-    String getKeyVaultProviderClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientKey\n-     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n-\n-    /**\n-     * Returns the value for the connection property 'domain'.\n-     * \n-     * @return 'domain' property value\n-     */\n-    String getDomain();\n-\n-    /**\n-     * Sets the 'domain' connection property used for NTLM Authentication.\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n      *\n-     * @param domain\n-     *        Windows domain name\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setDomain(String domain);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the current flag value for useFmtOnly.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n      *\n-     * @return 'useFmtOnly' property value.\n+     * @return maximum number of attempts\n      */\n-    boolean getUseFmtOnly();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Specifies the flag to use FMTONLY for parameter metadata queries.\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n      *\n-     * @param useFmtOnly\n-     *        boolean value for 'useFmtOnly'.\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setUseFmtOnly(boolean useFmtOnly);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return enclave attestation URL.\n-     */\n-    String getEnclaveAttestationUrl();\n-\n-    /**\n-     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param url\n-     *        Enclave attestation URL.\n-     */\n-    void setEnclaveAttestationUrl(String url);\n-\n-    /**\n-     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return Enclave attestation protocol.\n-     */\n-    String getEnclaveAttestationProtocol();\n-\n-    /**\n-     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param protocol\n-     *        Enclave attestation protocol.\n-     */\n-    void setEnclaveAttestationProtocol(String protocol);\n-    \n-    /**\n-     * Returns client certificate path for client certificate authentication.\n-     * \n-     * @return Client certificate path.\n-     */\n-    String getClientCertificate();\n-\n-    /**\n-     * Sets client certificate path for client certificate authentication.\n-     * \n-     * @param certPath\n-     *        Client certificate path.\n-     */\n-    void setClientCertificate(String certPath);\n-    \n-    /**\n-     * Returns Private key file path for client certificate authentication.\n-     * \n-     * @return Private key file path.\n-     */\n-    String getClientKey();\n-\n-    /**\n-     * Sets Private key file path for client certificate authentication.\n-     * \n-     * @param keyPath\n-     *        Private key file path.\n-     */\n-    void setClientKey(String keyPath);\n-\n-    /**\n-     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n-     * \n-     * @param password\n-     *        Private key password.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    void setClientKeyPassword(String password);\n-\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d30f3404be0bf4a537455133a96ef35eb9c6b09a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex f6104c6d..866bca0f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,35 +834,142 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the maximum number of attempts to reestablish a broken connection.\n-     *\n-     * @param connectRetryCount\n-     *        maximum number of attempts\n+     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n+     * \n+     * @param msiClientId\n+     *        Client ID of User Assigned Managed Identity\n      */\n-    public void setConnectRetryCount(int connectRetryCount);\n+    void setMSIClientId(String msiClientId);\n \n     /**\n-     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     * Returns the value for the connection property 'msiClientId'.\n+     * \n+     * @return msiClientId property value\n+     */\n+    String getMSIClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientId\n+     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n+\n+    /**\n+     * Returns the value for the connection property 'keyVaultProviderClientId'.\n+     * \n+     * @return keyVaultProviderClientId\n+     */\n+    String getKeyVaultProviderClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientKey\n+     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n+\n+    /**\n+     * Returns the value for the connection property 'domain'.\n+     * \n+     * @return 'domain' property value\n+     */\n+    String getDomain();\n+\n+    /**\n+     * Sets the 'domain' connection property used for NTLM Authentication.\n      *\n-     * @return maximum number of attempts\n+     * @param domain\n+     *        Windows domain name\n      */\n-    public int getConnectRetryCount();\n+    void setDomain(String domain);\n \n     /**\n-     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     * Returns the current flag value for useFmtOnly.\n      *\n-     * @param connectRetryInterval\n-     *        interval in seconds\n+     * @return 'useFmtOnly' property value.\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    boolean getUseFmtOnly();\n \n     /**\n-     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     * Specifies the flag to use FMTONLY for parameter metadata queries.\n      *\n-     * @return interval in seconds\n+     * @param useFmtOnly\n+     *        boolean value for 'useFmtOnly'.\n      */\n-    public int getConnectRetryInterval();\n+    void setUseFmtOnly(boolean useFmtOnly);\n+\n+    /**\n+     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return enclave attestation URL.\n+     */\n+    String getEnclaveAttestationUrl();\n+\n+    /**\n+     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param url\n+     *        Enclave attestation URL.\n+     */\n+    void setEnclaveAttestationUrl(String url);\n+\n+    /**\n+     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return Enclave attestation protocol.\n+     */\n+    String getEnclaveAttestationProtocol();\n+\n+    /**\n+     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param protocol\n+     *        Enclave attestation protocol.\n+     */\n+    void setEnclaveAttestationProtocol(String protocol);\n+\n+    /**\n+     * Returns client certificate path for client certificate authentication.\n+     * \n+     * @return Client certificate path.\n+     */\n+    String getClientCertificate();\n+\n+    /**\n+     * Sets client certificate path for client certificate authentication.\n+     * \n+     * @param certPath\n+     *        Client certificate path.\n+     */\n+    void setClientCertificate(String certPath);\n+\n+    /**\n+     * Returns Private key file path for client certificate authentication.\n+     * \n+     * @return Private key file path.\n+     */\n+    String getClientKey();\n+\n+    /**\n+     * Sets Private key file path for client certificate authentication.\n+     * \n+     * @param keyPath\n+     *        Private key file path.\n+     */\n+    void setClientKey(String keyPath);\n+\n+    /**\n+     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n+     * \n+     * @param password\n+     *        Private key password.\n+     */\n+    void setClientKeyPassword(String password);\n+\n }\n", "next_change": {"commit": "f857e2505aec7b413fbd1f5b722862d915b2b2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 866bca0f..6e401075 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -972,4 +991,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setClientKeyPassword(String password);\n \n+    /**\n+     * Returns the current flag for value sendTemporalDataTypesAsStringForBulkCopy\n+     * \n+     * @return 'sendTemporalDataTypesAsStringForBulkCopy' property value.\n+     */\n+    boolean getSendTemporalDataTypesAsStringForBulkCopy();\n+\n+    /**\n+     * Specifies the flag to send temporal datatypes as String for Bulk Copy.\n+     * \n+     * @param sendTemporalDataTypesAsStringForBulkCopy\n+     *        boolean value for 'sendTemporalDataTypesAsStringForBulkCopy'.\n+     */\n+    void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n+\n }\n", "next_change": {"commit": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 6e401075..9288d59a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1006,4 +1021,34 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n \n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalId'.\n+     *\n+     * @return 'AADSecurePrincipalId' property value.\n+     */\n+    String getAADSecurePrincipalId();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalId' connection property used for Active Directory Service Principal authentication.\n+     *\n+     * @param AADSecurePrincipalId\n+     *        Active Directory Service Principal Id.\n+     */\n+    void setAADSecurePrincipalId(String AADSecurePrincipalId);\n+\n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalSecret'.\n+     *\n+     * @return 'AADSecurePrincipalSecret' property value.\n+     */\n+    String getAADSecurePrincipalSecret();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalSecret' connection property used for Active Directory Service Principal\n+     * authentication.\n+     *\n+     * @param AADSecurePrincipalSecret\n+     *        Active Directory Service Principal secret.\n+     */\n+    void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n }\n", "next_change": {"commit": "d9909748368af7d2944dab4fa382ee513f2b76f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 9288d59a..87152862 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1051,4 +1051,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      *        Active Directory Service Principal secret.\n      */\n     void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n+\n+    /**\n+     * Returns value of 'maxResultBuffer' from Connection String.\n+     *\n+     * @return 'maxResultBuffer' property.\n+     */\n+    String getMaxResultBuffer();\n+\n+    /**\n+     * Specifies value for 'maxResultBuffer' property\n+     *\n+     * @param maxResultBuffer\n+     *        String value for 'maxResultBuffer'\n+     */\n+    void setMaxResultBuffer(String maxResultBuffer);\n }\n", "next_change": {"commit": "af679a5f3754611273caa484fba9867a8e3c777c", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 87152862..1308a5cd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1060,10 +1060,42 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getMaxResultBuffer();\n \n     /**\n-     * Specifies value for 'maxResultBuffer' property\n+     * Sets the value for 'maxResultBuffer' property\n      *\n      * @param maxResultBuffer\n      *        String value for 'maxResultBuffer'\n      */\n     void setMaxResultBuffer(String maxResultBuffer);\n+\n+    /**\n+     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n+     * failure\n+     * \n+     * @param count\n+     *        the number of reconnection attempts if there is a connection failure\n+     */\n+    void setConnectRetryCount(int count);\n+\n+    /**\n+     * Returns the value of 'connectRetryCount' property\n+     * \n+     * @return 'connectRetryCount' property.\n+     */\n+    int getConnectRetryCount();\n+\n+    /**\n+     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n+     * attempt\n+     * \n+     * @param interval\n+     *        the number of seconds between each connection retry attempt\n+     */\n+    void setConnectRetryInterval(int interval);\n+\n+    /**\n+     * Returns the value of 'connectRetryInterval' property\n+     * \n+     * @return 'connectRetryInterval' property.\n+     */\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 1308a5cd..210bb34b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1068,34 +1099,32 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     void setMaxResultBuffer(String maxResultBuffer);\n \n     /**\n-     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n-     * failure\n-     * \n-     * @param count\n-     *        the number of reconnection attempts if there is a connection failure\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setConnectRetryCount(int count);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the value of 'connectRetryCount' property\n-     * \n-     * @return 'connectRetryCount' property.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     *\n+     * @return maximum number of attempts\n      */\n-    int getConnectRetryCount();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n-     * attempt\n-     * \n-     * @param interval\n-     *        the number of seconds between each connection retry attempt\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setConnectRetryInterval(int interval);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the value of 'connectRetryInterval' property\n-     * \n-     * @return 'connectRetryInterval' property.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    int getConnectRetryInterval();\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 210bb34b..e9f55e9b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1119,12 +1119,12 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param connectRetryInterval\n      *        interval in seconds\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n      * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n      *\n      * @return interval in seconds\n      */\n-    public int getConnectRetryInterval();\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex e9f55e9b..76db4be5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1127,4 +1126,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return interval in seconds\n      */\n     int getConnectRetryInterval();\n+\n+    /**\n+     * Sets the behavior for the prepare method. {@link PrepareMethod}\n+     *\n+     * @param prepareMethod\n+     *        Changes the setting as per description\n+     */\n+    void setPrepareMethod(String prepareMethod);\n+\n+    /**\n+     * Returns the value indicating the prepare method. {@link PrepareMethod}\n+     *\n+     * @return prepare method\n+     */\n+    String getPrepareMethod();\n }\n", "next_change": {"commit": "900fe16ffb7b048d8617d79e5891f3ceb2e314e3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 76db4be5..c85bbd26 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1141,4 +1206,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return prepare method\n      */\n     String getPrepareMethod();\n+\n+    /**\n+     * Sets time-to-live for the the cached MSI token\n+     *\n+     * @param timeToLive\n+     *        Changes the setting as per description\n+     */\n+    void setMsiTokenCacheTtl(int timeToLive);\n+\n+    /**\n+     * Gets the time-to-live for the the cached MSI token\n+     *\n+     * @return time-to-live for the cached MSI token\n+     */\n+    int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex c85bbd26..19f98695 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1208,17 +1214,16 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getPrepareMethod();\n \n     /**\n-     * Sets time-to-live for the the cached MSI token\n-     *\n-     * @param timeToLive\n-     *        Changes the setting as per description\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method is a no-op for backwards compatibility only.\n      */\n+    @Deprecated\n     void setMsiTokenCacheTtl(int timeToLive);\n \n     /**\n-     * Gets the time-to-live for the the cached MSI token\n-     *\n-     * @return time-to-live for the cached MSI token\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method will always return 0 and is for backwards compatibility only.\n      */\n+    @Deprecated\n     int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 19f98695..a9ba172d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1223,7 +1226,24 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     /**\n      * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n      * This method will always return 0 and is for backwards compatibility only.\n+     *\n+     * @return Method will always return 0.\n      */\n     @Deprecated\n     int getMsiTokenCacheTtl();\n+\n+    /**\n+     * Sets the {@link SQLServerAccessTokenCallback} delegate.\n+     *\n+     * @param accessTokenCallback\n+     *        Access token callback delegate.\n+     */\n+    void setAccessTokenCallback(SQLServerAccessTokenCallback accessTokenCallback);\n+\n+    /**\n+     * Returns a {@link SQLServerAccessTokenCallback}, the access token callback delegate.\n+     *\n+     * @return Access token callback delegate.\n+     */\n+    SQLServerAccessTokenCallback getAccessTokenCallback();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NjIzMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r400576232", "body": "Same here.", "bodyText": "Same here.", "bodyHTML": "<p dir=\"auto\">Same here.</p>", "author": "ulvii", "createdAt": "2020-03-31T00:39:55Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -821,6 +821,21 @@\n      */\n     String getMSIClientId();\n \n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider user principal id.\n+     * \n+     * @param keyVaultPrincipalId\n+     *        principal Id of Azure Key Vault (AKV) Provider to be used for column encryption.", "originalCommit": "ff179c14be160f612d70e3102c4a4ed8e85dd628", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 49120388..f6104c6d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,157 +804,35 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n-     * \n-     * @param msiClientId\n-     *        Client ID of User Assigned Managed Identity\n-     */\n-    void setMSIClientId(String msiClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'msiClientId'.\n-     * \n-     * @return msiClientId property value\n-     */\n-    String getMSIClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider user principal id.\n-     * \n-     * @param keyVaultPrincipalId\n-     *        principal Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyStorePrincipalId(String keyVaultPrincipalId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultPrincipalId'.\n-     * \n-     * @return keyVaultPrincipalId\n-     */\n-    String getKeyStorePrincipalId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientId\n-     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultProviderClientId'.\n-     * \n-     * @return keyVaultProviderClientId\n-     */\n-    String getKeyVaultProviderClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientKey\n-     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n-\n-    /**\n-     * Returns the value for the connection property 'domain'.\n-     * \n-     * @return 'domain' property value\n-     */\n-    String getDomain();\n-\n-    /**\n-     * Sets the 'domain' connection property used for NTLM Authentication.\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n      *\n-     * @param domain\n-     *        Windows domain name\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setDomain(String domain);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the current flag value for useFmtOnly.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n      *\n-     * @return 'useFmtOnly' property value.\n+     * @return maximum number of attempts\n      */\n-    boolean getUseFmtOnly();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Specifies the flag to use FMTONLY for parameter metadata queries.\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n      *\n-     * @param useFmtOnly\n-     *        boolean value for 'useFmtOnly'.\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setUseFmtOnly(boolean useFmtOnly);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return enclave attestation URL.\n-     */\n-    String getEnclaveAttestationUrl();\n-\n-    /**\n-     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param url\n-     *        Enclave attestation URL.\n-     */\n-    void setEnclaveAttestationUrl(String url);\n-\n-    /**\n-     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return Enclave attestation protocol.\n-     */\n-    String getEnclaveAttestationProtocol();\n-\n-    /**\n-     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param protocol\n-     *        Enclave attestation protocol.\n-     */\n-    void setEnclaveAttestationProtocol(String protocol);\n-    \n-    /**\n-     * Returns client certificate path for client certificate authentication.\n-     * \n-     * @return Client certificate path.\n-     */\n-    String getClientCertificate();\n-\n-    /**\n-     * Sets client certificate path for client certificate authentication.\n-     * \n-     * @param certPath\n-     *        Client certificate path.\n-     */\n-    void setClientCertificate(String certPath);\n-    \n-    /**\n-     * Returns Private key file path for client certificate authentication.\n-     * \n-     * @return Private key file path.\n-     */\n-    String getClientKey();\n-\n-    /**\n-     * Sets Private key file path for client certificate authentication.\n-     * \n-     * @param keyPath\n-     *        Private key file path.\n-     */\n-    void setClientKey(String keyPath);\n-\n-    /**\n-     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n-     * \n-     * @param password\n-     *        Private key password.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    void setClientKeyPassword(String password);\n-\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d30f3404be0bf4a537455133a96ef35eb9c6b09a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex f6104c6d..866bca0f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,35 +834,142 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the maximum number of attempts to reestablish a broken connection.\n-     *\n-     * @param connectRetryCount\n-     *        maximum number of attempts\n+     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n+     * \n+     * @param msiClientId\n+     *        Client ID of User Assigned Managed Identity\n      */\n-    public void setConnectRetryCount(int connectRetryCount);\n+    void setMSIClientId(String msiClientId);\n \n     /**\n-     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     * Returns the value for the connection property 'msiClientId'.\n+     * \n+     * @return msiClientId property value\n+     */\n+    String getMSIClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientId\n+     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n+\n+    /**\n+     * Returns the value for the connection property 'keyVaultProviderClientId'.\n+     * \n+     * @return keyVaultProviderClientId\n+     */\n+    String getKeyVaultProviderClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientKey\n+     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n+\n+    /**\n+     * Returns the value for the connection property 'domain'.\n+     * \n+     * @return 'domain' property value\n+     */\n+    String getDomain();\n+\n+    /**\n+     * Sets the 'domain' connection property used for NTLM Authentication.\n      *\n-     * @return maximum number of attempts\n+     * @param domain\n+     *        Windows domain name\n      */\n-    public int getConnectRetryCount();\n+    void setDomain(String domain);\n \n     /**\n-     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     * Returns the current flag value for useFmtOnly.\n      *\n-     * @param connectRetryInterval\n-     *        interval in seconds\n+     * @return 'useFmtOnly' property value.\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    boolean getUseFmtOnly();\n \n     /**\n-     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     * Specifies the flag to use FMTONLY for parameter metadata queries.\n      *\n-     * @return interval in seconds\n+     * @param useFmtOnly\n+     *        boolean value for 'useFmtOnly'.\n      */\n-    public int getConnectRetryInterval();\n+    void setUseFmtOnly(boolean useFmtOnly);\n+\n+    /**\n+     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return enclave attestation URL.\n+     */\n+    String getEnclaveAttestationUrl();\n+\n+    /**\n+     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param url\n+     *        Enclave attestation URL.\n+     */\n+    void setEnclaveAttestationUrl(String url);\n+\n+    /**\n+     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return Enclave attestation protocol.\n+     */\n+    String getEnclaveAttestationProtocol();\n+\n+    /**\n+     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param protocol\n+     *        Enclave attestation protocol.\n+     */\n+    void setEnclaveAttestationProtocol(String protocol);\n+\n+    /**\n+     * Returns client certificate path for client certificate authentication.\n+     * \n+     * @return Client certificate path.\n+     */\n+    String getClientCertificate();\n+\n+    /**\n+     * Sets client certificate path for client certificate authentication.\n+     * \n+     * @param certPath\n+     *        Client certificate path.\n+     */\n+    void setClientCertificate(String certPath);\n+\n+    /**\n+     * Returns Private key file path for client certificate authentication.\n+     * \n+     * @return Private key file path.\n+     */\n+    String getClientKey();\n+\n+    /**\n+     * Sets Private key file path for client certificate authentication.\n+     * \n+     * @param keyPath\n+     *        Private key file path.\n+     */\n+    void setClientKey(String keyPath);\n+\n+    /**\n+     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n+     * \n+     * @param password\n+     *        Private key password.\n+     */\n+    void setClientKeyPassword(String password);\n+\n }\n", "next_change": {"commit": "f857e2505aec7b413fbd1f5b722862d915b2b2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 866bca0f..6e401075 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -972,4 +991,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setClientKeyPassword(String password);\n \n+    /**\n+     * Returns the current flag for value sendTemporalDataTypesAsStringForBulkCopy\n+     * \n+     * @return 'sendTemporalDataTypesAsStringForBulkCopy' property value.\n+     */\n+    boolean getSendTemporalDataTypesAsStringForBulkCopy();\n+\n+    /**\n+     * Specifies the flag to send temporal datatypes as String for Bulk Copy.\n+     * \n+     * @param sendTemporalDataTypesAsStringForBulkCopy\n+     *        boolean value for 'sendTemporalDataTypesAsStringForBulkCopy'.\n+     */\n+    void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n+\n }\n", "next_change": {"commit": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 6e401075..9288d59a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1006,4 +1021,34 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n \n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalId'.\n+     *\n+     * @return 'AADSecurePrincipalId' property value.\n+     */\n+    String getAADSecurePrincipalId();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalId' connection property used for Active Directory Service Principal authentication.\n+     *\n+     * @param AADSecurePrincipalId\n+     *        Active Directory Service Principal Id.\n+     */\n+    void setAADSecurePrincipalId(String AADSecurePrincipalId);\n+\n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalSecret'.\n+     *\n+     * @return 'AADSecurePrincipalSecret' property value.\n+     */\n+    String getAADSecurePrincipalSecret();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalSecret' connection property used for Active Directory Service Principal\n+     * authentication.\n+     *\n+     * @param AADSecurePrincipalSecret\n+     *        Active Directory Service Principal secret.\n+     */\n+    void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n }\n", "next_change": {"commit": "d9909748368af7d2944dab4fa382ee513f2b76f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 9288d59a..87152862 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1051,4 +1051,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      *        Active Directory Service Principal secret.\n      */\n     void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n+\n+    /**\n+     * Returns value of 'maxResultBuffer' from Connection String.\n+     *\n+     * @return 'maxResultBuffer' property.\n+     */\n+    String getMaxResultBuffer();\n+\n+    /**\n+     * Specifies value for 'maxResultBuffer' property\n+     *\n+     * @param maxResultBuffer\n+     *        String value for 'maxResultBuffer'\n+     */\n+    void setMaxResultBuffer(String maxResultBuffer);\n }\n", "next_change": {"commit": "af679a5f3754611273caa484fba9867a8e3c777c", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 87152862..1308a5cd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1060,10 +1060,42 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getMaxResultBuffer();\n \n     /**\n-     * Specifies value for 'maxResultBuffer' property\n+     * Sets the value for 'maxResultBuffer' property\n      *\n      * @param maxResultBuffer\n      *        String value for 'maxResultBuffer'\n      */\n     void setMaxResultBuffer(String maxResultBuffer);\n+\n+    /**\n+     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n+     * failure\n+     * \n+     * @param count\n+     *        the number of reconnection attempts if there is a connection failure\n+     */\n+    void setConnectRetryCount(int count);\n+\n+    /**\n+     * Returns the value of 'connectRetryCount' property\n+     * \n+     * @return 'connectRetryCount' property.\n+     */\n+    int getConnectRetryCount();\n+\n+    /**\n+     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n+     * attempt\n+     * \n+     * @param interval\n+     *        the number of seconds between each connection retry attempt\n+     */\n+    void setConnectRetryInterval(int interval);\n+\n+    /**\n+     * Returns the value of 'connectRetryInterval' property\n+     * \n+     * @return 'connectRetryInterval' property.\n+     */\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 1308a5cd..210bb34b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1068,34 +1099,32 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     void setMaxResultBuffer(String maxResultBuffer);\n \n     /**\n-     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n-     * failure\n-     * \n-     * @param count\n-     *        the number of reconnection attempts if there is a connection failure\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setConnectRetryCount(int count);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the value of 'connectRetryCount' property\n-     * \n-     * @return 'connectRetryCount' property.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     *\n+     * @return maximum number of attempts\n      */\n-    int getConnectRetryCount();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n-     * attempt\n-     * \n-     * @param interval\n-     *        the number of seconds between each connection retry attempt\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setConnectRetryInterval(int interval);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the value of 'connectRetryInterval' property\n-     * \n-     * @return 'connectRetryInterval' property.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    int getConnectRetryInterval();\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 210bb34b..e9f55e9b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1119,12 +1119,12 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param connectRetryInterval\n      *        interval in seconds\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n      * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n      *\n      * @return interval in seconds\n      */\n-    public int getConnectRetryInterval();\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex e9f55e9b..76db4be5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1127,4 +1126,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return interval in seconds\n      */\n     int getConnectRetryInterval();\n+\n+    /**\n+     * Sets the behavior for the prepare method. {@link PrepareMethod}\n+     *\n+     * @param prepareMethod\n+     *        Changes the setting as per description\n+     */\n+    void setPrepareMethod(String prepareMethod);\n+\n+    /**\n+     * Returns the value indicating the prepare method. {@link PrepareMethod}\n+     *\n+     * @return prepare method\n+     */\n+    String getPrepareMethod();\n }\n", "next_change": {"commit": "900fe16ffb7b048d8617d79e5891f3ceb2e314e3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 76db4be5..c85bbd26 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1141,4 +1206,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return prepare method\n      */\n     String getPrepareMethod();\n+\n+    /**\n+     * Sets time-to-live for the the cached MSI token\n+     *\n+     * @param timeToLive\n+     *        Changes the setting as per description\n+     */\n+    void setMsiTokenCacheTtl(int timeToLive);\n+\n+    /**\n+     * Gets the time-to-live for the the cached MSI token\n+     *\n+     * @return time-to-live for the cached MSI token\n+     */\n+    int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex c85bbd26..19f98695 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1208,17 +1214,16 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getPrepareMethod();\n \n     /**\n-     * Sets time-to-live for the the cached MSI token\n-     *\n-     * @param timeToLive\n-     *        Changes the setting as per description\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method is a no-op for backwards compatibility only.\n      */\n+    @Deprecated\n     void setMsiTokenCacheTtl(int timeToLive);\n \n     /**\n-     * Gets the time-to-live for the the cached MSI token\n-     *\n-     * @return time-to-live for the cached MSI token\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method will always return 0 and is for backwards compatibility only.\n      */\n+    @Deprecated\n     int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 19f98695..a9ba172d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1223,7 +1226,24 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     /**\n      * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n      * This method will always return 0 and is for backwards compatibility only.\n+     *\n+     * @return Method will always return 0.\n      */\n     @Deprecated\n     int getMsiTokenCacheTtl();\n+\n+    /**\n+     * Sets the {@link SQLServerAccessTokenCallback} delegate.\n+     *\n+     * @param accessTokenCallback\n+     *        Access token callback delegate.\n+     */\n+    void setAccessTokenCallback(SQLServerAccessTokenCallback accessTokenCallback);\n+\n+    /**\n+     * Returns a {@link SQLServerAccessTokenCallback}, the access token callback delegate.\n+     *\n+     * @return Access token callback delegate.\n+     */\n+    SQLServerAccessTokenCallback getAccessTokenCallback();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "49224f57565a52cb69c0e6ed464205019f4df652", "url": "https://github.com/microsoft/mssql-jdbc/commit/49224f57565a52cb69c0e6ed464205019f4df652", "message": "comment changes", "committedDate": "2020-03-31T01:20:07Z", "type": "commit"}, {"oid": "2a55d5b70b3dc899ddee573e04564d0ee6647c00", "url": "https://github.com/microsoft/mssql-jdbc/commit/2a55d5b70b3dc899ddee573e04564d0ee6647c00", "message": "remove unused", "committedDate": "2020-03-31T01:57:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAzMjU3Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401032576", "body": "Please do not call class.getName() in logger, it traverses the stack and is extremely costly performance-wise. I also recommend checking the logging level before calling these entering/exiting methods, although I'm not sure if the intent here is to always log. As for the class.getName(), just use a static string, so SQLServerConnection.class.getName() would be \"com.microsoft.sqlserver.jdbc.SQLServerConnection\".", "bodyText": "Please do not call class.getName() in logger, it traverses the stack and is extremely costly performance-wise. I also recommend checking the logging level before calling these entering/exiting methods, although I'm not sure if the intent here is to always log. As for the class.getName(), just use a static string, so SQLServerConnection.class.getName() would be \"com.microsoft.sqlserver.jdbc.SQLServerConnection\".", "bodyHTML": "<p dir=\"auto\">Please do not call class.getName() in logger, it traverses the stack and is extremely costly performance-wise. I also recommend checking the logging level before calling these entering/exiting methods, although I'm not sure if the intent here is to always log. As for the class.getName(), just use a static string, so SQLServerConnection.class.getName() would be \"com.microsoft.sqlserver.jdbc.SQLServerConnection\".</p>", "author": "rene-ye", "createdAt": "2020-03-31T16:03:20Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -720,6 +722,23 @@ public static synchronized void registerColumnEncryptionKeyStoreProviders(\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n+    /**\n+     * Unregisters the custom key store providers from the globalCustomColumnEncryptionKeyStoreProviders.\n+     */\n+    public static synchronized void unregisterColumnEncryptionKeyStoreProviders() {\n+        loggerExternal.entering(SQLServerConnection.class.getName(), \"unregisterColumnEncryptionKeyStoreProviders\",\n+                \"Removing Column Encryption Key Store Provider\");\n+\n+        if (null != globalCustomColumnEncryptionKeyStoreProviders) {\n+            globalCustomColumnEncryptionKeyStoreProviders.clear();\n+        }\n+\n+        loggerExternal.exiting(SQLServerConnection.class.getName(), \"unregisterColumnEncryptionKeyStoreProviders\",", "originalCommit": "2a55d5b70b3dc899ddee573e04564d0ee6647c00", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 96ea4030..7e6320f2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -722,32 +664,20 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n-    /**\n-     * Unregisters the custom key store providers from the globalCustomColumnEncryptionKeyStoreProviders.\n-     */\n-    public static synchronized void unregisterColumnEncryptionKeyStoreProviders() {\n-        loggerExternal.entering(SQLServerConnection.class.getName(), \"unregisterColumnEncryptionKeyStoreProviders\",\n-                \"Removing Column Encryption Key Store Provider\");\n-\n-        if (null != globalCustomColumnEncryptionKeyStoreProviders) {\n-            globalCustomColumnEncryptionKeyStoreProviders.clear();\n-        }\n-\n-        loggerExternal.exiting(SQLServerConnection.class.getName(), \"unregisterColumnEncryptionKeyStoreProviders\",\n-                \"Number of Key store providers that are registered:\"\n-                        + (null != globalCustomColumnEncryptionKeyStoreProviders ? globalCustomColumnEncryptionKeyStoreProviders\n-                                .size() : 0));\n-    }\n-\n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n+    static synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n             String providerName) {\n-        return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders\n-                .containsKey(providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+        if (null != globalSystemColumnEncryptionKeyStoreProviders\n+                && globalSystemColumnEncryptionKeyStoreProviders.containsKey(providerName)) {\n+            return globalSystemColumnEncryptionKeyStoreProviders.get(providerName);\n+        }\n+        return null;\n     }\n \n-    synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n-        return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders\n-                .keySet().toString() : null;\n+    static synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n+        if (null != globalCustomColumnEncryptionKeyStoreProviders)\n+            return globalCustomColumnEncryptionKeyStoreProviders.keySet().toString();\n+        else\n+            return null;\n     }\n \n     synchronized String getAllSystemColumnEncryptionKeyStoreProviders() {\n", "next_change": {"commit": "d30f3404be0bf4a537455133a96ef35eb9c6b09a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 7e6320f2..87e5d817 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -664,20 +732,15 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n-    static synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n+    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n             String providerName) {\n-        if (null != globalSystemColumnEncryptionKeyStoreProviders\n-                && globalSystemColumnEncryptionKeyStoreProviders.containsKey(providerName)) {\n-            return globalSystemColumnEncryptionKeyStoreProviders.get(providerName);\n-        }\n-        return null;\n+        return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders\n+                .containsKey(providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n     }\n \n-    static synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n-        if (null != globalCustomColumnEncryptionKeyStoreProviders)\n-            return globalCustomColumnEncryptionKeyStoreProviders.keySet().toString();\n-        else\n-            return null;\n+    synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n+        return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders\n+                .keySet().toString() : null;\n     }\n \n     synchronized String getAllSystemColumnEncryptionKeyStoreProviders() {\n", "next_change": {"commit": "bf7adc07ae6e31f96adf2e9ced8fc6603ffec9bf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 87e5d817..be09b2b4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -718,81 +967,243 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                 Object[] msgArgs = {providerName, RESERVED_PROVIDER_NAME_PREFIX};\n                 throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n             }\n-            if (null == entry.getValue()) {\n-                MessageFormat form = new MessageFormat(\n-                        SQLServerException.getErrString(\"R_CustomKeyStoreProviderValueNull\"));\n-                Object[] msgArgs = {providerName, RESERVED_PROVIDER_NAME_PREFIX};\n-                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+\n+            SQLServerColumnEncryptionKeyStoreProvider provider = entry.getValue();\n+            if (null == provider) {\n+                throw new SQLServerException(null, String\n+                        .format(SQLServerException.getErrString(\"R_CustomKeyStoreProviderValueNull\"), providerName),\n+                        null, 0, false);\n+            }\n+\n+                // Global providers should not use their own CEK caches.\n+                provider.setColumnEncryptionCacheTtl(Duration.ZERO);\n+                globalCustomColumnEncryptionKeyStoreProviders.put(providerName, provider);\n             }\n-            globalCustomColumnEncryptionKeyStoreProviders.put(entry.getKey(), entry.getValue());\n+        } finally {\n+            LOCK.unlock();\n         }\n \n-        loggerExternal.exiting(SQLServerConnection.class.getName(), \"registerColumnEncryptionKeyStoreProviders\",\n+        loggerExternal.exiting(loggingClassNameBase, \"registerColumnEncryptionKeyStoreProviders\",\n                 \"Number of Key store providers that are registered:\"\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n-            String providerName) {\n-        return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders\n-                .containsKey(providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+    /**\n+     * Unregisters all the custom key store providers from the globalCustomColumnEncryptionKeyStoreProviders by clearing\n+     * the map and setting it to null.\n+     */\n+    public static void unregisterColumnEncryptionKeyStoreProviders() {\n+        loggerExternal.entering(loggingClassNameBase, \"unregisterColumnEncryptionKeyStoreProviders\",\n+                \"Removing Column Encryption Key Store Provider\");\n+\n+        LOCK.lock();\n+        try {\n+            if (null != globalCustomColumnEncryptionKeyStoreProviders) {\n+                globalCustomColumnEncryptionKeyStoreProviders.clear();\n+                globalCustomColumnEncryptionKeyStoreProviders = null;\n+            }\n+        } finally {\n+            LOCK.unlock();\n+        }\n+\n+        loggerExternal.exiting(loggingClassNameBase, \"unregisterColumnEncryptionKeyStoreProviders\",\n+                \"Number of Key store providers that are registered: 0\");\n+    }\n+\n+    SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(String providerName) {\n+        lock.lock();\n+        try {\n+            return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders.containsKey(\n+                    providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n-        return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders\n-                .keySet().toString() : null;\n+    String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n+        lock.lock();\n+        try {\n+            return (null != globalCustomColumnEncryptionKeyStoreProviders)\n+                    ? globalCustomColumnEncryptionKeyStoreProviders.keySet().toString() : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized String getAllSystemColumnEncryptionKeyStoreProviders() {\n-        String keyStores = \"\";\n-        if (0 != systemColumnEncryptionKeyStoreProvider.size())\n-            keyStores = systemColumnEncryptionKeyStoreProvider.keySet().toString();\n-        if (0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size())\n-            keyStores += \",\" + SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.keySet().toString();\n-        return keyStores;\n+    String getAllSystemColumnEncryptionKeyStoreProviders() {\n+        lock.lock();\n+        try {\n+            String keyStores = \"\";\n+            if (0 != systemColumnEncryptionKeyStoreProvider.size()) {\n+                keyStores = systemColumnEncryptionKeyStoreProvider.keySet().toString();\n+            }\n+            if (0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size()) {\n+                keyStores += \",\" + SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.keySet()\n+                        .toString();\n+            }\n+            return keyStores;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalCustomColumnEncryptionKeyStoreProvider(\n-            String providerName) {\n-        return (null != globalCustomColumnEncryptionKeyStoreProviders && globalCustomColumnEncryptionKeyStoreProviders\n-                .containsKey(providerName)) ? globalCustomColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+    SQLServerColumnEncryptionKeyStoreProvider getGlobalCustomColumnEncryptionKeyStoreProvider(String providerName) {\n+        lock.lock();\n+        try {\n+            return (null != globalCustomColumnEncryptionKeyStoreProviders && globalCustomColumnEncryptionKeyStoreProviders.containsKey(\n+                    providerName)) ? globalCustomColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getSystemColumnEncryptionKeyStoreProvider(\n-            String providerName) {\n-        return (null != systemColumnEncryptionKeyStoreProvider && systemColumnEncryptionKeyStoreProvider\n-                .containsKey(providerName)) ? systemColumnEncryptionKeyStoreProvider.get(providerName) : null;\n+    SQLServerColumnEncryptionKeyStoreProvider getSystemColumnEncryptionKeyStoreProvider(String providerName) {\n+        lock.lock();\n+        try {\n+            return (null != systemColumnEncryptionKeyStoreProvider && systemColumnEncryptionKeyStoreProvider.containsKey(\n+                    providerName)) ? systemColumnEncryptionKeyStoreProvider.get(providerName) : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getColumnEncryptionKeyStoreProvider(\n+    SQLServerColumnEncryptionKeyStoreProvider getSystemOrGlobalColumnEncryptionKeyStoreProvider(\n             String providerName) throws SQLServerException {\n+        lock.lock();\n+        try {\n+            // check for global system providers\n+            keystoreProvider = getGlobalSystemColumnEncryptionKeyStoreProvider(providerName);\n+\n+            // Check for the connection system provider.\n+            if (null == keystoreProvider) {\n+                keystoreProvider = getSystemColumnEncryptionKeyStoreProvider(providerName);\n+            }\n \n-        // Check for the connection provider first.\n-        keystoreProvider = getSystemColumnEncryptionKeyStoreProvider(providerName);\n+            // There is no global system provider of this name, check for the global custom providers.\n+            if (null == keystoreProvider) {\n+                keystoreProvider = getGlobalCustomColumnEncryptionKeyStoreProvider(providerName);\n+            }\n \n-        // There is no connection provider of this name, check for the global system providers.\n-        if (null == keystoreProvider) {\n-            keystoreProvider = getGlobalSystemColumnEncryptionKeyStoreProvider(providerName);\n+            // No provider was found of this name.\n+            if (null == keystoreProvider) {\n+                String systemProviders = getAllSystemColumnEncryptionKeyStoreProviders();\n+                String customProviders = getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders();\n+                MessageFormat form = new MessageFormat(\n+                        SQLServerException.getErrString(\"R_UnrecognizedKeyStoreProviderName\"));\n+                Object[] msgArgs = {providerName, systemProviders, customProviders};\n+                throw new SQLServerException(form.format(msgArgs), null);\n+            }\n+\n+            return keystoreProvider;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    boolean hasConnectionColumnEncryptionKeyStoreProvidersRegistered() {\n+        lock.lock();\n+        try {\n+            return null != connectionColumnEncryptionKeyStoreProvider && connectionColumnEncryptionKeyStoreProvider.size() > 0;\n+        } finally {\n+            lock.unlock();\n         }\n+    }\n \n-        // There is no global system provider of this name, check for the global custom providers.\n-        if (null == keystoreProvider) {\n-            keystoreProvider = getGlobalCustomColumnEncryptionKeyStoreProvider(providerName);\n+    String getAllConnectionColumnEncryptionKeyStoreProviders() {\n+        lock.lock();\n+        try {\n+            String keyStores = \"\";\n+            if (0 != connectionColumnEncryptionKeyStoreProvider.size()) {\n+                keyStores = connectionColumnEncryptionKeyStoreProvider.keySet().toString();\n+            }\n+            return keyStores;\n+        } finally {\n+            lock.unlock();\n         }\n+    }\n \n-        // No provider was found of this name.\n-        if (null == keystoreProvider) {\n-            String systemProviders = getAllSystemColumnEncryptionKeyStoreProviders();\n-            String customProviders = getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders();\n-            MessageFormat form = new MessageFormat(\n-                    SQLServerException.getErrString(\"R_UnrecognizedKeyStoreProviderName\"));\n-            Object[] msgArgs = {providerName, systemProviders, customProviders};\n-            throw new SQLServerException(form.format(msgArgs), null);\n+    SQLServerColumnEncryptionKeyStoreProvider getColumnEncryptionKeyStoreProviderOnConnection(\n+            String providerName) throws SQLServerException {\n+        lock.lock();\n+        try {\n+            // Check for a connection-level provider first\n+            if (null != connectionColumnEncryptionKeyStoreProvider\n+                    && connectionColumnEncryptionKeyStoreProvider.size() > 0) {\n+                // If any connection-level providers are registered, we don't fall back to system/global providers\n+                if (connectionColumnEncryptionKeyStoreProvider.containsKey(providerName)) {\n+                    return connectionColumnEncryptionKeyStoreProvider.get(providerName);\n+                } else {\n+                    MessageFormat form = new MessageFormat(\n+                            SQLServerException.getErrString(\"R_UnrecognizedConnectionKeyStoreProviderName\"));\n+                    Object[] msgArgs = {providerName, getAllConnectionColumnEncryptionKeyStoreProviders()};\n+                    throw new SQLServerException(form.format(msgArgs), null);\n+                }\n+            }\n+\n+            // No connection-level providers registered, so return system/global provider\n+            return getSystemOrGlobalColumnEncryptionKeyStoreProvider(providerName);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /** This is a user-defined per-connection store provider. */\n+    Map<String, SQLServerColumnEncryptionKeyStoreProvider> connectionColumnEncryptionKeyStoreProvider = new HashMap<>();\n+\n+    /**\n+     * Registers connection-level key store providers, replacing all existing providers.\n+     *\n+     * @param clientKeyStoreProviders\n+     *         a map containing the store providers information.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public void registerColumnEncryptionKeyStoreProvidersOnConnection(\n+            Map<String, SQLServerColumnEncryptionKeyStoreProvider> clientKeyStoreProviders) throws SQLServerException {\n+        loggerExternal.entering(loggingClassName, \"registerColumnEncryptionKeyStoreProvidersOnConnection\",\n+                \"Registering Column Encryption Key Store Providers on Connection\");\n+        lock.lock();\n+        try {\n+            if (null == clientKeyStoreProviders) {\n+                throw new SQLServerException(null, SQLServerException.getErrString(\"R_CustomKeyStoreProviderMapNull\"),\n+                        null, 0, false);\n+            }\n+\n+            connectionColumnEncryptionKeyStoreProvider.clear();\n+\n+            for (Map.Entry<String, SQLServerColumnEncryptionKeyStoreProvider> entry : clientKeyStoreProviders.entrySet()) {\n+                String providerName = entry.getKey();\n+                if (null == providerName || 0 == providerName.trim().length()) {\n+                    throw new SQLServerException(null,\n+                            SQLServerException.getErrString(\"R_EmptyCustomKeyStoreProviderName\"), null, 0, false);\n+                }\n+\n+                // MSSQL_CERTIFICATE_STORE not allowed on connection level\n+                if ((providerName.equalsIgnoreCase(WINDOWS_KEY_STORE_NAME))) {\n+                    MessageFormat form = new MessageFormat(\n+                            SQLServerException.getErrString(\"R_InvalidCustomKeyStoreProviderName\"));\n+                    Object[] msgArgs = {providerName, WINDOWS_KEY_STORE_NAME};\n+                    throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                }\n+\n+                if (null == entry.getValue()) {\n+                    throw new SQLServerException(null,\n+                            String.format(SQLServerException.getErrString(\"R_CustomKeyStoreProviderValueNull\"),\n+                                    providerName), null, 0, false);\n+                }\n+\n+                connectionColumnEncryptionKeyStoreProvider.put(entry.getKey(), entry.getValue());\n+            }\n+        } finally {\n+            lock.unlock();\n         }\n \n-        return keystoreProvider;\n+        loggerExternal.exiting(loggingClassName, \"registerColumnEncryptionKeyStoreProvidersOnConnection\",\n+                \"Number of connection-level Key store providers that are registered: \"\n+                        + connectionColumnEncryptionKeyStoreProvider.size());\n     }\n \n+    /** trusted servername AE */\n     private String trustedServerNameAE = null;\n     private static Map<String, List<String>> columnEncryptionTrustedMasterKeyPaths = new HashMap<>();\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAzNDQ5Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401034497", "body": "Feels like a waste to create a hash-map w/ 1 entry just to conform to the existing constructor. Maybe this can be done better?", "bodyText": "Feels like a waste to create a hash-map w/ 1 entry just to conform to the existing constructor. Maybe this can be done better?", "bodyHTML": "<p dir=\"auto\">Feels like a waste to create a hash-map w/ 1 entry just to conform to the existing constructor. Maybe this can be done better?</p>", "author": "rene-ye", "createdAt": "2020-03-31T16:06:07Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -1291,7 +1316,30 @@ private void registerKeyStoreProviderOnConnection(String keyStoreAuth, String ke\n                         systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     }\n                     break;\n-\n+                case KeyVaultClientSecret:\n+                    // need a secret use use the secret method\n+                    if (null == keyStoreSecret) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n+                    } else {\n+                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                                keyStorePrincipalId, keyStoreSecret);\n+                        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                        keyStoreMap.put(provider.getName(), provider);\n+                        registerColumnEncryptionKeyStoreProviders(keyStoreMap);", "originalCommit": "2a55d5b70b3dc899ddee573e04564d0ee6647c00", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 96ea4030..7e6320f2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1316,30 +1205,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     }\n                     break;\n-                case KeyVaultClientSecret:\n-                    // need a secret use use the secret method\n-                    if (null == keyStoreSecret) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n-                    } else {\n-                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                                keyStorePrincipalId, keyStoreSecret);\n-                        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n-                        keyStoreMap.put(provider.getName(), provider);\n-                        registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n-                    }\n-                    break;\n-                case KeyVaultManagedIdentity:\n-                    SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n-                    if (null != keyStorePrincipalId) {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n-                    } else {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n-                    }\n-                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n-                    keyStoreMap.put(provider.getName(), provider);\n-                    registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n-                    break;\n+\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n                     break;\n", "next_change": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 7e6320f2..3973bfc8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1205,7 +1313,30 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     }\n                     break;\n-\n+                case KeyVaultClientSecret:\n+                    // need a secret use use the secret method\n+                    if (null == keyStoreSecret) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_keyStoreSecretNotSet\"), null);\n+                    } else {\n+                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                                keyStorePrincipalId, keyStoreSecret);\n+                        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                        keyStoreMap.put(provider.getName(), provider);\n+                        registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+                    }\n+                    break;\n+                case KeyVaultManagedIdentity:\n+                    SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n+                    if (null != keyStorePrincipalId) {\n+                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n+                    } else {\n+                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n+                    }\n+                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                    keyStoreMap.put(provider.getName(), provider);\n+                    registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+                    break;\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n                     break;\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 3973bfc8..36c0bb8b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1333,7 +1379,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                     } else {\n                         provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n                     }\n-                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<>();\n                     keyStoreMap.put(provider.getName(), provider);\n                     registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n                     break;\n", "next_change": {"commit": "21b8ec1ac90884ca7c83b7a79a08bf78702b52bb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 36c0bb8b..da4731e7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1379,9 +1604,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                     } else {\n                         provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n                     }\n-                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<>();\n-                    keyStoreMap.put(provider.getName(), provider);\n-                    registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+                    systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     break;\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n", "next_change": {"commit": "8e66ac0b5364be903d337828f5cec9dd352972e3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex da4731e7..802e9c12 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1577,34 +1749,13 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n             KeyStoreAuthentication keyStoreAuthentication = KeyStoreAuthentication.valueOfString(keyStoreAuth);\n             switch (keyStoreAuthentication) {\n                 case JavaKeyStorePassword:\n-                    // both secret and location must be set for JKS.\n-                    if ((null == keyStoreSecret) || (null == keyStoreLocation)) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n-                    } else {\n-                        SQLServerColumnEncryptionJavaKeyStoreProvider provider = new SQLServerColumnEncryptionJavaKeyStoreProvider(\n-                                keyStoreLocation, keyStoreSecret.toCharArray());\n-                        systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n-                    }\n+                    setKeyStoreSecretAndLocation(keyStoreSecret, keyStoreLocation);\n                     break;\n                 case KeyVaultClientSecret:\n-                    // need a secret to use the secret method\n-                    if (null == keyStoreSecret) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_keyStoreSecretNotSet\"), null);\n-                    } else {\n-                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                                keyStorePrincipalId, keyStoreSecret);\n-                        systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n-                    }\n+                    this.setKeyVaultProvider(keyStorePrincipalId, keyStoreSecret);\n                     break;\n                 case KeyVaultManagedIdentity:\n-                    SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n-                    if (null != keyStorePrincipalId) {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n-                    } else {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n-                    }\n-                    systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+                    setKeyVaultProvider(keyStorePrincipalId);\n                     break;\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 802e9c12..1d502335 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1764,14 +1765,14 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n \n-    private void setKeyStoreSecretAndLocation(String keyStoreSecret, String keyStoreLocation) throws SQLServerException {\n+    private void setKeyStoreSecretAndLocation(String keyStoreSecret,\n+            String keyStoreLocation) throws SQLServerException {\n         // both secret and location must be set for JKS.\n         if ((null == keyStoreSecret) || (null == keyStoreLocation)) {\n-            throw new SQLServerException(\n-                    SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n         } else {\n             SQLServerColumnEncryptionJavaKeyStoreProvider provider = new SQLServerColumnEncryptionJavaKeyStoreProvider(\n-                     keyStoreLocation, keyStoreSecret.toCharArray());\n+                    keyStoreLocation, keyStoreSecret.toCharArray());\n             systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n         }\n     }\n", "next_change": null}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex da4731e7..802e9c12 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1613,6 +1764,39 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n \n+    private void setKeyStoreSecretAndLocation(String keyStoreSecret, String keyStoreLocation) throws SQLServerException {\n+        // both secret and location must be set for JKS.\n+        if ((null == keyStoreSecret) || (null == keyStoreLocation)) {\n+            throw new SQLServerException(\n+                    SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n+        } else {\n+            SQLServerColumnEncryptionJavaKeyStoreProvider provider = new SQLServerColumnEncryptionJavaKeyStoreProvider(\n+                     keyStoreLocation, keyStoreSecret.toCharArray());\n+            systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+        }\n+    }\n+\n+    private void setKeyVaultProvider(String keyStorePrincipalId) throws SQLServerException {\n+        SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n+        if (null != keyStorePrincipalId) {\n+            provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n+        } else {\n+            provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n+        }\n+        systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+    }\n+\n+    private void setKeyVaultProvider(String keyStorePrincipalId, String keyStoreSecret) throws SQLServerException {\n+        // need a secret to use the secret method\n+        if (null == keyStoreSecret) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_keyStoreSecretNotSet\"), null);\n+        } else {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    keyStorePrincipalId, keyStoreSecret);\n+            systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+        }\n+    }\n+\n     // Helper to check if timeout value is valid\n     int validateTimeout(SQLServerDriverIntProperty property) throws SQLServerException {\n         int timeout = property.getDefaultValue();\n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 3973bfc8..36c0bb8b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1344,6 +1390,15 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n \n+    private void registerKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        // need a secret to use the secret method\n+        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                clientId, clientKey);\n+        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<>();\n+        keyStoreMap.put(provider.getName(), provider);\n+        registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+    }\n+\n     /**\n      * Establish a physical database connection based on the user specified connection properties. Logon to the\n      * database.\n", "next_change": {"commit": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 36c0bb8b..851c6569 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1399,6 +1455,29 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n     }\n \n+    // Helper to check if timeout value is valid\n+    int validateTimeout(SQLServerDriverIntProperty property) throws SQLServerException {\n+        int timeout = property.getDefaultValue();\n+        String sPropValue = activeConnectionProperties.getProperty(property.toString());\n+        if (null != sPropValue && sPropValue.length() > 0) {\n+            try {\n+                timeout = Integer.parseInt(sPropValue);\n+                if (!property.isValidValue(timeout)) {\n+                    MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_invalidTimeOut\"));\n+                    Object[] msgArgs = {sPropValue};\n+                    SQLServerException.makeFromDriverError(this, this, form.format(msgArgs), null, false);\n+\n+                }\n+            } catch (NumberFormatException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_invalidTimeOut\"));\n+                Object[] msgArgs = {sPropValue};\n+                SQLServerException.makeFromDriverError(this, this, form.format(msgArgs), null, false);\n+\n+            }\n+        }\n+        return timeout;\n+    }\n+\n     /**\n      * Establish a physical database connection based on the user specified connection properties. Logon to the\n      * database.\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAzNjI0OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401036248", "body": "Response codes shouldn't be magic numbers, better to create constants and document a little of their meaning in comments. I think this part of the code is just moved though so please document/create a work item.", "bodyText": "Response codes shouldn't be magic numbers, better to create constants and document a little of their meaning in comments. I think this part of the code is just moved though so please document/create a work item.", "bodyHTML": "<p dir=\"auto\">Response codes shouldn't be magic numbers, better to create constants and document a little of their meaning in comments. I think this part of the code is just moved though so please document/create a work item.</p>", "author": "rene-ye", "createdAt": "2020-03-31T16:08:31Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java", "diffHunk": "@@ -215,4 +234,164 @@ static void verifyColumnMasterKeyMetadata(SQLServerConnection connection, String\n             throw new SQLServerException(SQLServerException.getErrString(\"R_VerifySignature\"), null);\r\n         }\r\n     }\r\n+\r\n+    /**\r\n+     * Get Managed Identity Authentication token\r\n+     * \r\n+     * @param resource\r\n+     *        token resource\r\n+     * @param msiClientId\r\n+     *        Managed Identity or User Assigned Managed Identity\r\n+     * @return fedauth token\r\n+     * @throws SQLServerException\r\n+     */\r\n+    static SqlFedAuthToken getMSIAuthToken(String resource, String msiClientId) throws SQLServerException {\r\n+        // IMDS upgrade time can take up to 70s\r\n+        final int imdsUpgradeTimeInMs = 70 * 1000;\r\n+        final List<Integer> retrySlots = new ArrayList<>();\r\n+        final String msiEndpoint = System.getenv(\"MSI_ENDPOINT\");\r\n+        final String msiSecret = System.getenv(\"MSI_SECRET\");\r\n+\r\n+        StringBuilder urlString = new StringBuilder();\r\n+        int retry = 1, maxRetry = 1;\r\n+\r\n+        /*\r\n+         * isAzureFunction is used for identifying if the current client application is running in a Virtual Machine\r\n+         * (without MSI environment variables) or App Service/Function (with MSI environment variables) as the APIs to\r\n+         * be called for acquiring MSI Token are different for both cases.\r\n+         */\r\n+        boolean isAzureFunction = null != msiEndpoint && !msiEndpoint.isEmpty() && null != msiSecret\r\n+                && !msiSecret.isEmpty();\r\n+\r\n+        if (isAzureFunction) {\r\n+            urlString.append(msiEndpoint).append(\"?api-version=2017-09-01&resource=\").append(resource);\r\n+        } else {\r\n+            urlString.append(ActiveDirectoryAuthentication.AZURE_REST_MSI_URL).append(\"&resource=\").append(resource);\r\n+            // Retry acquiring access token upto 20 times due to possible IMDS upgrade (Applies to VM only)\r\n+            maxRetry = 20;\r\n+            // Simplified variant of Exponential BackOff\r\n+            for (int x = 0; x < maxRetry; x++) {\r\n+                retrySlots.add(500 * ((2 << 1) - 1) / 1000);\r\n+            }\r\n+        }\r\n+\r\n+        // Append Client Id if available\r\n+        if (null != msiClientId && !msiClientId.isEmpty()) {\r\n+            if (isAzureFunction) {\r\n+                urlString.append(\"&clientid=\").append(msiClientId);\r\n+            } else {\r\n+                urlString.append(\"&client_id=\").append(msiClientId);\r\n+            }\r\n+        }\r\n+\r\n+        // Loop while maxRetry reaches its limit\r\n+        while (retry <= maxRetry) {\r\n+            HttpURLConnection connection = null;\r\n+\r\n+            try {\r\n+                connection = (HttpURLConnection) new URL(urlString.toString()).openConnection();\r\n+                connection.setRequestMethod(\"GET\");\r\n+\r\n+                if (isAzureFunction) {\r\n+                    connection.setRequestProperty(\"Secret\", msiSecret);\r\n+                    if (connectionlogger.isLoggable(Level.FINER)) {\r\n+                        connectionlogger.finer(\"Using Azure Function/App Service MSI auth: \" + urlString);\r\n+                    }\r\n+                } else {\r\n+                    connection.setRequestProperty(\"Metadata\", \"true\");\r\n+                    if (connectionlogger.isLoggable(Level.FINER)) {\r\n+                        connectionlogger.finer(\"Using Azure MSI auth: \" + urlString);\r\n+                    }\r\n+                }\r\n+\r\n+                connection.connect();\r\n+\r\n+                try (InputStream stream = connection.getInputStream()) {\r\n+\r\n+                    BufferedReader reader = new BufferedReader(new InputStreamReader(stream, UTF_8), 100);\r\n+                    String result = reader.readLine();\r\n+\r\n+                    int startIndex_AT = result.indexOf(ActiveDirectoryAuthentication.ACCESS_TOKEN_IDENTIFIER)\r\n+                            + ActiveDirectoryAuthentication.ACCESS_TOKEN_IDENTIFIER.length();\r\n+\r\n+                    String accessToken = result.substring(startIndex_AT, result.indexOf(\"\\\"\", startIndex_AT + 1));\r\n+\r\n+                    Calendar cal = new Calendar.Builder().setInstant(new Date()).build();\r\n+\r\n+                    if (isAzureFunction) {\r\n+                        // Fetch expires_on\r\n+                        int startIndex_ATX = result\r\n+                                .indexOf(ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_ON_IDENTIFIER)\r\n+                                + ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_ON_IDENTIFIER.length();\r\n+                        String accessTokenExpiry = result.substring(startIndex_ATX,\r\n+                                result.indexOf(\"\\\"\", startIndex_ATX + 1));\r\n+                        if (connectionlogger.isLoggable(Level.FINER)) {\r\n+                            connectionlogger.finer(\"MSI auth token expires on: \" + accessTokenExpiry);\r\n+                        }\r\n+\r\n+                        DateFormat df = new SimpleDateFormat(\r\n+                                ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_ON_DATE_FORMAT);\r\n+                        cal = new Calendar.Builder().setInstant(df.parse(accessTokenExpiry)).build();\r\n+                    } else {\r\n+                        // Fetch expires_in\r\n+                        int startIndex_ATX = result\r\n+                                .indexOf(ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_IN_IDENTIFIER)\r\n+                                + ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_IN_IDENTIFIER.length();\r\n+                        String accessTokenExpiry = result.substring(startIndex_ATX,\r\n+                                result.indexOf(\"\\\"\", startIndex_ATX + 1));\r\n+                        cal.add(Calendar.SECOND, Integer.parseInt(accessTokenExpiry));\r\n+                    }\r\n+\r\n+                    return new SqlFedAuthToken(accessToken, cal.getTime());\r\n+                }\r\n+            } catch (Exception e) {\r\n+                retry++;\r\n+                // Below code applicable only when !isAzureFunctcion (VM)\r\n+                if (retry > maxRetry) {\r\n+                    // Do not retry if maxRetry limit has been reached.\r\n+                    break;\r\n+                } else {\r\n+                    try {\r\n+                        int responseCode = connection.getResponseCode();\r\n+                        // Check Error Response Code from Connection\r\n+                        if (410 == responseCode || 429 == responseCode || 404 == responseCode\r\n+                                || (500 <= responseCode && 599 >= responseCode)) {\r", "originalCommit": "2a55d5b70b3dc899ddee573e04564d0ee6647c00", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\nindex 289ddd7c..2a91ee1f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n", "chunk": "@@ -354,8 +360,9 @@ class SQLServerSecurityUtility {\n                     try {\n                         int responseCode = connection.getResponseCode();\n                         // Check Error Response Code from Connection\n-                        if (410 == responseCode || 429 == responseCode || 404 == responseCode\n-                                || (500 <= responseCode && 599 >= responseCode)) {\n+                        if (GONE == responseCode || TOO_MANY_RESQUESTS == responseCode || NOT_FOUND == responseCode\n+                                || (INTERNAL_SERVER_ERROR <= responseCode\n+                                        && NETWORK_CONNECT_TIMEOUT_ERROR >= responseCode)) {\n                             try {\n                                 int retryTimeoutInMs = retrySlots.get(ThreadLocalRandom.current().nextInt(retry - 1));\n                                 // Error code 410 indicates IMDS upgrade is in progress, which can take up to 70s\n", "next_change": {"commit": "aef84944b1731fd0de40b004bcff7e44b4f31ad8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\nindex 2a91ee1f..b8110f78 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n", "chunk": "@@ -371,6 +446,9 @@ class SQLServerSecurityUtility {\n                                                                                    : retryTimeoutInMs;\n                                 Thread.sleep(retryTimeoutInMs);\n                             } catch (InterruptedException ex) {\n+                                // re-interrupt thread\n+                                Thread.currentThread().interrupt();\n+\n                                 // Throw runtime exception as driver must not be interrupted here\n                                 throw new RuntimeException(ex);\n                             }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\nindex b8110f78..277ddbc6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n", "chunk": "@@ -319,164 +319,104 @@ class SQLServerSecurityUtility {\n     }\n \n     /**\n-     * Get Managed Identity Authentication token\n+     * Get Managed Identity Authentication token through a ManagedIdentityCredential\n      * \n      * @param resource\n-     *        token resource\n-     * @param msiClientId\n-     *        Managed Identity or User Assigned Managed Identity\n+     *        Token resource.\n+     * @param managedIdentityClientId\n+     *        Client ID of the user-assigned Managed Identity.\n      * @return fedauth token\n      * @throws SQLServerException\n      */\n-    static SqlFedAuthToken getMSIAuthToken(String resource, String msiClientId) throws SQLServerException {\n-        // IMDS upgrade time can take up to 70s\n-        final int imdsUpgradeTimeInMs = 70 * 1000;\n-        final List<Integer> retrySlots = new ArrayList<>();\n-\n-        StringBuilder urlString = new StringBuilder();\n-        int retry = 1, maxRetry = 1;\n-\n-        // MSI_ENDPOINT and MSI_SECRET can be used instead of IDENTITY_ENDPOINT and IDENTITY_HEADER\n-        String identityEndpoint = System.getenv(\"IDENTITY_ENDPOINT\");\n-        if (null == identityEndpoint || identityEndpoint.trim().isEmpty()) {\n-            identityEndpoint = System.getenv(\"MSI_ENDPOINT\");\n-        }\n+    static SqlFedAuthToken getManagedIdentityCredAuthToken(String resource,\n+            String managedIdentityClientId) throws SQLServerException {\n+        ManagedIdentityCredential mic = null;\n \n-        String identityHeader = System.getenv(\"IDENTITY_HEADER\");\n-        if (null == identityHeader || identityHeader.trim().isEmpty()) {\n-            identityHeader = System.getenv(\"MSI_SECRET\");\n+        if (null != managedIdentityClientId && !managedIdentityClientId.isEmpty()) {\n+            mic = new ManagedIdentityCredentialBuilder().clientId(managedIdentityClientId).build();\n+        } else {\n+            mic = new ManagedIdentityCredentialBuilder().build();\n         }\n \n-        /*\n-         * isAzureFunction is used for identifying if the current client application is running in a Virtual Machine\n-         * (without Managed Identity environment variables) or App Service/Function (with Managed Identity environment\n-         * variables) as the APIs to be called for acquiring MSI Token are different for both cases.\n-         */\n-        boolean isAzureFunction = null != identityEndpoint && !identityEndpoint.isEmpty() && null != identityHeader\n-                && !identityHeader.isEmpty();\n+        TokenRequestContext tokenRequestContext = new TokenRequestContext();\n+        String scope = resource.endsWith(SQLServerMSAL4JUtils.SLASH_DEFAULT) ? resource : resource\n+                + SQLServerMSAL4JUtils.SLASH_DEFAULT;\n+        tokenRequestContext.setScopes(Arrays.asList(scope));\n \n-        if (isAzureFunction) {\n-            urlString.append(identityEndpoint).append(\"?api-version=2019-08-01&resource=\").append(resource);\n+        SqlFedAuthToken sqlFedAuthToken = null;\n+\n+        Optional<AccessToken> accessTokenOptional = mic.getToken(tokenRequestContext).blockOptional();\n+\n+        if (!accessTokenOptional.isPresent()) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_ManagedIdentityTokenAcquisitionFail\"),\n+                    null);\n         } else {\n-            urlString.append(ActiveDirectoryAuthentication.AZURE_REST_MSI_URL).append(\"&resource=\").append(resource);\n-            // Retry acquiring access token up to 20 times due to possible IMDS upgrade (Applies to VM only)\n-            maxRetry = 20;\n-            // Simplified variant of Exponential BackOff\n-            for (int x = 0; x < maxRetry; x++) {\n-                retrySlots.add(INTERNAL_SERVER_ERROR * ((2 << 1) - 1) / 1000);\n-            }\n+            AccessToken accessToken = accessTokenOptional.get();\n+            sqlFedAuthToken = new SqlFedAuthToken(accessToken.getToken(), accessToken.getExpiresAt().toEpochSecond());\n         }\n \n-        // Append Client Id if available\n-        if (null != msiClientId && !msiClientId.isEmpty()) {\n-            urlString.append(\"&client_id=\").append(msiClientId);\n-        }\n+        return sqlFedAuthToken;\n+    }\n \n-        // Loop while maxRetry reaches its limit\n-        while (retry <= maxRetry) {\n-            HttpURLConnection connection = null;\n+    /**\n+     * Get Managed Identity Authentication token through the DefaultAzureCredential\n+     *\n+     * @param resource\n+     *        Token resource.\n+     * @param managedIdentityClientId\n+     *        Client ID of the user-assigned Managed Identity.\n+     * @return fedauth token\n+     * @throws SQLServerException\n+     */\n+    static SqlFedAuthToken getDefaultAzureCredAuthToken(String resource,\n+            String managedIdentityClientId) throws SQLServerException {\n+        String intellijKeepassPath = System.getenv(INTELLIJ_KEEPASS_PASS);\n+        String[] additionallyAllowedTenants = getAdditonallyAllowedTenants();\n \n-            try {\n-                connection = (HttpURLConnection) new URL(urlString.toString()).openConnection();\n-                connection.setRequestMethod(\"GET\");\n-\n-                if (isAzureFunction) {\n-                    connection.setRequestProperty(\"X-IDENTITY-HEADER\", identityHeader);\n-                    if (connectionlogger.isLoggable(Level.FINER)) {\n-                        connectionlogger.finer(\"Using Azure Function/App Service Managed Identity auth: \" + urlString);\n-                    }\n-                } else {\n-                    connection.setRequestProperty(\"Metadata\", \"true\");\n-                    if (connectionlogger.isLoggable(Level.FINER)) {\n-                        connectionlogger.finer(\"Using Azure Managed Identity auth: \" + urlString);\n-                    }\n-                }\n+        DefaultAzureCredentialBuilder dacBuilder = new DefaultAzureCredentialBuilder();\n+        DefaultAzureCredential dac = null;\n \n-                connection.connect();\n+        if (null != managedIdentityClientId && !managedIdentityClientId.isEmpty()) {\n+            dacBuilder.managedIdentityClientId(managedIdentityClientId);\n+        }\n \n-                try (InputStream stream = connection.getInputStream()) {\n+        if (null != intellijKeepassPath && !intellijKeepassPath.isEmpty()) {\n+            dacBuilder.intelliJKeePassDatabasePath(intellijKeepassPath);\n+        }\n \n-                    BufferedReader reader = new BufferedReader(new InputStreamReader(stream, UTF_8), 100);\n-                    StringBuilder result = new StringBuilder(reader.readLine());\n+        if (null != additionallyAllowedTenants && additionallyAllowedTenants.length != 0) {\n+            dacBuilder.additionallyAllowedTenants(additionallyAllowedTenants);\n+        }\n \n-                    int startIndex_AT = result.indexOf(ActiveDirectoryAuthentication.ACCESS_TOKEN_IDENTIFIER)\n-                            + ActiveDirectoryAuthentication.ACCESS_TOKEN_IDENTIFIER.length();\n+        dac = dacBuilder.build();\n \n-                    String accessToken = result.substring(startIndex_AT, result.indexOf(\"\\\"\", startIndex_AT + 1));\n+        TokenRequestContext tokenRequestContext = new TokenRequestContext();\n+        String scope = resource.endsWith(SQLServerMSAL4JUtils.SLASH_DEFAULT) ? resource : resource\n+                + SQLServerMSAL4JUtils.SLASH_DEFAULT;\n+        tokenRequestContext.setScopes(Arrays.asList(scope));\n \n-                    Calendar cal = new Calendar.Builder().setInstant(new Date()).build();\n+        SqlFedAuthToken sqlFedAuthToken = null;\n \n-                    int startIndex_ATX;\n+        Optional<AccessToken> accessTokenOptional = dac.getToken(tokenRequestContext).blockOptional();\n \n-                    // Fetch expires_on\n-                    if (isAzureFunction) {\n-                        startIndex_ATX = result\n-                                .indexOf(ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_ON_IDENTIFIER)\n-                                + ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_ON_IDENTIFIER.length();\n-                    } else {\n-                        startIndex_ATX = result\n-                                .indexOf(ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_IN_IDENTIFIER)\n-                                + ActiveDirectoryAuthentication.ACCESS_TOKEN_EXPIRES_IN_IDENTIFIER.length();\n-                    }\n+        if (!accessTokenOptional.isPresent()) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_ManagedIdentityTokenAcquisitionFail\"),\n+                    null);\n+        } else {\n+            AccessToken accessToken = accessTokenOptional.get();\n+            sqlFedAuthToken = new SqlFedAuthToken(accessToken.getToken(), accessToken.getExpiresAt().toEpochSecond());\n+        }\n \n-                    String accessTokenExpiry = result.substring(startIndex_ATX,\n-                            result.indexOf(\"\\\"\", startIndex_ATX + 1));\n-                    cal.add(Calendar.SECOND, Integer.parseInt(accessTokenExpiry));\n+        return sqlFedAuthToken;\n+    }\n \n-                    return new SqlFedAuthToken(accessToken, cal.getTime());\n-                }\n-            } catch (Exception e) {\n-                retry++;\n-                // Below code applicable only when !isAzureFunctcion (VM)\n-                if (retry > maxRetry) {\n-                    // Do not retry if maxRetry limit has been reached.\n-                    break;\n-                } else {\n-                    try {\n-                        int responseCode = connection.getResponseCode();\n-                        // Check Error Response Code from Connection\n-                        if (GONE == responseCode || TOO_MANY_RESQUESTS == responseCode || NOT_FOUND == responseCode\n-                                || (INTERNAL_SERVER_ERROR <= responseCode\n-                                        && NETWORK_CONNECT_TIMEOUT_ERROR >= responseCode)) {\n-                            try {\n-                                int retryTimeoutInMs = retrySlots.get(ThreadLocalRandom.current().nextInt(retry - 1));\n-                                // Error code 410 indicates IMDS upgrade is in progress, which can take up to 70s\n-                                retryTimeoutInMs = (responseCode == 410\n-                                        && retryTimeoutInMs < imdsUpgradeTimeInMs) ? imdsUpgradeTimeInMs\n-                                                                                   : retryTimeoutInMs;\n-                                Thread.sleep(retryTimeoutInMs);\n-                            } catch (InterruptedException ex) {\n-                                // re-interrupt thread\n-                                Thread.currentThread().interrupt();\n-\n-                                // Throw runtime exception as driver must not be interrupted here\n-                                throw new RuntimeException(ex);\n-                            }\n-                        } else {\n-                            if (null != msiClientId && !msiClientId.isEmpty()) {\n-                                throw new SQLServerException(\n-                                        SQLServerException.getErrString(\"R_MSITokenFailureImdsClientId\"), null);\n-                            } else {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_MSITokenFailureImds\"),\n-                                        null);\n-                            }\n-                        }\n-                    } catch (IOException io) {\n-                        // Throw error as unexpected if response code not available\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_MSITokenFailureUnexpected\"),\n-                                null);\n-                    }\n-                }\n-            } finally {\n-                if (connection != null) {\n-                    connection.disconnect();\n-                }\n-            }\n-        }\n-        if (retry > maxRetry) {\n-            throw new SQLServerException(SQLServerException\n-                    .getErrString(isAzureFunction ? \"R_MSITokenFailureEndpoint\" : \"R_MSITokenFailureImds\"), null);\n+    private static String[] getAdditonallyAllowedTenants() {\n+        String additonallyAllowedTenants = System.getenv(ADDITIONALLY_ALLOWED_TENANTS);\n+\n+        if (null != additonallyAllowedTenants && !additonallyAllowedTenants.isEmpty()) {\n+            return System.getenv(ADDITIONALLY_ALLOWED_TENANTS).split(\",\");\n         }\n+\n         return null;\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4MTI3Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401081272", "body": "From ODBC docs, keyStorePrincipalId description:\r\n\r\nWhen KeyStoreAuthentication = KeyVaultPassword, set this value to a valid Azure Active Directory User Principal Name.\r\nWhen KeyStoreAuthetication = KeyVaultClientSecret set this value to a valid Azure Active Directory Application Client ID", "bodyText": "From ODBC docs, keyStorePrincipalId description:\nWhen KeyStoreAuthentication = KeyVaultPassword, set this value to a valid Azure Active Directory User Principal Name.\nWhen KeyStoreAuthetication = KeyVaultClientSecret set this value to a valid Azure Active Directory Application Client ID", "bodyHTML": "<p dir=\"auto\">From ODBC docs, keyStorePrincipalId description:</p>\n<p dir=\"auto\">When KeyStoreAuthentication = KeyVaultPassword, set this value to a valid Azure Active Directory User Principal Name.<br>\nWhen KeyStoreAuthetication = KeyVaultClientSecret set this value to a valid Azure Active Directory Application Client ID</p>", "author": "ulvii", "createdAt": "2020-03-31T17:17:03Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -821,6 +821,21 @@\n      */\n     String getMSIClientId();\n \n+    /**\n+     * Sets the Azure Active Directory Application Client ID.", "originalCommit": "2a55d5b70b3dc899ddee573e04564d0ee6647c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MzYzOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401153639", "bodyText": "Please set Javadoc to this\n    /**\n     * Sets the value for the connection property 'keyStorePrincipalId'.\n     * \n     * @param keyStorePrincipalId\n     * \n     *        <pre>\n     *        When keyStoreAuthentication = keyVaultPassword, set this value to a valid Azure Active Directory User Principal Name.\n     *        When keyStoreAuthentication = keyVaultClientSecret, set this value to a valid Azure Active Directory Application Client ID.\n     *        When keyStoreAuthentication = keyVaultManagedIdentity, set this value to a valid Azure Active Directory Application Object ID (optional, for user-assigned only).\n     *        </pre>\n     */", "author": "ulvii", "createdAt": "2020-03-31T19:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4MTI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex bee58181..f6104c6d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,157 +804,35 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n-     * \n-     * @param msiClientId\n-     *        Client ID of User Assigned Managed Identity\n-     */\n-    void setMSIClientId(String msiClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'msiClientId'.\n-     * \n-     * @return msiClientId property value\n-     */\n-    String getMSIClientId();\n-\n-    /**\n-     * Sets the Azure Active Directory Application Client ID.\n-     * \n-     * @param keyStorePrincipalId\n-     *        Azure Active Directory Application Client ID.\n-     */\n-    void setKeyStorePrincipalId(String keyStorePrincipalId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyStorePrincipalId'.\n-     * \n-     * @return keyStorePrincipalId\n-     */\n-    String getKeyStorePrincipalId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientId\n-     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n-\n-    /**\n-     * Returns the value for the connection property 'keyVaultProviderClientId'.\n-     * \n-     * @return keyVaultProviderClientId\n-     */\n-    String getKeyVaultProviderClientId();\n-\n-    /**\n-     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n-     * \n-     * @param keyVaultProviderClientKey\n-     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n-     */\n-    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n-\n-    /**\n-     * Returns the value for the connection property 'domain'.\n-     * \n-     * @return 'domain' property value\n-     */\n-    String getDomain();\n-\n-    /**\n-     * Sets the 'domain' connection property used for NTLM Authentication.\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n      *\n-     * @param domain\n-     *        Windows domain name\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setDomain(String domain);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the current flag value for useFmtOnly.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n      *\n-     * @return 'useFmtOnly' property value.\n+     * @return maximum number of attempts\n      */\n-    boolean getUseFmtOnly();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Specifies the flag to use FMTONLY for parameter metadata queries.\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n      *\n-     * @param useFmtOnly\n-     *        boolean value for 'useFmtOnly'.\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setUseFmtOnly(boolean useFmtOnly);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return enclave attestation URL.\n-     */\n-    String getEnclaveAttestationUrl();\n-\n-    /**\n-     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param url\n-     *        Enclave attestation URL.\n-     */\n-    void setEnclaveAttestationUrl(String url);\n-\n-    /**\n-     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @return Enclave attestation protocol.\n-     */\n-    String getEnclaveAttestationProtocol();\n-\n-    /**\n-     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n-     * \n-     * @param protocol\n-     *        Enclave attestation protocol.\n-     */\n-    void setEnclaveAttestationProtocol(String protocol);\n-\n-    /**\n-     * Returns client certificate path for client certificate authentication.\n-     * \n-     * @return Client certificate path.\n-     */\n-    String getClientCertificate();\n-\n-    /**\n-     * Sets client certificate path for client certificate authentication.\n-     * \n-     * @param certPath\n-     *        Client certificate path.\n-     */\n-    void setClientCertificate(String certPath);\n-\n-    /**\n-     * Returns Private key file path for client certificate authentication.\n-     * \n-     * @return Private key file path.\n-     */\n-    String getClientKey();\n-\n-    /**\n-     * Sets Private key file path for client certificate authentication.\n-     * \n-     * @param keyPath\n-     *        Private key file path.\n-     */\n-    void setClientKey(String keyPath);\n-\n-    /**\n-     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n-     * \n-     * @param password\n-     *        Private key password.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    void setClientKeyPassword(String password);\n-\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d30f3404be0bf4a537455133a96ef35eb9c6b09a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex f6104c6d..866bca0f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -804,35 +834,142 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param useBulkCopyForBatchInsert\n      *        indicates whether Bulk Copy API should be used for Batch Insert operations.\n      */\n-    public void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n+    void setUseBulkCopyForBatchInsert(boolean useBulkCopyForBatchInsert);\n \n     /**\n-     * Sets the maximum number of attempts to reestablish a broken connection.\n-     *\n-     * @param connectRetryCount\n-     *        maximum number of attempts\n+     * Sets the client id to be used to retrieve access token from MSI EndPoint.\n+     * \n+     * @param msiClientId\n+     *        Client ID of User Assigned Managed Identity\n      */\n-    public void setConnectRetryCount(int connectRetryCount);\n+    void setMSIClientId(String msiClientId);\n \n     /**\n-     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     * Returns the value for the connection property 'msiClientId'.\n+     * \n+     * @return msiClientId property value\n+     */\n+    String getMSIClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Id to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientId\n+     *        Client Id of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientId(String keyVaultProviderClientId);\n+\n+    /**\n+     * Returns the value for the connection property 'keyVaultProviderClientId'.\n+     * \n+     * @return keyVaultProviderClientId\n+     */\n+    String getKeyVaultProviderClientId();\n+\n+    /**\n+     * Sets the Azure Key Vault (AKV) Provider Client Key to provided value to be used for column encryption.\n+     * \n+     * @param keyVaultProviderClientKey\n+     *        Client Key of Azure Key Vault (AKV) Provider to be used for column encryption.\n+     */\n+    void setKeyVaultProviderClientKey(String keyVaultProviderClientKey);\n+\n+    /**\n+     * Returns the value for the connection property 'domain'.\n+     * \n+     * @return 'domain' property value\n+     */\n+    String getDomain();\n+\n+    /**\n+     * Sets the 'domain' connection property used for NTLM Authentication.\n      *\n-     * @return maximum number of attempts\n+     * @param domain\n+     *        Windows domain name\n      */\n-    public int getConnectRetryCount();\n+    void setDomain(String domain);\n \n     /**\n-     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     * Returns the current flag value for useFmtOnly.\n      *\n-     * @param connectRetryInterval\n-     *        interval in seconds\n+     * @return 'useFmtOnly' property value.\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    boolean getUseFmtOnly();\n \n     /**\n-     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     * Specifies the flag to use FMTONLY for parameter metadata queries.\n      *\n-     * @return interval in seconds\n+     * @param useFmtOnly\n+     *        boolean value for 'useFmtOnly'.\n      */\n-    public int getConnectRetryInterval();\n+    void setUseFmtOnly(boolean useFmtOnly);\n+\n+    /**\n+     * Returns the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return enclave attestation URL.\n+     */\n+    String getEnclaveAttestationUrl();\n+\n+    /**\n+     * Sets the enclave attestation URL used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param url\n+     *        Enclave attestation URL.\n+     */\n+    void setEnclaveAttestationUrl(String url);\n+\n+    /**\n+     * Returns the enclave attestation protocol used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @return Enclave attestation protocol.\n+     */\n+    String getEnclaveAttestationProtocol();\n+\n+    /**\n+     * Sets the enclave attestation protocol to be used in Always Encrypted with Secure Enclaves.\n+     * \n+     * @param protocol\n+     *        Enclave attestation protocol.\n+     */\n+    void setEnclaveAttestationProtocol(String protocol);\n+\n+    /**\n+     * Returns client certificate path for client certificate authentication.\n+     * \n+     * @return Client certificate path.\n+     */\n+    String getClientCertificate();\n+\n+    /**\n+     * Sets client certificate path for client certificate authentication.\n+     * \n+     * @param certPath\n+     *        Client certificate path.\n+     */\n+    void setClientCertificate(String certPath);\n+\n+    /**\n+     * Returns Private key file path for client certificate authentication.\n+     * \n+     * @return Private key file path.\n+     */\n+    String getClientKey();\n+\n+    /**\n+     * Sets Private key file path for client certificate authentication.\n+     * \n+     * @param keyPath\n+     *        Private key file path.\n+     */\n+    void setClientKey(String keyPath);\n+\n+    /**\n+     * Sets the password to be used for Private key provided by the user for client certificate authentication.\n+     * \n+     * @param password\n+     *        Private key password.\n+     */\n+    void setClientKeyPassword(String password);\n+\n }\n", "next_change": {"commit": "f857e2505aec7b413fbd1f5b722862d915b2b2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 866bca0f..6e401075 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -972,4 +991,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setClientKeyPassword(String password);\n \n+    /**\n+     * Returns the current flag for value sendTemporalDataTypesAsStringForBulkCopy\n+     * \n+     * @return 'sendTemporalDataTypesAsStringForBulkCopy' property value.\n+     */\n+    boolean getSendTemporalDataTypesAsStringForBulkCopy();\n+\n+    /**\n+     * Specifies the flag to send temporal datatypes as String for Bulk Copy.\n+     * \n+     * @param sendTemporalDataTypesAsStringForBulkCopy\n+     *        boolean value for 'sendTemporalDataTypesAsStringForBulkCopy'.\n+     */\n+    void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n+\n }\n", "next_change": {"commit": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 6e401075..9288d59a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1006,4 +1021,34 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      */\n     void setSendTemporalDataTypesAsStringForBulkCopy(boolean sendTemporalDataTypesAsStringForBulkCopy);\n \n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalId'.\n+     *\n+     * @return 'AADSecurePrincipalId' property value.\n+     */\n+    String getAADSecurePrincipalId();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalId' connection property used for Active Directory Service Principal authentication.\n+     *\n+     * @param AADSecurePrincipalId\n+     *        Active Directory Service Principal Id.\n+     */\n+    void setAADSecurePrincipalId(String AADSecurePrincipalId);\n+\n+    /**\n+     * Returns the value for the connection property 'AADSecurePrincipalSecret'.\n+     *\n+     * @return 'AADSecurePrincipalSecret' property value.\n+     */\n+    String getAADSecurePrincipalSecret();\n+\n+    /**\n+     * Sets the 'AADSecurePrincipalSecret' connection property used for Active Directory Service Principal\n+     * authentication.\n+     *\n+     * @param AADSecurePrincipalSecret\n+     *        Active Directory Service Principal secret.\n+     */\n+    void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n }\n", "next_change": {"commit": "d9909748368af7d2944dab4fa382ee513f2b76f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 9288d59a..87152862 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1051,4 +1051,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      *        Active Directory Service Principal secret.\n      */\n     void setAADSecurePrincipalSecret(String AADSecurePrincipalSecret);\n+\n+    /**\n+     * Returns value of 'maxResultBuffer' from Connection String.\n+     *\n+     * @return 'maxResultBuffer' property.\n+     */\n+    String getMaxResultBuffer();\n+\n+    /**\n+     * Specifies value for 'maxResultBuffer' property\n+     *\n+     * @param maxResultBuffer\n+     *        String value for 'maxResultBuffer'\n+     */\n+    void setMaxResultBuffer(String maxResultBuffer);\n }\n", "next_change": {"commit": "af679a5f3754611273caa484fba9867a8e3c777c", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 87152862..1308a5cd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1060,10 +1060,42 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getMaxResultBuffer();\n \n     /**\n-     * Specifies value for 'maxResultBuffer' property\n+     * Sets the value for 'maxResultBuffer' property\n      *\n      * @param maxResultBuffer\n      *        String value for 'maxResultBuffer'\n      */\n     void setMaxResultBuffer(String maxResultBuffer);\n+\n+    /**\n+     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n+     * failure\n+     * \n+     * @param count\n+     *        the number of reconnection attempts if there is a connection failure\n+     */\n+    void setConnectRetryCount(int count);\n+\n+    /**\n+     * Returns the value of 'connectRetryCount' property\n+     * \n+     * @return 'connectRetryCount' property.\n+     */\n+    int getConnectRetryCount();\n+\n+    /**\n+     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n+     * attempt\n+     * \n+     * @param interval\n+     *        the number of seconds between each connection retry attempt\n+     */\n+    void setConnectRetryInterval(int interval);\n+\n+    /**\n+     * Returns the value of 'connectRetryInterval' property\n+     * \n+     * @return 'connectRetryInterval' property.\n+     */\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 1308a5cd..210bb34b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1068,34 +1099,32 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     void setMaxResultBuffer(String maxResultBuffer);\n \n     /**\n-     * Sets the 'connectRetryCount' property that specifies the number of reconnection attempts if there is a connection\n-     * failure\n-     * \n-     * @param count\n-     *        the number of reconnection attempts if there is a connection failure\n+     * Sets the maximum number of attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryCount\n+     *        maximum number of attempts\n      */\n-    void setConnectRetryCount(int count);\n+    public void setConnectRetryCount(int connectRetryCount);\n \n     /**\n-     * Returns the value of 'connectRetryCount' property\n-     * \n-     * @return 'connectRetryCount' property.\n+     * Returns the maximum number of attempts set to reestablish a broken connection.\n+     *\n+     * @return maximum number of attempts\n      */\n-    int getConnectRetryCount();\n+    public int getConnectRetryCount();\n \n     /**\n-     * Sets the 'connectRetryInterval' property that specifies the number of seconds between each connection retry\n-     * attempt\n-     * \n-     * @param interval\n-     *        the number of seconds between each connection retry attempt\n+     * Sets the interval, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @param connectRetryInterval\n+     *        interval in seconds\n      */\n-    void setConnectRetryInterval(int interval);\n+    public void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n-     * Returns the value of 'connectRetryInterval' property\n-     * \n-     * @return 'connectRetryInterval' property.\n+     * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n+     *\n+     * @return interval in seconds\n      */\n-    int getConnectRetryInterval();\n+    public int getConnectRetryInterval();\n }\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 210bb34b..e9f55e9b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1119,12 +1119,12 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @param connectRetryInterval\n      *        interval in seconds\n      */\n-    public void setConnectRetryInterval(int connectRetryInterval);\n+    void setConnectRetryInterval(int connectRetryInterval);\n \n     /**\n      * Returns the interval set, in seconds, between attempts to reestablish a broken connection.\n      *\n      * @return interval in seconds\n      */\n-    public int getConnectRetryInterval();\n+    int getConnectRetryInterval();\n }\n", "next_change": {"commit": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex e9f55e9b..76db4be5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1127,4 +1126,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return interval in seconds\n      */\n     int getConnectRetryInterval();\n+\n+    /**\n+     * Sets the behavior for the prepare method. {@link PrepareMethod}\n+     *\n+     * @param prepareMethod\n+     *        Changes the setting as per description\n+     */\n+    void setPrepareMethod(String prepareMethod);\n+\n+    /**\n+     * Returns the value indicating the prepare method. {@link PrepareMethod}\n+     *\n+     * @return prepare method\n+     */\n+    String getPrepareMethod();\n }\n", "next_change": {"commit": "900fe16ffb7b048d8617d79e5891f3ceb2e314e3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 76db4be5..c85bbd26 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1141,4 +1206,19 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      * @return prepare method\n      */\n     String getPrepareMethod();\n+\n+    /**\n+     * Sets time-to-live for the the cached MSI token\n+     *\n+     * @param timeToLive\n+     *        Changes the setting as per description\n+     */\n+    void setMsiTokenCacheTtl(int timeToLive);\n+\n+    /**\n+     * Gets the time-to-live for the the cached MSI token\n+     *\n+     * @return time-to-live for the cached MSI token\n+     */\n+    int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex c85bbd26..19f98695 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1208,17 +1214,16 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     String getPrepareMethod();\n \n     /**\n-     * Sets time-to-live for the the cached MSI token\n-     *\n-     * @param timeToLive\n-     *        Changes the setting as per description\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method is a no-op for backwards compatibility only.\n      */\n+    @Deprecated\n     void setMsiTokenCacheTtl(int timeToLive);\n \n     /**\n-     * Gets the time-to-live for the the cached MSI token\n-     *\n-     * @return time-to-live for the cached MSI token\n+     * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n+     * This method will always return 0 and is for backwards compatibility only.\n      */\n+    @Deprecated\n     int getMsiTokenCacheTtl();\n }\n", "next_change": {"commit": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex 19f98695..a9ba172d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -1223,7 +1226,24 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n     /**\n      * Deprecated. Time-to-live is no longer supported for the cached Managed Identity tokens.\n      * This method will always return 0 and is for backwards compatibility only.\n+     *\n+     * @return Method will always return 0.\n      */\n     @Deprecated\n     int getMsiTokenCacheTtl();\n+\n+    /**\n+     * Sets the {@link SQLServerAccessTokenCallback} delegate.\n+     *\n+     * @param accessTokenCallback\n+     *        Access token callback delegate.\n+     */\n+    void setAccessTokenCallback(SQLServerAccessTokenCallback accessTokenCallback);\n+\n+    /**\n+     * Returns a {@link SQLServerAccessTokenCallback}, the access token callback delegate.\n+     *\n+     * @return Access token callback delegate.\n+     */\n+    SQLServerAccessTokenCallback getAccessTokenCallback();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4Nzg5MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401087890", "body": "Please add proper javadoc, this is a public API.", "bodyText": "Please add proper javadoc, this is a public API.", "bodyHTML": "<p dir=\"auto\">Please add proper javadoc, this is a public API.</p>", "author": "ulvii", "createdAt": "2020-03-31T17:27:29Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -720,6 +722,23 @@ public static synchronized void registerColumnEncryptionKeyStoreProviders(\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n+    /**\n+     * Unregisters the custom key store providers from the globalCustomColumnEncryptionKeyStoreProviders.", "originalCommit": "2a55d5b70b3dc899ddee573e04564d0ee6647c00", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 96ea4030..7e6320f2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -722,32 +664,20 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n-    /**\n-     * Unregisters the custom key store providers from the globalCustomColumnEncryptionKeyStoreProviders.\n-     */\n-    public static synchronized void unregisterColumnEncryptionKeyStoreProviders() {\n-        loggerExternal.entering(SQLServerConnection.class.getName(), \"unregisterColumnEncryptionKeyStoreProviders\",\n-                \"Removing Column Encryption Key Store Provider\");\n-\n-        if (null != globalCustomColumnEncryptionKeyStoreProviders) {\n-            globalCustomColumnEncryptionKeyStoreProviders.clear();\n-        }\n-\n-        loggerExternal.exiting(SQLServerConnection.class.getName(), \"unregisterColumnEncryptionKeyStoreProviders\",\n-                \"Number of Key store providers that are registered:\"\n-                        + (null != globalCustomColumnEncryptionKeyStoreProviders ? globalCustomColumnEncryptionKeyStoreProviders\n-                                .size() : 0));\n-    }\n-\n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n+    static synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n             String providerName) {\n-        return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders\n-                .containsKey(providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+        if (null != globalSystemColumnEncryptionKeyStoreProviders\n+                && globalSystemColumnEncryptionKeyStoreProviders.containsKey(providerName)) {\n+            return globalSystemColumnEncryptionKeyStoreProviders.get(providerName);\n+        }\n+        return null;\n     }\n \n-    synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n-        return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders\n-                .keySet().toString() : null;\n+    static synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n+        if (null != globalCustomColumnEncryptionKeyStoreProviders)\n+            return globalCustomColumnEncryptionKeyStoreProviders.keySet().toString();\n+        else\n+            return null;\n     }\n \n     synchronized String getAllSystemColumnEncryptionKeyStoreProviders() {\n", "next_change": {"commit": "d30f3404be0bf4a537455133a96ef35eb9c6b09a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 7e6320f2..87e5d817 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -664,20 +732,15 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n-    static synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n+    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n             String providerName) {\n-        if (null != globalSystemColumnEncryptionKeyStoreProviders\n-                && globalSystemColumnEncryptionKeyStoreProviders.containsKey(providerName)) {\n-            return globalSystemColumnEncryptionKeyStoreProviders.get(providerName);\n-        }\n-        return null;\n+        return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders\n+                .containsKey(providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n     }\n \n-    static synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n-        if (null != globalCustomColumnEncryptionKeyStoreProviders)\n-            return globalCustomColumnEncryptionKeyStoreProviders.keySet().toString();\n-        else\n-            return null;\n+    synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n+        return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders\n+                .keySet().toString() : null;\n     }\n \n     synchronized String getAllSystemColumnEncryptionKeyStoreProviders() {\n", "next_change": {"commit": "bf7adc07ae6e31f96adf2e9ced8fc6603ffec9bf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 87e5d817..be09b2b4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -718,81 +967,243 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                 Object[] msgArgs = {providerName, RESERVED_PROVIDER_NAME_PREFIX};\n                 throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n             }\n-            if (null == entry.getValue()) {\n-                MessageFormat form = new MessageFormat(\n-                        SQLServerException.getErrString(\"R_CustomKeyStoreProviderValueNull\"));\n-                Object[] msgArgs = {providerName, RESERVED_PROVIDER_NAME_PREFIX};\n-                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+\n+            SQLServerColumnEncryptionKeyStoreProvider provider = entry.getValue();\n+            if (null == provider) {\n+                throw new SQLServerException(null, String\n+                        .format(SQLServerException.getErrString(\"R_CustomKeyStoreProviderValueNull\"), providerName),\n+                        null, 0, false);\n+            }\n+\n+                // Global providers should not use their own CEK caches.\n+                provider.setColumnEncryptionCacheTtl(Duration.ZERO);\n+                globalCustomColumnEncryptionKeyStoreProviders.put(providerName, provider);\n             }\n-            globalCustomColumnEncryptionKeyStoreProviders.put(entry.getKey(), entry.getValue());\n+        } finally {\n+            LOCK.unlock();\n         }\n \n-        loggerExternal.exiting(SQLServerConnection.class.getName(), \"registerColumnEncryptionKeyStoreProviders\",\n+        loggerExternal.exiting(loggingClassNameBase, \"registerColumnEncryptionKeyStoreProviders\",\n                 \"Number of Key store providers that are registered:\"\n                         + globalCustomColumnEncryptionKeyStoreProviders.size());\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(\n-            String providerName) {\n-        return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders\n-                .containsKey(providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+    /**\n+     * Unregisters all the custom key store providers from the globalCustomColumnEncryptionKeyStoreProviders by clearing\n+     * the map and setting it to null.\n+     */\n+    public static void unregisterColumnEncryptionKeyStoreProviders() {\n+        loggerExternal.entering(loggingClassNameBase, \"unregisterColumnEncryptionKeyStoreProviders\",\n+                \"Removing Column Encryption Key Store Provider\");\n+\n+        LOCK.lock();\n+        try {\n+            if (null != globalCustomColumnEncryptionKeyStoreProviders) {\n+                globalCustomColumnEncryptionKeyStoreProviders.clear();\n+                globalCustomColumnEncryptionKeyStoreProviders = null;\n+            }\n+        } finally {\n+            LOCK.unlock();\n+        }\n+\n+        loggerExternal.exiting(loggingClassNameBase, \"unregisterColumnEncryptionKeyStoreProviders\",\n+                \"Number of Key store providers that are registered: 0\");\n+    }\n+\n+    SQLServerColumnEncryptionKeyStoreProvider getGlobalSystemColumnEncryptionKeyStoreProvider(String providerName) {\n+        lock.lock();\n+        try {\n+            return (null != globalSystemColumnEncryptionKeyStoreProviders && globalSystemColumnEncryptionKeyStoreProviders.containsKey(\n+                    providerName)) ? globalSystemColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n-        return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders\n-                .keySet().toString() : null;\n+    String getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders() {\n+        lock.lock();\n+        try {\n+            return (null != globalCustomColumnEncryptionKeyStoreProviders)\n+                    ? globalCustomColumnEncryptionKeyStoreProviders.keySet().toString() : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized String getAllSystemColumnEncryptionKeyStoreProviders() {\n-        String keyStores = \"\";\n-        if (0 != systemColumnEncryptionKeyStoreProvider.size())\n-            keyStores = systemColumnEncryptionKeyStoreProvider.keySet().toString();\n-        if (0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size())\n-            keyStores += \",\" + SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.keySet().toString();\n-        return keyStores;\n+    String getAllSystemColumnEncryptionKeyStoreProviders() {\n+        lock.lock();\n+        try {\n+            String keyStores = \"\";\n+            if (0 != systemColumnEncryptionKeyStoreProvider.size()) {\n+                keyStores = systemColumnEncryptionKeyStoreProvider.keySet().toString();\n+            }\n+            if (0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size()) {\n+                keyStores += \",\" + SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.keySet()\n+                        .toString();\n+            }\n+            return keyStores;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getGlobalCustomColumnEncryptionKeyStoreProvider(\n-            String providerName) {\n-        return (null != globalCustomColumnEncryptionKeyStoreProviders && globalCustomColumnEncryptionKeyStoreProviders\n-                .containsKey(providerName)) ? globalCustomColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+    SQLServerColumnEncryptionKeyStoreProvider getGlobalCustomColumnEncryptionKeyStoreProvider(String providerName) {\n+        lock.lock();\n+        try {\n+            return (null != globalCustomColumnEncryptionKeyStoreProviders && globalCustomColumnEncryptionKeyStoreProviders.containsKey(\n+                    providerName)) ? globalCustomColumnEncryptionKeyStoreProviders.get(providerName) : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getSystemColumnEncryptionKeyStoreProvider(\n-            String providerName) {\n-        return (null != systemColumnEncryptionKeyStoreProvider && systemColumnEncryptionKeyStoreProvider\n-                .containsKey(providerName)) ? systemColumnEncryptionKeyStoreProvider.get(providerName) : null;\n+    SQLServerColumnEncryptionKeyStoreProvider getSystemColumnEncryptionKeyStoreProvider(String providerName) {\n+        lock.lock();\n+        try {\n+            return (null != systemColumnEncryptionKeyStoreProvider && systemColumnEncryptionKeyStoreProvider.containsKey(\n+                    providerName)) ? systemColumnEncryptionKeyStoreProvider.get(providerName) : null;\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    synchronized SQLServerColumnEncryptionKeyStoreProvider getColumnEncryptionKeyStoreProvider(\n+    SQLServerColumnEncryptionKeyStoreProvider getSystemOrGlobalColumnEncryptionKeyStoreProvider(\n             String providerName) throws SQLServerException {\n+        lock.lock();\n+        try {\n+            // check for global system providers\n+            keystoreProvider = getGlobalSystemColumnEncryptionKeyStoreProvider(providerName);\n+\n+            // Check for the connection system provider.\n+            if (null == keystoreProvider) {\n+                keystoreProvider = getSystemColumnEncryptionKeyStoreProvider(providerName);\n+            }\n \n-        // Check for the connection provider first.\n-        keystoreProvider = getSystemColumnEncryptionKeyStoreProvider(providerName);\n+            // There is no global system provider of this name, check for the global custom providers.\n+            if (null == keystoreProvider) {\n+                keystoreProvider = getGlobalCustomColumnEncryptionKeyStoreProvider(providerName);\n+            }\n \n-        // There is no connection provider of this name, check for the global system providers.\n-        if (null == keystoreProvider) {\n-            keystoreProvider = getGlobalSystemColumnEncryptionKeyStoreProvider(providerName);\n+            // No provider was found of this name.\n+            if (null == keystoreProvider) {\n+                String systemProviders = getAllSystemColumnEncryptionKeyStoreProviders();\n+                String customProviders = getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders();\n+                MessageFormat form = new MessageFormat(\n+                        SQLServerException.getErrString(\"R_UnrecognizedKeyStoreProviderName\"));\n+                Object[] msgArgs = {providerName, systemProviders, customProviders};\n+                throw new SQLServerException(form.format(msgArgs), null);\n+            }\n+\n+            return keystoreProvider;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    boolean hasConnectionColumnEncryptionKeyStoreProvidersRegistered() {\n+        lock.lock();\n+        try {\n+            return null != connectionColumnEncryptionKeyStoreProvider && connectionColumnEncryptionKeyStoreProvider.size() > 0;\n+        } finally {\n+            lock.unlock();\n         }\n+    }\n \n-        // There is no global system provider of this name, check for the global custom providers.\n-        if (null == keystoreProvider) {\n-            keystoreProvider = getGlobalCustomColumnEncryptionKeyStoreProvider(providerName);\n+    String getAllConnectionColumnEncryptionKeyStoreProviders() {\n+        lock.lock();\n+        try {\n+            String keyStores = \"\";\n+            if (0 != connectionColumnEncryptionKeyStoreProvider.size()) {\n+                keyStores = connectionColumnEncryptionKeyStoreProvider.keySet().toString();\n+            }\n+            return keyStores;\n+        } finally {\n+            lock.unlock();\n         }\n+    }\n \n-        // No provider was found of this name.\n-        if (null == keystoreProvider) {\n-            String systemProviders = getAllSystemColumnEncryptionKeyStoreProviders();\n-            String customProviders = getAllGlobalCustomSystemColumnEncryptionKeyStoreProviders();\n-            MessageFormat form = new MessageFormat(\n-                    SQLServerException.getErrString(\"R_UnrecognizedKeyStoreProviderName\"));\n-            Object[] msgArgs = {providerName, systemProviders, customProviders};\n-            throw new SQLServerException(form.format(msgArgs), null);\n+    SQLServerColumnEncryptionKeyStoreProvider getColumnEncryptionKeyStoreProviderOnConnection(\n+            String providerName) throws SQLServerException {\n+        lock.lock();\n+        try {\n+            // Check for a connection-level provider first\n+            if (null != connectionColumnEncryptionKeyStoreProvider\n+                    && connectionColumnEncryptionKeyStoreProvider.size() > 0) {\n+                // If any connection-level providers are registered, we don't fall back to system/global providers\n+                if (connectionColumnEncryptionKeyStoreProvider.containsKey(providerName)) {\n+                    return connectionColumnEncryptionKeyStoreProvider.get(providerName);\n+                } else {\n+                    MessageFormat form = new MessageFormat(\n+                            SQLServerException.getErrString(\"R_UnrecognizedConnectionKeyStoreProviderName\"));\n+                    Object[] msgArgs = {providerName, getAllConnectionColumnEncryptionKeyStoreProviders()};\n+                    throw new SQLServerException(form.format(msgArgs), null);\n+                }\n+            }\n+\n+            // No connection-level providers registered, so return system/global provider\n+            return getSystemOrGlobalColumnEncryptionKeyStoreProvider(providerName);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /** This is a user-defined per-connection store provider. */\n+    Map<String, SQLServerColumnEncryptionKeyStoreProvider> connectionColumnEncryptionKeyStoreProvider = new HashMap<>();\n+\n+    /**\n+     * Registers connection-level key store providers, replacing all existing providers.\n+     *\n+     * @param clientKeyStoreProviders\n+     *         a map containing the store providers information.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public void registerColumnEncryptionKeyStoreProvidersOnConnection(\n+            Map<String, SQLServerColumnEncryptionKeyStoreProvider> clientKeyStoreProviders) throws SQLServerException {\n+        loggerExternal.entering(loggingClassName, \"registerColumnEncryptionKeyStoreProvidersOnConnection\",\n+                \"Registering Column Encryption Key Store Providers on Connection\");\n+        lock.lock();\n+        try {\n+            if (null == clientKeyStoreProviders) {\n+                throw new SQLServerException(null, SQLServerException.getErrString(\"R_CustomKeyStoreProviderMapNull\"),\n+                        null, 0, false);\n+            }\n+\n+            connectionColumnEncryptionKeyStoreProvider.clear();\n+\n+            for (Map.Entry<String, SQLServerColumnEncryptionKeyStoreProvider> entry : clientKeyStoreProviders.entrySet()) {\n+                String providerName = entry.getKey();\n+                if (null == providerName || 0 == providerName.trim().length()) {\n+                    throw new SQLServerException(null,\n+                            SQLServerException.getErrString(\"R_EmptyCustomKeyStoreProviderName\"), null, 0, false);\n+                }\n+\n+                // MSSQL_CERTIFICATE_STORE not allowed on connection level\n+                if ((providerName.equalsIgnoreCase(WINDOWS_KEY_STORE_NAME))) {\n+                    MessageFormat form = new MessageFormat(\n+                            SQLServerException.getErrString(\"R_InvalidCustomKeyStoreProviderName\"));\n+                    Object[] msgArgs = {providerName, WINDOWS_KEY_STORE_NAME};\n+                    throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                }\n+\n+                if (null == entry.getValue()) {\n+                    throw new SQLServerException(null,\n+                            String.format(SQLServerException.getErrString(\"R_CustomKeyStoreProviderValueNull\"),\n+                                    providerName), null, 0, false);\n+                }\n+\n+                connectionColumnEncryptionKeyStoreProvider.put(entry.getKey(), entry.getValue());\n+            }\n+        } finally {\n+            lock.unlock();\n         }\n \n-        return keystoreProvider;\n+        loggerExternal.exiting(loggingClassName, \"registerColumnEncryptionKeyStoreProvidersOnConnection\",\n+                \"Number of connection-level Key store providers that are registered: \"\n+                        + connectionColumnEncryptionKeyStoreProvider.size());\n     }\n \n+    /** trusted servername AE */\n     private String trustedServerNameAE = null;\n     private static Map<String, List<String>> columnEncryptionTrustedMasterKeyPaths = new HashMap<>();\n \n", "next_change": null}]}}]}}]}}, {"oid": "795e653ee609c10fc71ed37f08e7174e9b78b87b", "url": "https://github.com/microsoft/mssql-jdbc/commit/795e653ee609c10fc71ed37f08e7174e9b78b87b", "message": "review updates", "committedDate": "2020-03-31T18:08:45Z", "type": "commit"}, {"oid": "88d5d708fbaeb96fc9eaa0625fdbf01f842dd248", "url": "https://github.com/microsoft/mssql-jdbc/commit/88d5d708fbaeb96fc9eaa0625fdbf01f842dd248", "message": "more review updates", "committedDate": "2020-03-31T18:45:20Z", "type": "commit"}, {"oid": "91639a5bc7eb9bf5ce36972f3a254376a3077b1c", "url": "https://github.com/microsoft/mssql-jdbc/commit/91639a5bc7eb9bf5ce36972f3a254376a3077b1c", "message": "javadoc update", "committedDate": "2020-03-31T19:33:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDg5Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401180897", "body": "`R_keyStoreSecretOrLocationNotSet` message does not make sense for this future.", "bodyText": "R_keyStoreSecretOrLocationNotSet message does not make sense for this future.", "bodyHTML": "<p dir=\"auto\"><code>R_keyStoreSecretOrLocationNotSet</code> message does not make sense for this future.</p>", "author": "ulvii", "createdAt": "2020-03-31T20:04:56Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -1291,7 +1301,30 @@ private void registerKeyStoreProviderOnConnection(String keyStoreAuth, String ke\n                         systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     }\n                     break;\n-\n+                case KeyVaultClientSecret:\n+                    // need a secret use use the secret method\n+                    if (null == keyStoreSecret) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);", "originalCommit": "91639a5bc7eb9bf5ce36972f3a254376a3077b1c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 32415ac8..7e6320f2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1301,30 +1205,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     }\n                     break;\n-                case KeyVaultClientSecret:\n-                    // need a secret use use the secret method\n-                    if (null == keyStoreSecret) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n-                    } else {\n-                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                                keyStorePrincipalId, keyStoreSecret);\n-                        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n-                        keyStoreMap.put(provider.getName(), provider);\n-                        registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n-                    }\n-                    break;\n-                case KeyVaultManagedIdentity:\n-                    SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n-                    if (null != keyStorePrincipalId) {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n-                    } else {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n-                    }\n-                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n-                    keyStoreMap.put(provider.getName(), provider);\n-                    registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n-                    break;\n+\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n                     break;\n", "next_change": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 7e6320f2..3973bfc8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1205,7 +1313,30 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                         systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     }\n                     break;\n-\n+                case KeyVaultClientSecret:\n+                    // need a secret use use the secret method\n+                    if (null == keyStoreSecret) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_keyStoreSecretNotSet\"), null);\n+                    } else {\n+                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                                keyStorePrincipalId, keyStoreSecret);\n+                        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                        keyStoreMap.put(provider.getName(), provider);\n+                        registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+                    }\n+                    break;\n+                case KeyVaultManagedIdentity:\n+                    SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n+                    if (null != keyStorePrincipalId) {\n+                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n+                    } else {\n+                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n+                    }\n+                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                    keyStoreMap.put(provider.getName(), provider);\n+                    registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+                    break;\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n                     break;\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 3973bfc8..36c0bb8b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1333,7 +1379,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                     } else {\n                         provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n                     }\n-                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<>();\n                     keyStoreMap.put(provider.getName(), provider);\n                     registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n                     break;\n", "next_change": {"commit": "21b8ec1ac90884ca7c83b7a79a08bf78702b52bb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 36c0bb8b..da4731e7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1379,9 +1604,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                     } else {\n                         provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n                     }\n-                    Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<>();\n-                    keyStoreMap.put(provider.getName(), provider);\n-                    registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+                    systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n                     break;\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n", "next_change": {"commit": "8e66ac0b5364be903d337828f5cec9dd352972e3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex da4731e7..802e9c12 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1577,34 +1749,13 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n             KeyStoreAuthentication keyStoreAuthentication = KeyStoreAuthentication.valueOfString(keyStoreAuth);\n             switch (keyStoreAuthentication) {\n                 case JavaKeyStorePassword:\n-                    // both secret and location must be set for JKS.\n-                    if ((null == keyStoreSecret) || (null == keyStoreLocation)) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n-                    } else {\n-                        SQLServerColumnEncryptionJavaKeyStoreProvider provider = new SQLServerColumnEncryptionJavaKeyStoreProvider(\n-                                keyStoreLocation, keyStoreSecret.toCharArray());\n-                        systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n-                    }\n+                    setKeyStoreSecretAndLocation(keyStoreSecret, keyStoreLocation);\n                     break;\n                 case KeyVaultClientSecret:\n-                    // need a secret to use the secret method\n-                    if (null == keyStoreSecret) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_keyStoreSecretNotSet\"), null);\n-                    } else {\n-                        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                                keyStorePrincipalId, keyStoreSecret);\n-                        systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n-                    }\n+                    this.setKeyVaultProvider(keyStorePrincipalId, keyStoreSecret);\n                     break;\n                 case KeyVaultManagedIdentity:\n-                    SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n-                    if (null != keyStorePrincipalId) {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n-                    } else {\n-                        provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n-                    }\n-                    systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+                    setKeyVaultProvider(keyStorePrincipalId);\n                     break;\n                 default:\n                     // valueOfString would throw an exception if the keyStoreAuthentication is not valid.\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 802e9c12..1d502335 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1764,14 +1765,14 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n \n-    private void setKeyStoreSecretAndLocation(String keyStoreSecret, String keyStoreLocation) throws SQLServerException {\n+    private void setKeyStoreSecretAndLocation(String keyStoreSecret,\n+            String keyStoreLocation) throws SQLServerException {\n         // both secret and location must be set for JKS.\n         if ((null == keyStoreSecret) || (null == keyStoreLocation)) {\n-            throw new SQLServerException(\n-                    SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n         } else {\n             SQLServerColumnEncryptionJavaKeyStoreProvider provider = new SQLServerColumnEncryptionJavaKeyStoreProvider(\n-                     keyStoreLocation, keyStoreSecret.toCharArray());\n+                    keyStoreLocation, keyStoreSecret.toCharArray());\n             systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n         }\n     }\n", "next_change": null}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex da4731e7..802e9c12 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1613,6 +1764,39 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n \n+    private void setKeyStoreSecretAndLocation(String keyStoreSecret, String keyStoreLocation) throws SQLServerException {\n+        // both secret and location must be set for JKS.\n+        if ((null == keyStoreSecret) || (null == keyStoreLocation)) {\n+            throw new SQLServerException(\n+                    SQLServerException.getErrString(\"R_keyStoreSecretOrLocationNotSet\"), null);\n+        } else {\n+            SQLServerColumnEncryptionJavaKeyStoreProvider provider = new SQLServerColumnEncryptionJavaKeyStoreProvider(\n+                     keyStoreLocation, keyStoreSecret.toCharArray());\n+            systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+        }\n+    }\n+\n+    private void setKeyVaultProvider(String keyStorePrincipalId) throws SQLServerException {\n+        SQLServerColumnEncryptionAzureKeyVaultProvider provider;\n+        if (null != keyStorePrincipalId) {\n+            provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(keyStorePrincipalId);\n+        } else {\n+            provider = new SQLServerColumnEncryptionAzureKeyVaultProvider();\n+        }\n+        systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+    }\n+\n+    private void setKeyVaultProvider(String keyStorePrincipalId, String keyStoreSecret) throws SQLServerException {\n+        // need a secret to use the secret method\n+        if (null == keyStoreSecret) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_keyStoreSecretNotSet\"), null);\n+        } else {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    keyStorePrincipalId, keyStoreSecret);\n+            systemColumnEncryptionKeyStoreProvider.put(provider.getName(), provider);\n+        }\n+    }\n+\n     // Helper to check if timeout value is valid\n     int validateTimeout(SQLServerDriverIntProperty property) throws SQLServerException {\n         int timeout = property.getDefaultValue();\n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 3973bfc8..36c0bb8b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1344,6 +1390,15 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n \n+    private void registerKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        // need a secret to use the secret method\n+        SQLServerColumnEncryptionAzureKeyVaultProvider provider = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                clientId, clientKey);\n+        Map<String, SQLServerColumnEncryptionKeyStoreProvider> keyStoreMap = new HashMap<>();\n+        keyStoreMap.put(provider.getName(), provider);\n+        registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n+    }\n+\n     /**\n      * Establish a physical database connection based on the user specified connection properties. Logon to the\n      * database.\n", "next_change": {"commit": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 36c0bb8b..851c6569 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -1399,6 +1455,29 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         registerColumnEncryptionKeyStoreProviders(keyStoreMap);\n     }\n \n+    // Helper to check if timeout value is valid\n+    int validateTimeout(SQLServerDriverIntProperty property) throws SQLServerException {\n+        int timeout = property.getDefaultValue();\n+        String sPropValue = activeConnectionProperties.getProperty(property.toString());\n+        if (null != sPropValue && sPropValue.length() > 0) {\n+            try {\n+                timeout = Integer.parseInt(sPropValue);\n+                if (!property.isValidValue(timeout)) {\n+                    MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_invalidTimeOut\"));\n+                    Object[] msgArgs = {sPropValue};\n+                    SQLServerException.makeFromDriverError(this, this, form.format(msgArgs), null, false);\n+\n+                }\n+            } catch (NumberFormatException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_invalidTimeOut\"));\n+                Object[] msgArgs = {sPropValue};\n+                SQLServerException.makeFromDriverError(this, this, form.format(msgArgs), null, false);\n+\n+            }\n+        }\n+        return timeout;\n+    }\n+\n     /**\n      * Establish a physical database connection based on the user specified connection properties. Logon to the\n      * database.\n", "next_change": null}]}}]}}]}}]}}, {"oid": "7ddd56156e31b863bb36352cc6c5015059e13380", "url": "https://github.com/microsoft/mssql-jdbc/commit/7ddd56156e31b863bb36352cc6c5015059e13380", "message": "updated SQLServerConnection loggingClassName", "committedDate": "2020-03-31T20:07:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MDUxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401190510", "body": "How is this testing MSI auth? You are using the global connection stirng.", "bodyText": "How is this testing MSI auth? You are using the global connection stirng.", "bodyHTML": "<p dir=\"auto\">How is this testing MSI auth? You are using the global connection stirng.</p>", "author": "ulvii", "createdAt": "2020-03-31T20:21:32Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+    /*\r\n+     * Test basic MSI auth\r\n+     */\r\n+    @Test\r\n+    public void testAuth() throws SQLException {\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r", "originalCommit": "7ddd56156e31b863bb36352cc6c5015059e13380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 76b4de70..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -34,12 +34,46 @@ import com.microsoft.sqlserver.testframework.PrepUtil;\n @RunWith(JUnitPlatform.class)\n @Tag(Constants.MSI)\n public class MSITest extends AESetup {\n+\n     /*\n-     * Test basic MSI auth\n+     * Test MSI auth\n      */\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n     @Test\n-    public void testAuth() throws SQLException {\n-        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\n+    public void testMSIAuth() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Test MSI auth with msiClientId\n+     */\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testMSIAuthWithMSIClientId() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n+\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n             fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n         }\n     }\n", "next_change": {"commit": "692fe4eacb5c3f183257c69c4a404dc0524df255", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..7eec04b7 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -81,14 +87,12 @@ public class MSITest extends AESetup {\n     /*\n      * Test MSI auth using datasource\n      */\n+    @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n     public void testDSMSIAuth() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         String connStr = connectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n", "next_change": {"commit": "7ffc2f0b5c7b88269c7603f5e3faeb1470fd44ea", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7eec04b7..ce8a562b 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -101,9 +123,7 @@ public class MSITest extends AESetup {\n         ds.setAuthentication(\"ActiveDirectoryMSI\");\n         AbstractTest.updateDataSource(connStr, ds);\n \n-        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\n-            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n-        }\n+        testSimpleConnect(connStr);\n     }\n \n     /*\n", "next_change": {"commit": "cee2c54f87bfb75054d5b61720d59ee9a8a73a27", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex ce8a562b..0ea51ed5 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -123,7 +108,12 @@ public class MSITest extends AESetup {\n         ds.setAuthentication(\"ActiveDirectoryMSI\");\n         AbstractTest.updateDataSource(connStr, ds);\n \n-        testSimpleConnect(connStr);\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        AbstractTest.updateDataSource(connStr, ds);\n+\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n     /*\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 0ea51ed5..92d39bb7 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -71,74 +72,146 @@ public class MSITest extends AESetup {\n     }\n \n     /*\n-     * Test MSI auth with msiClientId\n+     * Test Managed Identity auth with Managed Identity client ID\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testMSIAuthWithMSIClientId() throws SQLException {\n+    public void testManagedIdentityAuthWithManagedIdentityClientId() throws SQLException {\n         String connStr = connectionString;\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n \n-        testSimpleConnect(connStr);\n+        // Test with user=<managed-identity-client-id>\n+        try {\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+\n+            // Set msiClientId to incorrect managed identity client ID. Since \"User\" is set with the ID, \"User\" should override msiClientId.\n+            // Otherwise, test should fail with the incorrect \"msiClientId\" property value because \"User\" was not overrided\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID,\n+                    \"incorrect-managed-identity-client-id\");\n+            try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION,\n+                    \"ActiveDirectoryManagedIdentity\");\n+            try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+        } catch (CredentialUnavailableException ce) {\n+            fail(\"\\\"User\\\" was overrided by incorrect managed identity client ID set in \\\"msiClientId\\\" property.\");\n+        }\n \n+        // Test with msiClientId=<managed-identity-client-id>\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, managedIdentityClientId);\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n-        testSimpleConnect(connStr);\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n     }\n \n     /*\n-     * Test MSI auth using datasource\n+     * Test Managed Identity auth using datasource\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSMSIAuth() throws SQLException {\n+    public void testDSManagedIdentityAuth() throws SQLException {\n         String connStr = connectionString;\n+\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n-\n         SQLServerDataSource ds = new SQLServerDataSource();\n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n         AbstractTest.updateDataSource(connStr, ds);\n \n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+\n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n \n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n-        AbstractTest.updateDataSource(connStr, ds);\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n \n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n     /*\n-     * Test MSI auth with msiClientId using datasource\n+     * Test Managed Identity auth with a Managed Identity client ID using datasource\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSMSIAuthWithMSIClientId() throws SQLException {\n+    public void testDSManagedIdentityAuthWithManagedIdentityClientId() throws SQLException {\n         String connStr = connectionString;\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+\n+        // Test with user=<managed-identity-client-id>\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n \n         SQLServerDataSource ds = new SQLServerDataSource();\n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n-        ds.setMSIClientId(msiClientId);\n         AbstractTest.updateDataSource(connStr, ds);\n-\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n \n+        // Test with msiClientId=<managed-identity-client-id>\n+        ds.setUser(\"\");\n+        ds.setMSIClientId(managedIdentityClientId);\n         ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+    }\n+\n+    @Tag(Constants.xSQLv11)\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDefaultAzureCredentialAuth() throws SQLException {\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"DefaultAzureCredential\");\n+\n+        // With Managed Identity client ID\n+        try (SQLServerConnection con = (SQLServerConnection) PrepUtil.getConnection(connStr)) {}\n+\n+        // Without Managed Identity client ID\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        try (SQLServerConnection con = (SQLServerConnection) PrepUtil.getConnection(connStr)) {}\n+    }\n+\n+    @Tag(Constants.xSQLv11)\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDefaultAzureCredentialAuthDS() throws SQLException {\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+\n+        SQLServerDataSource ds = new SQLServerDataSource();\n+        ds.setAuthentication(\"DefaultAzureCredential\");\n+        ds.setMSIClientId(managedIdentityClientId);\n         AbstractTest.updateDataSource(connStr, ds);\n \n+        // With msiClientId property\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Without msiClientId property\n+        ds.setMSIClientId(\"\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // With user property\n+        ds.setUser(managedIdentityClientId);\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Without user property\n+        ds.setUser(\"\");\n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MDY4NQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401190685", "body": "Same here, how is this testing MSI auth?", "bodyText": "Same here, how is this testing MSI auth?", "bodyHTML": "<p dir=\"auto\">Same here, how is this testing MSI auth?</p>", "author": "ulvii", "createdAt": "2020-03-31T20:21:49Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+    /*\r\n+     * Test basic MSI auth\r\n+     */\r\n+    @Test\r\n+    public void testAuth() throws SQLException {\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test MSI auth using datasource\r\n+     */\r\n+    @Test\r\n+    public void testDSAuth() throws SQLException {\r\n+        SQLServerDataSource ds = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, ds);\r", "originalCommit": "7ddd56156e31b863bb36352cc6c5015059e13380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 76b4de70..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -47,16 +81,68 @@ public class MSITest extends AESetup {\n     /*\n      * Test MSI auth using datasource\n      */\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSAuth() throws SQLException {\n+    public void testDSMSIAuth() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+\n+        SQLServerDataSource ds = new SQLServerDataSource();\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        AbstractTest.updateDataSource(connStr, ds);\n+\n+        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Test MSI auth with msiClientId using datasource\n+     */\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDSMSIAuthWithMSIClientId() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+\n         SQLServerDataSource ds = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(connectionString, ds);\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        ds.setMSIClientId(msiClientId);\n+        AbstractTest.updateDataSource(connStr, ds);\n \n         try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\n             fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n         }\n     }\n \n+    /*\n+     * Test AKV with MSI using datasource\n+     */\n+    @Test\n+    public void testDSAkvWithMSI() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\n+                \"KeyVaultManagedIdentity\");\n+        SQLServerDataSource ds = new SQLServerDataSource();\n+        AbstractTest.updateDataSource(connStr, ds);\n+        testCharAkv(connStr);\n+    }\n+\n     /*\n      * Test AKV with with credentials\n      */\n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -148,9 +143,6 @@ public class MSITest extends AESetup {\n      */\n     @Test\n     public void testCharAkvWithCred() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         // add credentials to connection string\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5NDQyMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401194423", "body": "Login failed? This catch block implies that, the only exception that can happen inside try block is due to a login failure. Just remove the catch block and let the test throw the original exception.", "bodyText": "Login failed? This catch block implies that, the only exception that can happen inside try block is due to a login failure. Just remove the catch block and let the test throw the original exception.", "bodyHTML": "<p dir=\"auto\">Login failed? This catch block implies that, the only exception that can happen inside try block is due to a login failure. Just remove the catch block and let the test throw the original exception.</p>", "author": "ulvii", "createdAt": "2020-03-31T20:28:17Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+    /*\r\n+     * Test basic MSI auth\r\n+     */\r\n+    @Test\r\n+    public void testAuth() throws SQLException {\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test MSI auth using datasource\r\n+     */\r\n+    @Test\r\n+    public void testDSAuth() throws SQLException {\r\n+        SQLServerDataSource ds = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, ds);\r\n+\r\n+        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with credentials\r\n+     */\r\n+    @Test\r\n+    public void testCharAkvWithCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, keyStoreSecret);\r\n+        testCharAkv(connStr);\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with MSI\r\n+     */\r\n+    @Test\r\n+    public void testCharAkvWithMSI() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // set to use Managed Identity for keystore auth\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\r\n+                \"KeyVaultManagedIdentity\");\r\n+        testCharAkv(connStr);\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with bad credentials\r\n+     */\r\n+    @Test\r\n+    public void testNumericAkvWithBadCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, \"bad\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, \"bad\");\r\n+        try {\r\n+            testNumericAKV(connStr);\r\n+            fail(TestResource.getResource(\"R_expectedFailPassed\"));\r\n+        } catch (Exception e) {\r\n+            assert (e.getMessage().contains(\"AuthenticationException\"));\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with credentials\r\n+     */\r\n+    @Test\r\n+    public void testNumericAkvWithCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, keyStoreSecret);\r\n+        testNumericAKV(connStr);\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with MSI\r\n+     */\r\n+    @Test\r\n+    public void testNumericAkvWithMSI() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // set to use Managed Identity for keystore auth\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\r\n+                \"KeyVaultManagedIdentity\");\r\n+        testNumericAKV(connStr);\r\n+    }\r\n+\r\n+    private void testCharAkv(String connStr) throws SQLException {\r\n+        String sql = \"select * from \" + CHAR_TABLE_AE;\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr);\r\n+                SQLServerStatement stmt = (SQLServerStatement) con.createStatement();\r\n+                SQLServerPreparedStatement pstmt = (SQLServerPreparedStatement) TestUtils.getPreparedStmt(con, sql,\r\n+                        stmtColEncSetting)) {\r\n+            TestUtils.dropTableIfExists(CHAR_TABLE_AE, stmt);\r\n+            createTable(CHAR_TABLE_AE, cekAkv, charTable);\r\n+            String[] values = createCharValues(false);\r\n+            populateCharNormalCase(values);\r\n+\r\n+            try (ResultSet rs = (null == stmt) ? pstmt.executeQuery() : stmt.executeQuery(sql)) {\r\n+                int numberOfColumns = rs.getMetaData().getColumnCount();\r\n+                while (rs.next()) {\r\n+                    AECommon.testGetString(rs, numberOfColumns, values);\r\n+                    AECommon.testGetObject(rs, numberOfColumns, values);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void testNumericAKV(String connStr) throws SQLException {\r\n+        String sql = \"select * from \" + NUMERIC_TABLE_AE;\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr);\r\n+                SQLServerStatement stmt = (SQLServerStatement) con.createStatement();\r\n+                SQLServerPreparedStatement pstmt = (SQLServerPreparedStatement) TestUtils.getPreparedStmt(con, sql,\r\n+                        stmtColEncSetting)) {\r\n+            TestUtils.dropTableIfExists(NUMERIC_TABLE_AE, stmt);\r\n+            createTable(NUMERIC_TABLE_AE, cekAkv, numericTable);\r\n+            String[] values = createNumericValues(false);\r\n+            populateNumeric(values);\r\n+\r\n+            try (SQLServerResultSet rs = (null == stmt) ? (SQLServerResultSet) pstmt.executeQuery()\r\n+                                                        : (SQLServerResultSet) stmt.executeQuery(sql)) {\r\n+                int numberOfColumns = rs.getMetaData().getColumnCount();\r\n+                while (rs.next()) {\r\n+                    AECommon.testGetString(rs, numberOfColumns, values);\r\n+                    AECommon.testGetObject(rs, numberOfColumns, values);\r\n+                    AECommon.testGetBigDecimal(rs, numberOfColumns, values);\r\n+                    AECommon.testWithSpecifiedtype(rs, numberOfColumns, values);\r\n+                }\r\n+            } catch (Exception e) {\r\n+                fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r", "originalCommit": "7ddd56156e31b863bb36352cc6c5015059e13380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 76b4de70..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -181,8 +299,6 @@ public class MSITest extends AESetup {\n                     AECommon.testGetBigDecimal(rs, numberOfColumns, values);\n                     AECommon.testWithSpecifiedtype(rs, numberOfColumns, values);\n                 }\n-            } catch (Exception e) {\n-                fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n             }\n         }\n     }\n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -302,4 +356,32 @@ public class MSITest extends AESetup {\n             }\n         }\n     }\n+\n+    @BeforeEach\n+    public void registerAKVProvider() throws Exception {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n+        Map<String, SQLServerColumnEncryptionKeyStoreProvider> map = new HashMap<String, SQLServerColumnEncryptionKeyStoreProvider>();\n+        if (null == akvProvider && null != applicationClientID && null != applicationKey) {\n+            File file = null;\n+            try {\n+                file = new File(Constants.MSSQL_JDBC_PROPERTIES);\n+                try (OutputStream os = new FileOutputStream(file);) {\n+                    Properties props = new Properties();\n+                    // Append to the list of hardcoded endpoints.\n+                    props.setProperty(Constants.AKV_TRUSTED_ENDPOINTS_KEYWORD, \";vault.azure.net\");\n+                    props.store(os, \"\");\n+                }\n+                akvProvider = new SQLServerColumnEncryptionAzureKeyVaultProvider(applicationClientID, applicationKey);\n+                map.put(Constants.AZURE_KEY_VAULT_NAME, akvProvider);\n+            } finally {\n+                if (null != file) {\n+                    file.delete();\n+                }\n+            }\n+        }\n+\n+        SQLServerConnection.registerColumnEncryptionKeyStoreProviders(map);\n+    }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwMDY3Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401200673", "body": "I would prefer to use `KeyVaultManagedIdentity` here, that is what the feature is about.", "bodyText": "I would prefer to use KeyVaultManagedIdentity here, that is what the feature is about.", "bodyHTML": "<p dir=\"auto\">I would prefer to use <code>KeyVaultManagedIdentity</code> here, that is what the feature is about.</p>", "author": "ulvii", "createdAt": "2020-03-31T20:39:20Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+    /*\r\n+     * Test basic MSI auth\r\n+     */\r\n+    @Test\r\n+    public void testAuth() throws SQLException {\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test MSI auth using datasource\r\n+     */\r\n+    @Test\r\n+    public void testDSAuth() throws SQLException {\r\n+        SQLServerDataSource ds = new SQLServerDataSource();\r\n+        AbstractTest.updateDataSource(connectionString, ds);\r\n+\r\n+        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\r\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with credentials\r\n+     */\r\n+    @Test\r\n+    public void testCharAkvWithCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, keyStoreSecret);\r\n+        testCharAkv(connStr);\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with MSI\r\n+     */\r\n+    @Test\r\n+    public void testCharAkvWithMSI() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // set to use Managed Identity for keystore auth\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\r\n+                \"KeyVaultManagedIdentity\");\r\n+        testCharAkv(connStr);\r\n+    }\r\n+\r\n+    /*\r\n+     * Test AKV with with bad credentials\r\n+     */\r\n+    @Test\r\n+    public void testNumericAkvWithBadCred() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        // add credentials to connection string\r\n+        String connStr = AETestConnectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\r", "originalCommit": "7ddd56156e31b863bb36352cc6c5015059e13380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 76b4de70..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -88,14 +175,91 @@ public class MSITest extends AESetup {\n         testCharAkv(connStr);\n     }\n \n+    /*\n+     * Test AKV with MSI and and principal id\n+     */\n+    @Test\n+    public void testCharAkvWithMSIandPrincipalId() throws SQLException {\n+        // set to use Managed Identity for keystore auth and principal id\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION,\n+                \"KeyVaultManagedIdentity\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\n+        testCharAkv(connStr);\n+    }\n+\n+    /*\n+     * Test AKV with with missing credentials\n+     */\n+    @Test\n+    public void testNumericAkvMissingCred() throws SQLException {\n+        // set auth type to key vault client secret but do not provide secret\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n+        try {\n+            testNumericAKV(connStr);\n+            fail(TestResource.getResource(\"R_expectedFailPassed\"));\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_keyStoreSecretNotSet\")), e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Test AKV with with keyStoreSecret secret but no keyStoreAuthentication\n+     */\n+    @Test\n+    public void testNumericAkvSecretNoAuth() throws SQLException {\n+        // set key store secret but do not specify authentication type\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_SECRET, keyStoreSecret);\n+        try {\n+            testNumericAKV(connStr);\n+            fail(TestResource.getResource(\"R_expectedFailPassed\"));\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_keyStoreAuthenticationNotSet\")),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Test AKV with with keyStorePrincipalId but no keyStoreAuthentication\n+     */\n+    @Test\n+    public void testNumericAkvPrincipalIdNoAuth() throws SQLException {\n+        // set principal id but do not specify authentication type\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_PRINCIPALID, keyStorePrincipalId);\n+        try {\n+            testNumericAKV(connStr);\n+            fail(TestResource.getResource(\"R_expectedFailPassed\"));\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_keyStoreAuthenticationNotSet\")),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Test AKV with with keyStoreLocation but no keyStoreAuthentication\n+     */\n+    @Test\n+    public void testNumericAkvLocationNoAuth() throws SQLException {\n+        // set key store location but do not specify authentication type\n+        String connStr = AETestConnectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_LOCATION, \"location\");\n+        try {\n+            testNumericAKV(connStr);\n+            fail(TestResource.getResource(\"R_expectedFailPassed\"));\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_keyStoreAuthenticationNotSet\")),\n+                    e.getMessage());\n+        }\n+    }\n+\n     /*\n      * Test AKV with with bad credentials\n      */\n     @Test\n     public void testNumericAkvWithBadCred() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         // add credentials to connection string\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n", "next_change": {"commit": "4b7c218da1d9113c2e8276f2078b96baf9adb14d", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 17814b34..1ee50066 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -260,6 +260,9 @@ public class MSITest extends AESetup {\n      */\n     @Test\n     public void testNumericAkvWithBadCred() throws SQLException {\n+        // unregister the custom providers registered in AESetup\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+\n         // add credentials to connection string\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n", "next_change": null}]}}]}}, {"oid": "ee0a1fbf0e356627076da3cda6b520bbb8c61f54", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee0a1fbf0e356627076da3cda6b520bbb8c61f54", "message": "added tests for MSI and principal id only", "committedDate": "2020-03-31T20:57:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNzczNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401227736", "body": "Requests", "bodyText": "Requests", "bodyHTML": "<p dir=\"auto\">Requests</p>", "author": "rene-ye", "createdAt": "2020-03-31T21:31:45Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java", "diffHunk": "@@ -5,21 +5,46 @@\n \r\n package com.microsoft.sqlserver.jdbc;\r\n \r\n+import static java.nio.charset.StandardCharsets.UTF_8;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.net.HttpURLConnection;\r\n+import java.net.URL;\r\n import java.security.InvalidKeyException;\r\n import java.security.NoSuchAlgorithmException;\r\n+import java.text.DateFormat;\r\n import java.text.MessageFormat;\r\n+import java.text.SimpleDateFormat;\r\n+import java.util.ArrayList;\r\n+import java.util.Calendar;\r\n+import java.util.Date;\r\n import java.util.Iterator;\r\n import java.util.List;\r\n+import java.util.concurrent.ThreadLocalRandom;\r\n+import java.util.logging.Level;\r\n \r\n import javax.crypto.Mac;\r\n import javax.crypto.spec.SecretKeySpec;\r\n \r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection.ActiveDirectoryAuthentication;\r\n+\r\n \r\n /**\r\n  * Various SQLServer security utilities.\r\n  *\r\n  */\r\n class SQLServerSecurityUtility {\r\n+    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger\r\n+            .getLogger(\"com.microsoft.sqlserver.jdbc.internals.SQLServerConnection\");\r\n+\r\n+    static final int GONE = 410;\r\n+    static final int TOO_MANY_RESQUESTS = 429;\r", "originalCommit": "ee0a1fbf0e356627076da3cda6b520bbb8c61f54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\nindex 5167917d..d0b64a4f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n", "chunk": "@@ -46,6 +44,8 @@ class SQLServerSecurityUtility {\n     static final int INTERNAL_SERVER_ERROR = 500;\n     static final int NETWORK_CONNECT_TIMEOUT_ERROR = 599;\n \n+    static final String WINDOWS_KEY_STORE_NAME = \"MSSQL_CERTIFICATE_STORE\";\n+\n     /**\n      * Give the hash of given plain text\n      * \n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\nindex d0b64a4f..277ddbc6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n", "chunk": "@@ -46,6 +40,12 @@ class SQLServerSecurityUtility {\n \n     static final String WINDOWS_KEY_STORE_NAME = \"MSSQL_CERTIFICATE_STORE\";\n \n+    // Environment variable for intellij keepass database path\n+    private static final String INTELLIJ_KEEPASS_PASS = \"INTELLIJ_KEEPASS_PATH\";\n+\n+    // Environment variable for additionally allowed tenants. The tenantIds are comma delimited\n+    private static final String ADDITIONALLY_ALLOWED_TENANTS = \"ADDITIONALLY_ALLOWED_TENANTS\";\n+\n     /**\n      * Give the hash of given plain text\n      * \n", "next_change": {"commit": "c443c7c521676813b6a7da15740d7a8ffc1880d3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\nindex 277ddbc6..26df5bb5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java\n", "chunk": "@@ -46,6 +46,10 @@ class SQLServerSecurityUtility {\n     // Environment variable for additionally allowed tenants. The tenantIds are comma delimited\n     private static final String ADDITIONALLY_ALLOWED_TENANTS = \"ADDITIONALLY_ALLOWED_TENANTS\";\n \n+    private SQLServerSecurityUtility() {\n+        throw new UnsupportedOperationException(SQLServerException.getErrString(\"R_notSupported\"));\n+    }\n+    \n     /**\n      * Give the hash of given plain text\n      * \n", "next_change": null}]}}]}}]}}, {"oid": "906a1111568824fa48dcbc4392d7c9da90f09a56", "url": "https://github.com/microsoft/mssql-jdbc/commit/906a1111568824fa48dcbc4392d7c9da90f09a56", "message": "review updates", "committedDate": "2020-03-31T21:44:26Z", "type": "commit"}, {"oid": "19e28a736913cf56e6caee992cce8f3b9de2b090", "url": "https://github.com/microsoft/mssql-jdbc/commit/19e28a736913cf56e6caee992cce8f3b9de2b090", "message": "added more MSI auth tests", "committedDate": "2020-03-31T22:20:59Z", "type": "commit"}, {"oid": "0b0d70d10810320422c1b359acb304ff9cf639fd", "url": "https://github.com/microsoft/mssql-jdbc/commit/0b0d70d10810320422c1b359acb304ff9cf639fd", "message": "tag for testing MSI auth", "committedDate": "2020-03-31T22:35:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1NzU2OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401257569", "body": "Please also add similar tests that test ActiveDirectoryMSI along with msiClientId ", "bodyText": "Please also add similar tests that test ActiveDirectoryMSI along with msiClientId", "bodyHTML": "<p dir=\"auto\">Please also add similar tests that test ActiveDirectoryMSI along with msiClientId</p>", "author": "ulvii", "createdAt": "2020-03-31T22:41:56Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.aad.adal4j.AuthenticationException;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+import static org.junit.jupiter.api.Assertions.assertTrue;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+\r\n+    /*\r\n+     * Test MSI auth\r\n+     */\r\n+    @Tag(Constants.xSQLv12)\r\n+    @Tag(Constants.xSQLv14)\r\n+    @Tag(Constants.xSQLv15)\r\n+    @Test\r\n+    public void testMSIAuth() throws SQLException {\r", "originalCommit": "0b0d70d10810320422c1b359acb304ff9cf639fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex db162142..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -45,15 +53,31 @@ public class MSITest extends AESetup {\n     @Tag(Constants.xSQLv15)\n     @Test\n     public void testMSIAuth() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n \n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n+            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Test MSI auth with msiClientId\n+     */\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testMSIAuthWithMSIClientId() throws SQLException {\n         String connStr = connectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n \n-        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n             fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n         }\n     }\n", "next_change": {"commit": "692fe4eacb5c3f183257c69c4a404dc0524df255", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 17814b34..7eec04b7 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -85,6 +87,7 @@ public class MSITest extends AESetup {\n     /*\n      * Test MSI auth using datasource\n      */\n+    @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7eec04b7..92d39bb7 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -53,80 +52,167 @@ public class MSITest extends AESetup {\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testMSIAuth() throws SQLException {\n+    public void testManagedIdentityAuth() throws SQLException {\n         String connStr = connectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n \n+        testSimpleConnect(connStr);\n+\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryManagedIdentity\");\n+\n+        testSimpleConnect(connStr);\n+    }\n+\n+    private void testSimpleConnect(String connStr) {\n         try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n             fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n         }\n     }\n \n     /*\n-     * Test MSI auth with msiClientId\n+     * Test Managed Identity auth with Managed Identity client ID\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testMSIAuthWithMSIClientId() throws SQLException {\n+    public void testManagedIdentityAuthWithManagedIdentityClientId() throws SQLException {\n         String connStr = connectionString;\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n \n-        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n-            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n+        // Test with user=<managed-identity-client-id>\n+        try {\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+\n+            // Set msiClientId to incorrect managed identity client ID. Since \"User\" is set with the ID, \"User\" should override msiClientId.\n+            // Otherwise, test should fail with the incorrect \"msiClientId\" property value because \"User\" was not overrided\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID,\n+                    \"incorrect-managed-identity-client-id\");\n+            try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION,\n+                    \"ActiveDirectoryManagedIdentity\");\n+            try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+        } catch (CredentialUnavailableException ce) {\n+            fail(\"\\\"User\\\" was overrided by incorrect managed identity client ID set in \\\"msiClientId\\\" property.\");\n         }\n+\n+        // Test with msiClientId=<managed-identity-client-id>\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, managedIdentityClientId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n     }\n \n     /*\n-     * Test MSI auth using datasource\n+     * Test Managed Identity auth using datasource\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSMSIAuth() throws SQLException {\n+    public void testDSManagedIdentityAuth() throws SQLException {\n         String connStr = connectionString;\n+\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n-\n         SQLServerDataSource ds = new SQLServerDataSource();\n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n         AbstractTest.updateDataSource(connStr, ds);\n \n-        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\n-            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n-        }\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n+\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n     /*\n-     * Test MSI auth with msiClientId using datasource\n+     * Test Managed Identity auth with a Managed Identity client ID using datasource\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSMSIAuthWithMSIClientId() throws SQLException {\n+    public void testDSManagedIdentityAuthWithManagedIdentityClientId() throws SQLException {\n         String connStr = connectionString;\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+\n+        // Test with user=<managed-identity-client-id>\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n \n         SQLServerDataSource ds = new SQLServerDataSource();\n+        AbstractTest.updateDataSource(connStr, ds);\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Test with msiClientId=<managed-identity-client-id>\n+        ds.setUser(\"\");\n+        ds.setMSIClientId(managedIdentityClientId);\n         ds.setAuthentication(\"ActiveDirectoryMSI\");\n-        ds.setMSIClientId(msiClientId);\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+    }\n+\n+    @Tag(Constants.xSQLv11)\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDefaultAzureCredentialAuth() throws SQLException {\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"DefaultAzureCredential\");\n+\n+        // With Managed Identity client ID\n+        try (SQLServerConnection con = (SQLServerConnection) PrepUtil.getConnection(connStr)) {}\n+\n+        // Without Managed Identity client ID\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        try (SQLServerConnection con = (SQLServerConnection) PrepUtil.getConnection(connStr)) {}\n+    }\n+\n+    @Tag(Constants.xSQLv11)\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDefaultAzureCredentialAuthDS() throws SQLException {\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+\n+        SQLServerDataSource ds = new SQLServerDataSource();\n+        ds.setAuthentication(\"DefaultAzureCredential\");\n+        ds.setMSIClientId(managedIdentityClientId);\n         AbstractTest.updateDataSource(connStr, ds);\n \n-        try (Connection con = ds.getConnection(); Statement stmt = con.createStatement()) {} catch (Exception e) {\n-            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n-        }\n+        // With msiClientId property\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Without msiClientId property\n+        ds.setMSIClientId(\"\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // With user property\n+        ds.setUser(managedIdentityClientId);\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Without user property\n+        ds.setUser(\"\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n     /*\n", "next_change": null}]}}]}}]}}, {"oid": "8b9e6331c22499af4272e50615d3dcd428f6f622", "url": "https://github.com/microsoft/mssql-jdbc/commit/8b9e6331c22499af4272e50615d3dcd428f6f622", "message": "msi auth servers tags", "committedDate": "2020-03-31T22:45:26Z", "type": "commit"}, {"oid": "19a582e1d8750ecc746f334c0a7f43cb66121a6a", "url": "https://github.com/microsoft/mssql-jdbc/commit/19a582e1d8750ecc746f334c0a7f43cb66121a6a", "message": "added MSI auth w msiClientId tests", "committedDate": "2020-03-31T22:57:00Z", "type": "commit"}, {"oid": "9497069ad2421e9c7dbe644d7b16cea2c927555c", "url": "https://github.com/microsoft/mssql-jdbc/commit/9497069ad2421e9c7dbe644d7b16cea2c927555c", "message": "Merge remote-tracking branch 'upstream/dev' into msi", "committedDate": "2020-03-31T23:35:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3NjAyNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401276027", "body": "There are unused imports here", "bodyText": "There are unused imports here", "bodyHTML": "<p dir=\"auto\">There are unused imports here</p>", "author": "ulvii", "createdAt": "2020-03-31T23:39:20Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.aad.adal4j.AuthenticationException;\r", "originalCommit": "19a582e1d8750ecc746f334c0a7f43cb66121a6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 12b5002d..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -16,7 +16,6 @@ import org.junit.jupiter.api.Test;\n import org.junit.platform.runner.JUnitPlatform;\n import org.junit.runner.RunWith;\n \n-import com.microsoft.aad.adal4j.AuthenticationException;\n import com.microsoft.sqlserver.jdbc.SQLServerConnection;\n import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\n import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -5,17 +5,27 @@\n package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\n \n import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.OutputStream;\n import java.sql.Connection;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n \n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n import org.junit.platform.runner.JUnitPlatform;\n import org.junit.runner.RunWith;\n \n+import com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider;\n+import com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionKeyStoreProvider;\n import com.microsoft.sqlserver.jdbc.SQLServerConnection;\n import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\n import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI4MTMyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1286#discussion_r401281329", "body": "aren't you supposed to use connStr ?", "bodyText": "aren't you supposed to use connStr ?", "bodyHTML": "<p dir=\"auto\">aren't you supposed to use connStr ?</p>", "author": "ulvii", "createdAt": "2020-03-31T23:56:29Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.jdbc.AlwaysEncrypted;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.fail;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.aad.adal4j.AuthenticationException;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerConnection;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerResultSet;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerStatement;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+import com.microsoft.sqlserver.testframework.PrepUtil;\r\n+import static org.junit.jupiter.api.Assertions.assertTrue;\r\n+\r\n+\r\n+/**\r\n+ * Tests involving MSI authentication\r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.MSI)\r\n+public class MSITest extends AESetup {\r\n+\r\n+    /*\r\n+     * Test MSI auth\r\n+     */\r\n+    @Tag(Constants.xSQLv12)\r\n+    @Tag(Constants.xSQLv14)\r\n+    @Tag(Constants.xSQLv15)\r\n+    @Test\r\n+    public void testMSIAuth() throws SQLException {\r\n+        // unregister the custom providers registered in AESetup\r\n+        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\r\n+\r\n+        String connStr = connectionString;\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\r\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\r\n+\r\n+        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\r", "originalCommit": "19a582e1d8750ecc746f334c0a7f43cb66121a6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a483b0a5e83816b79332ca2a772324087f6e4de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 12b5002d..6c073eaf 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -53,7 +51,7 @@ public class MSITest extends AESetup {\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n \n-        try (SQLServerConnection con = PrepUtil.getConnection(connectionString)) {} catch (Exception e) {\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n             fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n         }\n     }\n", "next_change": {"commit": "692fe4eacb5c3f183257c69c4a404dc0524df255", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 6c073eaf..7eec04b7 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -59,14 +67,12 @@ public class MSITest extends AESetup {\n     /*\n      * Test MSI auth with msiClientId\n      */\n+    @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n     public void testMSIAuthWithMSIClientId() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         String connStr = connectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n", "next_change": {"commit": "7ffc2f0b5c7b88269c7603f5e3faeb1470fd44ea", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7eec04b7..ce8a562b 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -79,9 +92,18 @@ public class MSITest extends AESetup {\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n \n-        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {} catch (Exception e) {\n-            fail(TestResource.getResource(\"R_loginFailed\") + e.getMessage());\n-        }\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSITOKENCACHETTL, \"0\");\n+\n+        testSimpleConnect(connStr);\n+\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSITOKENCACHETTL,\n+                Integer.toString(Integer.MAX_VALUE));\n+\n+        testSimpleConnect(connStr);\n+\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSITOKENCACHETTL, \"\");\n+\n+        testSimpleConnect(connStr); // This call will use a cached token\n     }\n \n     /*\n", "next_change": {"commit": "cee2c54f87bfb75054d5b61720d59ee9a8a73a27", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex ce8a562b..0ea51ed5 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -92,18 +85,10 @@ public class MSITest extends AESetup {\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n \n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSITOKENCACHETTL, \"0\");\n-\n         testSimpleConnect(connStr);\n \n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSITOKENCACHETTL,\n-                Integer.toString(Integer.MAX_VALUE));\n-\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n         testSimpleConnect(connStr);\n-\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSITOKENCACHETTL, \"\");\n-\n-        testSimpleConnect(connStr); // This call will use a cached token\n     }\n \n     /*\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 0ea51ed5..92d39bb7 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -71,74 +72,146 @@ public class MSITest extends AESetup {\n     }\n \n     /*\n-     * Test MSI auth with msiClientId\n+     * Test Managed Identity auth with Managed Identity client ID\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testMSIAuthWithMSIClientId() throws SQLException {\n+    public void testManagedIdentityAuthWithManagedIdentityClientId() throws SQLException {\n         String connStr = connectionString;\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, msiClientId);\n \n-        testSimpleConnect(connStr);\n+        // Test with user=<managed-identity-client-id>\n+        try {\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n+\n+            // Set msiClientId to incorrect managed identity client ID. Since \"User\" is set with the ID, \"User\" should override msiClientId.\n+            // Otherwise, test should fail with the incorrect \"msiClientId\" property value because \"User\" was not overrided\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID,\n+                    \"incorrect-managed-identity-client-id\");\n+            try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+            connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION,\n+                    \"ActiveDirectoryManagedIdentity\");\n+            try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+        } catch (CredentialUnavailableException ce) {\n+            fail(\"\\\"User\\\" was overrided by incorrect managed identity client ID set in \\\"msiClientId\\\" property.\");\n+        }\n \n+        // Test with msiClientId=<managed-identity-client-id>\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.MSICLIENTID, managedIdentityClientId);\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryMSI\");\n-        testSimpleConnect(connStr);\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = PrepUtil.getConnection(connStr)) {}\n     }\n \n     /*\n-     * Test MSI auth using datasource\n+     * Test Managed Identity auth using datasource\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSMSIAuth() throws SQLException {\n+    public void testDSManagedIdentityAuth() throws SQLException {\n         String connStr = connectionString;\n+\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n-\n         SQLServerDataSource ds = new SQLServerDataSource();\n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n         AbstractTest.updateDataSource(connStr, ds);\n \n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+\n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n \n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n-        AbstractTest.updateDataSource(connStr, ds);\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n \n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n     /*\n-     * Test MSI auth with msiClientId using datasource\n+     * Test Managed Identity auth with a Managed Identity client ID using datasource\n      */\n     @Tag(Constants.xSQLv11)\n     @Tag(Constants.xSQLv12)\n     @Tag(Constants.xSQLv14)\n     @Tag(Constants.xSQLv15)\n     @Test\n-    public void testDSMSIAuthWithMSIClientId() throws SQLException {\n+    public void testDSManagedIdentityAuthWithManagedIdentityClientId() throws SQLException {\n         String connStr = connectionString;\n-        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+\n+        // Test with user=<managed-identity-client-id>\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n \n         SQLServerDataSource ds = new SQLServerDataSource();\n-        ds.setAuthentication(\"ActiveDirectoryMSI\");\n-        ds.setMSIClientId(msiClientId);\n         AbstractTest.updateDataSource(connStr, ds);\n-\n+        ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n \n+        // Test with msiClientId=<managed-identity-client-id>\n+        ds.setUser(\"\");\n+        ds.setMSIClientId(managedIdentityClientId);\n         ds.setAuthentication(\"ActiveDirectoryMSI\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+        ds.setAuthentication(\"ActiveDirectoryManagedIdentity\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+    }\n+\n+    @Tag(Constants.xSQLv11)\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDefaultAzureCredentialAuth() throws SQLException {\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, managedIdentityClientId);\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.AUTHENTICATION, \"DefaultAzureCredential\");\n+\n+        // With Managed Identity client ID\n+        try (SQLServerConnection con = (SQLServerConnection) PrepUtil.getConnection(connStr)) {}\n+\n+        // Without Managed Identity client ID\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        try (SQLServerConnection con = (SQLServerConnection) PrepUtil.getConnection(connStr)) {}\n+    }\n+\n+    @Tag(Constants.xSQLv11)\n+    @Tag(Constants.xSQLv12)\n+    @Tag(Constants.xSQLv14)\n+    @Tag(Constants.xSQLv15)\n+    @Test\n+    public void testDefaultAzureCredentialAuthDS() throws SQLException {\n+        String connStr = connectionString;\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.USER, \"\");\n+        connStr = TestUtils.addOrOverrideProperty(connStr, Constants.PASSWORD, \"\");\n+\n+        SQLServerDataSource ds = new SQLServerDataSource();\n+        ds.setAuthentication(\"DefaultAzureCredential\");\n+        ds.setMSIClientId(managedIdentityClientId);\n         AbstractTest.updateDataSource(connStr, ds);\n \n+        // With msiClientId property\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Without msiClientId property\n+        ds.setMSIClientId(\"\");\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // With user property\n+        ds.setUser(managedIdentityClientId);\n+        try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n+\n+        // Without user property\n+        ds.setUser(\"\");\n         try (SQLServerConnection con = (SQLServerConnection) ds.getConnection()) {}\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "a1b7f14a1d09263b328ffb9818ae7a8f32bcc7d3", "url": "https://github.com/microsoft/mssql-jdbc/commit/a1b7f14a1d09263b328ffb9818ae7a8f32bcc7d3", "message": "fixed connectstr issue", "committedDate": "2020-04-01T00:36:01Z", "type": "commit"}, {"oid": "33edae9e8170240c486da3c1277e6c18b97de8d6", "url": "https://github.com/microsoft/mssql-jdbc/commit/33edae9e8170240c486da3c1277e6c18b97de8d6", "message": "removed unused imports", "committedDate": "2020-04-01T00:43:37Z", "type": "commit"}, {"oid": "b5f35eec9bc90a43bd250f0aa4248bb1bf6a3e27", "url": "https://github.com/microsoft/mssql-jdbc/commit/b5f35eec9bc90a43bd250f0aa4248bb1bf6a3e27", "message": "fixed resource strings", "committedDate": "2020-04-01T01:16:12Z", "type": "commit"}]}