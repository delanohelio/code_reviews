{"pr_number": 1413, "pr_title": "Upgrading to new Key Vault (and MSAL) libraries", "pr_author": "srnagar", "pr_createdAt": "2020-08-25T21:43:24Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1413", "merge_commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "timeline": [{"oid": "9fbc98936839a5b38ab504a69887c75be90c501b", "url": "https://github.com/microsoft/mssql-jdbc/commit/9fbc98936839a5b38ab504a69887c75be90c501b", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-10-10T01:30:25Z", "type": "commit"}, {"oid": "a011ea785fa37b356746671fa1d06ae99f5274f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/a011ea785fa37b356746671fa1d06ae99f5274f4", "message": "Merge pull request #9 from lilgreenbird/msal\n\nadd tenantID to pipeline and merged with dev", "committedDate": "2020-10-10T02:06:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3Mjc4Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r504172782", "body": "Please search for `ADAL` in SQLServerResource and make similar changes to the error messages that mentioned ADAL.", "bodyText": "Please search for ADAL in SQLServerResource and make similar changes to the error messages that mentioned ADAL.", "bodyHTML": "<p dir=\"auto\">Please search for <code>ADAL</code> in SQLServerResource and make similar changes to the error messages that mentioned ADAL.</p>", "author": "ulvii", "createdAt": "2020-10-13T18:32:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -404,7 +404,7 @@ static String getResource(String key) {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},", "originalCommit": "a011ea785fa37b356746671fa1d06ae99f5274f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 8045d1f8..754f1391 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -404,7 +373,7 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n             {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n             {\"R_FedAuthFeatureAckContainsExtraData\",\n                     \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n", "next_change": {"commit": "af76d7af3846801be86f7f94fbc3318b1ed5bc04", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..613a1fb2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -373,7 +404,7 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n             {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n             {\"R_FedAuthFeatureAckContainsExtraData\",\n                     \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n", "next_change": {"commit": "bd776c2b48691897cee900cc6e821d171f18513a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 613a1fb2..33e27f31 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -405,6 +409,7 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n             {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n             {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n             {\"R_FedAuthFeatureAckContainsExtraData\",\n                     \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n", "next_change": {"commit": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 33e27f31..278197bc 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -21,645 +21,474 @@ public final class SQLServerResource extends ListResourceBundle {\n         return CONTENTS;\n     }\n \n-    // The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n-    // camelCasing convention and be descriptive\n-    static final Object[][] CONTENTS = {\n-            // LOCALIZE THIS\n-            {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n-            {\"R_invalidRoutingInfo\",\n-                    \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_multipleRedirections\",\n-                    \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n-            {\"R_dbMirroringWithMultiSubnetFailover\",\n-                    \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n-            {\"R_dbMirroringWithReadOnlyIntent\",\n-                    \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n-            {\"R_ipAddressLimitWithMultiSubnetFailover\",\n-                    \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n-            {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n-            {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n-            {\"R_invalidLength\", \"The length {0} is not valid.\"},\n-            {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n-            {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n-            {\"R_notSQLServer\",\n-                    \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting \"\n-                            + \"TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n-            {\"R_tcpOpenFailed\",\n-                    \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP \"\n-                            + \"connections to the port are not blocked by a firewall.\"},\n-            {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n-            {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n-            {\"R_truncatedServerResponse\",\n-                    \"SQL Server returned an incomplete response. The connection has been closed.\"},\n-            {\"R_queryTimedOut\", \"The query has timed out.\"}, {\"R_queryCancelled\", \"The query was canceled.\"},\n-            {\"R_errorReadingStream\",\n-                    \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n-            {\"R_streamReadReturnedInvalidValue\",\n-                    \"The stream read operation returned an invalid value for the amount of data read.\"},\n-            {\"R_mismatchedStreamLength\",\n-                    \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n-            {\"R_notSupported\", \"This operation is not supported.\"},\n-            {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n-            {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n-            {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n-            {\"R_connectionIsClosed\", \"The connection is closed.\"},\n-            {\"R_invalidBooleanValue\",\n-                    \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n-            {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n-            {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n-            {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n-            {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n-            {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n-            {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n-            {\"R_packetSizeTooBigForSSL\",\n-                    \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n-            {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n-            {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n-            {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_sqlServerHoldability\",\n-                    \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n-            {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n-            {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n-            {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n-            {\"R_sqlBrowserFailed\",\n-                    \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. \"\n-                            + \" For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n-            {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n-            {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n-            {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n-            {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n-            {\"R_noMetadata\", \"There is no metadata.\"}, {\"R_resultsetClosed\", \"The result set is closed.\"},\n-            {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n-            {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n-            {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n-            {\"R_savepointNotNamed\", \"The savepoint is not named.\"}, {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n-            {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n-            {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n-            {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n-            {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n-            {\"R_noResultset\", \"The statement did not return a result set.\"},\n-            {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n-            {\"R_statementIsClosed\", \"The statement is closed.\"},\n-            {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n-            {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n-            {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n-            {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n-            {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n-            {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n-            {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n-            {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n-            {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n-            {\"R_invalidOffset\", \"The offset {0} is not valid.\"}, {\"R_nullConnection\", \"The connection URL is null.\"},\n-            {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n-            {\"R_cannotTakeArgumentsPreparedOrCallable\",\n-                    \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n-            // Invalid conversion (e.g. MONEY to Timestamp)\n-            {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n-            // Invalid conversion to an unknown type\n-            {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n-            // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n-            {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n-            {\"R_streamIsClosed\", \"The stream is closed.\"}, {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n-            {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n-            {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n-            {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n-            {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n-            {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n-            {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n-            {\"R_encodingErrorWritingTDS\",\n-                    \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n-            {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n-            {\"R_requestedOpNotSupportedOnForward\",\n-                    \"The requested operation is not supported on forward only result sets.\"},\n-            {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n-            {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n-            {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n-            {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n-            {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n-            {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n-            {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n-            {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n-            {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n-            {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n-            {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n-            {\"R_cantGetUpdatedColumnValue\",\n-                    \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n-            {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n-            {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n-            {\"R_invalidAutoGeneratedKeys\",\n-                    \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n-            {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n-            {\"R_failoverPartnerWithoutDB\",\n-                    \"databaseName is required when using the failoverPartner connection property.\"},\n-            {\"R_invalidPartnerConfiguration\",\n-                    \"The database {0} on server {1} is not configured for database mirroring.\"},\n-            {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n-            {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n-            {\"R_invalidpropertyValue\",\n-                    \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n-            {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n-            {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n-            {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n-            {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n-            {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n-            {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n-            {\"R_sslRequiredNoServerSupport\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. \"\n-                            + \"The application requested encryption but the server is not configured to support SSL.\"},\n-            {\"R_sslRequiredByServer\",\n-                    \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n-            {\"R_sslFailed\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n-            {\"R_certNameFailed\",\n-                    \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n-            {\"R_failedToInitializeXA\",\n-                    \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n-            {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n-            {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n-            {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n-            {\"R_userPropertyDescription\", \"The database user.\"},\n-            {\"R_passwordPropertyDescription\", \"The database password.\"},\n-            {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n-            {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n-            {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n-            {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n-            {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n-            {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n-            {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n-            {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n-            {\"R_serverNameAsACEPropertyDescription\",\n-                    \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n-            {\"R_sendStringParametersAsUnicodePropertyDescription\",\n-                    \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n-            {\"R_multiSubnetFailoverPropertyDescription\",\n-                    \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n-            {\"R_applicationNamePropertyDescription\",\n-                    \"The application name for SQL Server profiling and logging tools.\"},\n-            {\"R_lastUpdateCountPropertyDescription\",\n-                    \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n-            {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n-            {\"R_integratedSecurityPropertyDescription\",\n-                    \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n-            {\"R_authenticationSchemePropertyDescription\",\n-                    \"The authentication scheme to be used for integrated authentication.\"},\n-            {\"R_lockTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n-            {\"R_loginTimeoutPropertyDescription\",\n-                    \"The number of seconds the driver should wait before timing out a failed connection.\"},\n-            {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n-            {\"R_xopenStatesPropertyDescription\",\n-                    \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n-            {\"R_selectMethodPropertyDescription\",\n-                    \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n-            {\"R_responseBufferingPropertyDescription\",\n-                    \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n-            {\"R_applicationIntentPropertyDescription\",\n-                    \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n-            {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n-            {\"R_failoverPartnerPropertyDescription\",\n-                    \"The name of the failover server used in a database mirroring configuration.\"},\n-            {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n-            {\"R_encryptPropertyDescription\",\n-                    \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n-            {\"R_socketFactoryClassPropertyDescription\",\n-                    \"The class to instantiate as the SocketFactory for connections\"},\n-            {\"R_socketFactoryConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n-            {\"R_trustServerCertificatePropertyDescription\",\n-                    \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n-            {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n-            {\"R_trustStorePasswordPropertyDescription\",\n-                    \"The password used to check the integrity of the trust store data.\"},\n-            {\"R_trustManagerClassPropertyDescription\",\n-                    \"The class to instantiate as the TrustManager for SSL connections.\"},\n-            {\"R_trustManagerConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n-            {\"R_hostNameInCertificatePropertyDescription\",\n-                    \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_sendTimeAsDatetimePropertyDescription\",\n-                    \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n-            {\"R_TransparentNetworkIPResolutionPropertyDescription\",\n-                    \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n-            {\"R_queryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait before the database reports a query time-out.\"},\n-            {\"R_socketTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n-            {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\",\n-                    \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). \"\n-                            + \"A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n-            {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\",\n-                    \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n-            {\"R_statementPoolingCacheSizePropertyDescription\",\n-                    \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n-            {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n-            {\"R_msiClientIdPropertyDescription\",\n-                    \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n-            {\"R_clientCertificatePropertyDescription\",\n-                    \"Client certificate path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPasswordPropertyDescription\",\n-                    \"Password for private key if the private key is password protected.\"},\n-            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n-                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n-            {\"R_delayLoadingLobsPropertyDescription\",\n-                    \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n-            {\"R_AADSecurePrincipalIdPropertyDescription\",\n-                    \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n-            {\"R_AADSecurePrincipalSecretPropertyDescription\",\n-                    \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n-            {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n-            {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n-            {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n-            {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n-            {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n-            {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n-            {\"R_cantSetNull\", \"Cannot set a null value.\"},\n-            {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n-            {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n-            {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n-            {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n-            {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n-            {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n-            {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n-            {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n-            {\"R_getSchemaError\", \"Error getting default schema name.\"},\n-            {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n-            {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n-            {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n-            {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n-            {\"R_featureNotSupported\", \"{0} is not supported.\"},\n-            {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n-            {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n-            {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n-            {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n-            {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n-            {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n-            {\"R_invalidDestConnection\",\n-                    \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n-            {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n-            {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n-            {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n-            {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n-            {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n-            {\"R_invalidTransactionOption\",\n-                    \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n-            {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n-            {\"R_BulkColumnMappingsIsEmpty\",\n-                    \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n-            {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n-            {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n-            {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n-            {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n-            {\"R_UnexpectedDescribeParamFormat\",\n-                    \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n-            {\"R_InvalidEncryptionKeyOrdinal\",\n-                    \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n-            {\"R_MissingParamEncryptionMetadata\",\n-                    \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n-            {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n-            {\"R_InvalidCipherTextSize\",\n-                    \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n-            {\"R_InvalidAlgorithmVersion\",\n-                    \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n-            {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n-            {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n-            {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n-            {\"R_InvalidKeySize\",\n-                    \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". \"\n-                            + \"Verify the encrypted value of the column encryption key in the database.\"},\n-            {\"R_InvalidEncryptionType\",\n-                    \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n-            {\"R_UnknownColumnEncryptionAlgorithm\",\n-                    \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n-            {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n-            {\"R_UntrustedKeyPath\",\n-                    \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path \"\n-                            + \"using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n-            {\"R_UnrecognizedKeyStoreProviderName\",\n-                    \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider \"\n-                            + \"or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: \"\n-                            + \"{2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers \"\n-                            + \"used in your application are registered properly.\"},\n-            {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n-            {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n-            {\"R_UnsupportedNormalizationVersionAE\",\n-                    \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n-            {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n-            {\"R_NullColumnEncryptionAlgorithmAE\",\n-                    \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n-            {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n-            {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n-            {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n-            {\"R_AE_NotSupportedByServer\", \"SQL Server instance in use does not support column encryption.\"},\n-            {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n-                                                                                                           // Server\n-            {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n-            {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n-            {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n-            {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n-            {\"R_InvalidCertificateSignature\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n-            {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n-            {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithm\",\n-                    \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithmInternal\",\n-                    \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n-            {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n-            {\"R_CertificateNotFoundForAlias\",\n-                    \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. \"\n-                    + \" Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n-            {\"R_KeyStoreNotFound\",\n-                    \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n-            {\"R_CustomKeyStoreProviderMapNull\",\n-                    \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n-            {\"R_EmptyCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n-            {\"R_InvalidCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n-            {\"R_CustomKeyStoreProviderValueNull\",\n-                    \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n-            {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n-            {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n-            {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n-            {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n-            {\"R_InvalidDataForAE\",\n-                    \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n-            {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n-            {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n-            {\"R_FedAuthRequiredPreLoginResponseInvalidValue\",\n-                    \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n-            {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\",\n-                    \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n-            {\"R_FedAuthInfoInvalidOffset\",\n-                    \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n-            {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n-            {\"R_FedAuthInfoLengthTooShortForData\",\n-                    \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n-            {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n-                    \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n-            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n-            {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n-            {\"R_FedAuthFeatureAckContainsExtraData\",\n-                    \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n-            {\"R_FedAuthFeatureAckUnknownLibraryType\",\n-                    \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n-            {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n-            {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n-                    \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n-            {\"R_NtlmNoUserPasswordDomain\",\n-                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n-            {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n-                    \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n-            {\"R_IntegratedAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_MSIAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_AccessTokenWithUserPassword\",\n-                    \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n-            {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n-            {\"R_SetBothAuthenticationAndAccessToken\",\n-                    \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n-            {\"R_NoUserPasswordForActivePassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\",\n-                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n-            {\"R_NoUserPasswordForSqlPassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalse\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\",\n-                    \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalseRS\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\",\n-                    \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_NullValue\", \"{0} cannot be null.\"}, {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n-            {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n-            {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n-            {\"R_ManagedIdentityInitFail\",\n-                    \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n-            {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n-            {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n-            {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n-            {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n-            {\"R_InvalidEcryptionAlgorithmVersion\",\n-                    \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n-            {\"R_AKVKeyLengthError\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_AKVSignatureLengthError\",\n-                    \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n-            {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n-            {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n-            {\"R_CEKSignatureNotMatchCMK\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n-            {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n-            {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n-            {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n-            {\"R_UnableLoadADALSqlDll\",\n-                    \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n-            {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n-            {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n-            {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n-            {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n-            {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n-            {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n-            {\"R_TVPMixedSource\",\n-                    \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n-            {\"R_TVPEmptyMetadata\",\n-                    \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n-            {\"R_TVPInvalidValue\",\n-                    \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n-            {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n-            {\"R_TVPSortOrdinalGreaterThanFieldCount\",\n-                    \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n-            {\"R_TVPMissingSortOrderOrOrdinal\",\n-                    \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n-            {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n-            {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n-            {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n-            // This is used for connection settings. {0}-> property name as is, {1}-> value\n-            {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n-            {\"R_InvalidWindowsCertificateStoreEncryption\",\n-                    \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n-            {\"R_AEKeypathEmpty\",\n-                    \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n-            {\"R_AECertpathBad\",\n-                    \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertLocBad\",\n-                    \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertStoreBad\",\n-                    \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n-            {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n-            {\"R_AECertNotFound\",\n-                    \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition \"\n-                            + \"in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_AEMaloc\", \"Memory allocation failure.\"},\n-            {\"R_AEKeypathLong\",\n-                    \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n-            {\"R_AEECEKLenBad\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEECEKSigLenBad\",\n-                    \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEKeyPathEmptyOrReserved\",\n-                    \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n-            {\"R_AEKeyPathCurUser\",\n-                    \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n-            {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n-            {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n-            {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n-            {\"R_keyStoreSecretPropertyDescription\",\n-                    \"The authentication secret or information needed to locate the secret.\"},\n-            {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n-            {\"R_keyStoreAuthenticationNotSet\",\n-                    \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n-            {\"R_keyStoreSecretOrLocationNotSet\",\n-                    \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n-            {\"R_keyStoreSecretNotSet\",\n-                    \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreInvalidKeyword\",\n-                    \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreLocationNotSet\",\n-                    \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStorePlatformInvalid\",\n-                    \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n-            {\"R_invalidKeyStoreFile\",\n-                    \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n-                                                                                                                  // JKS/PKCS\n-            {\"R_invalidCEKCacheTtl\",\n-                    \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n-            {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n-            {\"R_TVPnotWorkWithSetObjectResultSet\",\n-                    \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n-            {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n-            {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n-            {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n-            {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n-            {\"R_serverPreparedStatementDiscardThreshold\",\n-                    \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n-            {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n-            {\"R_kerberosLoginFailedForUsername\",\n-                    \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n-            {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n-            {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n-            {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n-            {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n-            {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n-            {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n-            {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n-            {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n-            {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n-            {\"R_sslProtocolPropertyDescription\",\n-                    \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n-            {\"R_invalidSSLProtocol\",\n-                    \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n-            {\"R_cancelQueryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait to cancel sending a query timeout.\"},\n-            {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n-            {\"R_useBulkCopyForBatchInsertPropertyDescription\",\n-                    \"Whether the driver will use bulk copy API for batch insert operations\"},\n-            {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n-            {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n-            {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n-            {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n-            {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n-            {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n-            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n-            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n-            {\"R_maxResultBufferPropertyDescription\",\n-                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n-            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n-            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+    /*\n+     * The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n+     * camelCasing convention and be descriptive.\n+     */\n+    // @formatter:off\n+    // Disable formatting for localization parser: use 1 line per error message and do not use \"+\"\n+    // @formatter:off\n+    static final Object[][] CONTENTS =\n+    {\n+        // LOCALIZE THIS\n+        {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n+        {\"R_invalidRoutingInfo\", \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_multipleRedirections\", \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n+        {\"R_dbMirroringWithMultiSubnetFailover\", \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n+        {\"R_dbMirroringWithReadOnlyIntent\", \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n+        {\"R_ipAddressLimitWithMultiSubnetFailover\", \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n+        {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n+        {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n+        {\"R_invalidLength\", \"The length {0} is not valid.\"},\n+        {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n+        {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n+        {\"R_notSQLServer\", \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n+        {\"R_tcpOpenFailed\", \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP connections to the port are not blocked by a firewall.\"},\n+        {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n+        {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n+        {\"R_truncatedServerResponse\", \"SQL Server returned an incomplete response. The connection has been closed.\"},\n+        {\"R_queryTimedOut\", \"The query has timed out.\"},\n+        {\"R_queryCancelled\", \"The query was canceled.\"},\n+        {\"R_errorReadingStream\", \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n+        {\"R_streamReadReturnedInvalidValue\", \"The stream read operation returned an invalid value for the amount of data read.\"},\n+        {\"R_mismatchedStreamLength\", \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n+        {\"R_notSupported\", \"This operation is not supported.\"},\n+        {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n+        {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n+        {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n+        {\"R_connectionIsClosed\", \"The connection is closed.\"},\n+        {\"R_invalidBooleanValue\", \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n+        {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n+        {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n+        {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n+        {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n+        {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n+        {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n+        {\"R_packetSizeTooBigForSSL\", \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n+        {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n+        {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n+        {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_sqlServerHoldability\", \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n+        {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n+        {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n+        {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n+        {\"R_sqlBrowserFailed\", \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n+        {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n+        {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n+        {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n+        {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n+        {\"R_noMetadata\", \"There is no metadata.\"},\n+        {\"R_resultsetClosed\", \"The result set is closed.\"},\n+        {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n+        {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n+        {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n+        {\"R_savepointNotNamed\", \"The savepoint is not named.\"},\n+        {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n+        {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n+        {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n+        {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n+        {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n+        {\"R_noResultset\", \"The statement did not return a result set.\"},\n+        {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n+        {\"R_statementIsClosed\", \"The statement is closed.\"},\n+        {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n+        {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n+        {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n+        {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n+        {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n+        {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n+        {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n+        {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n+        {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n+        {\"R_invalidOffset\", \"The offset {0} is not valid.\"},\n+        {\"R_nullConnection\", \"The connection URL is null.\"},\n+        {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n+        {\"R_cannotTakeArgumentsPreparedOrCallable\", \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n+        // Invalid conversion (e.g. MONEY to Timestamp)\n+        {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n+        // Invalid conversion to an unknown type\n+        {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n+        // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n+        {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n+        {\"R_streamIsClosed\", \"The stream is closed.\"},\n+        {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n+        {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n+        {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n+        {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n+        {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n+        {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n+        {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n+        {\"R_encodingErrorWritingTDS\", \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n+        {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n+        {\"R_requestedOpNotSupportedOnForward\", \"The requested operation is not supported on forward only result sets.\"},\n+        {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n+        {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n+        {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n+        {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n+        {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n+        {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n+        {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n+        {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n+        {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n+        {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n+        {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n+        {\"R_cantGetUpdatedColumnValue\", \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n+        {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n+        {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n+        {\"R_invalidAutoGeneratedKeys\", \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n+        {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n+        {\"R_failoverPartnerWithoutDB\", \"databaseName is required when using the failoverPartner connection property.\"},\n+        {\"R_invalidPartnerConfiguration\", \"The database {0} on server {1} is not configured for database mirroring.\"},\n+        {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n+        {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n+        {\"R_invalidpropertyValue\", \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n+        {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n+        {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n+        {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n+        {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n+        {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n+        {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n+        {\"R_sslRequiredNoServerSupport\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. The application requested encryption but the server is not configured to support SSL.\"},\n+        {\"R_sslRequiredByServer\", \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n+        {\"R_sslFailed\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n+        {\"R_certNameFailed\", \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n+        {\"R_failedToInitializeXA\", \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n+        {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n+        {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n+        {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n+        {\"R_userPropertyDescription\", \"The database user.\"},\n+        {\"R_passwordPropertyDescription\", \"The database password.\"},\n+        {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n+        {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n+        {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n+        {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n+        {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n+        {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n+        {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n+        {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n+        {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n+        {\"R_serverNameAsACEPropertyDescription\", \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n+        {\"R_sendStringParametersAsUnicodePropertyDescription\", \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n+        {\"R_multiSubnetFailoverPropertyDescription\", \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n+        {\"R_applicationNamePropertyDescription\", \"The application name for SQL Server profiling and logging tools.\"},\n+        {\"R_lastUpdateCountPropertyDescription\", \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n+        {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n+        {\"R_integratedSecurityPropertyDescription\", \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n+        {\"R_authenticationSchemePropertyDescription\", \"The authentication scheme to be used for integrated authentication.\"},\n+        {\"R_lockTimeoutPropertyDescription\", \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The number of reconnection attempts if there is a connection failure.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The number of seconds between each connection retry attempt.\"},\n+        {\"R_loginTimeoutPropertyDescription\", \"The number of seconds the driver should wait before timing out a failed connection.\"},\n+        {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n+        {\"R_xopenStatesPropertyDescription\", \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n+        {\"R_selectMethodPropertyDescription\", \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n+        {\"R_responseBufferingPropertyDescription\", \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n+        {\"R_applicationIntentPropertyDescription\", \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n+        {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n+        {\"R_failoverPartnerPropertyDescription\", \"The name of the failover server used in a database mirroring configuration.\"},\n+        {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n+        {\"R_encryptPropertyDescription\", \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n+        {\"R_socketFactoryClassPropertyDescription\", \"The class to instantiate as the SocketFactory for connections\"},\n+        {\"R_socketFactoryConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n+        {\"R_trustServerCertificatePropertyDescription\", \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n+        {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n+        {\"R_trustStorePasswordPropertyDescription\", \"The password used to check the integrity of the trust store data.\"},\n+        {\"R_trustManagerClassPropertyDescription\", \"The class to instantiate as the TrustManager for SSL connections.\"},\n+        {\"R_trustManagerConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n+        {\"R_hostNameInCertificatePropertyDescription\", \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_replicationPropertyDescription\", \"This setting tells the server if the connection is used for replication.\"},\n+        {\"R_sendTimeAsDatetimePropertyDescription\", \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n+        {\"R_TransparentNetworkIPResolutionPropertyDescription\", \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n+        {\"R_queryTimeoutPropertyDescription\", \"The number of seconds to wait before the database reports a query time-out.\"},\n+        {\"R_socketTimeoutPropertyDescription\", \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n+        {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\", \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n+        {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\", \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n+        {\"R_statementPoolingCacheSizePropertyDescription\", \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n+        {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n+        {\"R_msiClientIdPropertyDescription\", \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n+        {\"R_clientCertificatePropertyDescription\", \"Client certificate path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPasswordPropertyDescription\", \"Password for private key if the private key is password protected.\"},\n+        {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\", \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n+        {\"R_delayLoadingLobsPropertyDescription\", \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n+        {\"R_AADSecurePrincipalIdPropertyDescription\", \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n+        {\"R_AADSecurePrincipalSecretPropertyDescription\", \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n+        {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n+        {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n+        {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n+        {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n+        {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n+        {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n+        {\"R_cantSetNull\", \"Cannot set a null value.\"},\n+        {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n+        {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n+        {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n+        {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n+        {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n+        {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n+        {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n+        {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n+        {\"R_getSchemaError\", \"Error getting default schema name.\"},\n+        {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n+        {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n+        {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n+        {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n+        {\"R_featureNotSupported\", \"{0} is not supported.\"},\n+        {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n+        {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n+        {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n+        {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n+        {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n+        {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n+        {\"R_invalidDestConnection\", \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n+        {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n+        {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n+        {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n+        {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n+        {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n+        {\"R_invalidTransactionOption\", \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n+        {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n+        {\"R_BulkColumnMappingsIsEmpty\", \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n+        {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n+        {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n+        {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n+        {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n+        {\"R_UnexpectedDescribeParamFormat\", \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n+        {\"R_InvalidEncryptionKeyOrdinal\", \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n+        {\"R_MissingParamEncryptionMetadata\", \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n+        {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n+        {\"R_InvalidCipherTextSize\", \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n+        {\"R_InvalidAlgorithmVersion\", \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n+        {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n+        {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n+        {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n+        {\"R_InvalidKeySize\", \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". Verify the encrypted value of the column encryption key in the database.\"},\n+        {\"R_InvalidEncryptionType\", \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n+        {\"R_UnknownColumnEncryptionAlgorithm\", \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n+        {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n+        {\"R_UntrustedKeyPath\", \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n+        {\"R_UnrecognizedKeyStoreProviderName\", \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: {2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers used in your application are registered properly.\"},\n+        {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n+        {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n+        {\"R_UnsupportedNormalizationVersionAE\", \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n+        {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n+        {\"R_NullColumnEncryptionAlgorithmAE\", \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n+        {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n+        {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n+        {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n+        {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n+        {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n+                                                                                                       // Server\n+        {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n+        {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n+        {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n+        {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n+        {\"R_InvalidCertificateSignature\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n+        {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n+        {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithm\", \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithmInternal\", \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n+        {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n+        {\"R_CertificateNotFoundForAlias\", \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n+        {\"R_KeyStoreNotFound\", \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n+        {\"R_CustomKeyStoreProviderMapNull\", \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n+        {\"R_EmptyCustomKeyStoreProviderName\", \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n+        {\"R_InvalidCustomKeyStoreProviderName\", \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n+        {\"R_CustomKeyStoreProviderValueNull\", \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n+        {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n+        {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n+        {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n+        {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n+        {\"R_InvalidDataForAE\", \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n+        {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n+        {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n+        {\"R_FedAuthRequiredPreLoginResponseInvalidValue\", \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n+        {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\", \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n+        {\"R_FedAuthInfoInvalidOffset\", \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n+        {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n+        {\"R_FedAuthInfoLengthTooShortForData\", \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n+        {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\", \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n+        {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+        {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n+        {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n+        {\"R_FedAuthFeatureAckContainsExtraData\", \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n+        {\"R_FedAuthFeatureAckUnknownLibraryType\", \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n+        {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n+        {\"R_SetAuthenticationWhenIntegratedSecurityTrue\", \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+        {\"R_NtlmNoUserPasswordDomain\", \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n+        {\"R_SetAccesstokenWhenIntegratedSecurityTrue\", \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n+        {\"R_IntegratedAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_MSIAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_AccessTokenWithUserPassword\", \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n+        {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n+        {\"R_SetBothAuthenticationAndAccessToken\", \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n+        {\"R_NoUserPasswordForActivePassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+        {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+        {\"R_NoUserPasswordForSqlPassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalse\", \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\", \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalseRS\", \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\", \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_NullValue\", \"{0} cannot be null.\"},\n+        {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n+        {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n+        {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n+        {\"R_ManagedIdentityInitFail\", \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n+        {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n+        {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n+        {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n+        {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n+        {\"R_InvalidEcryptionAlgorithmVersion\", \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n+        {\"R_AKVKeyLengthError\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_AKVSignatureLengthError\", \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n+        {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n+        {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n+        {\"R_CEKSignatureNotMatchCMK\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n+        {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n+        {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n+        {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n+        {\"R_UnableLoadADALSqlDll\", \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n+        {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n+        {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n+        {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n+        {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n+        {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n+        {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n+        {\"R_TVPMixedSource\", \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n+        {\"R_TVPEmptyMetadata\", \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n+        {\"R_TVPInvalidValue\", \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n+        {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n+        {\"R_TVPSortOrdinalGreaterThanFieldCount\", \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n+        {\"R_TVPMissingSortOrderOrOrdinal\", \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n+        {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n+        {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n+        {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n+        // This is used for connection settings. {0}-> property name as is, {1}-> value\n+        {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n+        {\"R_InvalidWindowsCertificateStoreEncryption\", \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n+        {\"R_AEKeypathEmpty\", \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n+        {\"R_AECertpathBad\", \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertLocBad\", \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertStoreBad\", \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n+        {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n+        {\"R_AECertNotFound\", \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_AEMaloc\", \"Memory allocation failure.\"},\n+        {\"R_AEKeypathLong\", \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n+        {\"R_AEECEKLenBad\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEECEKSigLenBad\", \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEKeyPathEmptyOrReserved\", \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n+        {\"R_AEKeyPathCurUser\", \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n+        {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n+        {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n+        {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n+        {\"R_keyStoreSecretPropertyDescription\", \"The authentication secret or information needed to locate the secret.\"},\n+        {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n+        {\"R_keyStoreAuthenticationNotSet\", \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n+        {\"R_keyStoreSecretOrLocationNotSet\", \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n+        {\"R_keyStoreSecretNotSet\", \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderClientKeyNotSet\", \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\", \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n+        {\"R_certificateStoreInvalidKeyword\", \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStoreLocationNotSet\", \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStorePlatformInvalid\", \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n+        {\"R_invalidKeyStoreFile\", \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n+                                                                                                                                // JKS/PKCS\n+        {\"R_invalidCEKCacheTtl\", \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n+        {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n+        {\"R_TVPnotWorkWithSetObjectResultSet\", \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n+        {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n+        {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n+        {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n+        {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n+        {\"R_serverPreparedStatementDiscardThreshold\", \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n+        {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n+        {\"R_kerberosLoginFailedForUsername\", \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n+        {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n+        {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n+        {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n+        {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n+        {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n+        {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n+        {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n+        {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n+        {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n+        {\"R_sslProtocolPropertyDescription\", \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n+        {\"R_invalidSSLProtocol\", \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n+        {\"R_cancelQueryTimeoutPropertyDescription\", \"The number of seconds to wait to cancel sending a query timeout.\"},\n+        {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n+        {\"R_useBulkCopyForBatchInsertPropertyDescription\", \"Whether the driver will use bulk copy API for batch insert operations\"},\n+        {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n+        {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n+        {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+        {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n+        {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n+        {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n+        {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n+        {\"R_keyVaultProviderClientIdPropertyDescription\", \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyVaultProviderClientKeyPropertyDescription\", \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+        {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+        {\"R_DLLandMSALMissing\", \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+        {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+        {\"R_MSITokenFailureImdsClientId\", \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+        {\"R_MSITokenFailureUnexpected\", \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+        {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+        {\"R_propertyNotSupported\", \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+        {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+        {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+        {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+        {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+        {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+        {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+        {\"R_useFmtOnlyPropertyDescription\", \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+        {\"R_invalidOpenqueryCall\", \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+        {\"R_invalidCTEFormat\", \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+        {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+        {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+        {\"R_invalidInsertValuesQuery\", \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+        {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+        {\"R_enclaveNotSupported\", \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclavePropertiesError\", \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclaveResponseLengthError\", \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePackageLengthError\", \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePKLengthError\", \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+        {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+        {\"R_HealthCertError\", \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidHealthCert\", \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidSignedStatement\", \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidDHKeySignature\", \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+        {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+        {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+        {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+        {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+        {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+        {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+        {\"R_InvalidCSVQuotes\", \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+        {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+        {\"R_maxResultBufferPropertyDescription\", \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+        {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+        {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+        {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+    };\n }\n+// @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 278197bc..3e3ba8e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,6 +489,14 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 3e3ba8e9..054cab87 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,14 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 054cab87..76210ff7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +489,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 76210ff7..02224d0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,15 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b32966371c5da329e3f8414b66b28fb3635ab646", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 02224d0a..5929f5c3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +491,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 5929f5c3..4f80d4f4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,4 +502,4 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n-// @formatter:on\n\\ No newline at end of file\n+// @formatter:on\n", "next_change": {"commit": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4f80d4f4..ffe08fbe 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -500,6 +500,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex ffe08fbe..2240bd47 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -501,6 +501,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 2240bd47..f1186553 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n+        {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex f1186553..da1b8d3d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n", "next_change": {"commit": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex da1b8d3d..bb98b34d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -507,6 +507,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex bb98b34d..c178c31e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -506,7 +506,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n-        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n", "next_change": {"commit": "0c703a74888da1897d2feb261d0ca91693caa422", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex c178c31e..85d91df1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -508,6 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n+        {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 85d91df1..be53aadd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,6 +519,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex be53aadd..fcab79f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -520,6 +515,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex fcab79f5..b264d3db 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -514,7 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n-        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b264d3db..96bd1847 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,7 +516,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n-        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "8412f0fd7c104853cefe5c744911737f31e9d57b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 96bd1847..d4634ae8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -517,6 +532,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_AmbiguousRowUpdate\", \"Failed to execute updateRow(). The update is attempting an ambiguous update on tables \\\"{0}\\\" and \\\"{1}\\\". Ensure all columns being updated prior to the updateRow() call belong to the same table.\"},\n         {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..613a1fb2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -382,10 +413,14 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n             {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n                     \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+            {\"R_NtlmNoUserPasswordDomain\",\n+                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n             {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n                     \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n             {\"R_IntegratedAuthenticationWithUserPassword\",\n                     \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+            {\"R_MSIAuthenticationWithUserPassword\",\n+                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n             {\"R_AccessTokenWithUserPassword\",\n                     \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n             {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n", "next_change": {"commit": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 613a1fb2..e772d9d0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -428,6 +430,7 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n             {\"R_NoUserPasswordForActivePassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+            {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n             {\"R_NoUserPasswordForSqlPassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n             {\"R_ForceEncryptionTrue_HonorAEFalse\",\n", "next_change": {"commit": "bd776c2b48691897cee900cc6e821d171f18513a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex e772d9d0..33e27f31 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -430,7 +433,8 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n             {\"R_NoUserPasswordForActivePassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+            {\"R_NoUserPasswordForActiveServicePrincipal\",\n+                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n             {\"R_NoUserPasswordForSqlPassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n             {\"R_ForceEncryptionTrue_HonorAEFalse\",\n", "next_change": {"commit": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 33e27f31..278197bc 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -21,645 +21,474 @@ public final class SQLServerResource extends ListResourceBundle {\n         return CONTENTS;\n     }\n \n-    // The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n-    // camelCasing convention and be descriptive\n-    static final Object[][] CONTENTS = {\n-            // LOCALIZE THIS\n-            {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n-            {\"R_invalidRoutingInfo\",\n-                    \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_multipleRedirections\",\n-                    \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n-            {\"R_dbMirroringWithMultiSubnetFailover\",\n-                    \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n-            {\"R_dbMirroringWithReadOnlyIntent\",\n-                    \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n-            {\"R_ipAddressLimitWithMultiSubnetFailover\",\n-                    \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n-            {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n-            {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n-            {\"R_invalidLength\", \"The length {0} is not valid.\"},\n-            {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n-            {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n-            {\"R_notSQLServer\",\n-                    \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting \"\n-                            + \"TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n-            {\"R_tcpOpenFailed\",\n-                    \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP \"\n-                            + \"connections to the port are not blocked by a firewall.\"},\n-            {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n-            {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n-            {\"R_truncatedServerResponse\",\n-                    \"SQL Server returned an incomplete response. The connection has been closed.\"},\n-            {\"R_queryTimedOut\", \"The query has timed out.\"}, {\"R_queryCancelled\", \"The query was canceled.\"},\n-            {\"R_errorReadingStream\",\n-                    \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n-            {\"R_streamReadReturnedInvalidValue\",\n-                    \"The stream read operation returned an invalid value for the amount of data read.\"},\n-            {\"R_mismatchedStreamLength\",\n-                    \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n-            {\"R_notSupported\", \"This operation is not supported.\"},\n-            {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n-            {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n-            {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n-            {\"R_connectionIsClosed\", \"The connection is closed.\"},\n-            {\"R_invalidBooleanValue\",\n-                    \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n-            {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n-            {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n-            {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n-            {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n-            {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n-            {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n-            {\"R_packetSizeTooBigForSSL\",\n-                    \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n-            {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n-            {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n-            {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_sqlServerHoldability\",\n-                    \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n-            {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n-            {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n-            {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n-            {\"R_sqlBrowserFailed\",\n-                    \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. \"\n-                            + \" For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n-            {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n-            {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n-            {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n-            {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n-            {\"R_noMetadata\", \"There is no metadata.\"}, {\"R_resultsetClosed\", \"The result set is closed.\"},\n-            {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n-            {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n-            {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n-            {\"R_savepointNotNamed\", \"The savepoint is not named.\"}, {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n-            {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n-            {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n-            {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n-            {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n-            {\"R_noResultset\", \"The statement did not return a result set.\"},\n-            {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n-            {\"R_statementIsClosed\", \"The statement is closed.\"},\n-            {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n-            {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n-            {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n-            {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n-            {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n-            {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n-            {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n-            {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n-            {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n-            {\"R_invalidOffset\", \"The offset {0} is not valid.\"}, {\"R_nullConnection\", \"The connection URL is null.\"},\n-            {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n-            {\"R_cannotTakeArgumentsPreparedOrCallable\",\n-                    \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n-            // Invalid conversion (e.g. MONEY to Timestamp)\n-            {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n-            // Invalid conversion to an unknown type\n-            {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n-            // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n-            {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n-            {\"R_streamIsClosed\", \"The stream is closed.\"}, {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n-            {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n-            {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n-            {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n-            {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n-            {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n-            {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n-            {\"R_encodingErrorWritingTDS\",\n-                    \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n-            {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n-            {\"R_requestedOpNotSupportedOnForward\",\n-                    \"The requested operation is not supported on forward only result sets.\"},\n-            {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n-            {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n-            {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n-            {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n-            {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n-            {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n-            {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n-            {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n-            {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n-            {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n-            {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n-            {\"R_cantGetUpdatedColumnValue\",\n-                    \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n-            {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n-            {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n-            {\"R_invalidAutoGeneratedKeys\",\n-                    \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n-            {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n-            {\"R_failoverPartnerWithoutDB\",\n-                    \"databaseName is required when using the failoverPartner connection property.\"},\n-            {\"R_invalidPartnerConfiguration\",\n-                    \"The database {0} on server {1} is not configured for database mirroring.\"},\n-            {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n-            {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n-            {\"R_invalidpropertyValue\",\n-                    \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n-            {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n-            {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n-            {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n-            {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n-            {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n-            {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n-            {\"R_sslRequiredNoServerSupport\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. \"\n-                            + \"The application requested encryption but the server is not configured to support SSL.\"},\n-            {\"R_sslRequiredByServer\",\n-                    \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n-            {\"R_sslFailed\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n-            {\"R_certNameFailed\",\n-                    \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n-            {\"R_failedToInitializeXA\",\n-                    \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n-            {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n-            {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n-            {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n-            {\"R_userPropertyDescription\", \"The database user.\"},\n-            {\"R_passwordPropertyDescription\", \"The database password.\"},\n-            {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n-            {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n-            {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n-            {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n-            {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n-            {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n-            {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n-            {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n-            {\"R_serverNameAsACEPropertyDescription\",\n-                    \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n-            {\"R_sendStringParametersAsUnicodePropertyDescription\",\n-                    \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n-            {\"R_multiSubnetFailoverPropertyDescription\",\n-                    \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n-            {\"R_applicationNamePropertyDescription\",\n-                    \"The application name for SQL Server profiling and logging tools.\"},\n-            {\"R_lastUpdateCountPropertyDescription\",\n-                    \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n-            {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n-            {\"R_integratedSecurityPropertyDescription\",\n-                    \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n-            {\"R_authenticationSchemePropertyDescription\",\n-                    \"The authentication scheme to be used for integrated authentication.\"},\n-            {\"R_lockTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n-            {\"R_loginTimeoutPropertyDescription\",\n-                    \"The number of seconds the driver should wait before timing out a failed connection.\"},\n-            {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n-            {\"R_xopenStatesPropertyDescription\",\n-                    \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n-            {\"R_selectMethodPropertyDescription\",\n-                    \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n-            {\"R_responseBufferingPropertyDescription\",\n-                    \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n-            {\"R_applicationIntentPropertyDescription\",\n-                    \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n-            {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n-            {\"R_failoverPartnerPropertyDescription\",\n-                    \"The name of the failover server used in a database mirroring configuration.\"},\n-            {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n-            {\"R_encryptPropertyDescription\",\n-                    \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n-            {\"R_socketFactoryClassPropertyDescription\",\n-                    \"The class to instantiate as the SocketFactory for connections\"},\n-            {\"R_socketFactoryConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n-            {\"R_trustServerCertificatePropertyDescription\",\n-                    \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n-            {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n-            {\"R_trustStorePasswordPropertyDescription\",\n-                    \"The password used to check the integrity of the trust store data.\"},\n-            {\"R_trustManagerClassPropertyDescription\",\n-                    \"The class to instantiate as the TrustManager for SSL connections.\"},\n-            {\"R_trustManagerConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n-            {\"R_hostNameInCertificatePropertyDescription\",\n-                    \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_sendTimeAsDatetimePropertyDescription\",\n-                    \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n-            {\"R_TransparentNetworkIPResolutionPropertyDescription\",\n-                    \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n-            {\"R_queryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait before the database reports a query time-out.\"},\n-            {\"R_socketTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n-            {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\",\n-                    \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). \"\n-                            + \"A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n-            {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\",\n-                    \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n-            {\"R_statementPoolingCacheSizePropertyDescription\",\n-                    \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n-            {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n-            {\"R_msiClientIdPropertyDescription\",\n-                    \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n-            {\"R_clientCertificatePropertyDescription\",\n-                    \"Client certificate path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPasswordPropertyDescription\",\n-                    \"Password for private key if the private key is password protected.\"},\n-            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n-                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n-            {\"R_delayLoadingLobsPropertyDescription\",\n-                    \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n-            {\"R_AADSecurePrincipalIdPropertyDescription\",\n-                    \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n-            {\"R_AADSecurePrincipalSecretPropertyDescription\",\n-                    \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n-            {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n-            {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n-            {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n-            {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n-            {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n-            {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n-            {\"R_cantSetNull\", \"Cannot set a null value.\"},\n-            {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n-            {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n-            {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n-            {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n-            {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n-            {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n-            {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n-            {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n-            {\"R_getSchemaError\", \"Error getting default schema name.\"},\n-            {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n-            {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n-            {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n-            {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n-            {\"R_featureNotSupported\", \"{0} is not supported.\"},\n-            {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n-            {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n-            {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n-            {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n-            {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n-            {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n-            {\"R_invalidDestConnection\",\n-                    \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n-            {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n-            {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n-            {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n-            {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n-            {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n-            {\"R_invalidTransactionOption\",\n-                    \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n-            {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n-            {\"R_BulkColumnMappingsIsEmpty\",\n-                    \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n-            {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n-            {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n-            {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n-            {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n-            {\"R_UnexpectedDescribeParamFormat\",\n-                    \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n-            {\"R_InvalidEncryptionKeyOrdinal\",\n-                    \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n-            {\"R_MissingParamEncryptionMetadata\",\n-                    \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n-            {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n-            {\"R_InvalidCipherTextSize\",\n-                    \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n-            {\"R_InvalidAlgorithmVersion\",\n-                    \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n-            {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n-            {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n-            {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n-            {\"R_InvalidKeySize\",\n-                    \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". \"\n-                            + \"Verify the encrypted value of the column encryption key in the database.\"},\n-            {\"R_InvalidEncryptionType\",\n-                    \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n-            {\"R_UnknownColumnEncryptionAlgorithm\",\n-                    \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n-            {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n-            {\"R_UntrustedKeyPath\",\n-                    \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path \"\n-                            + \"using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n-            {\"R_UnrecognizedKeyStoreProviderName\",\n-                    \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider \"\n-                            + \"or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: \"\n-                            + \"{2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers \"\n-                            + \"used in your application are registered properly.\"},\n-            {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n-            {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n-            {\"R_UnsupportedNormalizationVersionAE\",\n-                    \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n-            {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n-            {\"R_NullColumnEncryptionAlgorithmAE\",\n-                    \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n-            {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n-            {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n-            {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n-            {\"R_AE_NotSupportedByServer\", \"SQL Server instance in use does not support column encryption.\"},\n-            {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n-                                                                                                           // Server\n-            {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n-            {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n-            {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n-            {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n-            {\"R_InvalidCertificateSignature\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n-            {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n-            {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithm\",\n-                    \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithmInternal\",\n-                    \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n-            {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n-            {\"R_CertificateNotFoundForAlias\",\n-                    \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. \"\n-                    + \" Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n-            {\"R_KeyStoreNotFound\",\n-                    \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n-            {\"R_CustomKeyStoreProviderMapNull\",\n-                    \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n-            {\"R_EmptyCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n-            {\"R_InvalidCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n-            {\"R_CustomKeyStoreProviderValueNull\",\n-                    \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n-            {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n-            {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n-            {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n-            {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n-            {\"R_InvalidDataForAE\",\n-                    \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n-            {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n-            {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n-            {\"R_FedAuthRequiredPreLoginResponseInvalidValue\",\n-                    \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n-            {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\",\n-                    \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n-            {\"R_FedAuthInfoInvalidOffset\",\n-                    \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n-            {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n-            {\"R_FedAuthInfoLengthTooShortForData\",\n-                    \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n-            {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n-                    \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n-            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n-            {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n-            {\"R_FedAuthFeatureAckContainsExtraData\",\n-                    \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n-            {\"R_FedAuthFeatureAckUnknownLibraryType\",\n-                    \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n-            {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n-            {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n-                    \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n-            {\"R_NtlmNoUserPasswordDomain\",\n-                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n-            {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n-                    \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n-            {\"R_IntegratedAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_MSIAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_AccessTokenWithUserPassword\",\n-                    \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n-            {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n-            {\"R_SetBothAuthenticationAndAccessToken\",\n-                    \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n-            {\"R_NoUserPasswordForActivePassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\",\n-                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n-            {\"R_NoUserPasswordForSqlPassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalse\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\",\n-                    \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalseRS\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\",\n-                    \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_NullValue\", \"{0} cannot be null.\"}, {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n-            {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n-            {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n-            {\"R_ManagedIdentityInitFail\",\n-                    \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n-            {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n-            {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n-            {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n-            {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n-            {\"R_InvalidEcryptionAlgorithmVersion\",\n-                    \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n-            {\"R_AKVKeyLengthError\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_AKVSignatureLengthError\",\n-                    \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n-            {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n-            {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n-            {\"R_CEKSignatureNotMatchCMK\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n-            {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n-            {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n-            {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n-            {\"R_UnableLoadADALSqlDll\",\n-                    \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n-            {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n-            {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n-            {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n-            {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n-            {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n-            {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n-            {\"R_TVPMixedSource\",\n-                    \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n-            {\"R_TVPEmptyMetadata\",\n-                    \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n-            {\"R_TVPInvalidValue\",\n-                    \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n-            {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n-            {\"R_TVPSortOrdinalGreaterThanFieldCount\",\n-                    \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n-            {\"R_TVPMissingSortOrderOrOrdinal\",\n-                    \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n-            {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n-            {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n-            {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n-            // This is used for connection settings. {0}-> property name as is, {1}-> value\n-            {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n-            {\"R_InvalidWindowsCertificateStoreEncryption\",\n-                    \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n-            {\"R_AEKeypathEmpty\",\n-                    \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n-            {\"R_AECertpathBad\",\n-                    \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertLocBad\",\n-                    \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertStoreBad\",\n-                    \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n-            {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n-            {\"R_AECertNotFound\",\n-                    \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition \"\n-                            + \"in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_AEMaloc\", \"Memory allocation failure.\"},\n-            {\"R_AEKeypathLong\",\n-                    \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n-            {\"R_AEECEKLenBad\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEECEKSigLenBad\",\n-                    \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEKeyPathEmptyOrReserved\",\n-                    \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n-            {\"R_AEKeyPathCurUser\",\n-                    \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n-            {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n-            {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n-            {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n-            {\"R_keyStoreSecretPropertyDescription\",\n-                    \"The authentication secret or information needed to locate the secret.\"},\n-            {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n-            {\"R_keyStoreAuthenticationNotSet\",\n-                    \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n-            {\"R_keyStoreSecretOrLocationNotSet\",\n-                    \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n-            {\"R_keyStoreSecretNotSet\",\n-                    \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreInvalidKeyword\",\n-                    \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreLocationNotSet\",\n-                    \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStorePlatformInvalid\",\n-                    \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n-            {\"R_invalidKeyStoreFile\",\n-                    \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n-                                                                                                                  // JKS/PKCS\n-            {\"R_invalidCEKCacheTtl\",\n-                    \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n-            {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n-            {\"R_TVPnotWorkWithSetObjectResultSet\",\n-                    \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n-            {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n-            {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n-            {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n-            {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n-            {\"R_serverPreparedStatementDiscardThreshold\",\n-                    \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n-            {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n-            {\"R_kerberosLoginFailedForUsername\",\n-                    \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n-            {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n-            {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n-            {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n-            {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n-            {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n-            {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n-            {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n-            {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n-            {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n-            {\"R_sslProtocolPropertyDescription\",\n-                    \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n-            {\"R_invalidSSLProtocol\",\n-                    \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n-            {\"R_cancelQueryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait to cancel sending a query timeout.\"},\n-            {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n-            {\"R_useBulkCopyForBatchInsertPropertyDescription\",\n-                    \"Whether the driver will use bulk copy API for batch insert operations\"},\n-            {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n-            {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n-            {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n-            {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n-            {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n-            {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n-            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n-            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n-            {\"R_maxResultBufferPropertyDescription\",\n-                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n-            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n-            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+    /*\n+     * The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n+     * camelCasing convention and be descriptive.\n+     */\n+    // @formatter:off\n+    // Disable formatting for localization parser: use 1 line per error message and do not use \"+\"\n+    // @formatter:off\n+    static final Object[][] CONTENTS =\n+    {\n+        // LOCALIZE THIS\n+        {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n+        {\"R_invalidRoutingInfo\", \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_multipleRedirections\", \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n+        {\"R_dbMirroringWithMultiSubnetFailover\", \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n+        {\"R_dbMirroringWithReadOnlyIntent\", \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n+        {\"R_ipAddressLimitWithMultiSubnetFailover\", \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n+        {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n+        {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n+        {\"R_invalidLength\", \"The length {0} is not valid.\"},\n+        {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n+        {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n+        {\"R_notSQLServer\", \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n+        {\"R_tcpOpenFailed\", \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP connections to the port are not blocked by a firewall.\"},\n+        {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n+        {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n+        {\"R_truncatedServerResponse\", \"SQL Server returned an incomplete response. The connection has been closed.\"},\n+        {\"R_queryTimedOut\", \"The query has timed out.\"},\n+        {\"R_queryCancelled\", \"The query was canceled.\"},\n+        {\"R_errorReadingStream\", \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n+        {\"R_streamReadReturnedInvalidValue\", \"The stream read operation returned an invalid value for the amount of data read.\"},\n+        {\"R_mismatchedStreamLength\", \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n+        {\"R_notSupported\", \"This operation is not supported.\"},\n+        {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n+        {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n+        {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n+        {\"R_connectionIsClosed\", \"The connection is closed.\"},\n+        {\"R_invalidBooleanValue\", \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n+        {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n+        {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n+        {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n+        {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n+        {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n+        {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n+        {\"R_packetSizeTooBigForSSL\", \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n+        {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n+        {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n+        {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_sqlServerHoldability\", \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n+        {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n+        {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n+        {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n+        {\"R_sqlBrowserFailed\", \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n+        {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n+        {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n+        {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n+        {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n+        {\"R_noMetadata\", \"There is no metadata.\"},\n+        {\"R_resultsetClosed\", \"The result set is closed.\"},\n+        {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n+        {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n+        {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n+        {\"R_savepointNotNamed\", \"The savepoint is not named.\"},\n+        {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n+        {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n+        {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n+        {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n+        {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n+        {\"R_noResultset\", \"The statement did not return a result set.\"},\n+        {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n+        {\"R_statementIsClosed\", \"The statement is closed.\"},\n+        {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n+        {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n+        {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n+        {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n+        {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n+        {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n+        {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n+        {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n+        {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n+        {\"R_invalidOffset\", \"The offset {0} is not valid.\"},\n+        {\"R_nullConnection\", \"The connection URL is null.\"},\n+        {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n+        {\"R_cannotTakeArgumentsPreparedOrCallable\", \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n+        // Invalid conversion (e.g. MONEY to Timestamp)\n+        {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n+        // Invalid conversion to an unknown type\n+        {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n+        // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n+        {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n+        {\"R_streamIsClosed\", \"The stream is closed.\"},\n+        {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n+        {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n+        {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n+        {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n+        {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n+        {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n+        {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n+        {\"R_encodingErrorWritingTDS\", \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n+        {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n+        {\"R_requestedOpNotSupportedOnForward\", \"The requested operation is not supported on forward only result sets.\"},\n+        {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n+        {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n+        {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n+        {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n+        {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n+        {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n+        {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n+        {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n+        {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n+        {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n+        {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n+        {\"R_cantGetUpdatedColumnValue\", \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n+        {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n+        {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n+        {\"R_invalidAutoGeneratedKeys\", \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n+        {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n+        {\"R_failoverPartnerWithoutDB\", \"databaseName is required when using the failoverPartner connection property.\"},\n+        {\"R_invalidPartnerConfiguration\", \"The database {0} on server {1} is not configured for database mirroring.\"},\n+        {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n+        {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n+        {\"R_invalidpropertyValue\", \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n+        {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n+        {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n+        {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n+        {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n+        {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n+        {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n+        {\"R_sslRequiredNoServerSupport\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. The application requested encryption but the server is not configured to support SSL.\"},\n+        {\"R_sslRequiredByServer\", \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n+        {\"R_sslFailed\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n+        {\"R_certNameFailed\", \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n+        {\"R_failedToInitializeXA\", \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n+        {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n+        {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n+        {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n+        {\"R_userPropertyDescription\", \"The database user.\"},\n+        {\"R_passwordPropertyDescription\", \"The database password.\"},\n+        {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n+        {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n+        {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n+        {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n+        {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n+        {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n+        {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n+        {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n+        {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n+        {\"R_serverNameAsACEPropertyDescription\", \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n+        {\"R_sendStringParametersAsUnicodePropertyDescription\", \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n+        {\"R_multiSubnetFailoverPropertyDescription\", \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n+        {\"R_applicationNamePropertyDescription\", \"The application name for SQL Server profiling and logging tools.\"},\n+        {\"R_lastUpdateCountPropertyDescription\", \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n+        {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n+        {\"R_integratedSecurityPropertyDescription\", \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n+        {\"R_authenticationSchemePropertyDescription\", \"The authentication scheme to be used for integrated authentication.\"},\n+        {\"R_lockTimeoutPropertyDescription\", \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The number of reconnection attempts if there is a connection failure.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The number of seconds between each connection retry attempt.\"},\n+        {\"R_loginTimeoutPropertyDescription\", \"The number of seconds the driver should wait before timing out a failed connection.\"},\n+        {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n+        {\"R_xopenStatesPropertyDescription\", \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n+        {\"R_selectMethodPropertyDescription\", \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n+        {\"R_responseBufferingPropertyDescription\", \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n+        {\"R_applicationIntentPropertyDescription\", \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n+        {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n+        {\"R_failoverPartnerPropertyDescription\", \"The name of the failover server used in a database mirroring configuration.\"},\n+        {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n+        {\"R_encryptPropertyDescription\", \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n+        {\"R_socketFactoryClassPropertyDescription\", \"The class to instantiate as the SocketFactory for connections\"},\n+        {\"R_socketFactoryConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n+        {\"R_trustServerCertificatePropertyDescription\", \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n+        {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n+        {\"R_trustStorePasswordPropertyDescription\", \"The password used to check the integrity of the trust store data.\"},\n+        {\"R_trustManagerClassPropertyDescription\", \"The class to instantiate as the TrustManager for SSL connections.\"},\n+        {\"R_trustManagerConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n+        {\"R_hostNameInCertificatePropertyDescription\", \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_replicationPropertyDescription\", \"This setting tells the server if the connection is used for replication.\"},\n+        {\"R_sendTimeAsDatetimePropertyDescription\", \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n+        {\"R_TransparentNetworkIPResolutionPropertyDescription\", \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n+        {\"R_queryTimeoutPropertyDescription\", \"The number of seconds to wait before the database reports a query time-out.\"},\n+        {\"R_socketTimeoutPropertyDescription\", \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n+        {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\", \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n+        {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\", \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n+        {\"R_statementPoolingCacheSizePropertyDescription\", \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n+        {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n+        {\"R_msiClientIdPropertyDescription\", \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n+        {\"R_clientCertificatePropertyDescription\", \"Client certificate path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPasswordPropertyDescription\", \"Password for private key if the private key is password protected.\"},\n+        {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\", \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n+        {\"R_delayLoadingLobsPropertyDescription\", \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n+        {\"R_AADSecurePrincipalIdPropertyDescription\", \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n+        {\"R_AADSecurePrincipalSecretPropertyDescription\", \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n+        {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n+        {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n+        {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n+        {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n+        {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n+        {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n+        {\"R_cantSetNull\", \"Cannot set a null value.\"},\n+        {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n+        {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n+        {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n+        {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n+        {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n+        {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n+        {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n+        {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n+        {\"R_getSchemaError\", \"Error getting default schema name.\"},\n+        {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n+        {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n+        {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n+        {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n+        {\"R_featureNotSupported\", \"{0} is not supported.\"},\n+        {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n+        {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n+        {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n+        {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n+        {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n+        {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n+        {\"R_invalidDestConnection\", \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n+        {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n+        {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n+        {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n+        {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n+        {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n+        {\"R_invalidTransactionOption\", \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n+        {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n+        {\"R_BulkColumnMappingsIsEmpty\", \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n+        {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n+        {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n+        {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n+        {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n+        {\"R_UnexpectedDescribeParamFormat\", \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n+        {\"R_InvalidEncryptionKeyOrdinal\", \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n+        {\"R_MissingParamEncryptionMetadata\", \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n+        {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n+        {\"R_InvalidCipherTextSize\", \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n+        {\"R_InvalidAlgorithmVersion\", \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n+        {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n+        {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n+        {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n+        {\"R_InvalidKeySize\", \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". Verify the encrypted value of the column encryption key in the database.\"},\n+        {\"R_InvalidEncryptionType\", \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n+        {\"R_UnknownColumnEncryptionAlgorithm\", \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n+        {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n+        {\"R_UntrustedKeyPath\", \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n+        {\"R_UnrecognizedKeyStoreProviderName\", \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: {2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers used in your application are registered properly.\"},\n+        {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n+        {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n+        {\"R_UnsupportedNormalizationVersionAE\", \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n+        {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n+        {\"R_NullColumnEncryptionAlgorithmAE\", \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n+        {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n+        {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n+        {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n+        {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n+        {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n+                                                                                                       // Server\n+        {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n+        {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n+        {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n+        {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n+        {\"R_InvalidCertificateSignature\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n+        {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n+        {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithm\", \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithmInternal\", \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n+        {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n+        {\"R_CertificateNotFoundForAlias\", \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n+        {\"R_KeyStoreNotFound\", \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n+        {\"R_CustomKeyStoreProviderMapNull\", \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n+        {\"R_EmptyCustomKeyStoreProviderName\", \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n+        {\"R_InvalidCustomKeyStoreProviderName\", \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n+        {\"R_CustomKeyStoreProviderValueNull\", \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n+        {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n+        {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n+        {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n+        {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n+        {\"R_InvalidDataForAE\", \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n+        {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n+        {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n+        {\"R_FedAuthRequiredPreLoginResponseInvalidValue\", \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n+        {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\", \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n+        {\"R_FedAuthInfoInvalidOffset\", \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n+        {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n+        {\"R_FedAuthInfoLengthTooShortForData\", \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n+        {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\", \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n+        {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+        {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n+        {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n+        {\"R_FedAuthFeatureAckContainsExtraData\", \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n+        {\"R_FedAuthFeatureAckUnknownLibraryType\", \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n+        {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n+        {\"R_SetAuthenticationWhenIntegratedSecurityTrue\", \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+        {\"R_NtlmNoUserPasswordDomain\", \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n+        {\"R_SetAccesstokenWhenIntegratedSecurityTrue\", \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n+        {\"R_IntegratedAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_MSIAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_AccessTokenWithUserPassword\", \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n+        {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n+        {\"R_SetBothAuthenticationAndAccessToken\", \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n+        {\"R_NoUserPasswordForActivePassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+        {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+        {\"R_NoUserPasswordForSqlPassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalse\", \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\", \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalseRS\", \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\", \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_NullValue\", \"{0} cannot be null.\"},\n+        {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n+        {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n+        {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n+        {\"R_ManagedIdentityInitFail\", \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n+        {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n+        {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n+        {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n+        {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n+        {\"R_InvalidEcryptionAlgorithmVersion\", \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n+        {\"R_AKVKeyLengthError\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_AKVSignatureLengthError\", \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n+        {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n+        {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n+        {\"R_CEKSignatureNotMatchCMK\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n+        {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n+        {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n+        {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n+        {\"R_UnableLoadADALSqlDll\", \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n+        {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n+        {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n+        {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n+        {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n+        {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n+        {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n+        {\"R_TVPMixedSource\", \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n+        {\"R_TVPEmptyMetadata\", \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n+        {\"R_TVPInvalidValue\", \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n+        {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n+        {\"R_TVPSortOrdinalGreaterThanFieldCount\", \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n+        {\"R_TVPMissingSortOrderOrOrdinal\", \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n+        {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n+        {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n+        {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n+        // This is used for connection settings. {0}-> property name as is, {1}-> value\n+        {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n+        {\"R_InvalidWindowsCertificateStoreEncryption\", \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n+        {\"R_AEKeypathEmpty\", \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n+        {\"R_AECertpathBad\", \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertLocBad\", \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertStoreBad\", \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n+        {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n+        {\"R_AECertNotFound\", \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_AEMaloc\", \"Memory allocation failure.\"},\n+        {\"R_AEKeypathLong\", \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n+        {\"R_AEECEKLenBad\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEECEKSigLenBad\", \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEKeyPathEmptyOrReserved\", \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n+        {\"R_AEKeyPathCurUser\", \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n+        {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n+        {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n+        {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n+        {\"R_keyStoreSecretPropertyDescription\", \"The authentication secret or information needed to locate the secret.\"},\n+        {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n+        {\"R_keyStoreAuthenticationNotSet\", \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n+        {\"R_keyStoreSecretOrLocationNotSet\", \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n+        {\"R_keyStoreSecretNotSet\", \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderClientKeyNotSet\", \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\", \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n+        {\"R_certificateStoreInvalidKeyword\", \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStoreLocationNotSet\", \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStorePlatformInvalid\", \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n+        {\"R_invalidKeyStoreFile\", \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n+                                                                                                                                // JKS/PKCS\n+        {\"R_invalidCEKCacheTtl\", \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n+        {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n+        {\"R_TVPnotWorkWithSetObjectResultSet\", \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n+        {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n+        {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n+        {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n+        {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n+        {\"R_serverPreparedStatementDiscardThreshold\", \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n+        {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n+        {\"R_kerberosLoginFailedForUsername\", \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n+        {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n+        {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n+        {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n+        {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n+        {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n+        {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n+        {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n+        {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n+        {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n+        {\"R_sslProtocolPropertyDescription\", \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n+        {\"R_invalidSSLProtocol\", \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n+        {\"R_cancelQueryTimeoutPropertyDescription\", \"The number of seconds to wait to cancel sending a query timeout.\"},\n+        {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n+        {\"R_useBulkCopyForBatchInsertPropertyDescription\", \"Whether the driver will use bulk copy API for batch insert operations\"},\n+        {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n+        {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n+        {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+        {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n+        {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n+        {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n+        {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n+        {\"R_keyVaultProviderClientIdPropertyDescription\", \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyVaultProviderClientKeyPropertyDescription\", \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+        {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+        {\"R_DLLandMSALMissing\", \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+        {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+        {\"R_MSITokenFailureImdsClientId\", \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+        {\"R_MSITokenFailureUnexpected\", \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+        {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+        {\"R_propertyNotSupported\", \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+        {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+        {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+        {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+        {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+        {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+        {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+        {\"R_useFmtOnlyPropertyDescription\", \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+        {\"R_invalidOpenqueryCall\", \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+        {\"R_invalidCTEFormat\", \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+        {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+        {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+        {\"R_invalidInsertValuesQuery\", \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+        {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+        {\"R_enclaveNotSupported\", \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclavePropertiesError\", \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclaveResponseLengthError\", \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePackageLengthError\", \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePKLengthError\", \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+        {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+        {\"R_HealthCertError\", \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidHealthCert\", \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidSignedStatement\", \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidDHKeySignature\", \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+        {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+        {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+        {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+        {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+        {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+        {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+        {\"R_InvalidCSVQuotes\", \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+        {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+        {\"R_maxResultBufferPropertyDescription\", \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+        {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+        {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+        {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+    };\n }\n+// @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 278197bc..3e3ba8e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,6 +489,14 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 3e3ba8e9..054cab87 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,14 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 054cab87..76210ff7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +489,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 76210ff7..02224d0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,15 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b32966371c5da329e3f8414b66b28fb3635ab646", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 02224d0a..5929f5c3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +491,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 5929f5c3..4f80d4f4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,4 +502,4 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n-// @formatter:on\n\\ No newline at end of file\n+// @formatter:on\n", "next_change": {"commit": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4f80d4f4..ffe08fbe 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -500,6 +500,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex ffe08fbe..2240bd47 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -501,6 +501,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 2240bd47..f1186553 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n+        {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex f1186553..da1b8d3d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n", "next_change": {"commit": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex da1b8d3d..bb98b34d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -507,6 +507,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex bb98b34d..c178c31e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -506,7 +506,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n-        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n", "next_change": {"commit": "0c703a74888da1897d2feb261d0ca91693caa422", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex c178c31e..85d91df1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -508,6 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n+        {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 85d91df1..be53aadd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,6 +519,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex be53aadd..fcab79f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -520,6 +515,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex fcab79f5..b264d3db 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -514,7 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n-        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b264d3db..96bd1847 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,7 +516,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n-        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "8412f0fd7c104853cefe5c744911737f31e9d57b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 96bd1847..d4634ae8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -517,6 +532,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_AmbiguousRowUpdate\", \"Failed to execute updateRow(). The update is attempting an ambiguous update on tables \\\"{0}\\\" and \\\"{1}\\\". Ensure all columns being updated prior to the updateRow() call belong to the same table.\"},\n         {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "79cef888c070a270ef09411ca2e86b7d2cad1365", "committedDate": "2018-10-05 17:48:08 -0700", "message": "Add "}, {"oid": "cc192d36986c1c13fda64f1fa9f2e141e822d26d", "committedDate": "2018-11-08 16:33:58 -0800", "message": "reconnect thread and part of the session recovery writing"}, {"oid": "dfb4cadc777b3cd9e9217a5c08721b455dba4442", "committedDate": "2018-11-08 16:43:24 -0800", "message": "Revert \"reconnect thread and part of the session recovery writing\""}, {"oid": "252cbfc41198e3412558f359cef8b220f5bad546", "committedDate": "2018-11-09 10:58:10 -0800", "message": "adding resource"}, {"oid": "4877145e9dbc6a1178aa688afe5a14876db5a65f", "committedDate": "2018-11-09 11:48:16 -0800", "message": "another resource"}, {"oid": "503076fe213e018506f690177c32011f8ec22b62", "committedDate": "2018-11-09 15:41:30 -0800", "message": "adding resource"}, {"oid": "0170f891a15e70c7bf10af283f35a4a55e42a874", "committedDate": "2018-11-13 18:17:55 -0800", "message": "Fix "}, {"oid": "af76d7af3846801be86f7f94fbc3318b1ed5bc04", "committedDate": "2020-10-14 17:55:14 -0700", "message": "Make adal4j test dependency only (#1447)"}, {"oid": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "committedDate": "2020-11-19 12:24:40 -0800", "message": "Feature "}, {"oid": "d9909748368af7d2944dab4fa382ee513f2b76f4", "committedDate": "2020-11-27 14:25:58 -0800", "message": "Add maxResultBuffer property (#1431)"}, {"oid": "bd776c2b48691897cee900cc6e821d171f18513a", "committedDate": "2020-11-27 17:53:56 -0800", "message": "Added support for ActiveDirectoryInteractive authentication (#1464)"}, {"oid": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "committedDate": "2021-03-19 14:20:41 -0700", "message": "Open Connection Retry (#1535)"}, {"oid": "50b9fdb1f61ad2c53fc73077f6a39873f36158c4", "committedDate": "2021-04-23 17:18:23 -0700", "message": "Adding replication connection option (#1566)"}, {"oid": "b97172c148b90d5ea23cfce239606c722ec7ab9f", "committedDate": "2021-05-25 14:43:02 -0700", "message": "Update error messages for Enclave exceptions with forward link to troubleshooting guide (#1585)"}, {"oid": "fb15da6ed2b8e9c754f23a17d1c7fcd5a4611f2f", "committedDate": "2021-06-04 16:19:00 -0700", "message": "Add optional realm connection string property for Kerberos authentication (#1581)"}, {"oid": "21b8ec1ac90884ca7c83b7a79a08bf78702b52bb", "committedDate": "2021-06-14 13:17:54 -0700", "message": "Fix multiple, successive connections using AKV provider (#1594)"}, {"oid": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "committedDate": "2021-07-07 11:22:07 -0700", "message": "Integration of old code"}, {"oid": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "committedDate": "2021-07-15 18:13:18 -0700", "message": "Updated formatter to enable on/off tags and re-formatted error strings for localization parser (#1618)"}, {"oid": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "committedDate": "2021-08-12 10:20:32 -0700", "message": "Catching up to dev, 9.5, fixing merge conflicts"}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "b08500889f68eff2ba740b29c644980398c68003", "committedDate": "2021-09-02 20:12:20 -0700", "message": "Integrated new disconnected docket detection"}, {"oid": "11990186d8cdcd41d6192702805ece43134eb1ba", "committedDate": "2021-09-22 11:25:29 -0700", "message": "Catching up to dev"}, {"oid": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "committedDate": "2021-10-01 14:42:11 -0700", "message": "Delete yml (moved CI https://sqlclientdrivers.visualstudio.com/public) and minor changes for error msg (#1655)"}, {"oid": "b32966371c5da329e3f8414b66b28fb3635ab646", "committedDate": "2021-10-05 01:48:45 -0700", "message": "Catching up to upstream dev"}, {"oid": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "committedDate": "2021-11-03 11:46:28 -0700", "message": "Many code review fixes"}, {"oid": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "committedDate": "2021-11-23 14:40:40 -0800", "message": "New Exception Message (#1683)"}, {"oid": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "committedDate": "2021-11-30 08:52:27 -0800", "message": "Default encryption to true and fixed tests (#1697)"}, {"oid": "ab6abfab8c54450d6f534004b55a2f105f456982", "committedDate": "2021-12-01 11:21:10 -0800", "message": "Deprecate and Rename Service principal connection properties (#1693)"}, {"oid": "2183493a32286449713323335335232515ea1404", "committedDate": "2021-12-15 11:24:42 -0800", "message": "SQLServerBulkCopy: Added target field name to conversion error message (#1712)"}, {"oid": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "committedDate": "2022-03-04 09:55:44 -0800", "message": "Added new connection string property prepareMethod to toggle use of sp_prepare (#1719)"}, {"oid": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "committedDate": "2022-03-29 10:52:14 -0700", "message": "Add serverCertificate connection property for encrypt=strict (#1773)"}, {"oid": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "committedDate": "2022-03-30 11:42:09 -0700", "message": "Add Configurable IPv6 Support (#1766)"}, {"oid": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "committedDate": "2022-03-31 10:25:33 -0700", "message": "Add encrypt utility to obfuscate password strings (#1780)"}, {"oid": "0042429113f117c9b7118e67c13d430e0ba3bcde", "committedDate": "2022-04-12 12:36:10 -0700", "message": "Add ALPN for TDSS connections (#1795)"}, {"oid": "76941b78626836ed677d9dcce97be432ae8e8b86", "committedDate": "2022-04-29 11:58:49 -0700", "message": "warnings (#1819)"}, {"oid": "0c703a74888da1897d2feb261d0ca91693caa422", "committedDate": "2022-04-29 12:05:09 -0700", "message": "added check for ALPN (#1818)"}, {"oid": "7ffc2f0b5c7b88269c7603f5e3faeb1470fd44ea", "committedDate": "2022-05-26 12:09:57 -0700", "message": "Managed Identity token cache (#1825)"}, {"oid": "a41722291b05eb2ab80ce8753b0879e721f006a2", "committedDate": "2022-06-22 09:41:50 -0700", "message": "Cache Parameter Metadata (#1845)"}, {"oid": "274a46274d7cb35dae7079da119e7308d4e65726", "committedDate": "2022-07-18 13:48:46 -0700", "message": "Added validation for serverName field (#1856)"}, {"oid": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "committedDate": "2022-07-20 15:30:18 -0700", "message": "Added check for DONE_ERROR status token and throw appropriate exception (#1857)"}, {"oid": "87b092e754556c501f75496f241985725b9c56ba", "committedDate": "2022-07-20 17:08:50 -0700", "message": "Cache parameter metadata secure (#1866)"}, {"oid": "bc302702b4e5d4da276ed78c96c8da2045218e65", "committedDate": "2022-08-16 12:39:18 -0700", "message": "Fixed query cancellation bug that intermittently occurs in batch queries (#1897)"}, {"oid": "51dabe33ec44def2d7c14772419bbccee64427f7", "committedDate": "2022-08-22 13:19:17 -0700", "message": "Fixed callable statement index out of bounds error; Fixed parameter not defined error (#1898)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "committedDate": "2022-11-02 11:21:29 -0700", "message": "Check for error in DONE token when fetching result sets (#1943)"}, {"oid": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "committedDate": "2022-11-03 15:21:54 -0700", "message": "Access token callback (#1940)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "b79396d699d9fa76fd704ce084230647facb1018", "committedDate": "2022-11-25 10:20:37 -0800", "message": "More changes to address sonarqube warnings (#1974)"}, {"oid": "45c606fdfb9c103e093c5ae7424f01e2d5d403f2", "committedDate": "2022-12-21 13:50:32 -0800", "message": "Fixes #1590 - [FEATURE REQUEST] Ability to explicitly specify conversion to datetime or datetime2  (#1687)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e4bc368034ae5421c4e0215bf82335eb36b2aeac", "committedDate": "2023-02-16 13:06:32 -0800", "message": "Updated supportsTransactions method (#2075)"}, {"oid": "d0ab1a587377dd64d7c45e07e959b4857f39bb77", "committedDate": "2023-02-21 11:36:13 -0800", "message": "Added access token callback class connection string property (#2073)"}, {"oid": "8412f0fd7c104853cefe5c744911737f31e9d57b", "committedDate": "2023-03-07 14:44:14 -0800", "message": "Passing table name to sp_cursor call (#2087)"}]}, {"oid": "d8f20da4cfd2156c8ca08d54b6eaa8718493e85e", "url": "https://github.com/microsoft/mssql-jdbc/commit/d8f20da4cfd2156c8ca08d54b6eaa8718493e85e", "message": "updated error msgs", "committedDate": "2020-10-13T19:11:35Z", "type": "commit"}, {"oid": "c6d444cae4b34e9b56c6870c0c4bcc731bbae4ba", "url": "https://github.com/microsoft/mssql-jdbc/commit/c6d444cae4b34e9b56c6870c0c4bcc731bbae4ba", "message": "update version", "committedDate": "2020-10-13T19:16:56Z", "type": "commit"}, {"oid": "f7aeb12a67a165f6f09448bc958c0d22f4d617cc", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7aeb12a67a165f6f09448bc958c0d22f4d617cc", "message": "Update README.md\n\nupdated for MSAL", "committedDate": "2020-10-13T21:20:46Z", "type": "commit"}, {"oid": "61ee2d4c1131ec15530a10105f4cbd8c759bc2d9", "url": "https://github.com/microsoft/mssql-jdbc/commit/61ee2d4c1131ec15530a10105f4cbd8c759bc2d9", "message": "Merge pull request #10 from lilgreenbird/msal\n\nFixed error msgs", "committedDate": "2020-10-13T22:26:21Z", "type": "commit"}, {"oid": "53d44087620cbda9bcce55aad1d2cb810c9d50f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/53d44087620cbda9bcce55aad1d2cb810c9d50f7", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-28T00:38:19Z", "type": "commit"}, {"oid": "5bc675535eb3db983b094164a2b898855e6b57a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/5bc675535eb3db983b094164a2b898855e6b57a7", "message": "Merge pull request #1 from lilgreenbird/msal\n\nformatting and merged with latest dev", "committedDate": "2020-08-28T00:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5Mjg5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481492899", "body": "@lilgreenbird \r\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences. ", "bodyText": "@lilgreenbird\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lilgreenbird/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lilgreenbird\">@lilgreenbird</a><br>\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences.</p>", "author": "ulvii", "createdAt": "2020-09-01T23:47:01Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nnew file mode 100644\nindex 00000000..bc1ceea6\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+    }\n+}\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..bc1ceea6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n         } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n         }\n-        return accessToken;\n+        return applicationBuilder.build();\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n-        }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n-        }\n-        return result;\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..7e18bd81 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.create(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex 7e18bd81..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,133 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.text.MessageFormat;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+class KeyVaultCredential extends KeyVaultCredentials {\n \n-        if (null == clientSecret || clientSecret.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == authorization) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Authoriziation\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == clientSecret) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        IClientCredential credential;\n-        credential = ClientCredentialFactory.create(clientSecret);\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+        } else {\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+        }\n+        return accessToken;\n     }\n \n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n+            }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..85736942 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "43060f9fb25d71ab6724d2aa12712745d899c562", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nsimilarity index 84%\nrename from src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nrename to src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 85736942..8862df0b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -134,4 +148,12 @@ class KeyVaultCredential implements TokenCredential {\n                 .map(ar -> new AccessToken(ar.accessToken(),\n                         OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n+\n+    void setResource(String resource) {\n+        this.resource = resource;\n+    }\n+\n+    void setScope(String scope) {\n+        this.scope = scope;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MzM4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481493389", "body": "`.` at the end.", "bodyText": ". at the end.", "bodyHTML": "<p dir=\"auto\"><code>.</code> at the end.</p>", "author": "ulvii", "createdAt": "2020-09-01T23:48:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nnew file mode 100644\nindex 00000000..bc1ceea6\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+    }\n+}\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..bc1ceea6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n         } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n         }\n-        return accessToken;\n+        return applicationBuilder.build();\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n-        }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n-        }\n-        return result;\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..7e18bd81 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.create(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex 7e18bd81..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,133 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.text.MessageFormat;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+class KeyVaultCredential extends KeyVaultCredentials {\n \n-        if (null == clientSecret || clientSecret.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == authorization) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Authoriziation\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == clientSecret) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        IClientCredential credential;\n-        credential = ClientCredentialFactory.create(clientSecret);\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+        } else {\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+        }\n+        return accessToken;\n     }\n \n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n+            }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..85736942 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "43060f9fb25d71ab6724d2aa12712745d899c562", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nsimilarity index 84%\nrename from src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nrename to src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 85736942..8862df0b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -134,4 +148,12 @@ class KeyVaultCredential implements TokenCredential {\n                 .map(ar -> new AccessToken(ar.accessToken(),\n                         OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n+\n+    void setResource(String resource) {\n+        this.resource = resource;\n+    }\n+\n+    void setScope(String scope) {\n+        this.scope = scope;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MjM3OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481492378", "body": "We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.", "bodyText": "We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.", "bodyHTML": "<p dir=\"auto\">We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.</p>", "author": "David-Engel", "createdAt": "2020-09-01T23:45:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -84,76 +90,38 @@ public String getName() {\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         when an error occurs\n+     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -98,7 +98,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @param clientKey\n      *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n+     *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n         if (null == clientId || clientId.isEmpty()) {\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 47b9da5e..6cfe473f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -98,7 +98,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @param clientKey\n      *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         when an error occurs\n+     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n         if (null == clientId || clientId.isEmpty()) {\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -90,38 +84,76 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n-     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n+     *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n      * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..6cfe473f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -84,76 +90,38 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         when an error occurs\n+     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n     }\n \n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n      * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n", "next_change": {"commit": "4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..adcd20a1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -119,6 +120,9 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n      * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n         createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex adcd20a1..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -91,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..adcd20a1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -167,13 +139,47 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex adcd20a1..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -91,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..709db9ac 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -167,13 +142,47 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 709db9ac..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -94,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -137,43 +211,24 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b15e963e..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -211,24 +137,43 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n \n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -137,43 +211,24 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..adcd20a1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -130,6 +134,9 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *\n      * @param clientId\n      *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n         if (null == clientId || clientId.isEmpty()) {\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex adcd20a1..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -91,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..adcd20a1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -167,13 +139,47 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex adcd20a1..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -91,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..709db9ac 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -167,13 +142,47 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 709db9ac..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -94,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -137,43 +211,24 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b15e963e..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -211,24 +137,43 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n \n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -137,43 +211,24 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..6cfe473f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -162,18 +130,34 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *\n      * @param clientId\n      *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) {\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -130,34 +162,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *\n      * @param clientId\n      *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) {\n-        createKeyvaultClients(tokenCredential);\n-    }\n-\n-    private void createKeyvaultClients(TokenCredential credential) {\n-        this.credential = Objects.requireNonNull(credential);\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..adcd20a1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -167,13 +139,47 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex adcd20a1..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -91,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..709db9ac 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -167,13 +142,47 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 709db9ac..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -94,95 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        createKeyvaultClients(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -137,43 +211,24 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b15e963e..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -211,24 +137,43 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n-    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n \n-        this.credential = credential;\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -137,43 +211,24 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -98,7 +98,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @param clientKey\n      *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n+     *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n         if (null == clientId || clientId.isEmpty()) {\n", "next_change": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..3b31812a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -102,12 +104,12 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n         if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(NULL_VALUE));\n             Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n         if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(NULL_VALUE));\n             Object[] msgArgs1 = {\"Client Key\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MzkyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481493924", "body": "```suggestion\r\n/*\r\n * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n */\r\n\r\npackage com.microsoft.sqlserver.jdbc;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package com.microsoft.sqlserver.jdbc;\n          \n          \n            \n            /*\n          \n          \n            \n             * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n          \n          \n            \n             * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            package com.microsoft.sqlserver.jdbc;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"5\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k x x-first\">package</span><span class=\"x\"> </span><span class=\"pl-smi x\">com.microsoft.sqlserver.jdbc</span><span class=\"x x-last\">;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"5\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c x x-first x-last\">/*</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"6\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Microsoft</span> <span class=\"pl-c1\">JDBC</span> <span class=\"pl-smi\">Driver</span> <span class=\"pl-k\">for</span> <span class=\"pl-c1\">SQL</span> <span class=\"pl-smi\">Server</span> Copyright(c) <span class=\"pl-smi\">Microsoft</span> <span class=\"pl-smi\">Corporation</span> <span class=\"pl-smi\">All</span> rights reserved. <span class=\"pl-smi\">This</span> program is made</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"7\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> available under the terms of the <span class=\"pl-c1\">MIT</span> <span class=\"pl-smi\">License</span>. <span class=\"pl-smi\">See</span> the <span class=\"pl-c1\">LICENSE</span> file in the project root <span class=\"pl-k\">for</span> more information.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"8\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"9\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"10\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">package</span> <span class=\"pl-smi\">com.microsoft.sqlserver.jdbc</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "David-Engel", "createdAt": "2020-09-01T23:50:26Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex b36ccba2..c3457473 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -2,6 +2,7 @@\n  * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n  * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n  */\n+\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex c3457473..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,62 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..91d54f94\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex 91d54f94..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,57 +0,0 @@\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex b36ccba2..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex b36ccba2..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex b36ccba2..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5OTgxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481499810", "body": "This is not how exception are handled in the driver, @lilgreenbird please make sure to follow the guidelines. ", "bodyText": "This is not how exception are handled in the driver, @lilgreenbird please make sure to follow the guidelines.", "bodyHTML": "<p dir=\"auto\">This is not how exception are handled in the driver, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lilgreenbird/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lilgreenbird\">@lilgreenbird</a> please make sure to follow the guidelines.</p>", "author": "ulvii", "createdAt": "2020-09-02T00:10:48Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nnew file mode 100644\nindex 00000000..bc1ceea6\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+    }\n+}\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..bc1ceea6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n         } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n         }\n-        return accessToken;\n+        return applicationBuilder.build();\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n-        }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n-        }\n-        return result;\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..7e18bd81 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.create(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex 7e18bd81..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,133 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.text.MessageFormat;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+class KeyVaultCredential extends KeyVaultCredentials {\n \n-        if (null == clientSecret || clientSecret.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == authorization) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Authoriziation\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == clientSecret) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        IClientCredential credential;\n-        credential = ClientCredentialFactory.create(clientSecret);\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+        } else {\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+        }\n+        return accessToken;\n     }\n \n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n+            }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..85736942 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "43060f9fb25d71ab6724d2aa12712745d899c562", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nsimilarity index 84%\nrename from src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nrename to src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 85736942..8862df0b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -134,4 +148,12 @@ class KeyVaultCredential implements TokenCredential {\n                 .map(ar -> new AccessToken(ar.accessToken(),\n                         OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n+\n+    void setResource(String resource) {\n+        this.resource = resource;\n+    }\n+\n+    void setScope(String scope) {\n+        this.scope = scope;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwMzc4Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481503786", "body": "Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.", "bodyText": "Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.", "bodyHTML": "<p dir=\"auto\">Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.</p>", "author": "ulvii", "createdAt": "2020-09-02T00:24:10Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nnew file mode 100644\nindex 00000000..bc1ceea6\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+    }\n+}\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..bc1ceea6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+\n+        if (null == authorization) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    \"A non-null value for authorization must be provided for user authentication.\"));\n+        }\n+\n+        IClientCredential credential;\n+        if (null != clientSecret) {\n+            credential = ClientCredentialFactory.create(clientSecret);\n         } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n         }\n-        return accessToken;\n+        return applicationBuilder.build();\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n-        }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n-        }\n-        return result;\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex bc1ceea6..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,118 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n+class KeyVaultCredential extends KeyVaultCredentials {\n+\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+    }\n \n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n+            }\n         } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n         }\n-        return applicationBuilder.build();\n+        return accessToken;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..7e18bd81 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.create(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex 7e18bd81..ca4f21f6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,133 +5,86 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.text.MessageFormat;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import com.microsoft.aad.adal4j.AuthenticationContext;\n+import com.microsoft.aad.adal4j.AuthenticationResult;\n+import com.microsoft.aad.adal4j.ClientCredential;\n+import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n \n \n /**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n+ * \n+ * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n+ *\n  */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+class KeyVaultCredential extends KeyVaultCredentials {\n \n-        if (null == clientSecret || clientSecret.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n+    String clientId = null;\n+    String clientKey = null;\n+    String accessToken = null;\n \n+    KeyVaultCredential(String clientId) throws SQLServerException {\n         this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n     }\n \n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n+    KeyVaultCredential() {}\n \n-    KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n+    KeyVaultCredential(String clientId, String clientKey) {\n+        this.clientId = clientId;\n+        this.clientKey = clientKey;\n     }\n \n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == authorization) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Authoriziation\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        if (null == clientSecret) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Secret\"};\n-            throw new IllegalArgumentException(form.format(msgArgs1), null);\n-        }\n-\n-        IClientCredential credential;\n-        credential = ClientCredentialFactory.create(clientSecret);\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n+    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n     }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+    public String doAuthenticate(String authorization, String resource, String scope) {\n+        String accessToken = null;\n+        if (null == authenticationCallback) {\n+            if (null == clientKey) {\n+                try {\n+                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n+                    accessToken = (null != token) ? token.accessToken : null;\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n+                        clientKey);\n+                accessToken = token.getAccessToken();\n             }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+        } else {\n+            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+        }\n+        return accessToken;\n     }\n \n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n+    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n+            String clientId, String clientKey) {\n+        AuthenticationContext context = null;\n+        AuthenticationResult result = null;\n+        ExecutorService service = null;\n+        try {\n+            service = Executors.newFixedThreadPool(1);\n+            context = new AuthenticationContext(authorization, false, service);\n+            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n+            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n+            result = future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (null != service) {\n+                service.shutdown();\n+            }\n+        }\n \n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n+        if (null == result) {\n+            throw new RuntimeException(\"authentication result was null\");\n+        }\n+        return result;\n     }\n }\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nindex ca4f21f6..85736942 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n", "chunk": "@@ -5,86 +5,133 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n-        this.clientId = clientId;\n-    }\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential() {}\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n \n-    KeyVaultCredential(String clientId, String clientKey) {\n         this.clientId = clientId;\n-        this.clientKey = clientKey;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n-        } else {\n-            accessToken = authenticationCallback.getAccessToken(authorization, resource, scope);\n+    KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n         }\n-        return accessToken;\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource,\n-            String clientId, String clientKey) {\n-        AuthenticationContext context = null;\n-        AuthenticationResult result = null;\n-        ExecutorService service = null;\n-        try {\n-            service = Executors.newFixedThreadPool(1);\n-            context = new AuthenticationContext(authorization, false, service);\n-            ClientCredential credentials = new ClientCredential(clientId, clientKey);\n-            Future<AuthenticationResult> future = context.acquireToken(resource, credentials, null);\n-            result = future.get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            if (null != service) {\n-                service.shutdown();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authoriziation\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n \n-        if (null == result) {\n-            throw new RuntimeException(\"authentication result was null\");\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n         }\n-        return result;\n+\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+            }\n+        }).map(ar -> new AccessToken(ar.accessToken(),\n+                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n+    }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n+        return Mono\n+                .fromFuture(() -> confidentialClientApplication\n+                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n+                .map(ar -> new AccessToken(ar.accessToken(),\n+                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n }\n", "next_change": {"commit": "43060f9fb25d71ab6724d2aa12712745d899c562", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nsimilarity index 84%\nrename from src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\nrename to src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 85736942..8862df0b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -134,4 +148,12 @@ class KeyVaultCredential implements TokenCredential {\n                 .map(ar -> new AccessToken(ar.accessToken(),\n                         OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n+\n+    void setResource(String resource) {\n+        this.resource = resource;\n+    }\n+\n+    void setScope(String scope) {\n+        this.scope = scope;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODQ3Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481518473", "body": "Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .", "bodyText": "Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .", "bodyHTML": "<p dir=\"auto\">Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .</p>", "author": "ulvii", "createdAt": "2020-09-02T01:03:29Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -134,10 +126,10 @@ public void testBadAkv(String serverName, String url, String protocol) throws Ex\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        } catch (NullPointerException exception) {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 73b11a85..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -116,20 +132,38 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (NullPointerException exception) {\n-            assertNull(exception.getMessage());\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n         }\n     }\n \n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 55cad5f1..73b11a85 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -132,38 +116,20 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n+     * Test bad Azure Key Vault\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n-        setAEConnectionString(serverName, url, protocol);\n-\n-        try {\n-            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n-            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n-        }\n-    }\n-\n-    /*\n-     * Test bad Azure Key Vault using TokenCredential\n-     */\n-    @SuppressWarnings(\"unused\")\n-    @ParameterizedTest\n-    @MethodSource(\"enclaveParams\")\n-    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        } catch (NullPointerException exception) {\n+            assertNull(exception.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 73b11a85..ba4125f0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -126,10 +134,10 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (TokenCredential) null);\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (NullPointerException exception) {\n-            assertNull(exception.getMessage());\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n         }\n     }\n \n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex ba4125f0..73b11a85 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -134,10 +126,10 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        } catch (NullPointerException exception) {\n+            assertNull(exception.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 73b11a85..64a966e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -128,8 +128,8 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (NullPointerException exception) {\n-            assertNull(exception.getMessage());\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n         }\n     }\n \n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 64a966e0..ba4125f0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -126,7 +134,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (TokenCredential) null);\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex ba4125f0..64a966e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -134,7 +126,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 64a966e0..ba4125f0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -126,7 +134,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (TokenCredential) null);\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex ba4125f0..64a966e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -134,7 +126,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 64a966e0..ba4125f0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -126,7 +134,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (TokenCredential) null);\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex ba4125f0..64a966e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -134,7 +126,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 64a966e0..ba4125f0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -126,7 +134,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (TokenCredential) null);\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex ba4125f0..33ca40ef 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -134,7 +136,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n             assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 73b11a85..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -116,20 +132,38 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (NullPointerException exception) {\n-            assertNull(exception.getMessage());\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n         }\n     }\n \n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 55cad5f1..4829af34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -163,7 +164,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")), e.getMessage());\n         }\n     }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "committedDate": "2021-05-20 16:48:25 -0700", "message": "Add exception error messages to test failures (#1584)"}, {"oid": "692fe4eacb5c3f183257c69c4a404dc0524df255", "committedDate": "2021-12-14 12:40:29 -0800", "message": "added xSQLv11 tag for tests not compatible with SQL Server 2012 (#1713)"}, {"oid": "cd78ffe7b94f194540671a16b510e663b2b904ba", "committedDate": "2021-12-29 10:41:41 -0800", "message": "Update versions and remove ADAL dependency (#1726)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODY2Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481518667", "body": "Need to add license header here.", "bodyText": "Need to add license header here.", "bodyHTML": "<p dir=\"auto\">Need to add license header here.</p>", "author": "ulvii", "createdAt": "2020-09-02T01:04:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex b36ccba2..c3457473 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -2,6 +2,7 @@\n  * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n  * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n  */\n+\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex c3457473..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,62 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..91d54f94\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex 91d54f94..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,57 +0,0 @@\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex b36ccba2..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex b36ccba2..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\ndeleted file mode 100644\nindex b36ccba2..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenRequestContext;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n-\n-\n-/**\n- * A token cache that supports caching a token and refreshing it.\n- */\n-class ScopeTokenCache {\n-\n-    private final AtomicBoolean wip;\n-    private AccessToken cache;\n-    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n-    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n-    private TokenRequestContext request;\n-\n-    /**\n-     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n-     *\n-     * @param getNew\n-     *        a method to get a new token\n-     */\n-    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n-        this.wip = new AtomicBoolean(false);\n-        this.getNew = getNew;\n-    }\n-\n-    void setRequest(TokenRequestContext request) {\n-        this.request = request;\n-    }\n-\n-    /**\n-     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n-     * \n-     * @return a Publisher that emits an AccessToken\n-     */\n-    Mono<AccessToken> getToken() {\n-        if (cache != null && !cache.isExpired()) {\n-            return Mono.just(cache);\n-        }\n-        return Mono.defer(() -> {\n-            if (!wip.getAndSet(true)) {\n-                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n-                        .doOnTerminate(() -> wip.set(false));\n-            } else {\n-                return emitterProcessor.next();\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nnew file mode 100644\nindex 00000000..b36ccba2\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenRequestContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+\n+/**\n+ * A token cache that supports caching a token and refreshing it.\n+ */\n+class ScopeTokenCache {\n+\n+    private final AtomicBoolean wip;\n+    private AccessToken cache;\n+    private final ReplayProcessor<AccessToken> emitterProcessor = ReplayProcessor.create(1);\n+    private final FluxSink<AccessToken> sink = emitterProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Function<TokenRequestContext, Mono<AccessToken>> getNew;\n+    private TokenRequestContext request;\n+\n+    /**\n+     * Creates an instance of RefreshableTokenCredential with default scheme \"Bearer\".\n+     *\n+     * @param getNew\n+     *        a method to get a new token\n+     */\n+    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {\n+        this.wip = new AtomicBoolean(false);\n+        this.getNew = getNew;\n+    }\n+\n+    void setRequest(TokenRequestContext request) {\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Asynchronously get a token from either the cache or replenish the cache with a new token.\n+     * \n+     * @return a Publisher that emits an AccessToken\n+     */\n+    Mono<AccessToken> getToken() {\n+        if (cache != null && !cache.isExpired()) {\n+            return Mono.just(cache);\n+        }\n+        return Mono.defer(() -> {\n+            if (!wip.getAndSet(true)) {\n+                return getNew.apply(request).doOnNext(ac -> cache = ac).doOnNext(sink::next).doOnError(sink::error)\n+                        .doOnTerminate(() -> wip.set(false));\n+            } else {\n+                return emitterProcessor.next();\n+            }\n+        });\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNzQ1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481527451", "body": "CamelCase here", "bodyText": "CamelCase here", "bodyHTML": "<p dir=\"auto\">CamelCase here</p>", "author": "ulvii", "createdAt": "2020-09-02T01:28:25Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -198,7 +182,7 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,7 +237,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 47b9da5e..6cfe473f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -237,7 +182,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,7 +198,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..6cfe473f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,7 +182,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,7 +198,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..adcd20a1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,7 +204,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex adcd20a1..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -204,7 +198,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..709db9ac 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,7 +207,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 709db9ac..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -207,7 +198,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,7 +253,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b15e963e..90fbf756 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -253,7 +198,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 90fbf756..b15e963e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,7 +253,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b15e963e..e8ce7273 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -253,7 +252,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,7 +237,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTYxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481531617", "body": "The methods in this class should probably not be public.", "bodyText": "The methods in this class should probably not be public.", "bodyHTML": "<p dir=\"auto\">The methods in this class should probably not be public.</p>", "author": "ulvii", "createdAt": "2020-09-02T01:34:53Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NDQ4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r482254481", "bodyText": "I will change the visibility of these methods to package-private.", "author": "srnagar", "createdAt": "2020-09-02T17:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex ca5c3d44..51ff4eeb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -12,46 +12,41 @@ import com.azure.core.http.policy.HttpLoggingPolicy;\n import com.azure.core.http.policy.HttpPipelinePolicy;\n import com.azure.core.http.policy.HttpPolicyProviders;\n import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-import com.azure.core.util.logging.ClientLogger;\n+\n+import java.text.MessageFormat;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Objects;\n-\n \n+/**\n+ * The HTTP pipeline builder which includes all the necessary HTTP pipeline policies that will be applied for\n+ * sending and receiving HTTP requests to the Key Vault service.\n+ */\n final class KeyVaultHttpPipelineBuilder {\n-    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n \n     private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n+    private KeyVaultTokenCredential credential;\n     private HttpLogOptions httpLogOptions;\n     private final RetryPolicy retryPolicy;\n \n     /**\n-     * The constructor with defaults.\n+     * The constructor with default retry policy and log options.\n      */\n-    public KeyVaultHttpPipelineBuilder() {\n+    KeyVaultHttpPipelineBuilder() {\n         retryPolicy = new RetryPolicy();\n         httpLogOptions = new HttpLogOptions();\n         policies = new ArrayList<>();\n     }\n \n-    public HttpPipeline buildPipeline() {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        if (null == credential) {\n-            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n-        }\n-\n+    /**\n+     * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n+     *\n+     * @return A fully built HTTP pipeline including the default HTTP client.\n+     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n+     */\n+    HttpPipeline buildPipeline() throws SQLServerException {\n         // Closest to API goes first, closest to wire goes last.\n         final List<HttpPipelinePolicy> policies = new ArrayList<>();\n \n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n         HttpPolicyProviders.addBeforeRetryPolicies(policies);\n         policies.add(retryPolicy);\n         policies.add(new KeyVaultCustomCredentialPolicy(credential));\n", "next_change": {"commit": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex 51ff4eeb..ca5c3d44 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -12,41 +12,46 @@ import com.azure.core.http.policy.HttpLoggingPolicy;\n import com.azure.core.http.policy.HttpPipelinePolicy;\n import com.azure.core.http.policy.HttpPolicyProviders;\n import com.azure.core.http.policy.RetryPolicy;\n-\n-import java.text.MessageFormat;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n+\n \n-/**\n- * The HTTP pipeline builder which includes all the necessary HTTP pipeline policies that will be applied for\n- * sending and receiving HTTP requests to the Key Vault service.\n- */\n final class KeyVaultHttpPipelineBuilder {\n+    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n+    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n+    private static final String SDK_VERSION = \"4.2.0\";\n+\n+    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n \n     private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultTokenCredential credential;\n+    private KeyVaultCredential credential;\n     private HttpLogOptions httpLogOptions;\n     private final RetryPolicy retryPolicy;\n \n     /**\n-     * The constructor with default retry policy and log options.\n+     * The constructor with defaults.\n      */\n-    KeyVaultHttpPipelineBuilder() {\n+    public KeyVaultHttpPipelineBuilder() {\n         retryPolicy = new RetryPolicy();\n         httpLogOptions = new HttpLogOptions();\n         policies = new ArrayList<>();\n     }\n \n-    /**\n-     * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n-     *\n-     * @return A fully built HTTP pipeline including the default HTTP client.\n-     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n-     */\n-    HttpPipeline buildPipeline() throws SQLServerException {\n+    public HttpPipeline buildPipeline() {\n+        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n+\n+        if (null == credential) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n+        }\n+\n         // Closest to API goes first, closest to wire goes last.\n         final List<HttpPipelinePolicy> policies = new ArrayList<>();\n \n+        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n         HttpPolicyProviders.addBeforeRetryPolicies(policies);\n         policies.add(retryPolicy);\n         policies.add(new KeyVaultCustomCredentialPolicy(credential));\n", "next_change": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\ndeleted file mode 100644\nindex ca5c3d44..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.HttpPolicyProviders;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-import com.azure.core.util.logging.ClientLogger;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-\n-final class KeyVaultHttpPipelineBuilder {\n-    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n-\n-    private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n-    private HttpLogOptions httpLogOptions;\n-    private final RetryPolicy retryPolicy;\n-\n-    /**\n-     * The constructor with defaults.\n-     */\n-    public KeyVaultHttpPipelineBuilder() {\n-        retryPolicy = new RetryPolicy();\n-        httpLogOptions = new HttpLogOptions();\n-        policies = new ArrayList<>();\n-    }\n-\n-    public HttpPipeline buildPipeline() {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        if (null == credential) {\n-            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n-        }\n-\n-        // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n-\n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n-    }\n-\n-    /**\n-     * Sets the credential to use when authenticating HTTP requests.\n-     *\n-     * @param credential\n-     *        The credential to use for authenticating HTTP requests.\n-     * @return the updated KVHttpPipelineBuilder object.\n-     * @throws NullPointerException\n-     *         if {@code credential} is {@code null}.\n-     */\n-    public KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) {\n-        Objects.requireNonNull(credential);\n-        this.credential = credential;\n-        return this;\n-    }\n-}\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nnew file mode 100644\nindex 00000000..ca5c3d44\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {\n+    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n+    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n+    private static final String SDK_VERSION = \"4.2.0\";\n+\n+    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n+\n+    private final List<HttpPipelinePolicy> policies;\n+    private KeyVaultCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private final RetryPolicy retryPolicy;\n+\n+    /**\n+     * The constructor with defaults.\n+     */\n+    public KeyVaultHttpPipelineBuilder() {\n+        retryPolicy = new RetryPolicy();\n+        httpLogOptions = new HttpLogOptions();\n+        policies = new ArrayList<>();\n+    }\n+\n+    public HttpPipeline buildPipeline() {\n+        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n+\n+        if (null == credential) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n+        }\n+\n+        // Closest to API goes first, closest to wire goes last.\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n+        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+        policies.add(retryPolicy);\n+        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n+        policies.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(policies);\n+        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+\n+        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+    }\n+\n+    /**\n+     * Sets the credential to use when authenticating HTTP requests.\n+     *\n+     * @param credential\n+     *        The credential to use for authenticating HTTP requests.\n+     * @return the updated KVHttpPipelineBuilder object.\n+     * @throws NullPointerException\n+     *         if {@code credential} is {@code null}.\n+     */\n+    public KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        return this;\n+    }\n+}\n", "next_change": {"commit": "59aebe6a2f663c70638530cba96e898ee0b3d03f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex ca5c3d44..b8916734 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -68,11 +65,15 @@ final class KeyVaultHttpPipelineBuilder {\n      * @param credential\n      *        The credential to use for authenticating HTTP requests.\n      * @return the updated KVHttpPipelineBuilder object.\n-     * @throws NullPointerException\n-     *         if {@code credential} is {@code null}.\n+     * @throws SQLServerException\n      */\n-    public KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) {\n-        Objects.requireNonNull(credential);\n+    KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n         this.credential = credential;\n         return this;\n     }\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\ndeleted file mode 100644\nindex b8916734..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ /dev/null\n", "chunk": "@@ -1,80 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.HttpPolicyProviders;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-import com.azure.core.util.logging.ClientLogger;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\n-final class KeyVaultHttpPipelineBuilder {\n-    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n-\n-    private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n-    private HttpLogOptions httpLogOptions;\n-    private final RetryPolicy retryPolicy;\n-\n-    /**\n-     * The constructor with defaults.\n-     */\n-    public KeyVaultHttpPipelineBuilder() {\n-        retryPolicy = new RetryPolicy();\n-        httpLogOptions = new HttpLogOptions();\n-        policies = new ArrayList<>();\n-    }\n-\n-    HttpPipeline buildPipeline() throws SQLServerException {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n-\n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n-    }\n-\n-    /**\n-     * Sets the credential to use when authenticating HTTP requests.\n-     *\n-     * @param credential\n-     *        The credential to use for authenticating HTTP requests.\n-     * @return the updated KVHttpPipelineBuilder object.\n-     * @throws SQLServerException\n-     */\n-    KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n-        return this;\n-    }\n-}\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nnew file mode 100644\nindex 00000000..8b970662\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {\n+    private static final String APPLICATION_ID = \"mssql-jdbc\";\n+    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n+    private static final String SDK_VERSION = \"4.2.0\";\n+\n+    private final List<HttpPipelinePolicy> policies;\n+    private KeyVaultCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private final RetryPolicy retryPolicy;\n+\n+    /**\n+     * The constructor with defaults.\n+     */\n+    KeyVaultHttpPipelineBuilder() {\n+        retryPolicy = new RetryPolicy();\n+        httpLogOptions = new HttpLogOptions();\n+        policies = new ArrayList<>();\n+    }\n+\n+    HttpPipeline buildPipeline() throws SQLServerException {\n+        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n+\n+        // Closest to API goes first, closest to wire goes last.\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n+        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+        policies.add(retryPolicy);\n+        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n+        policies.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(policies);\n+        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+\n+        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+    }\n+\n+    /**\n+     * Sets the credential to use when authenticating HTTP requests.\n+     *\n+     * @param credential\n+     *        The credential to use for authenticating HTTP requests.\n+     * @return the updated KVHttpPipelineBuilder object.\n+     * @throws SQLServerException\n+     */\n+    KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+        return this;\n+    }\n+}\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\ndeleted file mode 100644\nindex 8b970662..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.HttpPolicyProviders;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\n-final class KeyVaultHttpPipelineBuilder {\n-    private static final String APPLICATION_ID = \"mssql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n-    private HttpLogOptions httpLogOptions;\n-    private final RetryPolicy retryPolicy;\n-\n-    /**\n-     * The constructor with defaults.\n-     */\n-    KeyVaultHttpPipelineBuilder() {\n-        retryPolicy = new RetryPolicy();\n-        httpLogOptions = new HttpLogOptions();\n-        policies = new ArrayList<>();\n-    }\n-\n-    HttpPipeline buildPipeline() throws SQLServerException {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n-\n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n-    }\n-\n-    /**\n-     * Sets the credential to use when authenticating HTTP requests.\n-     *\n-     * @param credential\n-     *        The credential to use for authenticating HTTP requests.\n-     * @return the updated KVHttpPipelineBuilder object.\n-     * @throws SQLServerException\n-     */\n-    KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n-        return this;\n-    }\n-}\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nnew file mode 100644\nindex 00000000..8b970662\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {\n+    private static final String APPLICATION_ID = \"mssql-jdbc\";\n+    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n+    private static final String SDK_VERSION = \"4.2.0\";\n+\n+    private final List<HttpPipelinePolicy> policies;\n+    private KeyVaultCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private final RetryPolicy retryPolicy;\n+\n+    /**\n+     * The constructor with defaults.\n+     */\n+    KeyVaultHttpPipelineBuilder() {\n+        retryPolicy = new RetryPolicy();\n+        httpLogOptions = new HttpLogOptions();\n+        policies = new ArrayList<>();\n+    }\n+\n+    HttpPipeline buildPipeline() throws SQLServerException {\n+        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n+\n+        // Closest to API goes first, closest to wire goes last.\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n+        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+        policies.add(retryPolicy);\n+        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n+        policies.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(policies);\n+        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+\n+        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+    }\n+\n+    /**\n+     * Sets the credential to use when authenticating HTTP requests.\n+     *\n+     * @param credential\n+     *        The credential to use for authenticating HTTP requests.\n+     * @return the updated KVHttpPipelineBuilder object.\n+     * @throws SQLServerException\n+     */\n+    KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+        return this;\n+    }\n+}\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\ndeleted file mode 100644\nindex 8b970662..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.HttpPolicyProviders;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\n-final class KeyVaultHttpPipelineBuilder {\n-    private static final String APPLICATION_ID = \"mssql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n-    private HttpLogOptions httpLogOptions;\n-    private final RetryPolicy retryPolicy;\n-\n-    /**\n-     * The constructor with defaults.\n-     */\n-    KeyVaultHttpPipelineBuilder() {\n-        retryPolicy = new RetryPolicy();\n-        httpLogOptions = new HttpLogOptions();\n-        policies = new ArrayList<>();\n-    }\n-\n-    HttpPipeline buildPipeline() throws SQLServerException {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n-\n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n-    }\n-\n-    /**\n-     * Sets the credential to use when authenticating HTTP requests.\n-     *\n-     * @param credential\n-     *        The credential to use for authenticating HTTP requests.\n-     * @return the updated KVHttpPipelineBuilder object.\n-     * @throws SQLServerException\n-     */\n-    KeyVaultHttpPipelineBuilder credential(KeyVaultCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n-        return this;\n-    }\n-}\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nnew file mode 100644\nindex 00000000..ac1f2cd5\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {\n+    private static final String APPLICATION_ID = \"mssql-jdbc\";\n+    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n+    private static final String SDK_VERSION = \"4.2.0\";\n+\n+    private final List<HttpPipelinePolicy> policies;\n+    private KeyVaultTokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private final RetryPolicy retryPolicy;\n+\n+    /**\n+     * The constructor with defaults.\n+     */\n+    KeyVaultHttpPipelineBuilder() {\n+        retryPolicy = new RetryPolicy();\n+        httpLogOptions = new HttpLogOptions();\n+        policies = new ArrayList<>();\n+    }\n+\n+    HttpPipeline buildPipeline() throws SQLServerException {\n+        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n+\n+        // Closest to API goes first, closest to wire goes last.\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n+        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+        policies.add(retryPolicy);\n+        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n+        policies.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(policies);\n+        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+\n+        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+    }\n+\n+    /**\n+     * Sets the credential to use when authenticating HTTP requests.\n+     *\n+     * @param credential\n+     *        The credential to use for authenticating HTTP requests.\n+     * @return the updated KVHttpPipelineBuilder object.\n+     * @throws SQLServerException\n+     */\n+    KeyVaultHttpPipelineBuilder credential(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+        return this;\n+    }\n+}\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\ndeleted file mode 100644\nindex ac1f2cd5..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.HttpPolicyProviders;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\n-final class KeyVaultHttpPipelineBuilder {\n-    private static final String APPLICATION_ID = \"mssql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultTokenCredential credential;\n-    private HttpLogOptions httpLogOptions;\n-    private final RetryPolicy retryPolicy;\n-\n-    /**\n-     * The constructor with defaults.\n-     */\n-    KeyVaultHttpPipelineBuilder() {\n-        retryPolicy = new RetryPolicy();\n-        httpLogOptions = new HttpLogOptions();\n-        policies = new ArrayList<>();\n-    }\n-\n-    HttpPipeline buildPipeline() throws SQLServerException {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n-\n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n-    }\n-\n-    /**\n-     * Sets the credential to use when authenticating HTTP requests.\n-     *\n-     * @param credential\n-     *        The credential to use for authenticating HTTP requests.\n-     * @return the updated KVHttpPipelineBuilder object.\n-     * @throws SQLServerException\n-     */\n-    KeyVaultHttpPipelineBuilder credential(KeyVaultTokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n-        return this;\n-    }\n-}\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nnew file mode 100644\nindex 00000000..ac1f2cd5\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {\n+    private static final String APPLICATION_ID = \"mssql-jdbc\";\n+    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n+    private static final String SDK_VERSION = \"4.2.0\";\n+\n+    private final List<HttpPipelinePolicy> policies;\n+    private KeyVaultTokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private final RetryPolicy retryPolicy;\n+\n+    /**\n+     * The constructor with defaults.\n+     */\n+    KeyVaultHttpPipelineBuilder() {\n+        retryPolicy = new RetryPolicy();\n+        httpLogOptions = new HttpLogOptions();\n+        policies = new ArrayList<>();\n+    }\n+\n+    HttpPipeline buildPipeline() throws SQLServerException {\n+        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n+\n+        // Closest to API goes first, closest to wire goes last.\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n+        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+        policies.add(retryPolicy);\n+        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n+        policies.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(policies);\n+        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+\n+        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+    }\n+\n+    /**\n+     * Sets the credential to use when authenticating HTTP requests.\n+     *\n+     * @param credential\n+     *        The credential to use for authenticating HTTP requests.\n+     * @return the updated KVHttpPipelineBuilder object.\n+     * @throws SQLServerException\n+     */\n+    KeyVaultHttpPipelineBuilder credential(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+        return this;\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex ca5c3d44..51ff4eeb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -12,46 +12,41 @@ import com.azure.core.http.policy.HttpLoggingPolicy;\n import com.azure.core.http.policy.HttpPipelinePolicy;\n import com.azure.core.http.policy.HttpPolicyProviders;\n import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-import com.azure.core.util.logging.ClientLogger;\n+\n+import java.text.MessageFormat;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Objects;\n-\n \n+/**\n+ * The HTTP pipeline builder which includes all the necessary HTTP pipeline policies that will be applied for\n+ * sending and receiving HTTP requests to the Key Vault service.\n+ */\n final class KeyVaultHttpPipelineBuilder {\n-    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n \n     private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n+    private KeyVaultTokenCredential credential;\n     private HttpLogOptions httpLogOptions;\n     private final RetryPolicy retryPolicy;\n \n     /**\n-     * The constructor with defaults.\n+     * The constructor with default retry policy and log options.\n      */\n-    public KeyVaultHttpPipelineBuilder() {\n+    KeyVaultHttpPipelineBuilder() {\n         retryPolicy = new RetryPolicy();\n         httpLogOptions = new HttpLogOptions();\n         policies = new ArrayList<>();\n     }\n \n-    public HttpPipeline buildPipeline() {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        if (null == credential) {\n-            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n-        }\n-\n+    /**\n+     * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n+     *\n+     * @return A fully built HTTP pipeline including the default HTTP client.\n+     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n+     */\n+    HttpPipeline buildPipeline() throws SQLServerException {\n         // Closest to API goes first, closest to wire goes last.\n         final List<HttpPipelinePolicy> policies = new ArrayList<>();\n \n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n         HttpPolicyProviders.addBeforeRetryPolicies(policies);\n         policies.add(retryPolicy);\n         policies.add(new KeyVaultCustomCredentialPolicy(credential));\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex 51ff4eeb..b635d846 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -41,20 +42,21 @@ final class KeyVaultHttpPipelineBuilder {\n      * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n      *\n      * @return A fully built HTTP pipeline including the default HTTP client.\n-     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n+     * @throws SQLServerException\n+     *         If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n      */\n     HttpPipeline buildPipeline() throws SQLServerException {\n         // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+        final List<HttpPipelinePolicy> pol = new ArrayList<>();\n \n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+        HttpPolicyProviders.addBeforeRetryPolicies(pol);\n+        pol.add(retryPolicy);\n+        pol.add(new KeyVaultCustomCredentialPolicy(credential));\n+        pol.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(pol);\n+        pol.add(new HttpLoggingPolicy(httpLogOptions));\n \n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+        return new HttpPipelineBuilder().policies(pol.toArray(new HttpPipelinePolicy[0])).build();\n     }\n \n     /**\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjAzNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481532035", "body": "The methods in this class should probably not be public.", "bodyText": "The methods in this class should probably not be public.", "bodyHTML": "<p dir=\"auto\">The methods in this class should probably not be public.</p>", "author": "ulvii", "createdAt": "2020-09-02T01:35:34Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\ndeleted file mode 100644\nindex 86edbf87..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ /dev/null\n", "chunk": "@@ -1,108 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.util.CoreUtils;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * A policy that authenticates requests with Azure Key Vault service.\n- */\n-class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n-    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n-    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n-    private static final String AUTHORIZATION = \"Authorization\";\n-    private final ScopeTokenCache cache;\n-    private final KeyVaultCredential keyVaultCredential;\n-\n-    /**\n-     * Creates KeyVaultCustomCredentialPolicy.\n-     *\n-     * @param credential\n-     *        the token credential to authenticate the request\n-     */\n-    public KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) {\n-        Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n-        this.cache = new ScopeTokenCache(credential::getToken);\n-        this.keyVaultCredential = credential;\n-    }\n-\n-    /**\n-     * Adds the required header to authenticate a request to Azure Key Vault service.\n-     *\n-     * @param context\n-     *        The request context\n-     * @param next\n-     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n-     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n-     */\n-    @Override\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n-            return Mono.error(new RuntimeException(\"Token credentials require a URL using the HTTPS protocol scheme\"));\n-        }\n-        return next.clone().process()\n-                // Ignore body\n-                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n-                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n-                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n-                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n-                    return cache.getToken();\n-                }).flatMap(token -> {\n-                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n-                    return next.process();\n-                });\n-    }\n-\n-    /**\n-     * Extracts the challenge off the authentication header.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return a challenge map.\n-     */\n-    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n-        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n-            return null;\n-        }\n-        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n-                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n-\n-        String[] challenges = authenticateHeader.split(\", \");\n-        Map<String, String> challengeMap = new HashMap<>();\n-        for (String pair : challenges) {\n-            String[] keyValue = pair.split(\"=\");\n-            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n-        }\n-        return challengeMap;\n-    }\n-\n-    /**\n-     * Verifies whether a challenge is bearer or not.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return A boolean indicating tha challenge is valid or not.\n-     */\n-    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n-        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n-                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n-    }\n-}\n", "next_change": {"commit": "d24dbff950d63d622a54555fca81d7a0e50451ea", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nnew file mode 100644\nindex 00000000..86edbf87\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultCredential keyVaultCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     */\n+    public KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) {\n+        Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(\"Token credentials require a URL using the HTTPS protocol scheme\"));\n+        }\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });\n+    }\n+\n+    /**\n+     * Extracts the challenge off the authentication header.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return a challenge map.\n+     */\n+    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n+        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n+            return null;\n+        }\n+        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n+                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n+\n+        String[] challenges = authenticateHeader.split(\", \");\n+        Map<String, String> challengeMap = new HashMap<>();\n+        for (String pair : challenges) {\n+            String[] keyValue = pair.split(\"=\");\n+            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n+        }\n+        return challengeMap;\n+    }\n+\n+    /**\n+     * Verifies whether a challenge is bearer or not.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return A boolean indicating tha challenge is valid or not.\n+     */\n+    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n+        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n+                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n+    }\n+}\n", "next_change": {"commit": "4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex 86edbf87..e36303dd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -99,7 +107,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      *        The authentication header containing all the challenges.\n      * @param authChallengePrefix\n      *        The authentication challenge name.\n-     * @return A boolean indicating tha challenge is valid or not.\n+     * @return A boolean indicating the challenge is valid or not.\n      */\n     private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n         return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n", "next_change": {"commit": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\ndeleted file mode 100644\nindex e36303dd..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ /dev/null\n", "chunk": "@@ -1,116 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.util.CoreUtils;\n-\n-import java.text.MessageFormat;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * A policy that authenticates requests with Azure Key Vault service.\n- */\n-class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n-    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n-    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n-    private static final String AUTHORIZATION = \"Authorization\";\n-    private final ScopeTokenCache cache;\n-    private final KeyVaultCredential keyVaultCredential;\n-\n-    /**\n-     * Creates KeyVaultCustomCredentialPolicy.\n-     *\n-     * @param credential\n-     *        the token credential to authenticate the request\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.cache = new ScopeTokenCache(credential::getToken);\n-        this.keyVaultCredential = credential;\n-    }\n-\n-    /**\n-     * Adds the required header to authenticate a request to Azure Key Vault service.\n-     *\n-     * @param context\n-     *        The request context\n-     * @param next\n-     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n-     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n-     */\n-    @Override\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n-            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n-        }\n-\n-        return next.clone().process()\n-                // Ignore body\n-                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n-                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n-                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n-                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n-                    return cache.getToken();\n-                }).flatMap(token -> {\n-                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n-                    return next.process();\n-                });\n-    }\n-\n-    /**\n-     * Extracts the challenge off the authentication header.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return a challenge map.\n-     */\n-    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n-        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n-            return null;\n-        }\n-        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n-                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n-\n-        String[] challenges = authenticateHeader.split(\", \");\n-        Map<String, String> challengeMap = new HashMap<>();\n-        for (String pair : challenges) {\n-            String[] keyValue = pair.split(\"=\");\n-            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n-        }\n-        return challengeMap;\n-    }\n-\n-    /**\n-     * Verifies whether a challenge is bearer or not.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return A boolean indicating the challenge is valid or not.\n-     */\n-    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n-        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n-                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n-    }\n-}\n", "next_change": {"commit": "887d9b14be71883977d8d2dc0bde233b59ec7759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nnew file mode 100644\nindex 00000000..e36303dd\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultCredential keyVaultCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });\n+    }\n+\n+    /**\n+     * Extracts the challenge off the authentication header.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return a challenge map.\n+     */\n+    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n+        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n+            return null;\n+        }\n+        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n+                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n+\n+        String[] challenges = authenticateHeader.split(\", \");\n+        Map<String, String> challengeMap = new HashMap<>();\n+        for (String pair : challenges) {\n+            String[] keyValue = pair.split(\"=\");\n+            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n+        }\n+        return challengeMap;\n+    }\n+\n+    /**\n+     * Verifies whether a challenge is bearer or not.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return A boolean indicating the challenge is valid or not.\n+     */\n+    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n+        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n+                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n+    }\n+}\n", "next_change": {"commit": "7cae3b431dc533e07042f1bbc810995f78b64510", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\ndeleted file mode 100644\nindex e36303dd..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ /dev/null\n", "chunk": "@@ -1,116 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.util.CoreUtils;\n-\n-import java.text.MessageFormat;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * A policy that authenticates requests with Azure Key Vault service.\n- */\n-class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n-    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n-    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n-    private static final String AUTHORIZATION = \"Authorization\";\n-    private final ScopeTokenCache cache;\n-    private final KeyVaultCredential keyVaultCredential;\n-\n-    /**\n-     * Creates KeyVaultCustomCredentialPolicy.\n-     *\n-     * @param credential\n-     *        the token credential to authenticate the request\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.cache = new ScopeTokenCache(credential::getToken);\n-        this.keyVaultCredential = credential;\n-    }\n-\n-    /**\n-     * Adds the required header to authenticate a request to Azure Key Vault service.\n-     *\n-     * @param context\n-     *        The request context\n-     * @param next\n-     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n-     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n-     */\n-    @Override\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n-            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n-        }\n-\n-        return next.clone().process()\n-                // Ignore body\n-                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n-                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n-                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n-                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n-                    return cache.getToken();\n-                }).flatMap(token -> {\n-                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n-                    return next.process();\n-                });\n-    }\n-\n-    /**\n-     * Extracts the challenge off the authentication header.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return a challenge map.\n-     */\n-    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n-        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n-            return null;\n-        }\n-        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n-                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n-\n-        String[] challenges = authenticateHeader.split(\", \");\n-        Map<String, String> challengeMap = new HashMap<>();\n-        for (String pair : challenges) {\n-            String[] keyValue = pair.split(\"=\");\n-            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n-        }\n-        return challengeMap;\n-    }\n-\n-    /**\n-     * Verifies whether a challenge is bearer or not.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return A boolean indicating the challenge is valid or not.\n-     */\n-    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n-        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n-                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n-    }\n-}\n", "next_change": {"commit": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nnew file mode 100644\nindex 00000000..e36303dd\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultCredential keyVaultCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });\n+    }\n+\n+    /**\n+     * Extracts the challenge off the authentication header.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return a challenge map.\n+     */\n+    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n+        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n+            return null;\n+        }\n+        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n+                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n+\n+        String[] challenges = authenticateHeader.split(\", \");\n+        Map<String, String> challengeMap = new HashMap<>();\n+        for (String pair : challenges) {\n+            String[] keyValue = pair.split(\"=\");\n+            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n+        }\n+        return challengeMap;\n+    }\n+\n+    /**\n+     * Verifies whether a challenge is bearer or not.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return A boolean indicating the challenge is valid or not.\n+     */\n+    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n+        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n+                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n+    }\n+}\n", "next_change": {"commit": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\ndeleted file mode 100644\nindex e36303dd..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ /dev/null\n", "chunk": "@@ -1,116 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.util.CoreUtils;\n-\n-import java.text.MessageFormat;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * A policy that authenticates requests with Azure Key Vault service.\n- */\n-class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n-    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n-    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n-    private static final String AUTHORIZATION = \"Authorization\";\n-    private final ScopeTokenCache cache;\n-    private final KeyVaultCredential keyVaultCredential;\n-\n-    /**\n-     * Creates KeyVaultCustomCredentialPolicy.\n-     *\n-     * @param credential\n-     *        the token credential to authenticate the request\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCustomCredentialPolicy(KeyVaultCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.cache = new ScopeTokenCache(credential::getToken);\n-        this.keyVaultCredential = credential;\n-    }\n-\n-    /**\n-     * Adds the required header to authenticate a request to Azure Key Vault service.\n-     *\n-     * @param context\n-     *        The request context\n-     * @param next\n-     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n-     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n-     */\n-    @Override\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n-            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n-        }\n-\n-        return next.clone().process()\n-                // Ignore body\n-                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n-                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n-                    keyVaultCredential.setAuthorization(map.get(\"authorization\"));\n-                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n-                    return cache.getToken();\n-                }).flatMap(token -> {\n-                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n-                    return next.process();\n-                });\n-    }\n-\n-    /**\n-     * Extracts the challenge off the authentication header.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return a challenge map.\n-     */\n-    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n-        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n-            return null;\n-        }\n-        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n-                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n-\n-        String[] challenges = authenticateHeader.split(\", \");\n-        Map<String, String> challengeMap = new HashMap<>();\n-        for (String pair : challenges) {\n-            String[] keyValue = pair.split(\"=\");\n-            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n-        }\n-        return challengeMap;\n-    }\n-\n-    /**\n-     * Verifies whether a challenge is bearer or not.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return A boolean indicating the challenge is valid or not.\n-     */\n-    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n-        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n-                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n-    }\n-}\n", "next_change": {"commit": "1550a9771ba87a07d1e767e63e3afe9133be6759", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nnew file mode 100644\nindex 00000000..fe4935e9\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultTokenCredential.setAuthorization(map.get(\"authorization\"));\n+                    keyVaultTokenCredential.setResource(map.get(\"resource\"));\n+                    keyVaultTokenCredential.setScope(map.get(\"scope\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });\n+    }\n+\n+    /**\n+     * Extracts the challenge off the authentication header.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return a challenge map.\n+     */\n+    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n+        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n+            return null;\n+        }\n+        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n+                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n+\n+        String[] challenges = authenticateHeader.split(\", \");\n+        Map<String, String> challengeMap = new HashMap<>();\n+        for (String pair : challenges) {\n+            String[] keyValue = pair.split(\"=\");\n+            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n+        }\n+        return challengeMap;\n+    }\n+\n+    /**\n+     * Verifies whether a challenge is bearer or not.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return A boolean indicating the challenge is valid or not.\n+     */\n+    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n+        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n+                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n+    }\n+}\n", "next_change": {"commit": "d76368aedf39c5dbc573f7449e91524b1227daf7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\ndeleted file mode 100644\nindex fe4935e9..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ /dev/null\n", "chunk": "@@ -1,118 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.util.CoreUtils;\n-\n-import java.text.MessageFormat;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * A policy that authenticates requests with Azure Key Vault service.\n- */\n-class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n-    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n-    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n-    private static final String AUTHORIZATION = \"Authorization\";\n-    private final ScopeTokenCache cache;\n-    private final KeyVaultTokenCredential keyVaultTokenCredential;\n-\n-    /**\n-     * Creates KeyVaultCustomCredentialPolicy.\n-     *\n-     * @param credential\n-     *        the token credential to authenticate the request\n-     * @throws SQLServerException\n-     */\n-    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.cache = new ScopeTokenCache(credential::getToken);\n-        this.keyVaultTokenCredential = credential;\n-    }\n-\n-    /**\n-     * Adds the required header to authenticate a request to Azure Key Vault service.\n-     *\n-     * @param context\n-     *        The request context\n-     * @param next\n-     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n-     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n-     */\n-    @Override\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n-            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n-        }\n-\n-        return next.clone().process()\n-                // Ignore body\n-                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n-                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n-                    keyVaultTokenCredential.setAuthorization(map.get(\"authorization\"));\n-                    keyVaultTokenCredential.setResource(map.get(\"resource\"));\n-                    keyVaultTokenCredential.setScope(map.get(\"scope\"));\n-                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n-                    return cache.getToken();\n-                }).flatMap(token -> {\n-                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n-                    return next.process();\n-                });\n-    }\n-\n-    /**\n-     * Extracts the challenge off the authentication header.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return a challenge map.\n-     */\n-    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n-        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n-            return null;\n-        }\n-        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n-                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n-\n-        String[] challenges = authenticateHeader.split(\", \");\n-        Map<String, String> challengeMap = new HashMap<>();\n-        for (String pair : challenges) {\n-            String[] keyValue = pair.split(\"=\");\n-            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n-        }\n-        return challengeMap;\n-    }\n-\n-    /**\n-     * Verifies whether a challenge is bearer or not.\n-     *\n-     * @param authenticateHeader\n-     *        The authentication header containing all the challenges.\n-     * @param authChallengePrefix\n-     *        The authentication challenge name.\n-     * @return A boolean indicating the challenge is valid or not.\n-     */\n-    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n-        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n-                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n-    }\n-}\n", "next_change": {"commit": "1108103183860d69b772d9902c434d59c5f239af", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nnew file mode 100644\nindex 00000000..fe4935e9\n--- /dev/null\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultTokenCredential.setAuthorization(map.get(\"authorization\"));\n+                    keyVaultTokenCredential.setResource(map.get(\"resource\"));\n+                    keyVaultTokenCredential.setScope(map.get(\"scope\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });\n+    }\n+\n+    /**\n+     * Extracts the challenge off the authentication header.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return a challenge map.\n+     */\n+    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {\n+        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {\n+            return null;\n+        }\n+        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)\n+                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), \"\");\n+\n+        String[] challenges = authenticateHeader.split(\", \");\n+        Map<String, String> challengeMap = new HashMap<>();\n+        for (String pair : challenges) {\n+            String[] keyValue = pair.split(\"=\");\n+            challengeMap.put(keyValue[0].replaceAll(\"\\\"\", \"\"), keyValue[1].replaceAll(\"\\\"\", \"\"));\n+        }\n+        return challengeMap;\n+    }\n+\n+    /**\n+     * Verifies whether a challenge is bearer or not.\n+     *\n+     * @param authenticateHeader\n+     *        The authentication header containing all the challenges.\n+     * @param authChallengePrefix\n+     *        The authentication challenge name.\n+     * @return A boolean indicating the challenge is valid or not.\n+     */\n+    private static boolean isValidChallenge(String authenticateHeader, String authChallengePrefix) {\n+        return (!CoreUtils.isNullOrEmpty(authenticateHeader) && authenticateHeader.toLowerCase(Locale.ROOT)\n+                .startsWith(authChallengePrefix.toLowerCase(Locale.ROOT)));\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": null, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"oid": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "url": "https://github.com/microsoft/mssql-jdbc/commit/3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "message": "Update src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n\nCo-authored-by: David Engel <dengel1012@gmail.com>", "committedDate": "2020-09-02T05:25:49Z", "type": "commit"}, {"oid": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d9bad87bda75441fad79010fb31e90c7de8b6a5d", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-02T05:47:37Z", "type": "commit"}, {"oid": "d24dbff950d63d622a54555fca81d7a0e50451ea", "url": "https://github.com/microsoft/mssql-jdbc/commit/d24dbff950d63d622a54555fca81d7a0e50451ea", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-02T05:48:23Z", "type": "commit"}, {"oid": "59aebe6a2f663c70638530cba96e898ee0b3d03f", "url": "https://github.com/microsoft/mssql-jdbc/commit/59aebe6a2f663c70638530cba96e898ee0b3d03f", "message": "exception handling and removed unnecessary public apis", "committedDate": "2020-09-02T18:30:20Z", "type": "commit"}, {"oid": "6b2f1a2c2490d7cfb090ed889e0d9bf2f1329508", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b2f1a2c2490d7cfb090ed889e0d9bf2f1329508", "message": "added header", "committedDate": "2020-09-02T18:38:56Z", "type": "commit"}, {"oid": "2e6180f8ae90791f662a2da9d6f0f2a5112c5ec3", "url": "https://github.com/microsoft/mssql-jdbc/commit/2e6180f8ae90791f662a2da9d6f0f2a5112c5ec3", "message": "merged", "committedDate": "2020-09-02T18:42:01Z", "type": "commit"}, {"oid": "c7cd5984f0e7d02a52d2bcaba154ddf32acaabe7", "url": "https://github.com/microsoft/mssql-jdbc/commit/c7cd5984f0e7d02a52d2bcaba154ddf32acaabe7", "message": "Merge pull request #2 from lilgreenbird/msal\n\nUpdates", "committedDate": "2020-09-02T18:47:26Z", "type": "commit"}, {"oid": "4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "url": "https://github.com/microsoft/mssql-jdbc/commit/4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "message": "more updates", "committedDate": "2020-09-02T22:27:44Z", "type": "commit"}, {"oid": "a0644beb6235fa466ac8998d8dd21284b92e239e", "url": "https://github.com/microsoft/mssql-jdbc/commit/a0644beb6235fa466ac8998d8dd21284b92e239e", "message": "update", "committedDate": "2020-09-02T22:36:37Z", "type": "commit"}, {"oid": "042ade5a8b3c75658b4d72fa04566f682781601a", "url": "https://github.com/microsoft/mssql-jdbc/commit/042ade5a8b3c75658b4d72fa04566f682781601a", "message": "Merge pull request #3 from lilgreenbird/msal\n\nmore updates", "committedDate": "2020-09-02T22:47:54Z", "type": "commit"}, {"oid": "abdf38daab8061c05458362a62496e79fb5e3dae", "url": "https://github.com/microsoft/mssql-jdbc/commit/abdf38daab8061c05458362a62496e79fb5e3dae", "message": "merged", "committedDate": "2020-09-04T06:16:43Z", "type": "commit"}, {"oid": "573dfb93fcd1c7e12c19c760d7160377f5dc04a3", "url": "https://github.com/microsoft/mssql-jdbc/commit/573dfb93fcd1c7e12c19c760d7160377f5dc04a3", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-04T06:16:57Z", "type": "commit"}, {"oid": "48fbe2c381292e7358d074e6efb098de837d26f8", "url": "https://github.com/microsoft/mssql-jdbc/commit/48fbe2c381292e7358d074e6efb098de837d26f8", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-05T02:08:55Z", "type": "commit"}, {"oid": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "url": "https://github.com/microsoft/mssql-jdbc/commit/a2e50b9b66d9207415d6853fa449fc55e968a44a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-09T19:00:26Z", "type": "commit"}, {"oid": "7ff97dee94ec4144ef22e5d12ba76f1a84ebe3c9", "url": "https://github.com/microsoft/mssql-jdbc/commit/7ff97dee94ec4144ef22e5d12ba76f1a84ebe3c9", "message": "enable ADintegrated tests for non-windows", "committedDate": "2020-09-09T23:20:13Z", "type": "commit"}, {"oid": "887d9b14be71883977d8d2dc0bde233b59ec7759", "url": "https://github.com/microsoft/mssql-jdbc/commit/887d9b14be71883977d8d2dc0bde233b59ec7759", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-10T00:32:20Z", "type": "commit"}, {"oid": "4a8b4f389937aed352098be48709a04ed50a9519", "url": "https://github.com/microsoft/mssql-jdbc/commit/4a8b4f389937aed352098be48709a04ed50a9519", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-10T23:32:02Z", "type": "commit"}, {"oid": "7cae3b431dc533e07042f1bbc810995f78b64510", "url": "https://github.com/microsoft/mssql-jdbc/commit/7cae3b431dc533e07042f1bbc810995f78b64510", "message": "fixed user test for kerberos", "committedDate": "2020-09-11T05:34:42Z", "type": "commit"}, {"oid": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "url": "https://github.com/microsoft/mssql-jdbc/commit/c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "message": "Update to latest version of KV and Identity", "committedDate": "2020-09-16T20:05:04Z", "type": "commit"}, {"oid": "d0186a9dec2411976db528bb90ece338a5f61a9a", "url": "https://github.com/microsoft/mssql-jdbc/commit/d0186a9dec2411976db528bb90ece338a5f61a9a", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-16T22:11:51Z", "type": "commit"}, {"oid": "4c9b6277174d8bb12de84b310a4296a6577075c1", "url": "https://github.com/microsoft/mssql-jdbc/commit/4c9b6277174d8bb12de84b310a4296a6577075c1", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-16T22:18:03Z", "type": "commit"}, {"oid": "e863c056cb2d36309c757e25bcf1bdc708bb9b26", "url": "https://github.com/microsoft/mssql-jdbc/commit/e863c056cb2d36309c757e25bcf1bdc708bb9b26", "message": "user name check", "committedDate": "2020-09-16T22:33:25Z", "type": "commit"}, {"oid": "43060f9fb25d71ab6724d2aa12712745d899c562", "url": "https://github.com/microsoft/mssql-jdbc/commit/43060f9fb25d71ab6724d2aa12712745d899c562", "message": "Bring back deprecated constructors", "committedDate": "2020-09-16T22:33:29Z", "type": "commit"}, {"oid": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "url": "https://github.com/microsoft/mssql-jdbc/commit/c8c5a2977c700d62815ab8073ea11a8d40885deb", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-16T22:34:15Z", "type": "commit"}, {"oid": "1550a9771ba87a07d1e767e63e3afe9133be6759", "url": "https://github.com/microsoft/mssql-jdbc/commit/1550a9771ba87a07d1e767e63e3afe9133be6759", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-16T22:35:05Z", "type": "commit"}, {"oid": "f4825dbdfdfb4ea3d1a64df845527e6532076196", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4825dbdfdfb4ea3d1a64df845527e6532076196", "message": "Resolve merge conflicts", "committedDate": "2020-09-16T22:39:20Z", "type": "commit"}, {"oid": "b85e3c20207d7119b4e8e1e671de905c3e3589db", "url": "https://github.com/microsoft/mssql-jdbc/commit/b85e3c20207d7119b4e8e1e671de905c3e3589db", "message": "merged", "committedDate": "2020-09-17T21:37:24Z", "type": "commit"}, {"oid": "7d4274f06582ee91a43eff1e6b276a93f785f688", "url": "https://github.com/microsoft/mssql-jdbc/commit/7d4274f06582ee91a43eff1e6b276a93f785f688", "message": "Add auth callback tests", "committedDate": "2020-09-18T20:49:14Z", "type": "commit"}, {"oid": "2a92d4dc6b373d166fe85200586b33730a5e71ab", "url": "https://github.com/microsoft/mssql-jdbc/commit/2a92d4dc6b373d166fe85200586b33730a5e71ab", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-19T00:48:44Z", "type": "commit"}, {"oid": "61b787f737ddf8c9d1fd0342be7c1d8826c42fe0", "url": "https://github.com/microsoft/mssql-jdbc/commit/61b787f737ddf8c9d1fd0342be7c1d8826c42fe0", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-22T04:13:14Z", "type": "commit"}, {"oid": "360a8d4bb6f6e680e3ee0043f32d738b806cf22e", "url": "https://github.com/microsoft/mssql-jdbc/commit/360a8d4bb6f6e680e3ee0043f32d738b806cf22e", "message": "lib conflict", "committedDate": "2020-09-22T05:04:17Z", "type": "commit"}, {"oid": "d76368aedf39c5dbc573f7449e91524b1227daf7", "url": "https://github.com/microsoft/mssql-jdbc/commit/d76368aedf39c5dbc573f7449e91524b1227daf7", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-22T05:08:08Z", "type": "commit"}, {"oid": "e5aafd300061bee1968463cf7ad1d07d6da8356d", "url": "https://github.com/microsoft/mssql-jdbc/commit/e5aafd300061bee1968463cf7ad1d07d6da8356d", "message": "Merge branch 'dev' of https://github.com/lilgreenbird/mssql-jdbc into dev", "committedDate": "2020-09-22T05:08:27Z", "type": "commit"}, {"oid": "1108103183860d69b772d9902c434d59c5f239af", "url": "https://github.com/microsoft/mssql-jdbc/commit/1108103183860d69b772d9902c434d59c5f239af", "message": "merged", "committedDate": "2020-09-22T05:15:41Z", "type": "commit"}, {"oid": "950677fd4de54a43fd5b085da4b71e371058dbf5", "url": "https://github.com/microsoft/mssql-jdbc/commit/950677fd4de54a43fd5b085da4b71e371058dbf5", "message": "merged", "committedDate": "2020-09-22T05:19:56Z", "type": "commit"}, {"oid": "12f2da986ea6412b19d6d6e14eb27de7af224966", "url": "https://github.com/microsoft/mssql-jdbc/commit/12f2da986ea6412b19d6d6e14eb27de7af224966", "message": "back to prev lib version", "committedDate": "2020-09-22T06:49:51Z", "type": "commit"}, {"oid": "2b3ccd6930333ac63f25320c5a3a0ea0c243b07d", "url": "https://github.com/microsoft/mssql-jdbc/commit/2b3ccd6930333ac63f25320c5a3a0ea0c243b07d", "message": "fix", "committedDate": "2020-09-23T05:33:46Z", "type": "commit"}, {"oid": "497f1bead6faa74a53460e4182727ab22a772489", "url": "https://github.com/microsoft/mssql-jdbc/commit/497f1bead6faa74a53460e4182727ab22a772489", "message": "merged", "committedDate": "2020-09-23T05:36:57Z", "type": "commit"}, {"oid": "972f95c65fcfd3bc9a99064ccb22ce2f7e2147e9", "url": "https://github.com/microsoft/mssql-jdbc/commit/972f95c65fcfd3bc9a99064ccb22ce2f7e2147e9", "message": "Merge branch 'msal' of https://github.com/lilgreenbird/mssql-jdbc into msal", "committedDate": "2020-09-23T05:37:44Z", "type": "commit"}, {"oid": "216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "url": "https://github.com/microsoft/mssql-jdbc/commit/216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "message": "fixed", "committedDate": "2020-09-23T05:51:29Z", "type": "commit"}, {"oid": "791e2b6b473f6cac5a9ecde7359527c78921d3f0", "url": "https://github.com/microsoft/mssql-jdbc/commit/791e2b6b473f6cac5a9ecde7359527c78921d3f0", "message": "update", "committedDate": "2020-09-23T06:02:38Z", "type": "commit"}, {"oid": "a7119131d567639e5a97a35f20ffe8759745d89d", "url": "https://github.com/microsoft/mssql-jdbc/commit/a7119131d567639e5a97a35f20ffe8759745d89d", "message": "merged", "committedDate": "2020-09-23T06:04:34Z", "type": "commit"}, {"oid": "122e408633ef0aca67e2a1358ce19c4caead5904", "url": "https://github.com/microsoft/mssql-jdbc/commit/122e408633ef0aca67e2a1358ce19c4caead5904", "message": "Merge pull request #4 from lilgreenbird/msal\n\nMsal", "committedDate": "2020-09-23T06:10:11Z", "type": "commit"}, {"oid": "b4799ca4f4028d82b0791e9f89e81103e9191c7d", "url": "https://github.com/microsoft/mssql-jdbc/commit/b4799ca4f4028d82b0791e9f89e81103e9191c7d", "message": "Remove hardcoded version and package name", "committedDate": "2020-09-24T19:27:53Z", "type": "commit"}, {"oid": "c722d34e80fc7d8c9954ebb9a859bb2e90e11107", "url": "https://github.com/microsoft/mssql-jdbc/commit/c722d34e80fc7d8c9954ebb9a859bb2e90e11107", "message": "clean and exclude lib", "committedDate": "2020-09-25T18:03:41Z", "type": "commit"}, {"oid": "9c28d9844c1e30f210f1b685859396653a5d7363", "url": "https://github.com/microsoft/mssql-jdbc/commit/9c28d9844c1e30f210f1b685859396653a5d7363", "message": "Add code comments and javadoc", "committedDate": "2020-09-29T08:05:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499748260", "body": "Can the url be HTTP? Also please add a `.` to the end of the error message.", "bodyText": "Can the url be HTTP? Also please add a . to the end of the error message.", "bodyHTML": "<p dir=\"auto\">Can the url be HTTP? Also please add a <code>.</code> to the end of the error message.</p>", "author": "ulvii", "createdAt": "2020-10-05T17:09:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -648,5 +648,6 @@ static String getResource(String key) {\n             {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},};\n+                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NDkyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499754924", "bodyText": "I figured HTTP is not supported, so the question can be ignored.", "author": "ulvii", "createdAt": "2020-10-05T17:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MDkzMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r501860931", "bodyText": "@lilgreenbird  please add . to the end of the error message.", "author": "ulvii", "createdAt": "2020-10-08T16:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b83772f3..8045d1f8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -649,5 +649,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n };\n", "next_change": {"commit": "338f48051d001bf324b2a90de757c3572a6883c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 8045d1f8..b83772f3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -649,5 +649,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};\n };\n", "next_change": {"commit": "7a035c6333044677e99dbc96114959c49e10e954", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b83772f3..8045d1f8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -649,5 +649,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n };\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b83772f3..391a1377 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -649,5 +649,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n };\n", "next_change": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 391a1377..754f1391 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -581,73 +532,11 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n             {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n             {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n             {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n             {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n             {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALLMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALLMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n-            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n-            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n-};\n+            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n+}\n", "next_change": {"commit": "cc192d36986c1c13fda64f1fa9f2e141e822d26d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..6f87b8bf 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -538,5 +538,6 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n             {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+    };\n }\n", "next_change": {"commit": "dfb4cadc777b3cd9e9217a5c08721b455dba4442", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 6f87b8bf..754f1391 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -538,6 +538,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n             {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-    };\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n }\n", "next_change": {"commit": "252cbfc41198e3412558f359cef8b220f5bad546", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..df8bcc73 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -538,5 +538,7 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n             {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+    };\n }\n", "next_change": {"commit": "4877145e9dbc6a1178aa688afe5a14876db5a65f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex df8bcc73..cb70c10d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -540,5 +540,6 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n             {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n             {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n     };\n }\n", "next_change": {"commit": "503076fe213e018506f690177c32011f8ec22b62", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex cb70c10d..8acb6917 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -541,5 +541,6 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n             {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n             {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n", "next_change": {"commit": "0170f891a15e70c7bf10af283f35a4a55e42a874", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 8acb6917..453cc896 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -540,6 +540,7 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n             {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n             {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n             {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n             {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n", "next_change": {"commit": "af76d7af3846801be86f7f94fbc3318b1ed5bc04", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 453cc896..613a1fb2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -532,16 +581,73 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n             {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n             {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n             {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n             {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n             {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n-    };\n-}\n+            {\"R_keyVaultProviderClientIdPropertyDescription\",\n+                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n+                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+            {\"R_DLLandMSALMissing\",\n+                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+            {\"R_MSITokenFailureImdsClientId\",\n+                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+            {\"R_MSITokenFailureUnexpected\",\n+                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+            {\"R_propertyNotSupported\",\n+                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+            {\"R_useFmtOnlyPropertyDescription\",\n+                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+            {\"R_invalidOpenqueryCall\",\n+                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+            {\"R_invalidCTEFormat\",\n+                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+            {\"R_invalidInsertValuesQuery\",\n+                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n+            {\"R_enclavePropertiesError\",\n+                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n+            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n+            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n+            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n+            {\"R_EnclaveResponseLengthError\",\n+                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n+            {\"R_EnclavePackageLengthError\",\n+                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n+            {\"R_EnclavePKLengthError\",\n+                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n+            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+            {\"R_HealthCertError\",\n+                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n+            {\"R_InvalidHealthCert\",\n+                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n+            {\"R_InvalidSignedStatement\",\n+                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n+            {\"R_InvalidDHKeySignature\",\n+                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n+            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+            {\"R_InvalidCSVQuotes\",\n+                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n+};\n", "next_change": {"commit": "d9909748368af7d2944dab4fa382ee513f2b76f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 613a1fb2..1be1847f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -649,5 +652,10 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n-};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+            {\"R_maxResultBufferPropertyDescription\",\n+                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+}\n", "next_change": {"commit": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 1be1847f..4a29d517 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -657,5 +665,6 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n             {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n             {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+            {\"R_maxResultBufferPropertyExceeded\",\n+                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n }\n", "next_change": {"commit": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4a29d517..96eeaf10 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -666,5 +677,15 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n             {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n             {\"R_maxResultBufferPropertyExceeded\",\n-                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+//Todo new conn res from ulvii\n+            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+    };\n }\n", "next_change": {"commit": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 96eeaf10..278197bc 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -21,671 +21,474 @@ public final class SQLServerResource extends ListResourceBundle {\n         return CONTENTS;\n     }\n \n-    // The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n-    // camelCasing convention and be descriptive\n-    static final Object[][] CONTENTS = {\n-            // LOCALIZE THIS\n-            {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n-            {\"R_invalidRoutingInfo\",\n-                    \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_multipleRedirections\",\n-                    \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n-            {\"R_dbMirroringWithMultiSubnetFailover\",\n-                    \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n-            {\"R_dbMirroringWithReadOnlyIntent\",\n-                    \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n-            {\"R_ipAddressLimitWithMultiSubnetFailover\",\n-                    \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n-            {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n-            {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n-            {\"R_invalidLength\", \"The length {0} is not valid.\"},\n-            {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n-            {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n-            {\"R_notSQLServer\",\n-                    \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting \"\n-                            + \"TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n-            {\"R_tcpOpenFailed\",\n-                    \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP \"\n-                            + \"connections to the port are not blocked by a firewall.\"},\n-            {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n-            {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n-            {\"R_truncatedServerResponse\",\n-                    \"SQL Server returned an incomplete response. The connection has been closed.\"},\n-            {\"R_queryTimedOut\", \"The query has timed out.\"}, {\"R_queryCancelled\", \"The query was canceled.\"},\n-            {\"R_errorReadingStream\",\n-                    \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n-            {\"R_streamReadReturnedInvalidValue\",\n-                    \"The stream read operation returned an invalid value for the amount of data read.\"},\n-            {\"R_mismatchedStreamLength\",\n-                    \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n-            {\"R_notSupported\", \"This operation is not supported.\"},\n-            {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n-            {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n-            {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n-            {\"R_connectionIsClosed\", \"The connection is closed.\"},\n-            {\"R_invalidBooleanValue\",\n-                    \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n-            {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n-            {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n-            {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n-            {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n-            {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n-            {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n-            {\"R_packetSizeTooBigForSSL\",\n-                    \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n-            {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n-            {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n-            {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_sqlServerHoldability\",\n-                    \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n-            {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n-            {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n-            {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n-            {\"R_sqlBrowserFailed\",\n-                    \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. \"\n-                            + \" For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n-            {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n-            {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n-            {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n-            {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n-            {\"R_noMetadata\", \"There is no metadata.\"}, {\"R_resultsetClosed\", \"The result set is closed.\"},\n-            {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n-            {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n-            {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n-            {\"R_savepointNotNamed\", \"The savepoint is not named.\"}, {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n-            {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n-            {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n-            {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n-            {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n-            {\"R_noResultset\", \"The statement did not return a result set.\"},\n-            {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n-            {\"R_statementIsClosed\", \"The statement is closed.\"},\n-            {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n-            {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n-            {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n-            {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n-            {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n-            {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n-            {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n-            {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n-            {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n-            {\"R_invalidOffset\", \"The offset {0} is not valid.\"}, {\"R_nullConnection\", \"The connection URL is null.\"},\n-            {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n-            {\"R_cannotTakeArgumentsPreparedOrCallable\",\n-                    \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n-            // Invalid conversion (e.g. MONEY to Timestamp)\n-            {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n-            // Invalid conversion to an unknown type\n-            {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n-            // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n-            {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n-            {\"R_streamIsClosed\", \"The stream is closed.\"}, {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n-            {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n-            {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n-            {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n-            {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n-            {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n-            {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n-            {\"R_encodingErrorWritingTDS\",\n-                    \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n-            {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n-            {\"R_requestedOpNotSupportedOnForward\",\n-                    \"The requested operation is not supported on forward only result sets.\"},\n-            {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n-            {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n-            {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n-            {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n-            {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n-            {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n-            {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n-            {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n-            {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n-            {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n-            {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n-            {\"R_cantGetUpdatedColumnValue\",\n-                    \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n-            {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n-            {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n-            {\"R_invalidAutoGeneratedKeys\",\n-                    \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n-            {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n-            {\"R_failoverPartnerWithoutDB\",\n-                    \"databaseName is required when using the failoverPartner connection property.\"},\n-            {\"R_invalidPartnerConfiguration\",\n-                    \"The database {0} on server {1} is not configured for database mirroring.\"},\n-            {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n-            {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n-            {\"R_invalidpropertyValue\",\n-                    \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n-            {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n-            {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n-            {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n-            {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n-            {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n-            {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n-            {\"R_sslRequiredNoServerSupport\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. \"\n-                            + \"The application requested encryption but the server is not configured to support SSL.\"},\n-            {\"R_sslRequiredByServer\",\n-                    \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n-            {\"R_sslFailed\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n-            {\"R_certNameFailed\",\n-                    \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n-            {\"R_failedToInitializeXA\",\n-                    \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n-            {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n-            {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n-            {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n-            {\"R_userPropertyDescription\", \"The database user.\"},\n-            {\"R_passwordPropertyDescription\", \"The database password.\"},\n-            {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n-            {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n-            {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n-            {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n-            {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n-            {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n-            {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n-            {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n-            {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n-            {\"R_serverNameAsACEPropertyDescription\",\n-                    \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n-            {\"R_sendStringParametersAsUnicodePropertyDescription\",\n-                    \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n-            {\"R_multiSubnetFailoverPropertyDescription\",\n-                    \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n-            {\"R_applicationNamePropertyDescription\",\n-                    \"The application name for SQL Server profiling and logging tools.\"},\n-            {\"R_lastUpdateCountPropertyDescription\",\n-                    \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n-            {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n-            {\"R_integratedSecurityPropertyDescription\",\n-                    \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n-            {\"R_authenticationSchemePropertyDescription\",\n-                    \"The authentication scheme to be used for integrated authentication.\"},\n-            {\"R_lockTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n-            {\"R_connectRetryCountPropertyDescription\",\n-                    \"The number of reconnection attempts if there is a connection failure.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\",\n-                    \"The number of seconds between each connection retry attempt.\"},\n-            {\"R_loginTimeoutPropertyDescription\",\n-                    \"The number of seconds the driver should wait before timing out a failed connection.\"},\n-            {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n-            {\"R_xopenStatesPropertyDescription\",\n-                    \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n-            {\"R_selectMethodPropertyDescription\",\n-                    \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n-            {\"R_responseBufferingPropertyDescription\",\n-                    \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n-            {\"R_applicationIntentPropertyDescription\",\n-                    \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n-            {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n-            {\"R_failoverPartnerPropertyDescription\",\n-                    \"The name of the failover server used in a database mirroring configuration.\"},\n-            {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n-            {\"R_encryptPropertyDescription\",\n-                    \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n-            {\"R_socketFactoryClassPropertyDescription\",\n-                    \"The class to instantiate as the SocketFactory for connections\"},\n-            {\"R_socketFactoryConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n-            {\"R_trustServerCertificatePropertyDescription\",\n-                    \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n-            {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n-            {\"R_trustStorePasswordPropertyDescription\",\n-                    \"The password used to check the integrity of the trust store data.\"},\n-            {\"R_trustManagerClassPropertyDescription\",\n-                    \"The class to instantiate as the TrustManager for SSL connections.\"},\n-            {\"R_trustManagerConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n-            {\"R_hostNameInCertificatePropertyDescription\",\n-                    \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_replicationPropertyDescription\",\n-                    \"This setting tells the server if the connection is used for replication.\"},\n-            {\"R_sendTimeAsDatetimePropertyDescription\",\n-                    \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n-            {\"R_TransparentNetworkIPResolutionPropertyDescription\",\n-                    \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n-            {\"R_queryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait before the database reports a query time-out.\"},\n-            {\"R_socketTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n-            {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\",\n-                    \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). \"\n-                            + \"A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n-            {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\",\n-                    \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n-            {\"R_statementPoolingCacheSizePropertyDescription\",\n-                    \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n-            {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n-            {\"R_msiClientIdPropertyDescription\",\n-                    \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n-            {\"R_clientCertificatePropertyDescription\",\n-                    \"Client certificate path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPasswordPropertyDescription\",\n-                    \"Password for private key if the private key is password protected.\"},\n-            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n-                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n-            {\"R_delayLoadingLobsPropertyDescription\",\n-                    \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n-            {\"R_AADSecurePrincipalIdPropertyDescription\",\n-                    \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n-            {\"R_AADSecurePrincipalSecretPropertyDescription\",\n-                    \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n-            {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n-            {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n-            {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n-            {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n-            {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n-            {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n-            {\"R_cantSetNull\", \"Cannot set a null value.\"},\n-            {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n-            {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n-            {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n-            {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n-            {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n-            {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n-            {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n-            {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n-            {\"R_getSchemaError\", \"Error getting default schema name.\"},\n-            {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n-            {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n-            {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n-            {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n-            {\"R_featureNotSupported\", \"{0} is not supported.\"},\n-            {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n-            {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n-            {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n-            {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n-            {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n-            {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n-            {\"R_invalidDestConnection\",\n-                    \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n-            {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n-            {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n-            {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n-            {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n-            {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n-            {\"R_invalidTransactionOption\",\n-                    \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n-            {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n-            {\"R_BulkColumnMappingsIsEmpty\",\n-                    \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n-            {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n-            {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n-            {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n-            {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n-            {\"R_UnexpectedDescribeParamFormat\",\n-                    \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n-            {\"R_InvalidEncryptionKeyOrdinal\",\n-                    \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n-            {\"R_MissingParamEncryptionMetadata\",\n-                    \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n-            {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n-            {\"R_InvalidCipherTextSize\",\n-                    \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n-            {\"R_InvalidAlgorithmVersion\",\n-                    \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n-            {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n-            {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n-            {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n-            {\"R_InvalidKeySize\",\n-                    \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". \"\n-                            + \"Verify the encrypted value of the column encryption key in the database.\"},\n-            {\"R_InvalidEncryptionType\",\n-                    \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n-            {\"R_UnknownColumnEncryptionAlgorithm\",\n-                    \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n-            {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n-            {\"R_UntrustedKeyPath\",\n-                    \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path \"\n-                            + \"using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n-            {\"R_UnrecognizedKeyStoreProviderName\",\n-                    \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider \"\n-                            + \"or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: \"\n-                            + \"{2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers \"\n-                            + \"used in your application are registered properly.\"},\n-            {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n-            {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n-            {\"R_UnsupportedNormalizationVersionAE\",\n-                    \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n-            {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n-            {\"R_NullColumnEncryptionAlgorithmAE\",\n-                    \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n-            {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n-            {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n-            {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n-            {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n-            {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n-                                                                                                           // Server\n-            {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n-            {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n-            {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n-            {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n-            {\"R_InvalidCertificateSignature\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n-            {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n-            {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithm\",\n-                    \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithmInternal\",\n-                    \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n-            {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n-            {\"R_CertificateNotFoundForAlias\",\n-                    \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. \"\n-                    + \" Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n-            {\"R_KeyStoreNotFound\",\n-                    \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n-            {\"R_CustomKeyStoreProviderMapNull\",\n-                    \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n-            {\"R_EmptyCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n-            {\"R_InvalidCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n-            {\"R_CustomKeyStoreProviderValueNull\",\n-                    \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n-            {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n-            {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n-            {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n-            {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n-            {\"R_InvalidDataForAE\",\n-                    \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n-            {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n-            {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n-            {\"R_FedAuthRequiredPreLoginResponseInvalidValue\",\n-                    \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n-            {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\",\n-                    \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n-            {\"R_FedAuthInfoInvalidOffset\",\n-                    \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n-            {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n-            {\"R_FedAuthInfoLengthTooShortForData\",\n-                    \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n-            {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n-                    \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n-            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n-            {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n-            {\"R_FedAuthFeatureAckContainsExtraData\",\n-                    \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n-            {\"R_FedAuthFeatureAckUnknownLibraryType\",\n-                    \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n-            {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n-            {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n-                    \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n-            {\"R_NtlmNoUserPasswordDomain\",\n-                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n-            {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n-                    \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n-            {\"R_IntegratedAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_MSIAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_AccessTokenWithUserPassword\",\n-                    \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n-            {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n-            {\"R_SetBothAuthenticationAndAccessToken\",\n-                    \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n-            {\"R_NoUserPasswordForActivePassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\",\n-                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n-            {\"R_NoUserPasswordForSqlPassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalse\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\",\n-                    \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalseRS\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\",\n-                    \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_NullValue\", \"{0} cannot be null.\"}, {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n-            {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n-            {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n-            {\"R_ManagedIdentityInitFail\",\n-                    \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n-            {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n-            {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n-            {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n-            {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n-            {\"R_InvalidEcryptionAlgorithmVersion\",\n-                    \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n-            {\"R_AKVKeyLengthError\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_AKVSignatureLengthError\",\n-                    \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n-            {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n-            {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n-            {\"R_CEKSignatureNotMatchCMK\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n-            {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n-            {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n-            {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n-            {\"R_UnableLoadADALSqlDll\",\n-                    \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n-            {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n-            {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n-            {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n-            {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n-            {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n-            {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n-            {\"R_TVPMixedSource\",\n-                    \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n-            {\"R_TVPEmptyMetadata\",\n-                    \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n-            {\"R_TVPInvalidValue\",\n-                    \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n-            {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n-            {\"R_TVPSortOrdinalGreaterThanFieldCount\",\n-                    \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n-            {\"R_TVPMissingSortOrderOrOrdinal\",\n-                    \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n-            {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n-            {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n-            {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n-            // This is used for connection settings. {0}-> property name as is, {1}-> value\n-            {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n-            {\"R_InvalidWindowsCertificateStoreEncryption\",\n-                    \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n-            {\"R_AEKeypathEmpty\",\n-                    \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n-            {\"R_AECertpathBad\",\n-                    \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertLocBad\",\n-                    \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertStoreBad\",\n-                    \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n-            {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n-            {\"R_AECertNotFound\",\n-                    \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition \"\n-                            + \"in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_AEMaloc\", \"Memory allocation failure.\"},\n-            {\"R_AEKeypathLong\",\n-                    \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n-            {\"R_AEECEKLenBad\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEECEKSigLenBad\",\n-                    \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEKeyPathEmptyOrReserved\",\n-                    \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n-            {\"R_AEKeyPathCurUser\",\n-                    \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n-            {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n-            {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n-            {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n-            {\"R_keyStoreSecretPropertyDescription\",\n-                    \"The authentication secret or information needed to locate the secret.\"},\n-            {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n-            {\"R_keyStoreAuthenticationNotSet\",\n-                    \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n-            {\"R_keyStoreSecretOrLocationNotSet\",\n-                    \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n-            {\"R_keyStoreSecretNotSet\",\n-                    \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n-            {\"R_keyVaultProviderClientKeyNotSet\",\n-                    \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n-            {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\",\n-                    \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n-            {\"R_certificateStoreInvalidKeyword\",\n-                    \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreLocationNotSet\",\n-                    \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStorePlatformInvalid\",\n-                    \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n-            {\"R_invalidKeyStoreFile\",\n-                    \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n-                                                                                                                  // JKS/PKCS\n-            {\"R_invalidCEKCacheTtl\",\n-                    \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n-            {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n-            {\"R_TVPnotWorkWithSetObjectResultSet\",\n-                    \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n-            {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n-            {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n-            {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n-            {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n-            {\"R_serverPreparedStatementDiscardThreshold\",\n-                    \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n-            {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n-            {\"R_kerberosLoginFailedForUsername\",\n-                    \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n-            {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n-            {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n-            {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n-            {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n-            {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n-            {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n-            {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n-            {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n-            {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n-            {\"R_sslProtocolPropertyDescription\",\n-                    \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n-            {\"R_invalidSSLProtocol\",\n-                    \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n-            {\"R_cancelQueryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait to cancel sending a query timeout.\"},\n-            {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n-            {\"R_useBulkCopyForBatchInsertPropertyDescription\",\n-                    \"Whether the driver will use bulk copy API for batch insert operations\"},\n-            {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n-            {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n-            {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n-            {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n-            {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n-            {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\",\n-                    \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\",\n-                    \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_enclaveTypeInvalid\",\n-                    \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_attestationUrlInvalid\",\n-                    \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n-            {\"R_maxResultBufferPropertyDescription\",\n-                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n-            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n-            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\",\n-                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-//Todo new conn res from ulvii\n-            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+    /*\n+     * The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n+     * camelCasing convention and be descriptive.\n+     */\n+    // @formatter:off\n+    // Disable formatting for localization parser: use 1 line per error message and do not use \"+\"\n+    // @formatter:off\n+    static final Object[][] CONTENTS =\n+    {\n+        // LOCALIZE THIS\n+        {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n+        {\"R_invalidRoutingInfo\", \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_multipleRedirections\", \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n+        {\"R_dbMirroringWithMultiSubnetFailover\", \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n+        {\"R_dbMirroringWithReadOnlyIntent\", \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n+        {\"R_ipAddressLimitWithMultiSubnetFailover\", \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n+        {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n+        {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n+        {\"R_invalidLength\", \"The length {0} is not valid.\"},\n+        {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n+        {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n+        {\"R_notSQLServer\", \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n+        {\"R_tcpOpenFailed\", \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP connections to the port are not blocked by a firewall.\"},\n+        {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n+        {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n+        {\"R_truncatedServerResponse\", \"SQL Server returned an incomplete response. The connection has been closed.\"},\n+        {\"R_queryTimedOut\", \"The query has timed out.\"},\n+        {\"R_queryCancelled\", \"The query was canceled.\"},\n+        {\"R_errorReadingStream\", \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n+        {\"R_streamReadReturnedInvalidValue\", \"The stream read operation returned an invalid value for the amount of data read.\"},\n+        {\"R_mismatchedStreamLength\", \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n+        {\"R_notSupported\", \"This operation is not supported.\"},\n+        {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n+        {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n+        {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n+        {\"R_connectionIsClosed\", \"The connection is closed.\"},\n+        {\"R_invalidBooleanValue\", \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n+        {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n+        {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n+        {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n+        {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n+        {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n+        {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n+        {\"R_packetSizeTooBigForSSL\", \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n+        {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n+        {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n+        {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_sqlServerHoldability\", \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n+        {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n+        {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n+        {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n+        {\"R_sqlBrowserFailed\", \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n+        {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n+        {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n+        {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n+        {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n+        {\"R_noMetadata\", \"There is no metadata.\"},\n+        {\"R_resultsetClosed\", \"The result set is closed.\"},\n+        {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n+        {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n+        {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n+        {\"R_savepointNotNamed\", \"The savepoint is not named.\"},\n+        {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n+        {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n+        {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n+        {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n+        {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n+        {\"R_noResultset\", \"The statement did not return a result set.\"},\n+        {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n+        {\"R_statementIsClosed\", \"The statement is closed.\"},\n+        {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n+        {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n+        {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n+        {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n+        {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n+        {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n+        {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n+        {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n+        {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n+        {\"R_invalidOffset\", \"The offset {0} is not valid.\"},\n+        {\"R_nullConnection\", \"The connection URL is null.\"},\n+        {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n+        {\"R_cannotTakeArgumentsPreparedOrCallable\", \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n+        // Invalid conversion (e.g. MONEY to Timestamp)\n+        {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n+        // Invalid conversion to an unknown type\n+        {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n+        // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n+        {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n+        {\"R_streamIsClosed\", \"The stream is closed.\"},\n+        {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n+        {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n+        {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n+        {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n+        {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n+        {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n+        {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n+        {\"R_encodingErrorWritingTDS\", \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n+        {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n+        {\"R_requestedOpNotSupportedOnForward\", \"The requested operation is not supported on forward only result sets.\"},\n+        {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n+        {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n+        {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n+        {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n+        {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n+        {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n+        {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n+        {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n+        {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n+        {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n+        {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n+        {\"R_cantGetUpdatedColumnValue\", \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n+        {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n+        {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n+        {\"R_invalidAutoGeneratedKeys\", \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n+        {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n+        {\"R_failoverPartnerWithoutDB\", \"databaseName is required when using the failoverPartner connection property.\"},\n+        {\"R_invalidPartnerConfiguration\", \"The database {0} on server {1} is not configured for database mirroring.\"},\n+        {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n+        {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n+        {\"R_invalidpropertyValue\", \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n+        {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n+        {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n+        {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n+        {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n+        {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n+        {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n+        {\"R_sslRequiredNoServerSupport\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. The application requested encryption but the server is not configured to support SSL.\"},\n+        {\"R_sslRequiredByServer\", \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n+        {\"R_sslFailed\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n+        {\"R_certNameFailed\", \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n+        {\"R_failedToInitializeXA\", \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n+        {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n+        {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n+        {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n+        {\"R_userPropertyDescription\", \"The database user.\"},\n+        {\"R_passwordPropertyDescription\", \"The database password.\"},\n+        {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n+        {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n+        {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n+        {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n+        {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n+        {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n+        {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n+        {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n+        {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n+        {\"R_serverNameAsACEPropertyDescription\", \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n+        {\"R_sendStringParametersAsUnicodePropertyDescription\", \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n+        {\"R_multiSubnetFailoverPropertyDescription\", \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n+        {\"R_applicationNamePropertyDescription\", \"The application name for SQL Server profiling and logging tools.\"},\n+        {\"R_lastUpdateCountPropertyDescription\", \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n+        {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n+        {\"R_integratedSecurityPropertyDescription\", \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n+        {\"R_authenticationSchemePropertyDescription\", \"The authentication scheme to be used for integrated authentication.\"},\n+        {\"R_lockTimeoutPropertyDescription\", \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The number of reconnection attempts if there is a connection failure.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The number of seconds between each connection retry attempt.\"},\n+        {\"R_loginTimeoutPropertyDescription\", \"The number of seconds the driver should wait before timing out a failed connection.\"},\n+        {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n+        {\"R_xopenStatesPropertyDescription\", \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n+        {\"R_selectMethodPropertyDescription\", \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n+        {\"R_responseBufferingPropertyDescription\", \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n+        {\"R_applicationIntentPropertyDescription\", \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n+        {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n+        {\"R_failoverPartnerPropertyDescription\", \"The name of the failover server used in a database mirroring configuration.\"},\n+        {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n+        {\"R_encryptPropertyDescription\", \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n+        {\"R_socketFactoryClassPropertyDescription\", \"The class to instantiate as the SocketFactory for connections\"},\n+        {\"R_socketFactoryConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n+        {\"R_trustServerCertificatePropertyDescription\", \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n+        {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n+        {\"R_trustStorePasswordPropertyDescription\", \"The password used to check the integrity of the trust store data.\"},\n+        {\"R_trustManagerClassPropertyDescription\", \"The class to instantiate as the TrustManager for SSL connections.\"},\n+        {\"R_trustManagerConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n+        {\"R_hostNameInCertificatePropertyDescription\", \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_replicationPropertyDescription\", \"This setting tells the server if the connection is used for replication.\"},\n+        {\"R_sendTimeAsDatetimePropertyDescription\", \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n+        {\"R_TransparentNetworkIPResolutionPropertyDescription\", \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n+        {\"R_queryTimeoutPropertyDescription\", \"The number of seconds to wait before the database reports a query time-out.\"},\n+        {\"R_socketTimeoutPropertyDescription\", \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n+        {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\", \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n+        {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\", \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n+        {\"R_statementPoolingCacheSizePropertyDescription\", \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n+        {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n+        {\"R_msiClientIdPropertyDescription\", \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n+        {\"R_clientCertificatePropertyDescription\", \"Client certificate path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPasswordPropertyDescription\", \"Password for private key if the private key is password protected.\"},\n+        {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\", \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n+        {\"R_delayLoadingLobsPropertyDescription\", \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n+        {\"R_AADSecurePrincipalIdPropertyDescription\", \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n+        {\"R_AADSecurePrincipalSecretPropertyDescription\", \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n+        {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n+        {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n+        {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n+        {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n+        {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n+        {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n+        {\"R_cantSetNull\", \"Cannot set a null value.\"},\n+        {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n+        {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n+        {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n+        {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n+        {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n+        {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n+        {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n+        {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n+        {\"R_getSchemaError\", \"Error getting default schema name.\"},\n+        {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n+        {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n+        {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n+        {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n+        {\"R_featureNotSupported\", \"{0} is not supported.\"},\n+        {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n+        {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n+        {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n+        {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n+        {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n+        {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n+        {\"R_invalidDestConnection\", \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n+        {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n+        {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n+        {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n+        {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n+        {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n+        {\"R_invalidTransactionOption\", \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n+        {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n+        {\"R_BulkColumnMappingsIsEmpty\", \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n+        {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n+        {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n+        {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n+        {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n+        {\"R_UnexpectedDescribeParamFormat\", \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n+        {\"R_InvalidEncryptionKeyOrdinal\", \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n+        {\"R_MissingParamEncryptionMetadata\", \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n+        {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n+        {\"R_InvalidCipherTextSize\", \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n+        {\"R_InvalidAlgorithmVersion\", \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n+        {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n+        {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n+        {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n+        {\"R_InvalidKeySize\", \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". Verify the encrypted value of the column encryption key in the database.\"},\n+        {\"R_InvalidEncryptionType\", \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n+        {\"R_UnknownColumnEncryptionAlgorithm\", \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n+        {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n+        {\"R_UntrustedKeyPath\", \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n+        {\"R_UnrecognizedKeyStoreProviderName\", \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: {2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers used in your application are registered properly.\"},\n+        {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n+        {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n+        {\"R_UnsupportedNormalizationVersionAE\", \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n+        {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n+        {\"R_NullColumnEncryptionAlgorithmAE\", \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n+        {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n+        {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n+        {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n+        {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n+        {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n+                                                                                                       // Server\n+        {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n+        {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n+        {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n+        {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n+        {\"R_InvalidCertificateSignature\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n+        {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n+        {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithm\", \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithmInternal\", \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n+        {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n+        {\"R_CertificateNotFoundForAlias\", \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n+        {\"R_KeyStoreNotFound\", \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n+        {\"R_CustomKeyStoreProviderMapNull\", \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n+        {\"R_EmptyCustomKeyStoreProviderName\", \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n+        {\"R_InvalidCustomKeyStoreProviderName\", \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n+        {\"R_CustomKeyStoreProviderValueNull\", \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n+        {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n+        {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n+        {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n+        {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n+        {\"R_InvalidDataForAE\", \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n+        {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n+        {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n+        {\"R_FedAuthRequiredPreLoginResponseInvalidValue\", \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n+        {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\", \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n+        {\"R_FedAuthInfoInvalidOffset\", \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n+        {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n+        {\"R_FedAuthInfoLengthTooShortForData\", \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n+        {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\", \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n+        {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+        {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n+        {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n+        {\"R_FedAuthFeatureAckContainsExtraData\", \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n+        {\"R_FedAuthFeatureAckUnknownLibraryType\", \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n+        {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n+        {\"R_SetAuthenticationWhenIntegratedSecurityTrue\", \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+        {\"R_NtlmNoUserPasswordDomain\", \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n+        {\"R_SetAccesstokenWhenIntegratedSecurityTrue\", \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n+        {\"R_IntegratedAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_MSIAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_AccessTokenWithUserPassword\", \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n+        {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n+        {\"R_SetBothAuthenticationAndAccessToken\", \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n+        {\"R_NoUserPasswordForActivePassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+        {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+        {\"R_NoUserPasswordForSqlPassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalse\", \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\", \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalseRS\", \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\", \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_NullValue\", \"{0} cannot be null.\"},\n+        {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n+        {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n+        {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n+        {\"R_ManagedIdentityInitFail\", \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n+        {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n+        {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n+        {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n+        {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n+        {\"R_InvalidEcryptionAlgorithmVersion\", \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n+        {\"R_AKVKeyLengthError\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_AKVSignatureLengthError\", \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n+        {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n+        {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n+        {\"R_CEKSignatureNotMatchCMK\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n+        {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n+        {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n+        {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n+        {\"R_UnableLoadADALSqlDll\", \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n+        {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n+        {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n+        {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n+        {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n+        {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n+        {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n+        {\"R_TVPMixedSource\", \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n+        {\"R_TVPEmptyMetadata\", \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n+        {\"R_TVPInvalidValue\", \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n+        {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n+        {\"R_TVPSortOrdinalGreaterThanFieldCount\", \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n+        {\"R_TVPMissingSortOrderOrOrdinal\", \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n+        {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n+        {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n+        {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n+        // This is used for connection settings. {0}-> property name as is, {1}-> value\n+        {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n+        {\"R_InvalidWindowsCertificateStoreEncryption\", \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n+        {\"R_AEKeypathEmpty\", \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n+        {\"R_AECertpathBad\", \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertLocBad\", \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertStoreBad\", \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n+        {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n+        {\"R_AECertNotFound\", \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_AEMaloc\", \"Memory allocation failure.\"},\n+        {\"R_AEKeypathLong\", \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n+        {\"R_AEECEKLenBad\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEECEKSigLenBad\", \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEKeyPathEmptyOrReserved\", \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n+        {\"R_AEKeyPathCurUser\", \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n+        {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n+        {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n+        {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n+        {\"R_keyStoreSecretPropertyDescription\", \"The authentication secret or information needed to locate the secret.\"},\n+        {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n+        {\"R_keyStoreAuthenticationNotSet\", \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n+        {\"R_keyStoreSecretOrLocationNotSet\", \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n+        {\"R_keyStoreSecretNotSet\", \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderClientKeyNotSet\", \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\", \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n+        {\"R_certificateStoreInvalidKeyword\", \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStoreLocationNotSet\", \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStorePlatformInvalid\", \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n+        {\"R_invalidKeyStoreFile\", \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n+                                                                                                                                // JKS/PKCS\n+        {\"R_invalidCEKCacheTtl\", \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n+        {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n+        {\"R_TVPnotWorkWithSetObjectResultSet\", \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n+        {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n+        {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n+        {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n+        {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n+        {\"R_serverPreparedStatementDiscardThreshold\", \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n+        {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n+        {\"R_kerberosLoginFailedForUsername\", \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n+        {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n+        {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n+        {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n+        {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n+        {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n+        {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n+        {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n+        {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n+        {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n+        {\"R_sslProtocolPropertyDescription\", \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n+        {\"R_invalidSSLProtocol\", \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n+        {\"R_cancelQueryTimeoutPropertyDescription\", \"The number of seconds to wait to cancel sending a query timeout.\"},\n+        {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n+        {\"R_useBulkCopyForBatchInsertPropertyDescription\", \"Whether the driver will use bulk copy API for batch insert operations\"},\n+        {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n+        {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n+        {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+        {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n+        {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n+        {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n+        {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n+        {\"R_keyVaultProviderClientIdPropertyDescription\", \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyVaultProviderClientKeyPropertyDescription\", \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+        {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+        {\"R_DLLandMSALMissing\", \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+        {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+        {\"R_MSITokenFailureImdsClientId\", \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+        {\"R_MSITokenFailureUnexpected\", \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+        {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+        {\"R_propertyNotSupported\", \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+        {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+        {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+        {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+        {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+        {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+        {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+        {\"R_useFmtOnlyPropertyDescription\", \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+        {\"R_invalidOpenqueryCall\", \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+        {\"R_invalidCTEFormat\", \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+        {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+        {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+        {\"R_invalidInsertValuesQuery\", \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+        {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+        {\"R_enclaveNotSupported\", \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclavePropertiesError\", \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclaveResponseLengthError\", \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePackageLengthError\", \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePKLengthError\", \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+        {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+        {\"R_HealthCertError\", \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidHealthCert\", \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidSignedStatement\", \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidDHKeySignature\", \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+        {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+        {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+        {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+        {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+        {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+        {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+        {\"R_InvalidCSVQuotes\", \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+        {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+        {\"R_maxResultBufferPropertyDescription\", \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+        {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+        {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+        {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n     };\n }\n+// @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 278197bc..3e3ba8e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,6 +489,14 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 3e3ba8e9..054cab87 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,14 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 054cab87..76210ff7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +489,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 76210ff7..02224d0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,15 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b32966371c5da329e3f8414b66b28fb3635ab646", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 02224d0a..5929f5c3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +491,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 5929f5c3..4f80d4f4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,4 +502,4 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n-// @formatter:on\n\\ No newline at end of file\n+// @formatter:on\n", "next_change": {"commit": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4f80d4f4..ffe08fbe 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -500,6 +500,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex ffe08fbe..2240bd47 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -501,6 +501,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 2240bd47..f1186553 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n+        {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex f1186553..da1b8d3d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n", "next_change": {"commit": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex da1b8d3d..bb98b34d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -507,6 +507,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex bb98b34d..c178c31e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -506,7 +506,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n-        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n", "next_change": {"commit": "0c703a74888da1897d2feb261d0ca91693caa422", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex c178c31e..85d91df1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -508,6 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n+        {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 85d91df1..be53aadd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,6 +519,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex be53aadd..fcab79f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -520,6 +515,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex fcab79f5..b264d3db 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -514,7 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n-        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b264d3db..96bd1847 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,7 +516,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n-        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "8412f0fd7c104853cefe5c744911737f31e9d57b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 96bd1847..d4634ae8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -517,6 +532,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_AmbiguousRowUpdate\", \"Failed to execute updateRow(). The update is attempting an ambiguous update on tables \\\"{0}\\\" and \\\"{1}\\\". Ensure all columns being updated prior to the updateRow() call belong to the same table.\"},\n         {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "79cef888c070a270ef09411ca2e86b7d2cad1365", "committedDate": "2018-10-05 17:48:08 -0700", "message": "Add "}, {"oid": "cc192d36986c1c13fda64f1fa9f2e141e822d26d", "committedDate": "2018-11-08 16:33:58 -0800", "message": "reconnect thread and part of the session recovery writing"}, {"oid": "dfb4cadc777b3cd9e9217a5c08721b455dba4442", "committedDate": "2018-11-08 16:43:24 -0800", "message": "Revert \"reconnect thread and part of the session recovery writing\""}, {"oid": "252cbfc41198e3412558f359cef8b220f5bad546", "committedDate": "2018-11-09 10:58:10 -0800", "message": "adding resource"}, {"oid": "4877145e9dbc6a1178aa688afe5a14876db5a65f", "committedDate": "2018-11-09 11:48:16 -0800", "message": "another resource"}, {"oid": "503076fe213e018506f690177c32011f8ec22b62", "committedDate": "2018-11-09 15:41:30 -0800", "message": "adding resource"}, {"oid": "0170f891a15e70c7bf10af283f35a4a55e42a874", "committedDate": "2018-11-13 18:17:55 -0800", "message": "Fix "}, {"oid": "af76d7af3846801be86f7f94fbc3318b1ed5bc04", "committedDate": "2020-10-14 17:55:14 -0700", "message": "Make adal4j test dependency only (#1447)"}, {"oid": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "committedDate": "2020-11-19 12:24:40 -0800", "message": "Feature "}, {"oid": "d9909748368af7d2944dab4fa382ee513f2b76f4", "committedDate": "2020-11-27 14:25:58 -0800", "message": "Add maxResultBuffer property (#1431)"}, {"oid": "bd776c2b48691897cee900cc6e821d171f18513a", "committedDate": "2020-11-27 17:53:56 -0800", "message": "Added support for ActiveDirectoryInteractive authentication (#1464)"}, {"oid": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "committedDate": "2021-03-19 14:20:41 -0700", "message": "Open Connection Retry (#1535)"}, {"oid": "50b9fdb1f61ad2c53fc73077f6a39873f36158c4", "committedDate": "2021-04-23 17:18:23 -0700", "message": "Adding replication connection option (#1566)"}, {"oid": "b97172c148b90d5ea23cfce239606c722ec7ab9f", "committedDate": "2021-05-25 14:43:02 -0700", "message": "Update error messages for Enclave exceptions with forward link to troubleshooting guide (#1585)"}, {"oid": "fb15da6ed2b8e9c754f23a17d1c7fcd5a4611f2f", "committedDate": "2021-06-04 16:19:00 -0700", "message": "Add optional realm connection string property for Kerberos authentication (#1581)"}, {"oid": "21b8ec1ac90884ca7c83b7a79a08bf78702b52bb", "committedDate": "2021-06-14 13:17:54 -0700", "message": "Fix multiple, successive connections using AKV provider (#1594)"}, {"oid": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "committedDate": "2021-07-07 11:22:07 -0700", "message": "Integration of old code"}, {"oid": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "committedDate": "2021-07-15 18:13:18 -0700", "message": "Updated formatter to enable on/off tags and re-formatted error strings for localization parser (#1618)"}, {"oid": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "committedDate": "2021-08-12 10:20:32 -0700", "message": "Catching up to dev, 9.5, fixing merge conflicts"}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "b08500889f68eff2ba740b29c644980398c68003", "committedDate": "2021-09-02 20:12:20 -0700", "message": "Integrated new disconnected docket detection"}, {"oid": "11990186d8cdcd41d6192702805ece43134eb1ba", "committedDate": "2021-09-22 11:25:29 -0700", "message": "Catching up to dev"}, {"oid": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "committedDate": "2021-10-01 14:42:11 -0700", "message": "Delete yml (moved CI https://sqlclientdrivers.visualstudio.com/public) and minor changes for error msg (#1655)"}, {"oid": "b32966371c5da329e3f8414b66b28fb3635ab646", "committedDate": "2021-10-05 01:48:45 -0700", "message": "Catching up to upstream dev"}, {"oid": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "committedDate": "2021-11-03 11:46:28 -0700", "message": "Many code review fixes"}, {"oid": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "committedDate": "2021-11-23 14:40:40 -0800", "message": "New Exception Message (#1683)"}, {"oid": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "committedDate": "2021-11-30 08:52:27 -0800", "message": "Default encryption to true and fixed tests (#1697)"}, {"oid": "ab6abfab8c54450d6f534004b55a2f105f456982", "committedDate": "2021-12-01 11:21:10 -0800", "message": "Deprecate and Rename Service principal connection properties (#1693)"}, {"oid": "2183493a32286449713323335335232515ea1404", "committedDate": "2021-12-15 11:24:42 -0800", "message": "SQLServerBulkCopy: Added target field name to conversion error message (#1712)"}, {"oid": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "committedDate": "2022-03-04 09:55:44 -0800", "message": "Added new connection string property prepareMethod to toggle use of sp_prepare (#1719)"}, {"oid": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "committedDate": "2022-03-29 10:52:14 -0700", "message": "Add serverCertificate connection property for encrypt=strict (#1773)"}, {"oid": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "committedDate": "2022-03-30 11:42:09 -0700", "message": "Add Configurable IPv6 Support (#1766)"}, {"oid": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "committedDate": "2022-03-31 10:25:33 -0700", "message": "Add encrypt utility to obfuscate password strings (#1780)"}, {"oid": "0042429113f117c9b7118e67c13d430e0ba3bcde", "committedDate": "2022-04-12 12:36:10 -0700", "message": "Add ALPN for TDSS connections (#1795)"}, {"oid": "76941b78626836ed677d9dcce97be432ae8e8b86", "committedDate": "2022-04-29 11:58:49 -0700", "message": "warnings (#1819)"}, {"oid": "0c703a74888da1897d2feb261d0ca91693caa422", "committedDate": "2022-04-29 12:05:09 -0700", "message": "added check for ALPN (#1818)"}, {"oid": "7ffc2f0b5c7b88269c7603f5e3faeb1470fd44ea", "committedDate": "2022-05-26 12:09:57 -0700", "message": "Managed Identity token cache (#1825)"}, {"oid": "a41722291b05eb2ab80ce8753b0879e721f006a2", "committedDate": "2022-06-22 09:41:50 -0700", "message": "Cache Parameter Metadata (#1845)"}, {"oid": "274a46274d7cb35dae7079da119e7308d4e65726", "committedDate": "2022-07-18 13:48:46 -0700", "message": "Added validation for serverName field (#1856)"}, {"oid": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "committedDate": "2022-07-20 15:30:18 -0700", "message": "Added check for DONE_ERROR status token and throw appropriate exception (#1857)"}, {"oid": "87b092e754556c501f75496f241985725b9c56ba", "committedDate": "2022-07-20 17:08:50 -0700", "message": "Cache parameter metadata secure (#1866)"}, {"oid": "bc302702b4e5d4da276ed78c96c8da2045218e65", "committedDate": "2022-08-16 12:39:18 -0700", "message": "Fixed query cancellation bug that intermittently occurs in batch queries (#1897)"}, {"oid": "51dabe33ec44def2d7c14772419bbccee64427f7", "committedDate": "2022-08-22 13:19:17 -0700", "message": "Fixed callable statement index out of bounds error; Fixed parameter not defined error (#1898)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "committedDate": "2022-11-02 11:21:29 -0700", "message": "Check for error in DONE token when fetching result sets (#1943)"}, {"oid": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "committedDate": "2022-11-03 15:21:54 -0700", "message": "Access token callback (#1940)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "b79396d699d9fa76fd704ce084230647facb1018", "committedDate": "2022-11-25 10:20:37 -0800", "message": "More changes to address sonarqube warnings (#1974)"}, {"oid": "45c606fdfb9c103e093c5ae7424f01e2d5d403f2", "committedDate": "2022-12-21 13:50:32 -0800", "message": "Fixes #1590 - [FEATURE REQUEST] Ability to explicitly specify conversion to datetime or datetime2  (#1687)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e4bc368034ae5421c4e0215bf82335eb36b2aeac", "committedDate": "2023-02-16 13:06:32 -0800", "message": "Updated supportsTransactions method (#2075)"}, {"oid": "d0ab1a587377dd64d7c45e07e959b4857f39bb77", "committedDate": "2023-02-21 11:36:13 -0800", "message": "Added access token callback class connection string property (#2073)"}, {"oid": "8412f0fd7c104853cefe5c744911737f31e9d57b", "committedDate": "2023-03-07 14:44:14 -0800", "message": "Passing table name to sp_cursor call (#2087)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5NDIyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499794226", "body": "If only HTTPS supported lets change this to  `if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {`", "bodyText": "If only HTTPS supported lets change this to  if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "bodyHTML": "<p dir=\"auto\">If only HTTPS supported lets change this to  <code>if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {</code></p>", "author": "ulvii", "createdAt": "2020-10-05T18:35:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex a51340d1..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -57,7 +58,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": {"commit": "338f48051d001bf324b2a90de757c3572a6883c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex c9f85e23..fe4935e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -58,7 +58,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex fe4935e9..e4aae163 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -58,7 +57,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": {"commit": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex e4aae163..a51340d1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -57,7 +57,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": {"commit": "2bf012bdab01468aec967f17b8ae9bef86958deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex a51340d1..e4aae163 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -57,7 +57,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": {"commit": "7a035c6333044677e99dbc96114959c49e10e954", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex e4aae163..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -57,7 +58,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex a51340d1..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -57,7 +58,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499800864", "body": "Please change this to multi-line comment.", "bodyText": "Please change this to multi-line comment.", "bodyHTML": "<p dir=\"auto\">Please change this to multi-line comment.</p>", "author": "ulvii", "createdAt": "2020-10-05T18:47:42Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultTokenCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.authenticationCallback = null;\n+    }\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param authenticationCallback The authentication callback that gets invoked when an access token is requested.\n+     */\n+    KeyVaultTokenCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+        this.clientId = null;\n+        this.clientSecret = null;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNDg1OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499904859", "bodyText": "Not resolved.", "author": "ulvii", "createdAt": "2020-10-05T22:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNTI4MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r500505280", "bodyText": "sorry you're right, this change isn't merged to this PR yet..", "author": "lilgreenbird", "createdAt": "2020-10-06T18:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -80,9 +79,11 @@ class KeyVaultTokenCredential implements TokenCredential {\n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n         if (null != authenticationCallback) {\n-            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n-            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n-            // token each time it's invoked.\n+            /*\n+             * If the callback is not null, invoke the callback to get the token. This gets invoked each time this\n+             * method is called and will not cache the token. It's the callback's responsibility to return a valid token\n+             * each time it's invoked.\n+             */\n             String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n             return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n         }\n", "next_change": {"commit": "338f48051d001bf324b2a90de757c3572a6883c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 06c09be4..fb11377f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -79,27 +75,14 @@ class KeyVaultTokenCredential implements TokenCredential {\n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n         if (null != authenticationCallback) {\n-            /*\n-             * If the callback is not null, invoke the callback to get the token. This gets invoked each time this\n-             * method is called and will not cache the token. It's the callback's responsibility to return a valid token\n-             * each time it's invoked.\n-             */\n             String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n             return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n         }\n \n-        // gets the token from MSAL\n         return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n                 .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    /**\n-     * Sets the authority that will be used for authentication.\n-     *\n-     * @param authorization\n-     *        The name of the authorization.\n-     * @return The updated {@link KeyVaultTokenCredential} instance.\n-     */\n     KeyVaultTokenCredential setAuthorization(String authorization) {\n         if (null != this.authorization && this.authorization.equals(authorization)) {\n             return this;\n", "next_change": {"commit": "9010b5fc89ddc188b425e303a0f99f6429203852", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex fb11377f..de46eed3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -75,14 +80,24 @@ class KeyVaultTokenCredential implements TokenCredential {\n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n         if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n+            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n+            // token each time it's invoked.\n             String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n             return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n         }\n \n+        // gets the token from MSAL\n         return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n                 .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n+    /**\n+     * Sets the authority that will be used for authentication.\n+     *\n+     * @param authorization The name of the authorization.\n+     * @return The updated {@link KeyVaultTokenCredential} instance.\n+     */\n     KeyVaultTokenCredential setAuthorization(String authorization) {\n         if (null != this.authorization && this.authorization.equals(authorization)) {\n             return this;\n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..6079c30b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -95,7 +96,8 @@ class KeyVaultTokenCredential implements TokenCredential {\n     /**\n      * Sets the authority that will be used for authentication.\n      *\n-     * @param authorization The name of the authorization.\n+     * @param authorization\n+     *        The name of the authorization.\n      * @return The updated {@link KeyVaultTokenCredential} instance.\n      */\n     KeyVaultTokenCredential setAuthorization(String authorization) {\n", "next_change": {"commit": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 6079c30b..65eb9d59 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -96,8 +93,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n     /**\n      * Sets the authority that will be used for authentication.\n      *\n-     * @param authorization\n-     *        The name of the authorization.\n+     * @param authorization The name of the authorization.\n      * @return The updated {@link KeyVaultTokenCredential} instance.\n      */\n     KeyVaultTokenCredential setAuthorization(String authorization) {\n", "next_change": {"commit": "2bf012bdab01468aec967f17b8ae9bef86958deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 65eb9d59..207d3149 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -93,7 +96,8 @@ class KeyVaultTokenCredential implements TokenCredential {\n     /**\n      * Sets the authority that will be used for authentication.\n      *\n-     * @param authorization The name of the authorization.\n+     * @param authorization\n+     *        The name of the authorization.\n      * @return The updated {@link KeyVaultTokenCredential} instance.\n      */\n     KeyVaultTokenCredential setAuthorization(String authorization) {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -80,9 +79,11 @@ class KeyVaultTokenCredential implements TokenCredential {\n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n         if (null != authenticationCallback) {\n-            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n-            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n-            // token each time it's invoked.\n+            /*\n+             * If the callback is not null, invoke the callback to get the token. This gets invoked each time this\n+             * method is called and will not cache the token. It's the callback's responsibility to return a valid token\n+             * each time it's invoked.\n+             */\n             String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n             return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n         }\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNjUxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499806511", "body": "For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.", "bodyText": "For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.", "bodyHTML": "<p dir=\"auto\">For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.</p>", "author": "ulvii", "createdAt": "2020-10-05T18:58:11Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -30,7 +29,6 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": {"commit": "338f48051d001bf324b2a90de757c3572a6883c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 06c09be4..fb11377f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -29,6 +30,7 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": {"commit": "da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex fb11377f..0593bb83 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -30,7 +29,6 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -30,7 +29,6 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 06c09be4..3bedc589 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -29,6 +29,8 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n+    private static final String NULL_VALUE = \"R_NullValue\";\n+\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MDg4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499850889", "body": "Could you explain why we log a warning here instead of an exception?  ", "bodyText": "Could you explain why we log a warning here instead of an exception?", "bodyHTML": "<p dir=\"auto\">Could you explain why we log a warning here instead of an exception?</p>", "author": "ulvii", "createdAt": "2020-10-05T20:23:56Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultTokenCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.authenticationCallback = null;\n+    }\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param authenticationCallback The authentication callback that gets invoked when an access token is requested.\n+     */\n+    KeyVaultTokenCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+        this.clientId = null;\n+        this.clientSecret = null;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n+            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n+            // token each time it's invoked.\n+            String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n+            return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n+        }\n+\n+        // gets the token from MSAL\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    /**\n+     * Sets the authority that will be used for authentication.\n+     *\n+     * @param authorization The name of the authorization.\n+     * @return The updated {@link KeyVaultTokenCredential} instance.\n+     */\n+    KeyVaultTokenCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    /**\n+     * Creates an instance of {@link ConfidentialClientApplication} using the provided client id and secret.\n+     *\n+     * @return An instance of {@link ConfidentialClientApplication}.\n+     */\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authorization\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        // Create the credential using the MSAL factory method.\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    /**\n+     * Attempts to get the access token from the client cache if it's not expired. If it's expired this returns an\n+     * empty response.\n+     * @param request The context for requesting the token including the scope.\n+     * @return The cached access token if it's not expired.\n+     */\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMDczOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499900738", "bodyText": "it doesn't it's actually throwing a RuntimeException and doesn't need to be logged as that's a fatal error", "author": "lilgreenbird", "createdAt": "2020-10-05T22:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MDg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -157,7 +161,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n             try {\n                 return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+                return getFailedCompletableFuture(new RuntimeException(e));\n             }\n         }).map(ar -> new AccessToken(ar.accessToken(),\n                 OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n", "next_change": {"commit": "338f48051d001bf324b2a90de757c3572a6883c7", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 06c09be4..fb11377f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -161,32 +130,18 @@ class KeyVaultTokenCredential implements TokenCredential {\n             try {\n                 return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(new RuntimeException(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n         }).map(ar -> new AccessToken(ar.accessToken(),\n                 OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n     }\n \n-    /**\n-     * If fetching the token resulted in an error, this method returns the error wrapped in a completable future.\n-     * \n-     * @param e\n-     *        The original exception.\n-     * @return A {@link CompletableFuture} that completes with an error.\n-     */\n     private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n         CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n         completableFuture.completeExceptionally(e);\n         return completableFuture;\n     }\n \n-    /**\n-     * Attempts to get the access token from the {@link ConfidentialClientApplication} for the requested scope.\n-     * \n-     * @param request\n-     *        The context for requesting the token that includes the scope.\n-     * @return The access token.\n-     */\n     private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n         return Mono\n                 .fromFuture(() -> confidentialClientApplication\n", "next_change": {"commit": "9010b5fc89ddc188b425e303a0f99f6429203852", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex fb11377f..de46eed3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -136,12 +163,22 @@ class KeyVaultTokenCredential implements TokenCredential {\n                 OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n     }\n \n+    /**\n+     * If fetching the token resulted in an error, this method returns the error wrapped in a completable future.\n+     * @param e The original exception.\n+     * @return A {@link CompletableFuture} that completes with an error.\n+     */\n     private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n         CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n         completableFuture.completeExceptionally(e);\n         return completableFuture;\n     }\n \n+    /**\n+     * Attempts to get the access token from the {@link ConfidentialClientApplication} for the requested scope.\n+     * @param request The context for requesting the token that includes the scope.\n+     * @return The access token.\n+     */\n     private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n         return Mono\n                 .fromFuture(() -> confidentialClientApplication\n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..6079c30b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -176,7 +182,9 @@ class KeyVaultTokenCredential implements TokenCredential {\n \n     /**\n      * Attempts to get the access token from the {@link ConfidentialClientApplication} for the requested scope.\n-     * @param request The context for requesting the token that includes the scope.\n+     * \n+     * @param request\n+     *        The context for requesting the token that includes the scope.\n      * @return The access token.\n      */\n     private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n", "next_change": {"commit": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 6079c30b..65eb9d59 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -182,9 +174,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n \n     /**\n      * Attempts to get the access token from the {@link ConfidentialClientApplication} for the requested scope.\n-     * \n-     * @param request\n-     *        The context for requesting the token that includes the scope.\n+     * @param request The context for requesting the token that includes the scope.\n      * @return The access token.\n      */\n     private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n", "next_change": {"commit": "2bf012bdab01468aec967f17b8ae9bef86958deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 65eb9d59..207d3149 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -174,7 +182,9 @@ class KeyVaultTokenCredential implements TokenCredential {\n \n     /**\n      * Attempts to get the access token from the {@link ConfidentialClientApplication} for the requested scope.\n-     * @param request The context for requesting the token that includes the scope.\n+     * \n+     * @param request\n+     *        The context for requesting the token that includes the scope.\n      * @return The access token.\n      */\n     private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex fb11377f..de46eed3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -150,10 +187,18 @@ class KeyVaultTokenCredential implements TokenCredential {\n                         OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Sets the resource name.\n+     * @param resource The resource name.\n+     */\n     void setResource(String resource) {\n         this.resource = resource;\n     }\n \n+    /**\n+     * Sets the scope for the access token.\n+     * @param scope The scope for the access token.\n+     */\n     void setScope(String scope) {\n         this.scope = scope;\n     }\n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..6079c30b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -197,7 +207,9 @@ class KeyVaultTokenCredential implements TokenCredential {\n \n     /**\n      * Sets the scope for the access token.\n-     * @param scope The scope for the access token.\n+     * \n+     * @param scope\n+     *        The scope for the access token.\n      */\n     void setScope(String scope) {\n         this.scope = scope;\n", "next_change": {"commit": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 6079c30b..65eb9d59 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -207,9 +195,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n \n     /**\n      * Sets the scope for the access token.\n-     * \n-     * @param scope\n-     *        The scope for the access token.\n+     * @param scope The scope for the access token.\n      */\n     void setScope(String scope) {\n         this.scope = scope;\n", "next_change": {"commit": "2bf012bdab01468aec967f17b8ae9bef86958deb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 65eb9d59..207d3149 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -195,7 +207,9 @@ class KeyVaultTokenCredential implements TokenCredential {\n \n     /**\n      * Sets the scope for the access token.\n-     * @param scope The scope for the access token.\n+     * \n+     * @param scope\n+     *        The scope for the access token.\n      */\n     void setScope(String scope) {\n         this.scope = scope;\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -157,7 +161,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n             try {\n                 return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+                return getFailedCompletableFuture(new RuntimeException(e));\n             }\n         }).map(ar -> new AccessToken(ar.accessToken(),\n                 OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzMxMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499853313", "body": "These variables shouldn't be public.", "bodyText": "These variables shouldn't be public.", "bodyHTML": "<p dir=\"auto\">These variables shouldn't be public.</p>", "author": "ulvii", "createdAt": "2020-10-05T20:28:23Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -51,29 +56,35 @@\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    public static final int KEY_NAME_INDEX = 4;", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -56,9 +55,9 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    public static final int KEY_NAME_INDEX = 4;\n-    public static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n-    public static final String KEY_URL_DELIMITER = \"/\";\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n     private HttpPipeline keyVaultPipeline;\n     private KeyVaultTokenCredential keyVaultTokenCredential;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -56,9 +55,9 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    public static final int KEY_NAME_INDEX = 4;\n-    public static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n-    public static final String KEY_URL_DELIMITER = \"/\";\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n     private HttpPipeline keyVaultPipeline;\n     private KeyVaultTokenCredential keyVaultTokenCredential;\n \n", "next_change": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..3b31812a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -58,6 +58,8 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private static final int KEY_NAME_INDEX = 4;\n     private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n     private static final String KEY_URL_DELIMITER = \"/\";\n+    private static final String NULL_VALUE = \"R_NullValue\";\n+\n     private HttpPipeline keyVaultPipeline;\n     private KeyVaultTokenCredential keyVaultTokenCredential;\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NzE2MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499857161", "body": "Please revert the changes to this file.", "bodyText": "Please revert the changes to this file.", "bodyHTML": "<p dir=\"auto\">Please revert the changes to this file.</p>", "author": "ulvii", "createdAt": "2020-10-05T20:35:55Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java", "diffHunk": "@@ -1,26 +1,26 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-/**\n- * Provides a callback delegate which is to be implemented by the client code\n- * \n- */\n-public interface SQLServerKeyVaultAuthenticationCallback {\n-\n-    /**\n-     * Returns the acesss token of the authentication request\n-     * \n-     * @param authority\n-     *        - Identifier of the authority, a URL.\n-     * @param resource\n-     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-     * @param scope\n-     *        - The scope of the authentication request.\n-     * @return access token\n-     */\n-    String getAccessToken(String authority, String resource, String scope);\n-}\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+/**\r\n+ * Provides a callback delegate which is to be implemented by the client code\r\n+ *\r\n+ */\r\n+public interface SQLServerKeyVaultAuthenticationCallback {\r\n+\r\n+        /**\r", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\nindex 21199c58..4a954388 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n", "chunk": "@@ -11,16 +11,16 @@ package com.microsoft.sqlserver.jdbc;\n  */\n public interface SQLServerKeyVaultAuthenticationCallback {\n \n-        /**\n-         * Returns the acesss token of the authentication request\n-         *\n-         * @param authority\n-         *        - Identifier of the authority, a URL.\n-         * @param resource\n-         *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-         * @param scope\n-         *        - The scope of the authentication request.\n-         * @return access token\n-         */\n-        String getAccessToken(String authority, String resource, String scope);\n+    /**\n+     * Returns the acesss token of the authentication request\n+     *\n+     * @param authority\n+     *        - Identifier of the authority, a URL.\n+     * @param resource\n+     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n+     * @param scope\n+     *        - The scope of the authentication request.\n+     * @return access token\n+     */\n+    String getAccessToken(String authority, String resource, String scope);\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\nindex 21199c58..4a954388 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n", "chunk": "@@ -11,16 +11,16 @@ package com.microsoft.sqlserver.jdbc;\n  */\n public interface SQLServerKeyVaultAuthenticationCallback {\n \n-        /**\n-         * Returns the acesss token of the authentication request\n-         *\n-         * @param authority\n-         *        - Identifier of the authority, a URL.\n-         * @param resource\n-         *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-         * @param scope\n-         *        - The scope of the authentication request.\n-         * @return access token\n-         */\n-        String getAccessToken(String authority, String resource, String scope);\n+    /**\n+     * Returns the acesss token of the authentication request\n+     *\n+     * @param authority\n+     *        - Identifier of the authority, a URL.\n+     * @param resource\n+     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n+     * @param scope\n+     *        - The scope of the authentication request.\n+     * @return access token\n+     */\n+    String getAccessToken(String authority, String resource, String scope);\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"oid": "338f48051d001bf324b2a90de757c3572a6883c7", "url": "https://github.com/microsoft/mssql-jdbc/commit/338f48051d001bf324b2a90de757c3572a6883c7", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-10-05T20:58:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3OTMyOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499879328", "body": "No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.", "bodyText": "No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.", "bodyHTML": "<p dir=\"auto\">No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.</p>", "author": "ulvii", "createdAt": "2020-10-05T21:21:03Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -124,56 +198,43 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n+     *\n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -173,38 +168,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         setCredential(tokenCredential);\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     *\n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "9010b5fc89ddc188b425e303a0f99f6429203852", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 47b9da5e..d7067523 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -180,6 +207,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d7067523..aae4be84 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -207,7 +185,6 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -173,38 +168,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         setCredential(tokenCredential);\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     *\n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..3b31812a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -183,7 +185,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(NULL_VALUE));\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 3b31812a..53d58b8c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,6 +274,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 53d58b8c..5f0b5395 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -273,8 +274,10 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n+     *         \n+     * @deprecated\n      */\n-    @Deprecated\n+    @Deprecated(since = \"12.1.0\", forRemoval = true)\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "e487251f14df934f77491e38824abb73d60d52cc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 5f0b5395..33fb520b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -274,7 +274,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n-     *         \n+     * \n      * @deprecated\n      */\n     @Deprecated(since = \"12.1.0\", forRemoval = true)\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3ODE2NQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499878165", "body": "Do we need to deprecate this public interface? If so, why?\r\n\r\nI do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?", "bodyText": "Do we need to deprecate this public interface? If so, why?\nI do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?", "bodyHTML": "<p dir=\"auto\">Do we need to deprecate this public interface? If so, why?</p>\n<p dir=\"auto\">I do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?</p>", "author": "David-Engel", "createdAt": "2020-10-05T21:18:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -124,56 +198,43 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n+     *\n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMTEyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499901124", "bodyText": "no it doesn't anymore, I've removed that", "author": "lilgreenbird", "createdAt": "2020-10-05T22:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3ODE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -173,38 +168,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         setCredential(tokenCredential);\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     *\n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "9010b5fc89ddc188b425e303a0f99f6429203852", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 47b9da5e..d7067523 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -180,6 +207,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d7067523..aae4be84 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -207,7 +185,6 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -173,38 +168,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         setCredential(tokenCredential);\n     }\n \n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     *\n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..3b31812a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -183,7 +185,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(NULL_VALUE));\n             Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 3b31812a..53d58b8c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,6 +274,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 53d58b8c..5f0b5395 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -273,8 +274,10 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n+     *         \n+     * @deprecated\n      */\n-    @Deprecated\n+    @Deprecated(since = \"12.1.0\", forRemoval = true)\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "e487251f14df934f77491e38824abb73d60d52cc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 5f0b5395..33fb520b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -274,7 +274,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n-     *         \n+     * \n      * @deprecated\n      */\n     @Deprecated(since = \"12.1.0\", forRemoval = true)\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"oid": "9010b5fc89ddc188b425e303a0f99f6429203852", "url": "https://github.com/microsoft/mssql-jdbc/commit/9010b5fc89ddc188b425e303a0f99f6429203852", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-10-05T22:00:52Z", "type": "commit"}, {"oid": "da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "url": "https://github.com/microsoft/mssql-jdbc/commit/da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "message": "updates", "committedDate": "2020-10-05T22:04:41Z", "type": "commit"}, {"oid": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "url": "https://github.com/microsoft/mssql-jdbc/commit/0d509af9f2c34faf3eb5636654af974d1e5528f5", "message": "Merge pull request #5 from lilgreenbird/msal\n\ncleanup and exclude lib", "committedDate": "2020-10-05T22:08:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMDgxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499900810", "body": "This test should not be removed, it is the only test thats actually using `SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback)`. ", "bodyText": "This test should not be removed, it is the only test thats actually using SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback).", "bodyHTML": "<p dir=\"auto\">This test should not be removed, it is the only test thats actually using <code>SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback)</code>.</p>", "author": "ulvii", "createdAt": "2020-10-05T22:12:09Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java", "diffHunk": "@@ -128,7 +121,7 @@ public void testFedAuthWithAE_AKV() throws SQLException {\n             dropCMK(stmt, cmkName3);\r\n             setupCMK_AKVOld(cmkName3, stmt);\r\n \r\n-            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\r", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 573500cd..4193c9a6 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -121,7 +128,7 @@ public class FedauthWithAE extends FedauthCommon {\n             dropCMK(stmt, cmkName3);\n             setupCMK_AKVOld(cmkName3, stmt);\n \n-            createCEK(cmkName3, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n+            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n             createCharTable(stmt, charTableOld);\n \n             populateCharNormalCase(charValues, connection, charTableOld);\n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 4193c9a6..573500cd 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -128,7 +121,7 @@ public class FedauthWithAE extends FedauthCommon {\n             dropCMK(stmt, cmkName3);\n             setupCMK_AKVOld(cmkName3, stmt);\n \n-            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n+            createCEK(cmkName3, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n             createCharTable(stmt, charTableOld);\n \n             populateCharNormalCase(charValues, connection, charTableOld);\n", "next_change": {"commit": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 573500cd..4193c9a6 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -121,7 +128,7 @@ public class FedauthWithAE extends FedauthCommon {\n             dropCMK(stmt, cmkName3);\n             setupCMK_AKVOld(cmkName3, stmt);\n \n-            createCEK(cmkName3, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n+            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n             createCharTable(stmt, charTableOld);\n \n             populateCharNormalCase(charValues, connection, charTableOld);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 573500cd..4193c9a6 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -121,7 +128,7 @@ public class FedauthWithAE extends FedauthCommon {\n             dropCMK(stmt, cmkName3);\n             setupCMK_AKVOld(cmkName3, stmt);\n \n-            createCEK(cmkName3, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n+            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n             createCharTable(stmt, charTableOld);\n \n             populateCharNormalCase(charValues, connection, charTableOld);\n", "next_change": {"commit": "cd78ffe7b94f194540671a16b510e663b2b904ba", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 4193c9a6..a34d4ee3 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -108,39 +102,28 @@ public class FedauthWithAE extends FedauthCommon {\n         try (Connection connection = ds.getConnection(); Statement stmt = connection.createStatement()) {\n             callDbccFreeProcCache();\n \n-            TestUtils.dropTableIfExists(charTableNew, stmt);\n+            TestUtils.dropTableIfExists(charTableAKV, stmt);\n             dropCEK(stmt);\n             dropCMK(stmt, cmkName2);\n-            setupCMK_AKVNew(cmkName2, stmt);\n+            setupCMK_AKV(cmkName2, stmt);\n \n-            createCEK(cmkName2, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n-            createCharTable(stmt, charTableNew);\n+            createCEK(cmkName2, setupKeyStoreProvider_AKV(), stmt, keyIDs[0]);\n+            createCharTable(stmt, charTableAKV);\n \n-            populateCharNormalCase(charValues, connection, charTableNew);\n-            testChar(charValues, stmt, charTableNew);\n+            populateCharNormalCase(charValues, connection, charTableAKV);\n+            testChar(charValues, stmt, charTableAKV);\n \n-            TestUtils.dropTableIfExists(charTableNew, stmt);\n+            TestUtils.dropTableIfExists(charTableAKV, stmt);\n             dropCEK(stmt);\n             dropCMK(stmt, cmkName2);\n \n             callDbccFreeProcCache();\n-\n-            dropCMK(stmt, cmkName3);\n-            setupCMK_AKVOld(cmkName3, stmt);\n-\n-            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n-            createCharTable(stmt, charTableOld);\n-\n-            populateCharNormalCase(charValues, connection, charTableOld);\n-            testChar(charValues, stmt, charTableOld);\n-\n         } catch (SQLServerException e) {\n             fail(e.getMessage());\n         } finally {\n             if (null != ds) {\n                 try (Connection connection = ds.getConnection(); Statement stmt = connection.createStatement()) {\n-                    TestUtils.dropTableIfExists(charTableOld, stmt);\n-                    TestUtils.dropTableIfExists(charTableNew, stmt);\n+                    TestUtils.dropTableIfExists(charTableAKV, stmt);\n                     dropCEK(stmt);\n                     dropCMK(stmt, cmkName1);\n                     dropCMK(stmt, cmkName2);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "committedDate": "2021-11-30 08:52:27 -0800", "message": "Default encryption to true and fixed tests (#1697)"}, {"oid": "cd78ffe7b94f194540671a16b510e663b2b904ba", "committedDate": "2021-12-29 10:41:41 -0800", "message": "Update versions and remove ADAL dependency (#1726)"}, {"oid": "887cf6f1665b08cdd61df7f3f8c35153ce397011", "committedDate": "2022-03-16 11:59:53 -0700", "message": "TDSS Support (#1757)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjcwMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499906703", "body": "What is the actual exception type here? is it being thrown as SQLServerException?", "bodyText": "What is the actual exception type here? is it being thrown as SQLServerException?", "bodyHTML": "<p dir=\"auto\">What is the actual exception type here? is it being thrown as SQLServerException?</p>", "author": "ulvii", "createdAt": "2020-10-05T22:28:53Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -299,7 +300,9 @@ public void testNumericAkvWithBadCred() throws SQLException {\n             testNumericAKV(connStr);\r\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\r\n         } catch (Exception e) {\r\n-            assert (e.getMessage().contains(\"AuthenticationException\"));\r\n+            assertTrue(e.getCause() instanceof MsalServiceException);\r", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b4c28a17..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -300,7 +300,6 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n-            assertTrue(e.getCause() instanceof MsalServiceException);\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n             assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7688b098..b4c28a17 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -300,6 +300,7 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n+            assertTrue(e.getCause() instanceof MsalServiceException);\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n             assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n", "next_change": {"commit": "a6308974dfe7b2d7106292f069c697a83b5ad5de", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b4c28a17..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -300,7 +300,6 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n-            assertTrue(e.getCause() instanceof MsalServiceException);\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n             assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b4c28a17..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -300,7 +300,6 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n-            assertTrue(e.getCause() instanceof MsalServiceException);\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n             assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7688b098..306e23e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -301,7 +303,7 @@ public class MSITest extends AESetup {\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n-            assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n+            assertTrue(e.getMessage().contains(\"AADSTS700016\"), e.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 306e23e0..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -312,9 +279,6 @@ public class MSITest extends AESetup {\n      */\n     @Test\n     public void testNumericAkvWithCred() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         // add credentials to connection string\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "committedDate": "2021-05-20 16:48:25 -0700", "message": "Add exception error messages to test failures (#1584)"}, {"oid": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "committedDate": "2021-07-16 12:12:57 -0700", "message": "Fix MSI test failures (#1609)"}, {"oid": "4b7c218da1d9113c2e8276f2078b96baf9adb14d", "committedDate": "2021-07-28 18:45:29 -0700", "message": "Fix test failures (#1624)"}, {"oid": "692fe4eacb5c3f183257c69c4a404dc0524df255", "committedDate": "2021-12-14 12:40:29 -0800", "message": "added xSQLv11 tag for tests not compatible with SQL Server 2012 (#1713)"}, {"oid": "7ffc2f0b5c7b88269c7603f5e3faeb1470fd44ea", "committedDate": "2022-05-26 12:09:57 -0700", "message": "Managed Identity token cache (#1825)"}, {"oid": "cee2c54f87bfb75054d5b61720d59ee9a8a73a27", "committedDate": "2022-10-18 14:36:27 -0700", "message": "Fixed Managed Identity tests (#1935)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "d842883e3e69420a7a798294cb58ac252eead011", "committedDate": "2023-01-26 12:52:12 -0800", "message": "Renamed driver DefaultAzureCredential authentication to ActiveDirectoryDefault (#2055)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNjE5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499916192", "body": "Please do not remove this test, it is still valid.", "bodyText": "Please do not remove this test, it is still valid.", "bodyHTML": "<p dir=\"auto\">Please do not remove this test, it is still valid.</p>", "author": "ulvii", "createdAt": "2020-10-05T22:57:58Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -91,18 +92,15 @@ public void testJksName(String serverName, String url, String protocol) throws E\n      */\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n+    @Tag(Constants.reqExternalSetup)\n     public void testAkvName(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n-        try {", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3ODgzMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r502578833", "bodyText": "this is not removed, it's been renamed to testAkvNameWithAuthCallback", "author": "lilgreenbird", "createdAt": "2020-10-09T17:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNjE5Mg=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..4829af34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -100,7 +111,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n                 applicationClientID, applicationKey);\n         String keystoreName = \"keystoreName\";\n         akv.setName(keystoreName);\n-        assertTrue(akv.getName().equals(keystoreName));\n+        assertTrue(akv.getName().equals(keystoreName), \"AKV name: \" + akv.getName() + \" keystoreName: \" + keystoreName);\n     }\n \n     /*\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "committedDate": "2021-05-20 16:48:25 -0700", "message": "Add exception error messages to test failures (#1584)"}, {"oid": "692fe4eacb5c3f183257c69c4a404dc0524df255", "committedDate": "2021-12-14 12:40:29 -0800", "message": "added xSQLv11 tag for tests not compatible with SQL Server 2012 (#1713)"}, {"oid": "cd78ffe7b94f194540671a16b510e663b2b904ba", "committedDate": "2021-12-29 10:41:41 -0800", "message": "Update versions and remove ADAL dependency (#1726)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNzI1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499917251", "body": "There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.", "bodyText": "There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.", "bodyHTML": "<p dir=\"auto\">There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.</p>", "author": "ulvii", "createdAt": "2020-10-05T23:01:13Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -84,96 +95,126 @@ public String getName() {\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex aae4be84..3b31812a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -165,7 +162,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n         if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(NULL_VALUE));\n             Object[] msgArgs1 = {\"Token Credential\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNzMwNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499927306", "body": "This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.", "bodyText": "This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.", "bodyHTML": "<p dir=\"auto\">This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.</p>", "author": "rene-ye", "createdAt": "2020-10-05T23:34:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultTokenCredential.setAuthorization(map.get(\"authorization\"));\n+                    keyVaultTokenCredential.setResource(map.get(\"resource\"));\n+                    keyVaultTokenCredential.setScope(map.get(\"scope\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODA4OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499928088", "body": "None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  `SQLServerKeyVaultAuthenticationCallback.getAccessToken()` API in 2 ways:\r\n- Using adal4j library, see the sample [here](https://docs.microsoft.com/en-us/sql/connect/jdbc/azure-key-vault-sample-version-7.0?view=sql-server-ver15).\r\n- Using msal4j library, as implemented below.\r\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.", "bodyText": "None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  SQLServerKeyVaultAuthenticationCallback.getAccessToken() API in 2 ways:\n\nUsing adal4j library, see the sample here.\nUsing msal4j library, as implemented below.\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.", "bodyHTML": "<p dir=\"auto\">None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  <code>SQLServerKeyVaultAuthenticationCallback.getAccessToken()</code> API in 2 ways:</p>\n<ul dir=\"auto\">\n<li>Using adal4j library, see the sample <a href=\"https://docs.microsoft.com/en-us/sql/connect/jdbc/azure-key-vault-sample-version-7.0?view=sql-server-ver15\" rel=\"nofollow\">here</a>.</li>\n<li>Using msal4j library, as implemented below.<br>\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.</li>\n</ul>", "author": "ulvii", "createdAt": "2020-10-05T23:37:11Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -2244,22 +2234,69 @@ void testNumerics(SQLServerStatement stmt, String cekName, String[][] table, Str\n         }\n     }\n \n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = new SQLServerKeyVaultAuthenticationCallback() {\n-        // @Override\n-        ExecutorService service = Executors.newFixedThreadPool(2);\n+    @ParameterizedTest", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "committedDate": "2021-05-20 16:48:25 -0700", "message": "Add exception error messages to test failures (#1584)"}, {"oid": "692fe4eacb5c3f183257c69c4a404dc0524df255", "committedDate": "2021-12-14 12:40:29 -0800", "message": "added xSQLv11 tag for tests not compatible with SQL Server 2012 (#1713)"}, {"oid": "cd78ffe7b94f194540671a16b510e663b2b904ba", "committedDate": "2021-12-29 10:41:41 -0800", "message": "Update versions and remove ADAL dependency (#1726)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODY5Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499928693", "body": "Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.", "bodyText": "Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.", "bodyHTML": "<p dir=\"auto\">Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.</p>", "author": "ulvii", "createdAt": "2020-10-05T23:39:38Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -134,7 +132,7 @@ public void testBadAkv(String serverName, String url, String protocol) throws Ex\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -122,12 +132,30 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n", "next_change": {"commit": "33c276a47484a0dad04d71dd96f6325bba705847", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 55cad5f1..c073fee2 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -132,30 +122,12 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n+     * Test bad Azure Key Vault\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n-        setAEConnectionString(serverName, url, protocol);\n-\n-        try {\n-            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n-            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n-        }\n-    }\n-\n-    /*\n-     * Test bad Azure Key Vault using TokenCredential\n-     */\n-    @SuppressWarnings(\"unused\")\n-    @ParameterizedTest\n-    @MethodSource(\"enclaveParams\")\n-    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n", "next_change": {"commit": "7a035c6333044677e99dbc96114959c49e10e954", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..893192ca 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -122,12 +129,30 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -122,12 +132,30 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 55cad5f1..4829af34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -163,7 +164,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")), e.getMessage());\n         }\n     }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "committedDate": "2021-05-20 16:48:25 -0700", "message": "Add exception error messages to test failures (#1584)"}, {"oid": "692fe4eacb5c3f183257c69c4a404dc0524df255", "committedDate": "2021-12-14 12:40:29 -0800", "message": "added xSQLv11 tag for tests not compatible with SQL Server 2012 (#1713)"}, {"oid": "cd78ffe7b94f194540671a16b510e663b2b904ba", "committedDate": "2021-12-29 10:41:41 -0800", "message": "Update versions and remove ADAL dependency (#1726)"}]}, {"oid": "33c276a47484a0dad04d71dd96f6325bba705847", "url": "https://github.com/microsoft/mssql-jdbc/commit/33c276a47484a0dad04d71dd96f6325bba705847", "message": "formatting and reive updates", "committedDate": "2020-10-06T00:01:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5ODA0Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499998046", "body": "Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?", "bodyText": "Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?", "bodyHTML": "<p dir=\"auto\">Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?</p>", "author": "peterbae", "createdAt": "2020-10-06T04:24:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 0593bb83..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -38,7 +38,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n     private String scope;\n \n     /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n+     * Creates a KeyVaultTokenCredential with the given identity client options.\n      *\n      * @param clientId\n      *        the client ID of the application\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 0593bb83..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -38,7 +38,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n     private String scope;\n \n     /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n+     * Creates a KeyVaultTokenCredential with the given identity client options.\n      *\n      * @param clientId\n      *        the client ID of the application\n", "next_change": null}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}]}, {"oid": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "url": "https://github.com/microsoft/mssql-jdbc/commit/ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "message": "Rebase from remote branch", "committedDate": "2020-10-06T08:16:04Z", "type": "commit"}, {"oid": "089933342f5ea3e3c478f5b0152adbb91a456984", "url": "https://github.com/microsoft/mssql-jdbc/commit/089933342f5ea3e3c478f5b0152adbb91a456984", "message": "Update tests", "committedDate": "2020-10-06T08:17:41Z", "type": "commit"}, {"oid": "a4a99ec4da0e02a8413dfef87a91b0ee98b04b36", "url": "https://github.com/microsoft/mssql-jdbc/commit/a4a99ec4da0e02a8413dfef87a91b0ee98b04b36", "message": "Rebase from remote branch", "committedDate": "2020-10-06T08:18:10Z", "type": "commit"}, {"oid": "ca36f3469bdb927f1f01075b91e9a24e6a55f09d", "url": "https://github.com/microsoft/mssql-jdbc/commit/ca36f3469bdb927f1f01075b91e9a24e6a55f09d", "message": "Update pom.xml", "committedDate": "2020-10-06T08:21:38Z", "type": "commit"}, {"oid": "2bf012bdab01468aec967f17b8ae9bef86958deb", "url": "https://github.com/microsoft/mssql-jdbc/commit/2bf012bdab01468aec967f17b8ae9bef86958deb", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-10-06T21:34:36Z", "type": "commit"}, {"oid": "9e38cc336d505b58956d9674881763d5b9b70937", "url": "https://github.com/microsoft/mssql-jdbc/commit/9e38cc336d505b58956d9674881763d5b9b70937", "message": "Merge pull request #6 from lilgreenbird/msal\n\nMsal", "committedDate": "2020-10-06T21:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyODYxMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r500628613", "body": "Can just declare `private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();` since `getTrustedEndpoints` is static.", "bodyText": "Can just declare private static final List<String> akvTrustedEndpoints = getTrustedEndpoints(); since getTrustedEndpoints is static.", "bodyHTML": "<p dir=\"auto\">Can just declare <code>private static final List&lt;String&gt; akvTrustedEndpoints = getTrustedEndpoints();</code> since <code>getTrustedEndpoints</code> is static.</p>", "author": "rene-ye", "createdAt": "2020-10-06T22:20:31Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -51,29 +55,35 @@\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n     private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private KeyVaultClient keyVaultClient;\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n \n-    private KeyVaultCredential credentials;\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }", "originalCommit": "9e38cc336d505b58956d9674881763d5b9b70937", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 79383446..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,10 +81,6 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": {"commit": "7a035c6333044677e99dbc96114959c49e10e954", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 47b9da5e..79383446 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,6 +81,10 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }\n+\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": {"commit": "793207e04ec7d1f9990044a64c3e6eabab8240f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 79383446..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,10 +81,6 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 79383446..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,10 +81,6 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..a39efccb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,6 +142,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n+    /**\n+     * A cache of column encryption keys (once they are unwrapped). This is useful for rapidly decrypting multiple data\n+     * values. The default expiration is set to 2 hours.\n+     */\n+    private final SimpleTtlCache<String, byte[]> columnEncryptionKeyCache = new SimpleTtlCache<>();\n+    \n+    /**\n+     * A cache for storing the results of signature verification of column master key metadata.\n+     * The default expiration is set to 10 days.\n+     */\n+    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(Duration.ofDays(10));\n+\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": {"commit": "9de35042413d1edfc76ba0ab9e787355823d62f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a39efccb..80ccba0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -147,12 +146,13 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * values. The default expiration is set to 2 hours.\n      */\n     private final SimpleTtlCache<String, byte[]> columnEncryptionKeyCache = new SimpleTtlCache<>();\n-    \n+\n     /**\n-     * A cache for storing the results of signature verification of column master key metadata.\n-     * The default expiration is set to 10 days.\n+     * A cache for storing the results of signature verification of column master key metadata. The default expiration\n+     * is set to 10 days.\n      */\n-    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(Duration.ofDays(10));\n+    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(\n+            Duration.ofDays(10));\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": null}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..a39efccb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -89,6 +162,28 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         return this.name;\n     }\n \n+    /**\n+     * Returns the time-to-live for items in the columnEncryptionKeyCache.\n+     * \n+     * @return the time-to-live for items in the columnEncryptionKeyCache.\n+     */\n+    @Override\n+    public Duration getColumnEncryptionKeyCacheTtl() {\n+        return columnEncryptionKeyCache.getCacheTtl();\n+    }\n+\n+    /**\n+     * Sets the the time-to-live for items in the columnEncryptionKeyCache.\n+     * \n+     * @param duration\n+     *        value to be set for the time-to-live for items in the columnEncryptionKeyCache.\n+     */\n+    @Override\n+    public void setColumnEncryptionCacheTtl(Duration duration) {\n+        columnEncryptionKeyCache.setCacheTtl(duration);\n+    }\n+\n+\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n      * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n", "next_change": {"commit": "9de35042413d1edfc76ba0ab9e787355823d62f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a39efccb..80ccba0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -183,7 +183,6 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         columnEncryptionKeyCache.setCacheTtl(duration);\n     }\n \n-\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n      * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"oid": "7a035c6333044677e99dbc96114959c49e10e954", "url": "https://github.com/microsoft/mssql-jdbc/commit/7a035c6333044677e99dbc96114959c49e10e954", "message": "review updates", "committedDate": "2020-10-08T23:36:11Z", "type": "commit"}, {"oid": "a6308974dfe7b2d7106292f069c697a83b5ad5de", "url": "https://github.com/microsoft/mssql-jdbc/commit/a6308974dfe7b2d7106292f069c697a83b5ad5de", "message": "catch exception", "committedDate": "2020-10-09T00:26:28Z", "type": "commit"}, {"oid": "48cacfad6362e53ec29bd3132187989c7bcadb15", "url": "https://github.com/microsoft/mssql-jdbc/commit/48cacfad6362e53ec29bd3132187989c7bcadb15", "message": "Merge pull request #7 from lilgreenbird/msal\n\nAdded tests and catch exception from getKeyClient", "committedDate": "2020-10-09T17:30:18Z", "type": "commit"}, {"oid": "793207e04ec7d1f9990044a64c3e6eabab8240f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/793207e04ec7d1f9990044a64c3e6eabab8240f4", "message": "added test for token credential", "committedDate": "2020-10-09T22:26:32Z", "type": "commit"}, {"oid": "1a22d786577af55749e218ac694a61b1944500c8", "url": "https://github.com/microsoft/mssql-jdbc/commit/1a22d786577af55749e218ac694a61b1944500c8", "message": "Merge pull request #8 from lilgreenbird/msal\n\nadded test for token credential and other cosmetic fixes", "committedDate": "2020-10-09T22:39:52Z", "type": "commit"}, {"oid": "8f483e2a14477e6410cd7380f2372c6a0bb28cea", "url": "https://github.com/microsoft/mssql-jdbc/commit/8f483e2a14477e6410cd7380f2372c6a0bb28cea", "message": "added tenantID property", "committedDate": "2020-10-10T00:25:07Z", "type": "commit"}, {"oid": "c97b863c95385bdcd1afc897ef39cbebaf495578", "url": "https://github.com/microsoft/mssql-jdbc/commit/c97b863c95385bdcd1afc897ef39cbebaf495578", "message": "Fix AEv2 tests exclude for reqExternalSetup and cleanup (#1247)", "committedDate": "2020-02-05T19:03:48Z", "type": "commit"}, {"oid": "54b5a194e5d46552419c86e0d1f8c800f42d3de8", "url": "https://github.com/microsoft/mssql-jdbc/commit/54b5a194e5d46552419c86e0d1f8c800f42d3de8", "message": "Fix | Add null check for getObject() with LocalTime and LocalDate (#1250)", "committedDate": "2020-02-08T00:19:05Z", "type": "commit"}, {"oid": "672b7d67caae75250c53f82a760e8d3880e62a37", "url": "https://github.com/microsoft/mssql-jdbc/commit/672b7d67caae75250c53f82a760e8d3880e62a37", "message": "added all AKV tests to use reqExternalSetup tag so they will be skipped by default (#1254)\n\n* skip AKV test properly\r\n\r\n* removed enclave properties string to failed errors as enclave tests could be skipped", "committedDate": "2020-02-10T19:04:22Z", "type": "commit"}, {"oid": "3c3331b7b0ff1b27b1e80271bf9ffdc6aae7be79", "url": "https://github.com/microsoft/mssql-jdbc/commit/3c3331b7b0ff1b27b1e80271bf9ffdc6aae7be79", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-25T06:21:47Z", "type": "commit"}, {"oid": "e2c5640370daa89c0d8c1559b5791e99656f78c8", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2c5640370daa89c0d8c1559b5791e99656f78c8", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-26T06:10:08Z", "type": "commit"}, {"oid": "aad696640378b75f3cb8cb24cc2fa299358db9ac", "url": "https://github.com/microsoft/mssql-jdbc/commit/aad696640378b75f3cb8cb24cc2fa299358db9ac", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-28T03:18:02Z", "type": "commit"}, {"oid": "92bf04c2787c3b2a704f641f50cb4a83193f1d6d", "url": "https://github.com/microsoft/mssql-jdbc/commit/92bf04c2787c3b2a704f641f50cb4a83193f1d6d", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-31T01:58:20Z", "type": "commit"}, {"oid": "3ba5ab72008501e23f43dbcbcc333775320ddafa", "url": "https://github.com/microsoft/mssql-jdbc/commit/3ba5ab72008501e23f43dbcbcc333775320ddafa", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-04T05:47:37Z", "type": "commit"}, {"oid": "d20823deffea162b2b17b079cc291f91269558aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/d20823deffea162b2b17b079cc291f91269558aa", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-07T00:45:05Z", "type": "commit"}, {"oid": "4cc959f7e76eedbf49e30e5b92de43c86d7eb803", "url": "https://github.com/microsoft/mssql-jdbc/commit/4cc959f7e76eedbf49e30e5b92de43c86d7eb803", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-29T02:59:23Z", "type": "commit"}, {"oid": "7b301f8184b26da4d99b2feab8b2aea886c01cea", "url": "https://github.com/microsoft/mssql-jdbc/commit/7b301f8184b26da4d99b2feab8b2aea886c01cea", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-30T06:36:21Z", "type": "commit"}, {"oid": "56bcf139fe6acd87c41b3829b4f157c59bd9f873", "url": "https://github.com/microsoft/mssql-jdbc/commit/56bcf139fe6acd87c41b3829b4f157c59bd9f873", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-07T22:26:03Z", "type": "commit"}, {"oid": "744e0ca78e57bc6c0db98910a9066d5b583c6ba8", "url": "https://github.com/microsoft/mssql-jdbc/commit/744e0ca78e57bc6c0db98910a9066d5b583c6ba8", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-12T22:47:18Z", "type": "commit"}, {"oid": "df8fd41ffa6005b18b0e328593faaeb495ce6547", "url": "https://github.com/microsoft/mssql-jdbc/commit/df8fd41ffa6005b18b0e328593faaeb495ce6547", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-19T01:06:51Z", "type": "commit"}, {"oid": "652e68b110828db6b172c1b02df6a06ab04c2b59", "url": "https://github.com/microsoft/mssql-jdbc/commit/652e68b110828db6b172c1b02df6a06ab04c2b59", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-26T07:07:35Z", "type": "commit"}, {"oid": "53736db944298004a4a383be14ae83370ffab717", "url": "https://github.com/microsoft/mssql-jdbc/commit/53736db944298004a4a383be14ae83370ffab717", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-26T23:02:59Z", "type": "commit"}, {"oid": "9ba6a42285fcc046a0a68e110454b62d8f7f6657", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ba6a42285fcc046a0a68e110454b62d8f7f6657", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-02T06:50:57Z", "type": "commit"}, {"oid": "6d156f728a1253dd469da1c6896189762b00097b", "url": "https://github.com/microsoft/mssql-jdbc/commit/6d156f728a1253dd469da1c6896189762b00097b", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-05T19:15:40Z", "type": "commit"}, {"oid": "e08ffe5f54050344920bc48d44dc8e04cd143866", "url": "https://github.com/microsoft/mssql-jdbc/commit/e08ffe5f54050344920bc48d44dc8e04cd143866", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-10T21:34:05Z", "type": "commit"}, {"oid": "6b6cab266b655c48858187f56071aa3e4ba87054", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b6cab266b655c48858187f56071aa3e4ba87054", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-18T19:14:21Z", "type": "commit"}, {"oid": "f4555d66335e5ea3b053b9af303383cbfd50ef42", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4555d66335e5ea3b053b9af303383cbfd50ef42", "message": "First pass at porting to new Key Vault", "committedDate": "2020-06-24T04:57:40Z", "type": "commit"}, {"oid": "c2025901e1c9e8b279f42279da2f25ffd6c4232a", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2025901e1c9e8b279f42279da2f25ffd6c4232a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-24T18:58:46Z", "type": "commit"}, {"oid": "0515d4b0d51c3150b2149438f8b8a69be3dfc2bd", "url": "https://github.com/microsoft/mssql-jdbc/commit/0515d4b0d51c3150b2149438f8b8a69be3dfc2bd", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-24T20:34:25Z", "type": "commit"}, {"oid": "892eb2be48d9d9706004c96ca43e9400eaea1197", "url": "https://github.com/microsoft/mssql-jdbc/commit/892eb2be48d9d9706004c96ca43e9400eaea1197", "message": "Everything now compiles, but I'm sure there are numerous bugs, and testing has not been run yet.", "committedDate": "2020-06-25T01:42:07Z", "type": "commit"}, {"oid": "088d2f73cdd507404c2fe6398f78647c3b84a31c", "url": "https://github.com/microsoft/mssql-jdbc/commit/088d2f73cdd507404c2fe6398f78647c3b84a31c", "message": "Beginning to re-enable some disabled unit tests", "committedDate": "2020-06-25T02:39:22Z", "type": "commit"}, {"oid": "30e7fdf4c6b4a185132ca36d661e29371727e13f", "url": "https://github.com/microsoft/mssql-jdbc/commit/30e7fdf4c6b4a185132ca36d661e29371727e13f", "message": "Add requirement for a tenant ID to be set to run tests", "committedDate": "2020-06-25T03:48:10Z", "type": "commit"}, {"oid": "2c63b5828becf3f737f4edf95593d98ada4e273a", "url": "https://github.com/microsoft/mssql-jdbc/commit/2c63b5828becf3f737f4edf95593d98ada4e273a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-25T06:36:46Z", "type": "commit"}, {"oid": "2d62262aa453ecf96807f5f52b6f9a1bd908e4ca", "url": "https://github.com/microsoft/mssql-jdbc/commit/2d62262aa453ecf96807f5f52b6f9a1bd908e4ca", "message": "Minor tidy ups", "committedDate": "2020-06-30T02:04:24Z", "type": "commit"}, {"oid": "a6b75cdaf634a3899fd5586d0418df181d9e9cef", "url": "https://github.com/microsoft/mssql-jdbc/commit/a6b75cdaf634a3899fd5586d0418df181d9e9cef", "message": "Upgrade gradle file to include equivalent dependencies as in pom.xml, and remove try / catch in some test code where it is not required.", "committedDate": "2020-06-30T02:18:19Z", "type": "commit"}, {"oid": "78aa941fab02af4aef190c7da6141b1251a84b4b", "url": "https://github.com/microsoft/mssql-jdbc/commit/78aa941fab02af4aef190c7da6141b1251a84b4b", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-02T18:43:21Z", "type": "commit"}, {"oid": "90e99cd54a0cb4347f813d965ea38b0a9801e8b0", "url": "https://github.com/microsoft/mssql-jdbc/commit/90e99cd54a0cb4347f813d965ea38b0a9801e8b0", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-02T20:57:03Z", "type": "commit"}, {"oid": "5e373227bfc1deec11a6d8d5c820afabb00d38aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/5e373227bfc1deec11a6d8d5c820afabb00d38aa", "message": "add -DtenantID=$(tenantID)", "committedDate": "2020-07-03T20:28:32Z", "type": "commit"}, {"oid": "1df8828c03c162c6685f095f211fa8c8e51fccfc", "url": "https://github.com/microsoft/mssql-jdbc/commit/1df8828c03c162c6685f095f211fa8c8e51fccfc", "message": "Merge pull request #1 from peterbae/keyvault-upgrade\n\nAdd tenantID", "committedDate": "2020-07-05T20:44:52Z", "type": "commit"}, {"oid": "da1004bb9862d31941e537e77bd0e2ded5edef96", "url": "https://github.com/microsoft/mssql-jdbc/commit/da1004bb9862d31941e537e77bd0e2ded5edef96", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-06T22:39:35Z", "type": "commit"}, {"oid": "8c9a94473deee94dd40f928a710d2b2b279b45e3", "url": "https://github.com/microsoft/mssql-jdbc/commit/8c9a94473deee94dd40f928a710d2b2b279b45e3", "message": "Updating APIs to propagate tenantId. Still I am sure the tests will fail, but this is a step in the right direction.", "committedDate": "2020-07-06T23:25:56Z", "type": "commit"}, {"oid": "f7f12d9d6bb5a868e6bf4d127a34be75353727f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7f12d9d6bb5a868e6bf4d127a34be75353727f7", "message": "Merge branch 'keyvault-upgrade' of github.com:JonathanGiles/mssql-jdbc into keyvault-upgrade", "committedDate": "2020-07-06T23:26:24Z", "type": "commit"}, {"oid": "cc0ac7f33655ab1e105c12cd6da9abe06a6830bc", "url": "https://github.com/microsoft/mssql-jdbc/commit/cc0ac7f33655ab1e105c12cd6da9abe06a6830bc", "message": "Updating method call to add missing tenantId", "committedDate": "2020-07-06T23:31:09Z", "type": "commit"}, {"oid": "86fc00cbd8813fc9b2888a2dd078291753ffcf7c", "url": "https://github.com/microsoft/mssql-jdbc/commit/86fc00cbd8813fc9b2888a2dd078291753ffcf7c", "message": "Wiring in vaultBaseUrl env var lookup for Key Vault", "committedDate": "2020-07-06T23:50:31Z", "type": "commit"}, {"oid": "8fec202dca9cf413dfdadca1f99a89cd6d454fb3", "url": "https://github.com/microsoft/mssql-jdbc/commit/8fec202dca9cf413dfdadca1f99a89cd6d454fb3", "message": "Debugging key path format (hopefully)", "committedDate": "2020-07-07T00:01:29Z", "type": "commit"}, {"oid": "9f44f0f45a6daa99b2a121bfc62a59491e867821", "url": "https://github.com/microsoft/mssql-jdbc/commit/9f44f0f45a6daa99b2a121bfc62a59491e867821", "message": "Clean up algorithm code", "committedDate": "2020-07-07T00:10:22Z", "type": "commit"}, {"oid": "dab428f8ed0c1fce1dc3dc2158c1c233f701bb2e", "url": "https://github.com/microsoft/mssql-jdbc/commit/dab428f8ed0c1fce1dc3dc2158c1c233f701bb2e", "message": "Adding validation for vaultBaseURL", "committedDate": "2020-07-07T00:22:10Z", "type": "commit"}, {"oid": "9ca12848377fad04ad8f8d2a29258ea8500f70d2", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ca12848377fad04ad8f8d2a29258ea8500f70d2", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-28T07:45:46Z", "type": "commit"}, {"oid": "c67d8edea9341b2b94a075ecbbc4768e313f0658", "url": "https://github.com/microsoft/mssql-jdbc/commit/c67d8edea9341b2b94a075ecbbc4768e313f0658", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-01T00:41:25Z", "type": "commit"}, {"oid": "1d0a4adf7296966d52421ace5011fcc2fcc3147a", "url": "https://github.com/microsoft/mssql-jdbc/commit/1d0a4adf7296966d52421ace5011fcc2fcc3147a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-05T00:02:31Z", "type": "commit"}, {"oid": "398c2d86514e4e31e61ddfd5cf9e2ac83b3c56cf", "url": "https://github.com/microsoft/mssql-jdbc/commit/398c2d86514e4e31e61ddfd5cf9e2ac83b3c56cf", "message": "Fixes for Key and Crypto client", "committedDate": "2020-08-12T21:10:43Z", "type": "commit"}, {"oid": "1b363f7659ec1ed2576b616c97608063a541812e", "url": "https://github.com/microsoft/mssql-jdbc/commit/1b363f7659ec1ed2576b616c97608063a541812e", "message": "Merge pull request #2 from srnagar/keyvault-upgrade\n\nFixes for Key and Crypto client", "committedDate": "2020-08-12T21:16:05Z", "type": "commit"}, {"oid": "948939f99833c8741f42c97fc82b80a33d16cbf1", "url": "https://github.com/microsoft/mssql-jdbc/commit/948939f99833c8741f42c97fc82b80a33d16cbf1", "message": "Merge from master", "committedDate": "2020-08-12T21:22:10Z", "type": "commit"}, {"oid": "6d014b55e3d91988b2c09223dbff95d975d95fd5", "url": "https://github.com/microsoft/mssql-jdbc/commit/6d014b55e3d91988b2c09223dbff95d975d95fd5", "message": "Merge pull request #3 from srnagar/keyvault-upgrade\n\nMerge from master to resolve conflicts.", "committedDate": "2020-08-12T21:25:11Z", "type": "commit"}, {"oid": "dcf2f79d8dae25e5dce29f6c8f132f60f0a52de4", "url": "https://github.com/microsoft/mssql-jdbc/commit/dcf2f79d8dae25e5dce29f6c8f132f60f0a52de4", "message": "Fix compilation errors after merging from master", "committedDate": "2020-08-12T23:33:34Z", "type": "commit"}, {"oid": "62a83e4ad025e0377552869844b0f2ce074ba2b6", "url": "https://github.com/microsoft/mssql-jdbc/commit/62a83e4ad025e0377552869844b0f2ce074ba2b6", "message": "Merge pull request #4 from srnagar/keyvault-upgrade\n\nFix compilation errors after merging from master", "committedDate": "2020-08-12T23:36:35Z", "type": "commit"}, {"oid": "73d160fb9b57cba324a766edadcc96a6b7bec5f1", "url": "https://github.com/microsoft/mssql-jdbc/commit/73d160fb9b57cba324a766edadcc96a6b7bec5f1", "message": "Add tenantID to pipeline yml", "committedDate": "2020-08-13T08:14:10Z", "type": "commit"}, {"oid": "fba2a23884398f5bd0b5ff012b317166db80bc1b", "url": "https://github.com/microsoft/mssql-jdbc/commit/fba2a23884398f5bd0b5ff012b317166db80bc1b", "message": "Merge pull request #5 from srnagar/keyvault-upgrade\n\nAdd tenantID to pipeline yml", "committedDate": "2020-08-13T08:17:24Z", "type": "commit"}, {"oid": "54642abbb1caf15cdd9148d7360a2684adf68460", "url": "https://github.com/microsoft/mssql-jdbc/commit/54642abbb1caf15cdd9148d7360a2684adf68460", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-13T18:56:11Z", "type": "commit"}, {"oid": "f006a63e331016e1a6bdfbe42095156711a21bde", "url": "https://github.com/microsoft/mssql-jdbc/commit/f006a63e331016e1a6bdfbe42095156711a21bde", "message": "Fix unit test", "committedDate": "2020-08-13T19:54:01Z", "type": "commit"}, {"oid": "b2db031c2e2aca675d9ba87068b14ab878cce5fc", "url": "https://github.com/microsoft/mssql-jdbc/commit/b2db031c2e2aca675d9ba87068b14ab878cce5fc", "message": "Merge pull request #6 from srnagar/keyvault-upgrade\n\nFix unit test", "committedDate": "2020-08-13T19:55:57Z", "type": "commit"}, {"oid": "96e32f4c156d31264f14b91f786bcf06044726d7", "url": "https://github.com/microsoft/mssql-jdbc/commit/96e32f4c156d31264f14b91f786bcf06044726d7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-13T22:22:11Z", "type": "commit"}, {"oid": "47a7b945ce8e84c88498c31d688556a24d4f0d7f", "url": "https://github.com/microsoft/mssql-jdbc/commit/47a7b945ce8e84c88498c31d688556a24d4f0d7f", "message": "Address PR comments", "committedDate": "2020-08-18T00:53:42Z", "type": "commit"}, {"oid": "9b1cac05c0bd83f343d95921b88b754a7ebe6707", "url": "https://github.com/microsoft/mssql-jdbc/commit/9b1cac05c0bd83f343d95921b88b754a7ebe6707", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-18T00:54:59Z", "type": "commit"}, {"oid": "fcf327e11ba401078d988e7c13da18120de14a44", "url": "https://github.com/microsoft/mssql-jdbc/commit/fcf327e11ba401078d988e7c13da18120de14a44", "message": "Merge pull request #7 from srnagar/keyvault-upgrade\n\nKeyvault upgrade", "committedDate": "2020-08-18T01:07:13Z", "type": "commit"}, {"oid": "23b7f6a96e404bf08237cd07e7c2ce9bfcf11589", "url": "https://github.com/microsoft/mssql-jdbc/commit/23b7f6a96e404bf08237cd07e7c2ce9bfcf11589", "message": "Remove tenant Id and fix adal issues", "committedDate": "2020-08-18T20:25:10Z", "type": "commit"}, {"oid": "4121bc57cb984891fef55cc5af6fce68304f0208", "url": "https://github.com/microsoft/mssql-jdbc/commit/4121bc57cb984891fef55cc5af6fce68304f0208", "message": "Merge pull request #8 from srnagar/keyvault-upgrade\n\nRemove tenant Id and fix adal issues", "committedDate": "2020-08-18T20:32:33Z", "type": "commit"}, {"oid": "bca00d2aa8c8e7968ef1641e1468cf4e8ea3fa69", "url": "https://github.com/microsoft/mssql-jdbc/commit/bca00d2aa8c8e7968ef1641e1468cf4e8ea3fa69", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-18T21:09:51Z", "type": "commit"}, {"oid": "37c676d7aea6b43c7d347e353476a544da38b29f", "url": "https://github.com/microsoft/mssql-jdbc/commit/37c676d7aea6b43c7d347e353476a544da38b29f", "message": "Fix test failures", "committedDate": "2020-08-18T23:25:18Z", "type": "commit"}, {"oid": "8e8517b4797d404c2ff65f9f34230fe421dd3c3a", "url": "https://github.com/microsoft/mssql-jdbc/commit/8e8517b4797d404c2ff65f9f34230fe421dd3c3a", "message": "Merge pull request #9 from srnagar/keyvault-upgrade\n\nFix test failures", "committedDate": "2020-08-18T23:26:53Z", "type": "commit"}, {"oid": "b2eb9cb166f80d496b3bbcd030397e12d9c85455", "url": "https://github.com/microsoft/mssql-jdbc/commit/b2eb9cb166f80d496b3bbcd030397e12d9c85455", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-19T00:10:13Z", "type": "commit"}, {"oid": "ee3b5c88ceb8542bef086ff2d109247f07491032", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee3b5c88ceb8542bef086ff2d109247f07491032", "message": "Use cached key and crypto clients", "committedDate": "2020-08-19T00:58:23Z", "type": "commit"}, {"oid": "48c6dac906e5d5553440105ec9f806a56255797a", "url": "https://github.com/microsoft/mssql-jdbc/commit/48c6dac906e5d5553440105ec9f806a56255797a", "message": "Merge pull request #10 from srnagar/keyvault-upgrade\n\nUse cached key and crypto clients", "committedDate": "2020-08-19T01:36:24Z", "type": "commit"}, {"oid": "6baad02d1a21995d197a88ab220616c56ea2c431", "url": "https://github.com/microsoft/mssql-jdbc/commit/6baad02d1a21995d197a88ab220616c56ea2c431", "message": "Update license header and cleanup pipeline builder", "committedDate": "2020-08-20T00:05:34Z", "type": "commit"}, {"oid": "a053426d5a30ccc86aaf6478810e1bba7dce5ccc", "url": "https://github.com/microsoft/mssql-jdbc/commit/a053426d5a30ccc86aaf6478810e1bba7dce5ccc", "message": "Merge pull request #11 from srnagar/keyvault-upgrade\n\nUpdate license header and cleanup pipeline builder", "committedDate": "2020-08-20T00:07:43Z", "type": "commit"}, {"oid": "0a3cb0f316c1d29ea29298402f02b15b8d872578", "url": "https://github.com/microsoft/mssql-jdbc/commit/0a3cb0f316c1d29ea29298402f02b15b8d872578", "message": "Fix unit tests", "committedDate": "2020-08-20T04:40:06Z", "type": "commit"}, {"oid": "1bf984a45b4d0b4478be3fdcbcd853a3bf088b96", "url": "https://github.com/microsoft/mssql-jdbc/commit/1bf984a45b4d0b4478be3fdcbcd853a3bf088b96", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-20T18:23:00Z", "type": "commit"}, {"oid": "684ecce1f043edeb5621f8b3dc956b3b59d7024f", "url": "https://github.com/microsoft/mssql-jdbc/commit/684ecce1f043edeb5621f8b3dc956b3b59d7024f", "message": "Merge pull request #12 from srnagar/keyvault-upgrade\n\nFix unit tests", "committedDate": "2020-08-20T18:27:52Z", "type": "commit"}, {"oid": "62ab01a648baa75f4c44940fb43b8c56b4142845", "url": "https://github.com/microsoft/mssql-jdbc/commit/62ab01a648baa75f4c44940fb43b8c56b4142845", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-21T06:14:21Z", "type": "commit"}, {"oid": "ef464f912bb19208c77d86f12fc2547ce0890288", "url": "https://github.com/microsoft/mssql-jdbc/commit/ef464f912bb19208c77d86f12fc2547ce0890288", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-22T03:59:10Z", "type": "commit"}, {"oid": "e4206e1d96aab063aeb7ec5d5a2e9b1c99aa855b", "url": "https://github.com/microsoft/mssql-jdbc/commit/e4206e1d96aab063aeb7ec5d5a2e9b1c99aa855b", "message": "Java 8 compatibility", "committedDate": "2020-08-24T05:03:57Z", "type": "commit"}, {"oid": "d7c23058a745beab1f10ffe9077b10b365783a13", "url": "https://github.com/microsoft/mssql-jdbc/commit/d7c23058a745beab1f10ffe9077b10b365783a13", "message": "Merge pull request #13 from srnagar/keyvault-upgrade\n\nJava 8 compatibility", "committedDate": "2020-08-24T05:07:14Z", "type": "commit"}, {"oid": "fccc5b7efa64a060d730252265904e4720bfce16", "url": "https://github.com/microsoft/mssql-jdbc/commit/fccc5b7efa64a060d730252265904e4720bfce16", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-24T17:35:46Z", "type": "commit"}, {"oid": "be1d739e84b0304d9b31e655108a2896a05eb86b", "url": "https://github.com/microsoft/mssql-jdbc/commit/be1d739e84b0304d9b31e655108a2896a05eb86b", "message": "Change Set.of to Collections.singleton()", "committedDate": "2020-08-24T18:43:15Z", "type": "commit"}, {"oid": "1423d9382cf7e1f8e3286e6e83fd5f67362ad6a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/1423d9382cf7e1f8e3286e6e83fd5f67362ad6a7", "message": "Remote tenant id from JDBC tests", "committedDate": "2020-08-24T19:14:06Z", "type": "commit"}, {"oid": "e077ffe4fc5de650928c573f384015c8cba13b13", "url": "https://github.com/microsoft/mssql-jdbc/commit/e077ffe4fc5de650928c573f384015c8cba13b13", "message": "Merge pull request #14 from srnagar/keyvault-upgrade\n\nKeyvault upgrade", "committedDate": "2020-08-24T20:20:46Z", "type": "commit"}, {"oid": "9ad6edce5beaf5b97578d675f8462635dd07f9f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ad6edce5beaf5b97578d675f8462635dd07f9f7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-24T20:57:06Z", "type": "commit"}, {"oid": "f7493610d9583abd6f2c4d4dc63efe6fe3c730a0", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7493610d9583abd6f2c4d4dc63efe6fe3c730a0", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-24T23:49:23Z", "type": "commit"}, {"oid": "b08233c665cb54257a756169c216525f6add54c4", "url": "https://github.com/microsoft/mssql-jdbc/commit/b08233c665cb54257a756169c216525f6add54c4", "message": "Merge from dev", "committedDate": "2020-08-24T23:50:12Z", "type": "commit"}, {"oid": "49b802e1fc28bdfb1bac6ea247e895744f92f526", "url": "https://github.com/microsoft/mssql-jdbc/commit/49b802e1fc28bdfb1bac6ea247e895744f92f526", "message": "Merge pull request #15 from srnagar/keyvault-upgrade\n\nMerge from upstream dev branch", "committedDate": "2020-08-25T00:24:54Z", "type": "commit"}, {"oid": "c7bfe70cb9700d323f029d69792ae467a6a22906", "url": "https://github.com/microsoft/mssql-jdbc/commit/c7bfe70cb9700d323f029d69792ae467a6a22906", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-25T01:12:34Z", "type": "commit"}, {"oid": "e743268660f5506588ef578273246202d12e7a88", "url": "https://github.com/microsoft/mssql-jdbc/commit/e743268660f5506588ef578273246202d12e7a88", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-25T06:30:56Z", "type": "commit"}, {"oid": "c2622e46aa4001374e7aa69ff7ffd234ab061128", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2622e46aa4001374e7aa69ff7ffd234ab061128", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-25T21:39:30Z", "type": "commit"}, {"oid": "ffd6a7462323077d97ec3ad64047329288f08609", "url": "https://github.com/microsoft/mssql-jdbc/commit/ffd6a7462323077d97ec3ad64047329288f08609", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-26T18:06:10Z", "type": "commit"}, {"oid": "90ccde041653f327be0bddf55f0c4c31c6d4fcb1", "url": "https://github.com/microsoft/mssql-jdbc/commit/90ccde041653f327be0bddf55f0c4c31c6d4fcb1", "message": "Remove tenant id and reverse null checks", "committedDate": "2020-08-26T19:11:36Z", "type": "commit"}, {"oid": "f1b1dfbf14ed46682044e343a9e1e34e258827d3", "url": "https://github.com/microsoft/mssql-jdbc/commit/f1b1dfbf14ed46682044e343a9e1e34e258827d3", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-26T20:44:33Z", "type": "commit"}, {"oid": "d7c44b59affd57d3bb1c96557cc3711f7d99266d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d7c44b59affd57d3bb1c96557cc3711f7d99266d", "message": "Fix compile errors", "committedDate": "2020-08-26T21:33:01Z", "type": "commit"}, {"oid": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "url": "https://github.com/microsoft/mssql-jdbc/commit/fe0953145cc7b3e61444fe92e372e57bc2b855c5", "message": "Remove tenant id from pipelines yml", "committedDate": "2020-08-26T23:10:15Z", "type": "commit"}, {"oid": "15db9cd8b34f8e0aba09f639bd278b7b7996b26d", "url": "https://github.com/microsoft/mssql-jdbc/commit/15db9cd8b34f8e0aba09f639bd278b7b7996b26d", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-27T19:21:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczMzkyMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r478733921", "body": "remove, no longer needed", "bodyText": "remove, no longer needed", "bodyHTML": "<p dir=\"auto\">remove, no longer needed</p>", "author": "lilgreenbird", "createdAt": "2020-08-27T22:39:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -669,6 +669,8 @@ boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n     String keyStoreLocation = null;\n     String keyStorePrincipalId = null;\n \n+    String keyVaultProviderTenantId = null;", "originalCommit": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 466f362b..c1514714 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -669,8 +669,6 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     String keyStoreLocation = null;\n     String keyStorePrincipalId = null;\n \n-    String keyVaultProviderTenantId = null;\n-\n     private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n \n     private String enclaveType = null;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 466f362b..36c0bb8b 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -669,8 +669,6 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     String keyStoreLocation = null;\n     String keyStorePrincipalId = null;\n \n-    String keyVaultProviderTenantId = null;\n-\n     private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n \n     private String enclaveType = null;\n", "next_change": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 36c0bb8b..7e6320f2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -657,66 +582,31 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         return (columnEncryptionSetting.equalsIgnoreCase(ColumnEncryptionSetting.Enabled.toString()));\n     }\n \n-    boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n-        return sendTemporalDataTypesAsStringForBulkCopy;\n-    }\n-\n-    String enclaveAttestationUrl = null;\n-    String enclaveAttestationProtocol = null;\n-\n     String keyStoreAuthentication = null;\n     String keyStoreSecret = null;\n     String keyStoreLocation = null;\n-    String keyStorePrincipalId = null;\n \n-    private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n-\n-    private String enclaveType = null;\n+    private boolean serverSupportsColumnEncryption = false;\n \n     boolean getServerSupportsColumnEncryption() {\n-        return (serverColumnEncryptionVersion.value() > ColumnEncryptionVersion.AE_NotSupported.value());\n-    }\n-\n-    ColumnEncryptionVersion getServerColumnEncryptionVersion() {\n-        return serverColumnEncryptionVersion;\n+        return serverSupportsColumnEncryption;\n     }\n \n     private boolean serverSupportsDataClassification = false;\n-    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;\n \n     boolean getServerSupportsDataClassification() {\n         return serverSupportsDataClassification;\n     }\n \n-    private boolean serverSupportsDNSCaching = false;\n-    private static ConcurrentHashMap<String, InetSocketAddress> dnsCache = null;\n-\n-    static InetSocketAddress getDNSEntry(String key) {\n-        return (null != dnsCache) ? dnsCache.get(key) : null;\n-    }\n-\n-    byte getServerSupportedDataClassificationVersion() {\n-        return serverSupportedDataClassificationVersion;\n-    }\n-\n-    // Boolean that indicates whether LOB objects created by this connection should be loaded into memory\n-    private boolean delayLoadingLobs = SQLServerDriverBooleanProperty.DELAY_LOADING_LOBS.getDefaultValue();\n-\n-    @Override\n-    public boolean getDelayLoadingLobs() {\n-        return delayLoadingLobs;\n-    }\n-\n-    @Override\n-    public void setDelayLoadingLobs(boolean b) {\n-        delayLoadingLobs = b;\n-    }\n-\n+    static boolean isWindows;\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n+            isWindows = true;\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n+        } else {\n+            isWindows = false;\n         }\n     }\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n", "next_change": {"commit": "af76d7af3846801be86f7f94fbc3318b1ed5bc04", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 7e6320f2..1e3a5c0c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -582,31 +656,66 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         return (columnEncryptionSetting.equalsIgnoreCase(ColumnEncryptionSetting.Enabled.toString()));\n     }\n \n+    boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n+        return sendTemporalDataTypesAsStringForBulkCopy;\n+    }\n+\n+    String enclaveAttestationUrl = null;\n+    String enclaveAttestationProtocol = null;\n+\n     String keyStoreAuthentication = null;\n     String keyStoreSecret = null;\n     String keyStoreLocation = null;\n+    String keyStorePrincipalId = null;\n \n-    private boolean serverSupportsColumnEncryption = false;\n+    private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n+\n+    private String enclaveType = null;\n \n     boolean getServerSupportsColumnEncryption() {\n-        return serverSupportsColumnEncryption;\n+        return (serverColumnEncryptionVersion.value() > ColumnEncryptionVersion.AE_NotSupported.value());\n+    }\n+\n+    ColumnEncryptionVersion getServerColumnEncryptionVersion() {\n+        return serverColumnEncryptionVersion;\n     }\n \n     private boolean serverSupportsDataClassification = false;\n+    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;\n \n     boolean getServerSupportsDataClassification() {\n         return serverSupportsDataClassification;\n     }\n \n-    static boolean isWindows;\n+    private boolean serverSupportsDNSCaching = false;\n+    private static ConcurrentHashMap<String, InetSocketAddress> dnsCache = null;\n+\n+    static InetSocketAddress getDNSEntry(String key) {\n+        return (null != dnsCache) ? dnsCache.get(key) : null;\n+    }\n+\n+    byte getServerSupportedDataClassificationVersion() {\n+        return serverSupportedDataClassificationVersion;\n+    }\n+\n+    // Boolean that indicates whether LOB objects created by this connection should be loaded into memory\n+    private boolean delayLoadingLobs = SQLServerDriverBooleanProperty.DELAY_LOADING_LOBS.getDefaultValue();\n+\n+    @Override\n+    public boolean getDelayLoadingLobs() {\n+        return delayLoadingLobs;\n+    }\n+\n+    @Override\n+    public void setDelayLoadingLobs(boolean b) {\n+        delayLoadingLobs = b;\n+    }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n-            isWindows = true;\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n-        } else {\n-            isWindows = false;\n         }\n     }\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n", "next_change": {"commit": "0f3e0a10f2f85b5b357811907fdb487d63e49830", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 1e3a5c0c..961811b8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -719,7 +833,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n-    // This is a per-connection store provider. It can be JKS or AKV.\n+    /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n     /**\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 961811b8..a3c544cb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -826,13 +829,16 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n+\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n+\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "0641e315ebd547d407aa844177c05a68e577490d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex a3c544cb..74c71cc0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -827,18 +824,23 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         delayLoadingLobs = b;\n     }\n \n+    private SessionRecoveryFeature sessionRecovery = new SessionRecoveryFeature(this);\n+\n+    SessionRecoveryFeature getSessionRecovery() {\n+        return sessionRecovery;\n+    }\n+\n+    static boolean isWindows;\n+    \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n-\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n-\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n-\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "09d35bfc2338f1fc7c41a958d1e627fa0d6a2b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 74c71cc0..3f5730c7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -824,23 +827,18 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         delayLoadingLobs = b;\n     }\n \n-    private SessionRecoveryFeature sessionRecovery = new SessionRecoveryFeature(this);\n-\n-    SessionRecoveryFeature getSessionRecovery() {\n-        return sessionRecovery;\n-    }\n-\n-    static boolean isWindows;\n-    \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n+\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n+\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 3f5730c7..860a41ab 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -827,18 +851,23 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         delayLoadingLobs = b;\n     }\n \n+    private SessionRecoveryFeature sessionRecovery = new SessionRecoveryFeature(this);\n+\n+    SessionRecoveryFeature getSessionRecovery() {\n+        return sessionRecovery;\n+    }\n+\n+    static boolean isWindows;\n+    \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n-\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n-\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n-\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "11990186d8cdcd41d6192702805ece43134eb1ba", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 860a41ab..bfda7a2f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -858,16 +865,19 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     }\n \n     static boolean isWindows;\n-    \n+\n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n+\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n+\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "b79396d699d9fa76fd704ce084230647facb1018", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex bfda7a2f..b49fea88 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -879,7 +932,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n \n     /** This is a per-connection store provider. It can be JKS or AKV. */\n-    Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n+    transient Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n     /**\n      * Registers key store providers in the globalCustomColumnEncryptionKeyStoreProviders.\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "79cef888c070a270ef09411ca2e86b7d2cad1365", "committedDate": "2018-10-05 17:48:08 -0700", "message": "Add "}, {"oid": "7e67a2351c64cdb16a1b5faf0ba1feaba0980df7", "committedDate": "2018-10-11 15:12:12 -0700", "message": "Add "}, {"oid": "6618054fad0e2b01efc15bee1686880959cfebbf", "committedDate": "2018-10-12 16:20:12 -0700", "message": "Add "}, {"oid": "98cdc4140f5fce1e0691a386b9f7cb1dc1cacbda", "committedDate": "2018-10-12 16:25:31 -0700", "message": "Fix "}, {"oid": "3e2a2fd8e035b89eae1379f0bac5873e54360045", "committedDate": "2018-10-15 14:35:15 -0700", "message": "Fix "}, {"oid": "5d5f0a66d0d89ede79187d5a062303509b89e986", "committedDate": "2018-10-15 16:56:50 -0700", "message": "Fix "}, {"oid": "a901cbb419731119a12a6729ea38e0fe2c696b89", "committedDate": "2018-10-15 16:57:14 -0700", "message": "Merge remote-tracking branch 'upstream/dev' into ICREnableFeature"}, {"oid": "c25833fb18adcbe9bdb180329955784ad6bf35d5", "committedDate": "2018-11-05 10:09:26 -0800", "message": "update from Microsoft/dev"}, {"oid": "70f1fd52b37558a3da52721f765da3bfa7312fca", "committedDate": "2018-11-08 14:16:59 -0800", "message": "add reconnect thread"}, {"oid": "cc192d36986c1c13fda64f1fa9f2e141e822d26d", "committedDate": "2018-11-08 16:33:58 -0800", "message": "reconnect thread and part of the session recovery writing"}, {"oid": "dfb4cadc777b3cd9e9217a5c08721b455dba4442", "committedDate": "2018-11-08 16:43:24 -0800", "message": "Revert \"reconnect thread and part of the session recovery writing\""}, {"oid": "77f83280273ed455cf3e41db560258f217b7ecf8", "committedDate": "2018-11-08 17:02:30 -0800", "message": "removing writeSessionState changes"}, {"oid": "24cedbb36f493f6e44847c16aa2ee24204f9102b", "committedDate": "2018-11-09 10:45:12 -0800", "message": "remove executors and needless synchronizers"}, {"oid": "521cf633ba3330f47c44e335a86d6d4916127c93", "committedDate": "2018-11-09 10:53:51 -0800", "message": "removed unused imports, formatting, clean up, etc"}, {"oid": "f1a7d2dcff85aeade55dce2df52c58a9d523c17b", "committedDate": "2018-11-09 11:50:15 -0800", "message": "comment"}, {"oid": "a73c39bf43f687d042eed3d552b8de45f49d5c11", "committedDate": "2018-11-09 13:12:08 -0800", "message": "removing duplicate code"}, {"oid": "85fdb019927f71b11a4b22e161bb5f0651ece409", "committedDate": "2018-11-09 13:13:36 -0800", "message": "formatting"}, {"oid": "8180cba1c2a818ece1d5c3c7182fb7153e0380e0", "committedDate": "2018-11-09 13:19:13 -0800", "message": "Add "}, {"oid": "88d49f0de7a2b203e0f794f43a74557d2eccf781", "committedDate": "2018-11-09 13:36:11 -0800", "message": "Merge branch 'ICREnableFeature' of https://github.com/ulvii/mssql-jdbc into ICREnableFeatureMergeFix"}, {"oid": "920706e41ed1e47389e1251452fbedc836485d28", "committedDate": "2018-11-09 14:41:39 -0800", "message": "removing isReconnecting"}, {"oid": "559ed08cf7138ce3f33f7a6873a6a7dfb2f2efa6", "committedDate": "2018-11-09 15:34:46 -0800", "message": "removing isReconnecting"}, {"oid": "036d9532b200913c2cbcbfee94c234abf3221df9", "committedDate": "2018-11-09 15:36:57 -0800", "message": "Add "}, {"oid": "503076fe213e018506f690177c32011f8ec22b62", "committedDate": "2018-11-09 15:41:30 -0800", "message": "adding resource"}, {"oid": "18d4bec283ca6daa52229f575c55ee7542ad0515", "committedDate": "2018-11-09 16:04:20 -0800", "message": "removing comment"}, {"oid": "eaf3516af7518d128271a6751e73bd679478c9e6", "committedDate": "2018-11-09 16:13:09 -0800", "message": "renaming rt to reconnectThread"}, {"oid": "a1ab97e3308cbef1345709f93c1ef317b277d016", "committedDate": "2018-11-09 17:23:29 -0800", "message": "moved reconnectThread into session recovery class"}, {"oid": "6e4665b2ce157c402ba8a49384bc79ce7f8cf6c6", "committedDate": "2018-11-09 17:55:52 -0800", "message": "Add "}, {"oid": "0170f891a15e70c7bf10af283f35a4a55e42a874", "committedDate": "2018-11-13 18:17:55 -0800", "message": "Fix "}, {"oid": "baaf32fb0c39be005484faaf45b1c51a63411ba3", "committedDate": "2018-11-14 13:50:11 -0800", "message": "Revert checks before creating session state table for now"}, {"oid": "5be2dfb03ba23afc08398404bd6fc5971e0b8bc7", "committedDate": "2018-11-14 16:56:24 -0800", "message": "Fix "}, {"oid": "5e940e7f48a1059511dbbfa8e5c0f36fff914df1", "committedDate": "2018-11-22 13:41:27 -0800", "message": "Merge remote-tracking branch 'upstream/dev' into ICREnableFeature"}, {"oid": "1db13b4bf74544ead81bf1ba25f12d294a4a5335", "committedDate": "2018-11-22 14:10:38 -0800", "message": "Login logic for reconnect"}, {"oid": "efc219317ca921791ec5c1a8e903415f52361997", "committedDate": "2018-11-23 14:53:51 -0800", "message": "Query timeout logic for connection resiliency"}, {"oid": "0ea565d77f782ebd466132c200f5cff63b137d7c", "committedDate": "2018-11-23 15:57:47 -0800", "message": "Fix "}, {"oid": "f9d975f3ccb6a2d68668fa61d99b435aee7e8da1", "committedDate": "2018-11-30 14:08:21 -0800", "message": "fix for not immediately failing if database not found (#16)"}, {"oid": "7bdd7ed447257570f5541a8075c485720fe3701e", "committedDate": "2018-12-05 17:44:34 -0800", "message": "Fix "}, {"oid": "0e430d202c09e647f44fa234c230b7c01828713c", "committedDate": "2018-12-06 10:23:04 -0800", "message": "Tds token error (#17)"}, {"oid": "1ae8e3c4244d7169df1115e9bb864a47bbba83b2", "committedDate": "2018-12-11 10:47:50 -0800", "message": "Add tests (#19)"}, {"oid": "af76d7af3846801be86f7f94fbc3318b1ed5bc04", "committedDate": "2020-10-14 17:55:14 -0700", "message": "Make adal4j test dependency only (#1447)"}, {"oid": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "committedDate": "2020-11-19 12:24:40 -0800", "message": "Feature "}, {"oid": "d9909748368af7d2944dab4fa382ee513f2b76f4", "committedDate": "2020-11-27 14:25:58 -0800", "message": "Add maxResultBuffer property (#1431)"}, {"oid": "bd776c2b48691897cee900cc6e821d171f18513a", "committedDate": "2020-11-27 17:53:56 -0800", "message": "Added support for ActiveDirectoryInteractive authentication (#1464)"}, {"oid": "57c3fc3794d978e1886df81d1178989703b851ff", "committedDate": "2021-01-12 11:53:14 -0800", "message": "Handle MFA timeouts during ActiveDirectoryInteractive authentication by retrying connection (#1488)"}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "567ae6ee992f81e945bead5be05a36ab2c744fe5", "committedDate": "2021-02-22 14:30:55 -0800", "message": "Fix clientSecret is null or empty for ActiveDirectoryServicePrincipal in Azure container (#1519)"}, {"oid": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "committedDate": "2021-03-19 14:20:41 -0700", "message": "Open Connection Retry (#1535)"}, {"oid": "0fc61a7e6d54ed0e0e5559ddec0d635a0d7b0d86", "committedDate": "2021-03-24 12:55:09 -0700", "message": "Added Azure Synapse serverless SQL pool, Azure SQL Edge and also updated name for Azure Synapse Analytics (#1543)"}, {"oid": "66b86319ee7fa04c739f04922a8f4666671e8d68", "committedDate": "2021-03-30 15:47:56 -0700", "message": "Added check for invalid timeout (#1555)"}, {"oid": "50b9fdb1f61ad2c53fc73077f6a39873f36158c4", "committedDate": "2021-04-23 17:18:23 -0700", "message": "Adding replication connection option (#1566)"}, {"oid": "ae65652f0edaaca44d2eee4a4b3f44d2233d9860", "committedDate": "2021-04-26 15:41:31 -0700", "message": "Fixes trustStorePassword set to null when using applicationIntent=ReadOnly (#1565)"}, {"oid": "40a6a22f6b4bbe2ca4e467efcca2f60651ee1e4c", "committedDate": "2021-04-27 12:24:13 -0700", "message": "Fixed issue when redirected token contains named instance in servername (#1568)"}, {"oid": "0f3e0a10f2f85b5b357811907fdb487d63e49830", "committedDate": "2021-04-27 20:57:33 -0700", "message": "Fixed javadoc warnings (#1570)"}, {"oid": "a5e9ca7678f700fd77eb3d4dd856f4067c11eea0", "committedDate": "2021-05-20 11:31:24 -0700", "message": "Send the driver version to the database during prelogin (#1583)"}, {"oid": "574b1e1aefecd1162bccf064a26c8e76a9a2c5bf", "committedDate": "2021-06-11 15:01:35 -0700", "message": "Send client process ID to server on Java 9+ (#1595)"}, {"oid": "21b8ec1ac90884ca7c83b7a79a08bf78702b52bb", "committedDate": "2021-06-14 13:17:54 -0700", "message": "Fix multiple, successive connections using AKV provider (#1594)"}, {"oid": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "committedDate": "2021-07-07 11:22:07 -0700", "message": "Integration of old code"}, {"oid": "ad258e21abb401d7bde3073370ad8a7ef16da198", "committedDate": "2021-07-12 13:00:48 -0700", "message": "Fixing test fails"}, {"oid": "8172599fd735a5481b784ed9ef0237b9ab6f7ea2", "committedDate": "2021-07-30 17:23:52 -0700", "message": "Remove Java 9-specific class references from the Java 8 jar (#1626)"}, {"oid": "379a57ce0a3bce03096902474bbfa883959015aa", "committedDate": "2021-08-04 11:48:54 -0700", "message": "Fix memory leak (#1633)"}, {"oid": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "committedDate": "2021-08-12 10:20:32 -0700", "message": "Catching up to dev, 9.5, fixing merge conflicts"}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "0641e315ebd547d407aa844177c05a68e577490d", "committedDate": "2021-08-24 10:19:13 -0700", "message": "fixed feature ack ext"}, {"oid": "09d35bfc2338f1fc7c41a958d1e627fa0d6a2b65", "committedDate": "2021-08-30 11:57:00 -0700", "message": "Add 42108 and 42109 to transient errors list (#1643)"}, {"oid": "b08500889f68eff2ba740b29c644980398c68003", "committedDate": "2021-09-02 20:12:20 -0700", "message": "Integrated new disconnected docket detection"}, {"oid": "1bd85226d25e8b04aed601830fc322c9080811b7", "committedDate": "2021-09-03 14:41:34 -0700", "message": "Fixed a few more tests"}, {"oid": "4693c26b91ba02379f3f11a6eb839ad2e75d3959", "committedDate": "2021-09-07 14:07:27 -0700", "message": "Fixed retryinterval valid"}, {"oid": "0f266c05905874e6f8fb8739d08a7a3e9c9d0256", "committedDate": "2021-09-22 01:16:09 -0700", "message": "Fixed ResiliencyUtil for PooledConnections"}, {"oid": "11990186d8cdcd41d6192702805ece43134eb1ba", "committedDate": "2021-09-22 11:25:29 -0700", "message": "Catching up to dev"}, {"oid": "1d85778906f01fd4835b90b1c2c845d313b3796f", "committedDate": "2021-09-30 10:27:53 -0700", "message": "Reset lang-db-collation"}, {"oid": "47748db76bc86c2e4e237d207f22214eedf05c86", "committedDate": "2021-09-30 12:34:18 -0700", "message": "Missing break"}, {"oid": "54c27e931d2b9d8adbaa983d91c73219861c2d90", "committedDate": "2021-10-13 13:42:56 -0700", "message": "Fixed Polling and Tests for ICR"}, {"oid": "34e3b94ed40ffb12d1062581c687e04a7981d5df", "committedDate": "2021-10-21 11:48:42 -0700", "message": "Checks in case of slow dc vs azuredb"}, {"oid": "890778927388df2139136a5b08c56fa3db64f855", "committedDate": "2021-10-21 14:06:21 -0700", "message": "Reflection instead of public method"}, {"oid": "d3709f3119b668f16577d7a6958b54df253654c8", "committedDate": "2021-10-26 09:58:36 -0700", "message": "Limited runs of tests"}, {"oid": "5715001be63180e0aca9e12543f8c4ef4d368deb", "committedDate": "2021-10-28 02:31:50 -0700", "message": "Addressing code review comments"}, {"oid": "1a5206e06f8313d7d02b81a40559e67a566c35d7", "committedDate": "2021-11-02 17:12:34 -0700", "message": "Catching up to Dev, Addressing review comments"}, {"oid": "3a2a6ab60574035bd33c7f53457e18c66630d57a", "committedDate": "2021-11-04 12:57:28 -0700", "message": "refactored testutils"}, {"oid": "f4ef4f47b7e6d4abc4b6cabf7463d655006aa8cd", "committedDate": "2021-11-04 22:37:22 -0700", "message": "resolving comments"}, {"oid": "8f94517ccbc32ba026084ec605e0e7dcb2227946", "committedDate": "2021-11-05 00:33:50 -0700", "message": "Fixes"}, {"oid": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "committedDate": "2021-11-23 14:40:40 -0800", "message": "New Exception Message (#1683)"}, {"oid": "6ca48b39945ca12d3350218fefdd806e5e42608f", "committedDate": "2021-11-25 13:17:41 -0800", "message": "Fixed ActiveDirectoryInteractive authentication timeout issue (#1696)"}, {"oid": "ab6abfab8c54450d6f534004b55a2f105f456982", "committedDate": "2021-12-01 11:21:10 -0800", "message": "Deprecate and Rename Service principal connection properties (#1693)"}, {"oid": "901ec95427f8e8333296346c93a69efbd012b366", "committedDate": "2021-12-08 15:41:50 -0800", "message": "Retry randomUUID() to mitigate intermittent java NativeSeedGenerator failure (#1705)"}, {"oid": "aef84944b1731fd0de40b004bcff7e44b4f31ad8", "committedDate": "2022-01-24 11:15:26 -0800", "message": "Fix issues detected by SonarQube (#1739)"}, {"oid": "f0d6259851a514d9dd5a8da72ac060bdc00ead67", "committedDate": "2022-02-17 14:55:19 -0800", "message": "Removed extra call to executeCommand (#1754)"}, {"oid": "f9caf73e698206d94097b917e808333cfbf309e5", "committedDate": "2022-02-22 13:42:42 -0800", "message": "Added Azure Active Directory tests for Azure Data Explorer using user/password/applicationName AND removed deprecated tags to fix build warnings (#1755)"}, {"oid": "8806c175b6da532c3f6859cf97090b6434837f04", "committedDate": "2022-03-03 13:47:43 -0800", "message": "Add check for MSAL library when attempting ActiveDirectoryServicePrincipal auth (#1759)"}, {"oid": "d3cb66ee833934c1953fb77dc3462bd3f1e8a623", "committedDate": "2022-03-04 09:55:44 -0800", "message": "Added new connection string property prepareMethod to toggle use of sp_prepare (#1719)"}, {"oid": "887cf6f1665b08cdd61df7f3f8c35153ce397011", "committedDate": "2022-03-16 11:59:53 -0700", "message": "TDSS Support (#1757)"}, {"oid": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "committedDate": "2022-03-29 10:52:14 -0700", "message": "Add serverCertificate connection property for encrypt=strict (#1773)"}, {"oid": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "committedDate": "2022-03-30 11:42:09 -0700", "message": "Add Configurable IPv6 Support (#1766)"}, {"oid": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "committedDate": "2022-03-31 10:25:33 -0700", "message": "Add encrypt utility to obfuscate password strings (#1780)"}, {"oid": "8e66ac0b5364be903d337828f5cec9dd352972e3", "committedDate": "2022-03-31 15:14:51 -0700", "message": "Refactor SQLServerColumnEncryptionAzureKeyVaultProvider usage in SQLServerConnection (#1774)"}, {"oid": "ef08328f33a32572b0f84efda78f87470b09a4f5", "committedDate": "2022-04-01 13:43:10 -0700", "message": "Add option for NONE attestation protocol (#1779)"}, {"oid": "0042429113f117c9b7118e67c13d430e0ba3bcde", "committedDate": "2022-04-12 12:36:10 -0700", "message": "Add ALPN for TDSS connections (#1795)"}, {"oid": "487c355cbaf87a087f310264bdc1cffd7e9223fb", "committedDate": "2022-04-14 13:10:01 -0700", "message": "Refactor Idle Connection Resiliency timeout to use existing SharedTimer (#1794)"}, {"oid": "bec87174b9f6c74f35f36890ac5bd33531479322", "committedDate": "2022-04-19 10:30:01 -0700", "message": "Formatted the check that assigns AE version to correctly assign version to protocol (#1805)"}, {"oid": "17fdf967dcbbcff268c3a6a646287c0c69b5b523", "committedDate": "2022-04-27 11:55:36 -0700", "message": "Avoid String use with secure strings (#1813)"}, {"oid": "fafd6a8d385089e641c7e7d7d0eefeb34558866a", "committedDate": "2022-04-27 15:44:13 -0700", "message": "Fixed TDS 8 to not make double connections (#1817)"}, {"oid": "76941b78626836ed677d9dcce97be432ae8e8b86", "committedDate": "2022-04-29 11:58:49 -0700", "message": "warnings (#1819)"}, {"oid": "7ffc2f0b5c7b88269c7603f5e3faeb1470fd44ea", "committedDate": "2022-05-26 12:09:57 -0700", "message": "Managed Identity token cache (#1825)"}, {"oid": "900fe16ffb7b048d8617d79e5891f3ceb2e314e3", "committedDate": "2022-06-02 18:36:17 -0700", "message": "Added getters and setters for new msiTokenCacheTtl connection prop (#1842)"}, {"oid": "4b2641eaf53dfb3a701bb489a8247817667b5b77", "committedDate": "2022-07-20 15:29:22 -0700", "message": "Added TDS version 8 for strict mode (#1870)"}, {"oid": "87b092e754556c501f75496f241985725b9c56ba", "committedDate": "2022-07-20 17:08:50 -0700", "message": "Cache parameter metadata secure (#1866)"}, {"oid": "7f9a984170ae607fda61644e18193d0580daa632", "committedDate": "2022-07-28 09:00:43 -0700", "message": "Fix sending TDS8 version during login (#1878)"}, {"oid": "8fbd9edeb3e31fc67de1437691864401bf131ae0", "committedDate": "2022-08-25 11:47:09 -0700", "message": "Removed use of toString on a String, empty statements and double parentheses (#1901)"}, {"oid": "bf7adc07ae6e31f96adf2e9ced8fc6603ffec9bf", "committedDate": "2022-10-25 12:37:03 -0700", "message": "Loom friendly synchronization. (#1931)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "1797e17df84eb7c45e106577ed4f847178351db6", "committedDate": "2022-11-03 14:14:48 -0700", "message": "Fixed warnings detected by Sonartype (#1950)"}, {"oid": "c79db605cb78f8593b658ac506aad0f2f3d533d0", "committedDate": "2022-11-03 15:21:54 -0700", "message": "Access token callback (#1940)"}, {"oid": "1572bf66580b9fe085f9834c0dc23ec510fa88aa", "committedDate": "2022-11-03 16:23:47 -0700", "message": "Fixed mixing date import (#1954)"}, {"oid": "7f17532250eec3be7eab1e9a538eae49be905564", "committedDate": "2022-11-14 15:25:44 -0800", "message": "Resolved issues reported by SonarQube (#1962)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "b79396d699d9fa76fd704ce084230647facb1018", "committedDate": "2022-11-25 10:20:37 -0800", "message": "More changes to address sonarqube warnings (#1974)"}, {"oid": "fd16cb823bdaa439097f31b1fcab79102ed1ce74", "committedDate": "2022-12-13 11:01:12 -0800", "message": "Fixed Idle Connection recovery so that unprocessedResponseCount isn't over decremented (#1989)"}, {"oid": "45c606fdfb9c103e093c5ae7424f01e2d5d403f2", "committedDate": "2022-12-21 13:50:32 -0800", "message": "Fixes #1590 - [FEATURE REQUEST] Ability to explicitly specify conversion to datetime or datetime2  (#1687)"}, {"oid": "39561b4a949e72857f3286a2390149f48688fa4c", "committedDate": "2022-12-22 11:03:54 -0800", "message": "cleanup (#2012)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "2abc3d1980f8b1354a4bb8790c51dd9cc0e9d100", "committedDate": "2023-01-23 15:20:46 -0800", "message": "More code cleanup (#2048)"}, {"oid": "11929611c369efbcad01a0249ccfded2243154df", "committedDate": "2023-01-24 17:28:15 -0800", "message": "Suppressed deprecated warning for java security api (#2053)"}, {"oid": "d842883e3e69420a7a798294cb58ac252eead011", "committedDate": "2023-01-26 12:52:12 -0800", "message": "Renamed driver DefaultAzureCredential authentication to ActiveDirectoryDefault (#2055)"}, {"oid": "242911001e33e1ce242aa2066cf725a7553b885d", "committedDate": "2023-02-09 14:18:15 -0800", "message": "Updated fedauth tests to run on diff test server (#2062)"}, {"oid": "e4bc368034ae5421c4e0215bf82335eb36b2aeac", "committedDate": "2023-02-16 13:06:32 -0800", "message": "Updated supportsTransactions method (#2075)"}, {"oid": "d0ab1a587377dd64d7c45e07e959b4857f39bb77", "committedDate": "2023-02-21 11:36:13 -0800", "message": "Added access token callback class connection string property (#2073)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}, {"oid": "9cbaf1754194c4a6391e192f12fc59df7ad3ee03", "committedDate": "2023-02-23 15:54:13 -0800", "message": "more (#2082)"}, {"oid": "18db69cb8c7372c6bf5ba3fc883278436d48e26a", "committedDate": "2023-03-10 14:01:49 -0800", "message": "Fixed jdbcfx metadata test (#2089)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNjAxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r478736011", "body": "[WARNING] Javadoc Warnings\r\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no @throws for com.microsoft.sqlserver.jdbc.SQLServerException\r\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\r\n[WARNING] ^\r\n", "bodyText": "[WARNING] Javadoc Warnings\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no @throws for com.microsoft.sqlserver.jdbc.SQLServerException\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n[WARNING] ^", "bodyHTML": "<p dir=\"auto\">[WARNING] Javadoc Warnings<br>\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/throws/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/throws\">@throws</a> for com.microsoft.sqlserver.jdbc.SQLServerException<br>\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)<br>\n[WARNING] ^</p>", "author": "lilgreenbird", "createdAt": "2020-08-27T22:45:21Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -49,668 +53,682 @@\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    /**\n-     * Column Encryption Key Store Provider string\n-     */\n-    String name = \"AZURE_KEY_VAULT\";\n-\n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n-    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n-\n-    /**\n-     * Algorithm version\n-     */\n-    private final byte[] firstVersion = new byte[] {0x01};\n-\n-    private KeyVaultClient keyVaultClient;\n-\n-    private KeyVaultCredential credentials;\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return this.name;\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * @param clientKey\n-     *        Key of the client requesting the token.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+        private HttpPipeline keyVaultPipeline;\n+        private KeyVaultCredential keyVaultCredential;\n+        /**\n+         * Column Encryption Key Store Provider string\n+         */\n+        String name = \"AZURE_KEY_VAULT\";\n+\n+        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+        private static final List<String> akvTrustedEndpoints;\n+        /**\n+         * Algorithm version\n+         */\n+        private final byte[] firstVersion = new byte[] {0x01};\n+\n+        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+        private TokenCredential credential;\n+\n+        static {\n+                akvTrustedEndpoints = getTrustedEndpoints();\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n-     * @param masterKeyPath\n-     *        - Complete path of an asymmetric key in AKV\n-     * @param encryptionAlgorithm\n-     *        - Asymmetric Key Encryption Algorithm\n-     * @param encryptedColumnEncryptionKey\n-     *        - Encrypted Column Encryption Key\n-     * @return Plain text column encryption key\n-     */\n-    @Override\n-    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-        // Validate the input parameters\n-        this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-        if (null == encryptedColumnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n+\n+        public void setName(String name) {\n+                this.name = name;\n         }\n \n-        if (0 == encryptedColumnEncryptionKey.length) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n+        public String getName() {\n+                return this.name;\n         }\n \n-        // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-        // Validate whether the key is RSA one or not and then get the key size\n-        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-        // Validate and decrypt the EncryptedColumnEncryptionKey\n-        // Format is\n-        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-        //\n-        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-        // asymmetric key pair and\n-        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-        // Validate the version byte\n-        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-            MessageFormat form = new MessageFormat(\n-                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                    String.format(\"%02X \", firstVersion[0])};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n+         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+         * @param clientId Identifier of the client requesting the token.\n+         * @param clientKey Secret key of the client requesting the token.\n+         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n+         */\n+        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n+                throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                if (null == clientKey || clientKey.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client Key\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+\n+                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n+                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n+                        .buildPipeline();\n         }\n \n-        // Get key path length\n-        int currentIndex = firstVersion.length;\n-        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        // We just read 2 bytes\n-        currentIndex += 2;\n-\n-        // Get ciphertext length\n-        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        currentIndex += 2;\n-\n-        // Skip KeyPath\n-        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-        currentIndex += keyPathLength;\n-\n-        // validate the ciphertext length\n-        if (cipherTextLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n         }\n \n-        // Validate the signature length\n-        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param clientId Identifier of the client requesting the token.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        }\n \n-        if (signatureLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n+         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n+         */", "originalCommit": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fbc98936839a5b38ab504a69887c75be90c501b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b76ca77d..47b9da5e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -53,682 +53,785 @@ import com.azure.security.keyvault.keys.models.KeyVaultKey;\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-        private HttpPipeline keyVaultPipeline;\n-        private KeyVaultCredential keyVaultCredential;\n-        /**\n-         * Column Encryption Key Store Provider string\n-         */\n-        String name = \"AZURE_KEY_VAULT\";\n-\n-        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n-        private static final List<String> akvTrustedEndpoints;\n-        /**\n-         * Algorithm version\n-         */\n-        private final byte[] firstVersion = new byte[] {0x01};\n-\n-        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-        private TokenCredential credential;\n-\n-        static {\n-                akvTrustedEndpoints = getTrustedEndpoints();\n+    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Column Encryption Key Store Provider string\n+     */\n+    String name = \"AZURE_KEY_VAULT\";\n+\n+    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n+\n+    /**\n+     * Algorithm version\n+     */\n+    private final byte[] firstVersion = new byte[] {0x01};\n+\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * @param clientKey\n+     *        Secret key of the client requesting the token.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        public void setName(String name) {\n-                this.name = name;\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        public String getName() {\n-                return this.name;\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n-         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-         * @param clientId Identifier of the client requesting the token.\n-         * @param clientKey Secret key of the client requesting the token.\n-         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n-                throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                if (null == clientKey || clientKey.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client Key\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-\n-                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n-                        .buildPipeline();\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        setCredential(tokenCredential);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param clientId Identifier of the client requesting the token.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n+     * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n-         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n-                throws SQLServerException {\n-                createKeyvaultClients(tokenCredential);\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key\n+     * @return Plain text column encryption key\n+     */\n+    @Override\n+    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-                this.credential = Objects.requireNonNull(credential);\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        /**\n-         * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key\n-         * @return Plain text column encryption key\n-         */\n-        @Override public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-                // Validate and decrypt the EncryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                //\n-                // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-                // asymmetric key pair and\n-                // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-                // Validate the version byte\n-                if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-                        Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                                String.format(\"%02X \", firstVersion[0])};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get key path length\n-                int currentIndex = firstVersion.length;\n-                short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                // We just read 2 bytes\n-                currentIndex += 2;\n-\n-                // Get ciphertext length\n-                short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                currentIndex += 2;\n-\n-                // Skip KeyPath\n-                // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-                currentIndex += keyPathLength;\n-\n-                // validate the ciphertext length\n-                if (cipherTextLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-                        Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Validate the signature length\n-                int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n-\n-                if (signatureLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-                        Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get ciphertext\n-                byte[] cipherText = new byte[cipherTextLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n-                currentIndex += cipherTextLength;\n-\n-                // Get signature\n-                byte[] signature = new byte[signatureLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n-\n-                // Compute the hash to validate the signature\n-                byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n-\n-                System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n-                        encryptedColumnEncryptionKey.length - signature.length);\n-\n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(hash);\n-                byte dataToVerify[] = md.digest();\n-\n-                if (null == dataToVerify) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                }\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+\n+        // Validate and decrypt the EncryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        //\n+        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n+        // asymmetric key pair and\n+        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n+\n+        // Validate the version byte\n+        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n+            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n+                    String.format(\"%02X \", firstVersion[0])};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Validate the signature\n-                if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        // Get key path length\n+        int currentIndex = firstVersion.length;\n+        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        // We just read 2 bytes\n+        currentIndex += 2;\n+\n+        // Get ciphertext length\n+        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        currentIndex += 2;\n+\n+        // Skip KeyPath\n+        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n+        currentIndex += keyPathLength;\n+\n+        // validate the ciphertext length\n+        if (cipherTextLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n+            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Decrypt the CEK\n-                byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n+        // Validate the signature length\n+        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n \n-                return decryptedCEK;\n+        if (signatureLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n+            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n+        // Get ciphertext\n+        byte[] cipherText = new byte[cipherTextLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n+        currentIndex += cipherTextLength;\n \n-                short shortVal;\n-                if (index + 1 >= input.length) {\n-                        throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"),\n-                                null, 0, false);\n-                }\n-                ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n-                byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n-                byteBuffer.put(input[index]);\n-                byteBuffer.put(input[index + 1]);\n-                shortVal = byteBuffer.getShort(0);\n-                return shortVal;\n-\n-        }\n-\n-        /**\n-         * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param columnEncryptionKey - Plain text column encryption key\n-         * @return Encrypted column encryption key\n-         */\n-        @Override public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n+        // Get signature\n+        byte[] signature = new byte[signatureLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n \n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n+        // Compute the hash to validate the signature\n+        byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n \n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"),\n-                                null);\n-                }\n+        System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n+                encryptedColumnEncryptionKey.length - signature.length);\n \n-                if (0 == columnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(hash);\n+        byte dataToVerify[] = md.digest();\n \n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+        if (null == dataToVerify) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+        }\n \n-                // Construct the encryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n-                //\n-                // We currently only support one version\n-                byte[] version = new byte[] {firstVersion[0]};\n+        // Validate the signature\n+        if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n-                byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n+        // Decrypt the CEK\n+        byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, keyWrapAlgorithm, cipherText);\n \n-                byte[] keyPathLength = new byte[2];\n-                keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n-                keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n+        return decryptedCEK;\n+    }\n \n-                // Encrypt the plain text\n-                byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n+    private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n \n-                byte[] cipherTextLength = new byte[2];\n-                cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n-                cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n+        short shortVal;\n+        if (index + 1 >= input.length) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"), null, 0,\n+                    false);\n+        }\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n+        byteBuffer.put(input[index]);\n+        byteBuffer.put(input[index + 1]);\n+        shortVal = byteBuffer.getShort(0);\n+        return shortVal;\n+\n+    }\n+\n+    /**\n+     * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param columnEncryptionKey\n+     *        - Plain text column encryption key\n+     * @return Encrypted column encryption key\n+     */\n+    @Override\n+    public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"), null);\n+        }\n \n-                if (cipherText.length != keySizeInBytes) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n-                }\n+        if (0 == columnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+        }\n \n-                // Compute hash\n-                // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n-                byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n-                        + masterKeyPathBytes.length + cipherText.length];\n-                int destinationPosition = version.length;\n-                System.arraycopy(version, 0, dataToHash, 0, version.length);\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n-                System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n-                destinationPosition += keyPathLength.length;\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n \n-                System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n-                destinationPosition += cipherTextLength.length;\n+        // Construct the encryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n+        //\n+        // We currently only support one version\n+        byte[] version = new byte[] {firstVersion[0]};\n \n-                System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n-                destinationPosition += masterKeyPathBytes.length;\n+        // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n+        byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n \n-                System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n+        byte[] keyPathLength = new byte[2];\n+        keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n+        keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n \n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(dataToHash);\n-                byte dataToSign[] = md.digest();\n+        // Encrypt the plain text\n+        byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, keyWrapAlgorithm, columnEncryptionKey);\n \n-                // Sign the hash\n-                byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n+        byte[] cipherTextLength = new byte[2];\n+        cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n+        cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n \n-                if (signedHash.length != keySizeInBytes) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n-                }\n+        if (cipherText.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n+        }\n \n-                if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"),\n-                                null);\n-                }\n+        // Compute hash\n+        // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n+        byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n+                + masterKeyPathBytes.length + cipherText.length];\n+        int destinationPosition = version.length;\n+        System.arraycopy(version, 0, dataToHash, 0, version.length);\n \n-                // Construct the encrypted column encryption key\n-                // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                int encryptedColumnEncryptionKeyLength =\n-                        version.length + cipherTextLength.length + keyPathLength.length + cipherText.length\n-                                + masterKeyPathBytes.length + signedHash.length;\n-                byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+        System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n+        destinationPosition += keyPathLength.length;\n \n-                // Copy version byte\n-                int currentIndex = 0;\n-                System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n-                currentIndex += version.length;\n+        System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n+        destinationPosition += cipherTextLength.length;\n \n-                // Copy key path length\n-                System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n-                currentIndex += keyPathLength.length;\n+        System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n+        destinationPosition += masterKeyPathBytes.length;\n \n-                // Copy ciphertext length\n-                System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        cipherTextLength.length);\n-                currentIndex += cipherTextLength.length;\n+        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n \n-                // Copy key path\n-                System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        masterKeyPathBytes.length);\n-                currentIndex += masterKeyPathBytes.length;\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(dataToHash);\n+        byte dataToSign[] = md.digest();\n \n-                // Copy ciphertext\n-                System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n-                currentIndex += cipherText.length;\n+        // Sign the hash\n+        byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n \n-                // copy the signature\n-                System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+        if (signedHash.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n+        }\n \n-                return encryptedColumnEncryptionKey;\n+        if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"), null);\n         }\n \n-        /**\n-         * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n-         *\n-         * @param encryptionAlgorithm - Asymmetric key encryptio algorithm\n-         * @return The encryption algorithm that is going to be used.\n-         * @throws SQLServerException\n-         */\n-        private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+        // Construct the encrypted column encryption key\n+        // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        int encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length\n+                + cipherText.length + masterKeyPathBytes.length + signedHash.length;\n+        byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+\n+        // Copy version byte\n+        int currentIndex = 0;\n+        System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n+        currentIndex += version.length;\n+\n+        // Copy key path length\n+        System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n+        currentIndex += keyPathLength.length;\n+\n+        // Copy ciphertext length\n+        System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex, cipherTextLength.length);\n+        currentIndex += cipherTextLength.length;\n+\n+        // Copy key path\n+        System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex, masterKeyPathBytes.length);\n+        currentIndex += masterKeyPathBytes.length;\n+\n+        // Copy ciphertext\n+        System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n+        currentIndex += cipherText.length;\n+\n+        // copy the signature\n+        System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+\n+        return encryptedColumnEncryptionKey;\n+    }\n+\n+    /**\n+     * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n+     *\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric key encryptio algorithm\n+     * @return The encryption algorithm that is going to be used.\n+     * @throws SQLServerException\n+     */\n+    private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+\n+        if (null == encryptionAlgorithm) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0,\n+                    false);\n+        }\n \n-                if (null == encryptionAlgorithm) {\n-                        throw new SQLServerException(null,\n-                                SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0, false);\n-                }\n+        // Transform to standard format (dash instead of underscore) to support enum lookup\n+        if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n+            encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n+        }\n \n-                // Transform to standard format (dash instead of underscore) to support enum lookup\n-                if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n-                        encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n-                }\n+        if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n+            Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n-                        Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+    }\n+\n+    /**\n+     * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n+     *\n+     * @param masterKeyPath\n+     * @throws SQLServerException\n+     */\n+    private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n+        // throw appropriate error if masterKeyPath is null or empty\n+        if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+        } else {\n+            URI parsedUri = null;\n+            try {\n+                parsedUri = new URI(masterKeyPath);\n+\n+                // A valid URI.\n+                // Check if it is pointing to a trusted endpoint.\n+                String host = parsedUri.getHost();\n+                if (null != host) {\n+                    host = host.toLowerCase(Locale.ENGLISH);\n+                }\n+                for (final String endpoint : akvTrustedEndpoints) {\n+                    if (null != host && host.endsWith(endpoint)) {\n+                        return;\n+                    }\n+                }\n+            } catch (URISyntaxException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n+                Object[] msgArgs = {masterKeyPath};\n+                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n+            }\n \n-                return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n-\n-        /**\n-         * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n-         *\n-         * @param masterKeyPath\n-         * @throws SQLServerException\n-         */\n-        private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n-                // throw appropriate error if masterKeyPath is null or empty\n-                if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                } else {\n-                        URI parsedUri = null;\n-                        try {\n-                                parsedUri = new URI(masterKeyPath);\n-\n-                                // A valid URI.\n-                                // Check if it is pointing to a trusted endpoint.\n-                                String host = parsedUri.getHost();\n-                                if (null != host) {\n-                                        host = host.toLowerCase(Locale.ENGLISH);\n-                                }\n-                                for (final String endpoint : akvTrustedEndpoints) {\n-                                        if (null != host && host.endsWith(endpoint)) {\n-                                                return;\n-                                        }\n-                                }\n-                        } catch (URISyntaxException e) {\n-                                MessageFormat form = new MessageFormat(\n-                                        SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n-                                Object[] msgArgs = {masterKeyPath};\n-                                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n-                        }\n-\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encryption Algorithm.\n+     * @param columnEncryptionKey\n+     *        - Plain text Column Encryption Key.\n+     * @return Returns an encrypted blob or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encryption Algorithm.\n-         * @param columnEncryptionKey - Plain text Column Encryption Key.\n-         * @return Returns an encrypted blob or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n-                }\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n-                return wrappedKey.getEncryptedKey();\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n+        return wrappedKey.getEncryptedKey();\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encrypted Column Encryption Key.\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key.\n+     * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encrypted Column Encryption Key.\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key.\n-         * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n-                }\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+        }\n \n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n-                }\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n \n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n \n-                UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n+        return unwrappedKey.getKey();\n+    }\n \n-                return unwrappedKey.getKey();\n+    private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n+        if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n+            return cachedCryptographyClients.get(masterKeyPath);\n         }\n \n-        private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n-                if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n-                        return cachedCryptographyClients.get(masterKeyPath);\n-                }\n-\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n \n-                CryptographyClient cryptoClient;\n-                if (null != credential) {\n-                        cryptoClient = new CryptographyClientBuilder().credential(credential)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                } else {\n-                        cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                }\n-                cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n-                return cachedCryptographyClients.get(masterKeyPath);\n+        CryptographyClient cryptoClient;\n+        if (null != credential) {\n+            cryptoClient = new CryptographyClientBuilder().credential(credential).keyIdentifier(retrievedKey.getId())\n+                    .buildClient();\n+        } else {\n+            cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n+                    .keyIdentifier(retrievedKey.getId()).buildClient();\n+        }\n+        cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n+        return cachedCryptographyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n+     *\n+     * @param dataToSign\n+     *        - Text to sign.\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return Signature\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToSign) && (0 != dataToSign.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n+        return signedData.getSignature();\n+    }\n+\n+    /**\n+     * Verifies the given RSA PKCSv1.5 signature.\n+     *\n+     * @param dataToVerify\n+     * @param signature\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return true if signature is valid, false if it is not valid\n+     * @throws SQLServerException\n+     */\n+    private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature,\n+            String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToVerify) && (0 != dataToVerify.length));\n+        assert ((null != signature) && (0 != signature.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+\n+        return valid.isValid();\n+    }\n+\n+    /**\n+     * Returns the public Key size in bytes.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault Key path\n+     * @return Key size in bytes\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        return retrievedKey.getKey().getN().length;\n+    }\n+\n+    /**\n+     * Fetches the key from Azure Key Vault for given key path. If the key path includes a version, then that specific\n+     * version of the key is retrieved, otherwise the latest key will be retrieved.\n+     * \n+     * @param masterKeyPath\n+     *        The key path associated with the key\n+     * @return The Key Vault key.\n+     * @throws SQLServerException\n+     *         If there was an error retrieving the key from Key Vault.\n+     */\n+    private KeyVaultKey getKeyVaultKey(String masterKeyPath) throws SQLServerException {\n+        String[] keyTokens = masterKeyPath.split(KEY_URL_DELIMITER);\n+        String keyName = keyTokens[KEY_NAME_INDEX];\n+        String keyVersion = null;\n+        if (keyTokens.length == KEY_URL_SPLIT_LENGTH_WITH_VERSION) {\n+            keyVersion = keyTokens[keyTokens.length - 1];\n         }\n \n-        /**\n-         * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n-         *\n-         * @param dataToSign - Text to sign.\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return Signature\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n-                assert ((null != dataToSign) && (0 != dataToSign.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n-                return signedData.getSignature();\n-        }\n-\n-        /**\n-         * Verifies the given RSA PKCSv1.5 signature.\n-         *\n-         * @param dataToVerify\n-         * @param signature\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return true if signature is valid, false if it is not valid\n-         * @throws SQLServerException\n-         */\n-        private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature, String masterKeyPath)\n-                throws SQLServerException {\n-                assert ((null != dataToVerify) && (0 != dataToVerify.length));\n-                assert ((null != signature) && (0 != signature.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+        try {\n+            KeyClient keyClient = getKeyClient(masterKeyPath);\n+            KeyVaultKey retrievedKey;\n+            if (null != keyVersion) {\n+                retrievedKey = keyClient.getKey(keyName, keyVersion);\n+            } else {\n+                retrievedKey = keyClient.getKey(keyName);\n+            }\n+            if (null == retrievedKey) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n+                Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n+                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+            }\n \n-                return valid.isValid();\n+            if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n+                Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n+                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+            }\n+            return retrievedKey;\n+        } catch (RuntimeException e) {\n+            throw new SQLServerException(e.getMessage(), e);\n         }\n \n-        /**\n-         * Returns the public Key size in bytes.\n-         *\n-         * @param masterKeyPath - Azure Key Vault Key path\n-         * @return Key size in bytes\n-         * @throws SQLServerException when an error occurs\n-         */\n-        private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-                return retrievedKey.getKey().getN().length;\n-        }\n-\n-        private KeyVaultKey getKeyVaultKey(String masterKeyPath)\n-                throws SQLServerException {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String keyName = keyTokens[keyTokens.length - 2];\n-                String keyVersion = keyTokens[keyTokens.length - 1];\n-                KeyClient keyClient = getKeyClient(masterKeyPath);\n-                KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n-\n-                if (null == retrievedKey) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n-                        Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Creates a new {@link KeyClient} if one does not exist for the given key path. If the client already exists, the\n+     * client is returned from the cache. As the client is stateless, it's safe to cache the client for each key path.\n+     * \n+     * @param masterKeyPath\n+     *        The key path for which the {@link KeyClient} will be created, if it does not exist.\n+     * @return The {@link KeyClient} associated with the key path.\n+     */\n+    private KeyClient getKeyClient(String masterKeyPath) {\n+        if (cachedKeyClients.containsKey(masterKeyPath)) {\n+            return cachedKeyClients.get(masterKeyPath);\n+        }\n+        String vaultUrl = getVaultUrl(masterKeyPath);\n \n-                if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n-                        Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n-                return retrievedKey;\n+        KeyClient keyClient;\n+        if (null != credential) {\n+            keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n+        } else {\n+            keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n+        }\n+        cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n+        return cachedKeyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Returns the vault url extracted from the master key path.\n+     * \n+     * @param masterKeyPath\n+     *        The master key path.\n+     * @return The vault url.\n+     */\n+    private static String getVaultUrl(String masterKeyPath) {\n+        String[] keyTokens = masterKeyPath.split(\"/\");\n+        String hostName = keyTokens[2];\n+        return \"https://\" + hostName;\n+    }\n+\n+    @Override\n+    public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n+            byte[] signature) throws SQLServerException {\n+        if (!allowEnclaveComputations) {\n+            return false;\n         }\n \n-        private KeyClient getKeyClient(String masterKeyPath) {\n-                if (cachedKeyClients.containsKey(masterKeyPath)) {\n-                        return cachedKeyClients.get(masterKeyPath);\n-                }\n-                String vaultUrl = getVaultUrl(masterKeyPath);\n+        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n \n-                KeyClient keyClient;\n-                if (null != credential) {\n-                        keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n-                } else {\n-                        keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n-                }\n-                cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n-                return cachedKeyClients.get(masterKeyPath);\n-        }\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            // value of allowEnclaveComputations is always true here\n+            md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n \n-        private static String getVaultUrl(String masterKeyPath) {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String hostName = keyTokens[2];\n-                return \"https://\" + hostName;\n-        }\n+            byte[] dataToVerify = md.digest();\n+            if (null == dataToVerify) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+            }\n \n-        @Override public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n-                byte[] signature) throws SQLServerException {\n-            if (!allowEnclaveComputations) {\n-                return false;\n+            // Sign the hash\n+            byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n+            if (null == signedHash) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n             }\n \n-                KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n-\n-                try {\n-                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n-                        md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        // value of allowEnclaveComputations is always true here\n-                        md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-\n-                        byte[] dataToVerify = md.digest();\n-                        if (null == dataToVerify) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                        }\n-\n-                        // Sign the hash\n-                        byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n-                        if (null == signedHash) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"),\n-                                        null);\n-                        }\n-\n-                        // Validate the signature\n-                        return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n+            // Validate the signature\n+            return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n-\n-        private static List<String> getTrustedEndpoints() {\n-                Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n-                List<String> trustedEndpoints = new ArrayList<String>();\n-                boolean append = true;\n-                if (null != mssqlJdbcProperties) {\n-                        String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n-                        if (null != endpoints && !endpoints.trim().isEmpty()) {\n-                                endpoints = endpoints.trim();\n-                                // Append if the list starts with a semicolon.\n-                                if (';' != endpoints.charAt(0)) {\n-                                        append = false;\n-                                } else {\n-                                        endpoints = endpoints.substring(1);\n-                                }\n-                                String[] entries = endpoints.split(\";\");\n-                                for (String entry : entries) {\n-                                        if (null != entry && !entry.trim().isEmpty()) {\n-                                                trustedEndpoints.add(entry.trim());\n-                                        }\n-                                }\n-                        }\n+    }\n+\n+    private static List<String> getTrustedEndpoints() {\n+        Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n+        List<String> trustedEndpoints = new ArrayList<String>();\n+        boolean append = true;\n+        if (null != mssqlJdbcProperties) {\n+            String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n+            if (null != endpoints && !endpoints.trim().isEmpty()) {\n+                endpoints = endpoints.trim();\n+                // Append if the list starts with a semicolon.\n+                if (';' != endpoints.charAt(0)) {\n+                    append = false;\n+                } else {\n+                    endpoints = endpoints.substring(1);\n                 }\n-                /*\n-                 * List of Azure trusted endpoints\n-                 * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n-                 */\n-                if (append) {\n-                        trustedEndpoints.add(\"vault.azure.net\");\n-                        trustedEndpoints.add(\"vault.azure.cn\");\n-                        trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n-                        trustedEndpoints.add(\"vault.microsoftazure.de\");\n+                String[] entries = endpoints.split(\";\");\n+                for (String entry : entries) {\n+                    if (null != entry && !entry.trim().isEmpty()) {\n+                        trustedEndpoints.add(entry.trim());\n+                    }\n                 }\n-                return trustedEndpoints;\n+            }\n         }\n-\n-        /**\n-         * Attempt to read MSSQL_JDBC_PROPERTIES.\n-         *\n-         * @return corresponding Properties object or null if failed to read the file.\n+        /*\n+         * List of Azure trusted endpoints\n+         * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n          */\n-        private static Properties getMssqlJdbcProperties() {\n-                Properties props = null;\n-                try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n-                        props = new Properties();\n-                        props.load(in);\n-                } catch (IOException e) {\n-                        if (akvLogger.isLoggable(Level.FINER)) {\n-                                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n-                        }\n-                }\n-                return (null != props && !props.isEmpty()) ? props : null;\n+        if (append) {\n+            trustedEndpoints.add(\"vault.azure.net\");\n+            trustedEndpoints.add(\"vault.azure.cn\");\n+            trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"vault.microsoftazure.de\");\n+        }\n+        return trustedEndpoints;\n+    }\n+\n+    /**\n+     * Attempt to read MSSQL_JDBC_PROPERTIES.\n+     *\n+     * @return corresponding Properties object or null if failed to read the file.\n+     */\n+    private static Properties getMssqlJdbcProperties() {\n+        Properties props = null;\n+        try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n+            props = new Properties();\n+            props.load(in);\n+        } catch (IOException e) {\n+            if (akvLogger.isLoggable(Level.FINER)) {\n+                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n+            }\n         }\n+        return (null != props && !props.isEmpty()) ? props : null;\n+    }\n }\n", "next_change": {"commit": "8d1f4622295ed6fa69a2d57c57797f6dc1261620", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 47b9da5e..8d18bb85 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -53,785 +53,681 @@ import com.azure.security.keyvault.keys.models.KeyVaultKey;\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    private static final int KEY_NAME_INDEX = 4;\n-    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n-    private static final String KEY_URL_DELIMITER = \"/\";\n-    private HttpPipeline keyVaultPipeline;\n-    private KeyVaultTokenCredential keyVaultTokenCredential;\n-\n-    /**\n-     * Column Encryption Key Store Provider string\n-     */\n-    String name = \"AZURE_KEY_VAULT\";\n-\n-    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n-    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n-\n-    /**\n-     * Algorithm version\n-     */\n-    private final byte[] firstVersion = new byte[] {0x01};\n-\n-    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-    private TokenCredential credential;\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return this.name;\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * @param clientKey\n-     *        Secret key of the client requesting the token.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n+        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+        private HttpPipeline keyVaultPipeline;\n+        private KeyVaultCredential keyVaultCredential;\n+        /**\n+         * Column Encryption Key Store Provider string\n+         */\n+        String name = \"AZURE_KEY_VAULT\";\n+\n+        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+        private static final List<String> akvTrustedEndpoints;\n+        /**\n+         * Algorithm version\n+         */\n+        private final byte[] firstVersion = new byte[] {0x01};\n \n-        // create a token credential with given client id and secret which internally identifies the tenant id.\n-        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n-        // create the pipeline with the custom Key Vault credential\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n-     * client at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        setCredential(new ManagedIdentityCredentialBuilder().build());\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n-     * client at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+        private TokenCredential credential;\n+\n+        static {\n+                akvTrustedEndpoints = getTrustedEndpoints();\n         }\n-        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+\n+        public void setName(String name) {\n+                this.name = name;\n         }\n \n-        setCredential(tokenCredential);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-     *\n-     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+        public String getName() {\n+                return this.name;\n         }\n \n-        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n-    }\n-\n-    /**\n-     * Sets the credential that will be used for authenticating requests to Key Vault service.\n-     * \n-     * @param credential\n-     *        A credential of type {@link TokenCredential}.\n-     * @throws SQLServerException\n-     *         If the credential is null.\n-     */\n-    private void setCredential(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n+         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+         * @param clientId Identifier of the client requesting the token.\n+         * @param clientKey Secret key of the client requesting the token.\n+         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n+         */\n+        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n+                throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                if (null == clientKey || clientKey.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client Key\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+\n+                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n+                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n+                        .buildPipeline();\n         }\n \n-        this.credential = credential;\n-    }\n-\n-    /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n-     * @param masterKeyPath\n-     *        - Complete path of an asymmetric key in AKV\n-     * @param encryptionAlgorithm\n-     *        - Asymmetric Key Encryption Algorithm\n-     * @param encryptedColumnEncryptionKey\n-     *        - Encrypted Column Encryption Key\n-     * @return Plain text column encryption key\n-     */\n-    @Override\n-    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-        // Validate the input parameters\n-        this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-        if (null == encryptedColumnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n         }\n \n-        if (0 == encryptedColumnEncryptionKey.length) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param clientId Identifier of the client requesting the token.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n         }\n \n-        // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-        // Validate whether the key is RSA one or not and then get the key size\n-        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-        // Validate and decrypt the EncryptedColumnEncryptionKey\n-        // Format is\n-        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-        //\n-        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-        // asymmetric key pair and\n-        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-        // Validate the version byte\n-        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-            MessageFormat form = new MessageFormat(\n-                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                    String.format(\"%02X \", firstVersion[0])};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n+         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n+         */\n+        public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) {\n+                createKeyvaultClients(tokenCredential);\n         }\n \n-        // Get key path length\n-        int currentIndex = firstVersion.length;\n-        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        // We just read 2 bytes\n-        currentIndex += 2;\n-\n-        // Get ciphertext length\n-        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        currentIndex += 2;\n-\n-        // Skip KeyPath\n-        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-        currentIndex += keyPathLength;\n-\n-        // validate the ciphertext length\n-        if (cipherTextLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        private void createKeyvaultClients(TokenCredential credential) {\n+                this.credential = Objects.requireNonNull(credential);\n         }\n \n-        // Validate the signature length\n-        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n+        /**\n+         * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+         *\n+         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n+         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n+         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key\n+         * @return Plain text column encryption key\n+         */\n+        @Override public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n \n-        if (signatureLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-        }\n+                // Validate the input parameters\n+                this.ValidateNonEmptyAKVPath(masterKeyPath);\n \n-        // Get ciphertext\n-        byte[] cipherText = new byte[cipherTextLength];\n-        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n-        currentIndex += cipherTextLength;\n+                if (null == encryptedColumnEncryptionKey) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n+                }\n \n-        // Get signature\n-        byte[] signature = new byte[signatureLength];\n-        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n+                if (0 == encryptedColumnEncryptionKey.length) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n+                }\n \n-        // Compute the hash to validate the signature\n-        byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n+                // Validate encryptionAlgorithm\n+                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+\n+                // Validate whether the key is RSA one or not and then get the key size\n+                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+\n+                // Validate and decrypt the EncryptedColumnEncryptionKey\n+                // Format is\n+                // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+                //\n+                // keyPath is present in the encrypted column encryption key for identifying the original source of the\n+                // asymmetric key pair and\n+                // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n+\n+                // Validate the version byte\n+                if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n+                        MessageFormat form = new MessageFormat(\n+                                SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n+                        Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n+                                String.format(\"%02X \", firstVersion[0])};\n+                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+                }\n \n-        System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n-                encryptedColumnEncryptionKey.length - signature.length);\n+                // Get key path length\n+                int currentIndex = firstVersion.length;\n+                short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+                // We just read 2 bytes\n+                currentIndex += 2;\n+\n+                // Get ciphertext length\n+                short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+                currentIndex += 2;\n+\n+                // Skip KeyPath\n+                // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n+                currentIndex += keyPathLength;\n+\n+                // validate the ciphertext length\n+                if (cipherTextLength != keySizeInBytes) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n+                        Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n+                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+                }\n \n-        MessageDigest md = null;\n-        try {\n-            md = MessageDigest.getInstance(\"SHA-256\");\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-        }\n-        md.update(hash);\n-        byte dataToVerify[] = md.digest();\n+                // Validate the signature length\n+                int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n \n-        if (null == dataToVerify) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-        }\n+                if (signatureLength != keySizeInBytes) {\n+                        MessageFormat form = new MessageFormat(\n+                                SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n+                        Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n+                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+                }\n \n-        // Validate the signature\n-        if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n-            Object[] msgArgs = {masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-        }\n+                // Get ciphertext\n+                byte[] cipherText = new byte[cipherTextLength];\n+                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n+                currentIndex += cipherTextLength;\n \n-        // Decrypt the CEK\n-        byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, keyWrapAlgorithm, cipherText);\n+                // Get signature\n+                byte[] signature = new byte[signatureLength];\n+                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n \n-        return decryptedCEK;\n-    }\n+                // Compute the hash to validate the signature\n+                byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n \n-    private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n+                System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n+                        encryptedColumnEncryptionKey.length - signature.length);\n \n-        short shortVal;\n-        if (index + 1 >= input.length) {\n-            throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"), null, 0,\n-                    false);\n-        }\n-        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n-        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n-        byteBuffer.put(input[index]);\n-        byteBuffer.put(input[index + 1]);\n-        shortVal = byteBuffer.getShort(0);\n-        return shortVal;\n-\n-    }\n-\n-    /**\n-     * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n-     *\n-     * @param masterKeyPath\n-     *        - Complete path of an asymmetric key in AKV\n-     * @param encryptionAlgorithm\n-     *        - Asymmetric Key Encryption Algorithm\n-     * @param columnEncryptionKey\n-     *        - Plain text column encryption key\n-     * @return Encrypted column encryption key\n-     */\n-    @Override\n-    public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-            byte[] columnEncryptionKey) throws SQLServerException {\n-\n-        // Validate the input parameters\n-        this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-        if (null == columnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"), null);\n-        }\n+                MessageDigest md = null;\n+                try {\n+                        md = MessageDigest.getInstance(\"SHA-256\");\n+                } catch (NoSuchAlgorithmException e) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+                }\n+                md.update(hash);\n+                byte dataToVerify[] = md.digest();\n+\n+                if (null == dataToVerify) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+                }\n+\n+                // Validate the signature\n+                if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n+                        MessageFormat form = new MessageFormat(\n+                                SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n+                        Object[] msgArgs = {masterKeyPath};\n+                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+                }\n \n-        if (0 == columnEncryptionKey.length) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+                // Decrypt the CEK\n+                byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n+\n+                return decryptedCEK;\n         }\n \n-        // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n \n-        // Validate whether the key is RSA one or not and then get the key size\n-        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+                short shortVal;\n+                if (index + 1 >= input.length) {\n+                        throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"),\n+                                null, 0, false);\n+                }\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+                byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n+                byteBuffer.put(input[index]);\n+                byteBuffer.put(input[index + 1]);\n+                shortVal = byteBuffer.getShort(0);\n+                return shortVal;\n+\n+        }\n+\n+        /**\n+         * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n+         *\n+         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n+         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n+         * @param columnEncryptionKey - Plain text column encryption key\n+         * @return Encrypted column encryption key\n+         */\n+        @Override public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+                byte[] columnEncryptionKey) throws SQLServerException {\n \n-        // Construct the encryptedColumnEncryptionKey\n-        // Format is\n-        // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n-        //\n-        // We currently only support one version\n-        byte[] version = new byte[] {firstVersion[0]};\n+                // Validate the input parameters\n+                this.ValidateNonEmptyAKVPath(masterKeyPath);\n \n-        // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n-        byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n+                if (null == columnEncryptionKey) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"),\n+                                null);\n+                }\n \n-        byte[] keyPathLength = new byte[2];\n-        keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n-        keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n+                if (0 == columnEncryptionKey.length) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+                }\n \n-        // Encrypt the plain text\n-        byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, keyWrapAlgorithm, columnEncryptionKey);\n+                // Validate encryptionAlgorithm\n+                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n-        byte[] cipherTextLength = new byte[2];\n-        cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n-        cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n+                // Validate whether the key is RSA one or not and then get the key size\n+                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n \n-        if (cipherText.length != keySizeInBytes) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n-        }\n+                // Construct the encryptedColumnEncryptionKey\n+                // Format is\n+                // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n+                //\n+                // We currently only support one version\n+                byte[] version = new byte[] {firstVersion[0]};\n \n-        // Compute hash\n-        // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n-        byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n-                + masterKeyPathBytes.length + cipherText.length];\n-        int destinationPosition = version.length;\n-        System.arraycopy(version, 0, dataToHash, 0, version.length);\n+                // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n+                byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n \n-        System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n-        destinationPosition += keyPathLength.length;\n+                byte[] keyPathLength = new byte[2];\n+                keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n+                keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n \n-        System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n-        destinationPosition += cipherTextLength.length;\n+                // Encrypt the plain text\n+                byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n \n-        System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n-        destinationPosition += masterKeyPathBytes.length;\n+                byte[] cipherTextLength = new byte[2];\n+                cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n+                cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n \n-        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n+                if (cipherText.length != keySizeInBytes) {\n+                        throw new SQLServerException(\n+                                SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n+                }\n \n-        MessageDigest md = null;\n-        try {\n-            md = MessageDigest.getInstance(\"SHA-256\");\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-        }\n-        md.update(dataToHash);\n-        byte dataToSign[] = md.digest();\n+                // Compute hash\n+                // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n+                byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n+                        + masterKeyPathBytes.length + cipherText.length];\n+                int destinationPosition = version.length;\n+                System.arraycopy(version, 0, dataToHash, 0, version.length);\n \n-        // Sign the hash\n-        byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n+                System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n+                destinationPosition += keyPathLength.length;\n \n-        if (signedHash.length != keySizeInBytes) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n-        }\n+                System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n+                destinationPosition += cipherTextLength.length;\n \n-        if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"), null);\n-        }\n+                System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n+                destinationPosition += masterKeyPathBytes.length;\n \n-        // Construct the encrypted column encryption key\n-        // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-        int encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length\n-                + cipherText.length + masterKeyPathBytes.length + signedHash.length;\n-        byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n-\n-        // Copy version byte\n-        int currentIndex = 0;\n-        System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n-        currentIndex += version.length;\n-\n-        // Copy key path length\n-        System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n-        currentIndex += keyPathLength.length;\n-\n-        // Copy ciphertext length\n-        System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex, cipherTextLength.length);\n-        currentIndex += cipherTextLength.length;\n-\n-        // Copy key path\n-        System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex, masterKeyPathBytes.length);\n-        currentIndex += masterKeyPathBytes.length;\n-\n-        // Copy ciphertext\n-        System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n-        currentIndex += cipherText.length;\n-\n-        // copy the signature\n-        System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n-\n-        return encryptedColumnEncryptionKey;\n-    }\n-\n-    /**\n-     * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n-     *\n-     * @param encryptionAlgorithm\n-     *        - Asymmetric key encryptio algorithm\n-     * @return The encryption algorithm that is going to be used.\n-     * @throws SQLServerException\n-     */\n-    private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n-\n-        if (null == encryptionAlgorithm) {\n-            throw new SQLServerException(null, SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0,\n-                    false);\n-        }\n+                System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n \n-        // Transform to standard format (dash instead of underscore) to support enum lookup\n-        if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n-            encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n-        }\n+                MessageDigest md = null;\n+                try {\n+                        md = MessageDigest.getInstance(\"SHA-256\");\n+                } catch (NoSuchAlgorithmException e) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+                }\n+                md.update(dataToHash);\n+                byte dataToSign[] = md.digest();\n \n-        if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n-            Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-        }\n+                // Sign the hash\n+                byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n \n-        return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n-    }\n-\n-    /**\n-     * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n-     *\n-     * @param masterKeyPath\n-     * @throws SQLServerException\n-     */\n-    private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n-        // throw appropriate error if masterKeyPath is null or empty\n-        if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n-            Object[] msgArgs = {masterKeyPath};\n-            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-        } else {\n-            URI parsedUri = null;\n-            try {\n-                parsedUri = new URI(masterKeyPath);\n-\n-                // A valid URI.\n-                // Check if it is pointing to a trusted endpoint.\n-                String host = parsedUri.getHost();\n-                if (null != host) {\n-                    host = host.toLowerCase(Locale.ENGLISH);\n-                }\n-                for (final String endpoint : akvTrustedEndpoints) {\n-                    if (null != host && host.endsWith(endpoint)) {\n-                        return;\n-                    }\n-                }\n-            } catch (URISyntaxException e) {\n-                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n-                Object[] msgArgs = {masterKeyPath};\n-                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n-            }\n+                if (signedHash.length != keySizeInBytes) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n+                }\n+\n+                if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"),\n+                                null);\n+                }\n+\n+                // Construct the encrypted column encryption key\n+                // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+                int encryptedColumnEncryptionKeyLength =\n+                        version.length + cipherTextLength.length + keyPathLength.length + cipherText.length\n+                                + masterKeyPathBytes.length + signedHash.length;\n+                byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+\n+                // Copy version byte\n+                int currentIndex = 0;\n+                System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n+                currentIndex += version.length;\n \n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n-            Object[] msgArgs = {masterKeyPath};\n-            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                // Copy key path length\n+                System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n+                currentIndex += keyPathLength.length;\n+\n+                // Copy ciphertext length\n+                System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex,\n+                        cipherTextLength.length);\n+                currentIndex += cipherTextLength.length;\n+\n+                // Copy key path\n+                System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex,\n+                        masterKeyPathBytes.length);\n+                currentIndex += masterKeyPathBytes.length;\n+\n+                // Copy ciphertext\n+                System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n+                currentIndex += cipherText.length;\n+\n+                // copy the signature\n+                System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+\n+                return encryptedColumnEncryptionKey;\n         }\n-    }\n-\n-    /**\n-     * Encrypts the text using specified Azure Key Vault key.\n-     *\n-     * @param masterKeyPath\n-     *        - Azure Key Vault key url.\n-     * @param encryptionAlgorithm\n-     *        - Encryption Algorithm.\n-     * @param columnEncryptionKey\n-     *        - Plain text Column Encryption Key.\n-     * @return Returns an encrypted blob or throws an exception if there are any errors.\n-     * @throws SQLServerException\n-     */\n-    private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-            byte[] columnEncryptionKey) throws SQLServerException {\n-        if (null == columnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n+\n+        /**\n+         * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n+         *\n+         * @param encryptionAlgorithm - Asymmetric key encryptio algorithm\n+         * @return The encryption algorithm that is going to be used.\n+         * @throws SQLServerException\n+         */\n+        private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+\n+                if (null == encryptionAlgorithm) {\n+                        throw new SQLServerException(null,\n+                                SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0, false);\n+                }\n+\n+                // Transform to standard format (dash instead of underscore) to support enum lookup\n+                if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n+                        encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n+                }\n+\n+                if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n+                        MessageFormat form = new MessageFormat(\n+                                SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n+                        Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n+                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+                }\n+\n+                return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n         }\n \n-        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-        WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n-        return wrappedKey.getEncryptedKey();\n-    }\n-\n-    /**\n-     * Encrypts the text using specified Azure Key Vault key.\n-     *\n-     * @param masterKeyPath\n-     *        - Azure Key Vault key url.\n-     * @param encryptionAlgorithm\n-     *        - Encrypted Column Encryption Key.\n-     * @param encryptedColumnEncryptionKey\n-     *        - Encrypted Column Encryption Key.\n-     * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n-     * @throws SQLServerException\n-     */\n-    private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-        if (null == encryptedColumnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n+        /**\n+         * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n+         *\n+         * @param masterKeyPath\n+         * @throws SQLServerException\n+         */\n+        private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n+                // throw appropriate error if masterKeyPath is null or empty\n+                if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n+                        Object[] msgArgs = {masterKeyPath};\n+                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                } else {\n+                        URI parsedUri = null;\n+                        try {\n+                                parsedUri = new URI(masterKeyPath);\n+\n+                                // A valid URI.\n+                                // Check if it is pointing to a trusted endpoint.\n+                                String host = parsedUri.getHost();\n+                                if (null != host) {\n+                                        host = host.toLowerCase(Locale.ENGLISH);\n+                                }\n+                                for (final String endpoint : akvTrustedEndpoints) {\n+                                        if (null != host && host.endsWith(endpoint)) {\n+                                                return;\n+                                        }\n+                                }\n+                        } catch (URISyntaxException e) {\n+                                MessageFormat form = new MessageFormat(\n+                                        SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n+                                Object[] msgArgs = {masterKeyPath};\n+                                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n+                        }\n+\n+                        MessageFormat form = new MessageFormat(\n+                                SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n+                        Object[] msgArgs = {masterKeyPath};\n+                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                }\n         }\n \n-        if (0 == encryptedColumnEncryptionKey.length) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+        /**\n+         * Encrypts the text using specified Azure Key Vault key.\n+         *\n+         * @param masterKeyPath - Azure Key Vault key url.\n+         * @param encryptionAlgorithm - Encryption Algorithm.\n+         * @param columnEncryptionKey - Plain text Column Encryption Key.\n+         * @return Returns an encrypted blob or throws an exception if there are any errors.\n+         * @throws SQLServerException\n+         */\n+        private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+                byte[] columnEncryptionKey) throws SQLServerException {\n+                if (null == columnEncryptionKey) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n+                }\n+\n+                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+                WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n+                return wrappedKey.getEncryptedKey();\n         }\n \n-        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        /**\n+         * Encrypts the text using specified Azure Key Vault key.\n+         *\n+         * @param masterKeyPath - Azure Key Vault key url.\n+         * @param encryptionAlgorithm - Encrypted Column Encryption Key.\n+         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key.\n+         * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n+         * @throws SQLServerException\n+         */\n+        private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+                if (null == encryptedColumnEncryptionKey) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n+                }\n+\n+                if (0 == encryptedColumnEncryptionKey.length) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+                }\n \n-        UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n+                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n \n-        return unwrappedKey.getKey();\n-    }\n+                UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n \n-    private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n-        if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n-            return cachedCryptographyClients.get(masterKeyPath);\n+                return unwrappedKey.getKey();\n         }\n \n-        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n+                if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n+                        return cachedCryptographyClients.get(masterKeyPath);\n+                }\n \n-        CryptographyClient cryptoClient;\n-        if (null != credential) {\n-            cryptoClient = new CryptographyClientBuilder().credential(credential).keyIdentifier(retrievedKey.getId())\n-                    .buildClient();\n-        } else {\n-            cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n-                    .keyIdentifier(retrievedKey.getId()).buildClient();\n-        }\n-        cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n-        return cachedCryptographyClients.get(masterKeyPath);\n-    }\n-\n-    /**\n-     * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n-     *\n-     * @param dataToSign\n-     *        - Text to sign.\n-     * @param masterKeyPath\n-     *        - Azure Key Vault key url.\n-     * @return Signature\n-     * @throws SQLServerException\n-     */\n-    private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n-        assert ((null != dataToSign) && (0 != dataToSign.length));\n-\n-        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-        SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n-        return signedData.getSignature();\n-    }\n-\n-    /**\n-     * Verifies the given RSA PKCSv1.5 signature.\n-     *\n-     * @param dataToVerify\n-     * @param signature\n-     * @param masterKeyPath\n-     *        - Azure Key Vault key url.\n-     * @return true if signature is valid, false if it is not valid\n-     * @throws SQLServerException\n-     */\n-    private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature,\n-            String masterKeyPath) throws SQLServerException {\n-        assert ((null != dataToVerify) && (0 != dataToVerify.length));\n-        assert ((null != signature) && (0 != signature.length));\n-\n-        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-        VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n-\n-        return valid.isValid();\n-    }\n-\n-    /**\n-     * Returns the public Key size in bytes.\n-     *\n-     * @param masterKeyPath\n-     *        - Azure Key Vault Key path\n-     * @return Key size in bytes\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n-        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-        return retrievedKey.getKey().getN().length;\n-    }\n-\n-    /**\n-     * Fetches the key from Azure Key Vault for given key path. If the key path includes a version, then that specific\n-     * version of the key is retrieved, otherwise the latest key will be retrieved.\n-     * \n-     * @param masterKeyPath\n-     *        The key path associated with the key\n-     * @return The Key Vault key.\n-     * @throws SQLServerException\n-     *         If there was an error retrieving the key from Key Vault.\n-     */\n-    private KeyVaultKey getKeyVaultKey(String masterKeyPath) throws SQLServerException {\n-        String[] keyTokens = masterKeyPath.split(KEY_URL_DELIMITER);\n-        String keyName = keyTokens[KEY_NAME_INDEX];\n-        String keyVersion = null;\n-        if (keyTokens.length == KEY_URL_SPLIT_LENGTH_WITH_VERSION) {\n-            keyVersion = keyTokens[keyTokens.length - 1];\n+                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+\n+                CryptographyClient cryptoClient;\n+                if (null != credential) {\n+                        cryptoClient = new CryptographyClientBuilder().credential(credential)\n+                                .keyIdentifier(retrievedKey.getId()).buildClient();\n+                } else {\n+                        cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n+                                .keyIdentifier(retrievedKey.getId()).buildClient();\n+                }\n+                cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n+                return cachedCryptographyClients.get(masterKeyPath);\n         }\n \n-        try {\n-            KeyClient keyClient = getKeyClient(masterKeyPath);\n-            KeyVaultKey retrievedKey;\n-            if (null != keyVersion) {\n-                retrievedKey = keyClient.getKey(keyName, keyVersion);\n-            } else {\n-                retrievedKey = keyClient.getKey(keyName);\n-            }\n-            if (null == retrievedKey) {\n-                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n-                Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n-                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-            }\n+        /**\n+         * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n+         *\n+         * @param dataToSign - Text to sign.\n+         * @param masterKeyPath - Azure Key Vault key url.\n+         * @return Signature\n+         * @throws SQLServerException\n+         */\n+        private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n+                assert ((null != dataToSign) && (0 != dataToSign.length));\n+\n+                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+                SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n+                return signedData.getSignature();\n+        }\n+\n+        /**\n+         * Verifies the given RSA PKCSv1.5 signature.\n+         *\n+         * @param dataToVerify\n+         * @param signature\n+         * @param masterKeyPath - Azure Key Vault key url.\n+         * @return true if signature is valid, false if it is not valid\n+         * @throws SQLServerException\n+         */\n+        private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature, String masterKeyPath)\n+                throws SQLServerException {\n+                assert ((null != dataToVerify) && (0 != dataToVerify.length));\n+                assert ((null != signature) && (0 != signature.length));\n \n-            if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n-                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n-                Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n-                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-            }\n-            return retrievedKey;\n-        } catch (RuntimeException e) {\n-            throw new SQLServerException(e.getMessage(), e);\n-        }\n+                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+                VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n \n-    }\n-\n-    /**\n-     * Creates a new {@link KeyClient} if one does not exist for the given key path. If the client already exists, the\n-     * client is returned from the cache. As the client is stateless, it's safe to cache the client for each key path.\n-     * \n-     * @param masterKeyPath\n-     *        The key path for which the {@link KeyClient} will be created, if it does not exist.\n-     * @return The {@link KeyClient} associated with the key path.\n-     */\n-    private KeyClient getKeyClient(String masterKeyPath) {\n-        if (cachedKeyClients.containsKey(masterKeyPath)) {\n-            return cachedKeyClients.get(masterKeyPath);\n+                return valid.isValid();\n         }\n-        String vaultUrl = getVaultUrl(masterKeyPath);\n \n-        KeyClient keyClient;\n-        if (null != credential) {\n-            keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n-        } else {\n-            keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n-        }\n-        cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n-        return cachedKeyClients.get(masterKeyPath);\n-    }\n-\n-    /**\n-     * Returns the vault url extracted from the master key path.\n-     * \n-     * @param masterKeyPath\n-     *        The master key path.\n-     * @return The vault url.\n-     */\n-    private static String getVaultUrl(String masterKeyPath) {\n-        String[] keyTokens = masterKeyPath.split(\"/\");\n-        String hostName = keyTokens[2];\n-        return \"https://\" + hostName;\n-    }\n-\n-    @Override\n-    public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n-            byte[] signature) throws SQLServerException {\n-        if (!allowEnclaveComputations) {\n-            return false;\n+        /**\n+         * Returns the public Key size in bytes.\n+         *\n+         * @param masterKeyPath - Azure Key Vault Key path\n+         * @return Key size in bytes\n+         * @throws SQLServerException when an error occurs\n+         */\n+        private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n+                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+                return retrievedKey.getKey().getN().length;\n+        }\n+\n+        private KeyVaultKey getKeyVaultKey(String masterKeyPath)\n+                throws SQLServerException {\n+                String[] keyTokens = masterKeyPath.split(\"/\");\n+                String keyName = keyTokens[keyTokens.length - 2];\n+                String keyVersion = keyTokens[keyTokens.length - 1];\n+                KeyClient keyClient = getKeyClient(masterKeyPath);\n+                KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n+\n+                if (null == retrievedKey) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n+                        Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n+                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                }\n+\n+                if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n+                        Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n+                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+                }\n+                return retrievedKey;\n         }\n \n-        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n+        private KeyClient getKeyClient(String masterKeyPath) {\n+                if (cachedKeyClients.containsKey(masterKeyPath)) {\n+                        return cachedKeyClients.get(masterKeyPath);\n+                }\n+                String vaultUrl = getVaultUrl(masterKeyPath);\n \n-        try {\n-            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n-            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-            // value of allowEnclaveComputations is always true here\n-            md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+                KeyClient keyClient;\n+                if (null != credential) {\n+                        keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n+                } else {\n+                        keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n+                }\n+                cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n+                return cachedKeyClients.get(masterKeyPath);\n+        }\n \n-            byte[] dataToVerify = md.digest();\n-            if (null == dataToVerify) {\n-                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-            }\n+        private static String getVaultUrl(String masterKeyPath) {\n+                String[] keyTokens = masterKeyPath.split(\"/\");\n+                String hostName = keyTokens[2];\n+                return \"https://\" + hostName;\n+        }\n \n-            // Sign the hash\n-            byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n-            if (null == signedHash) {\n-                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n+        @Override public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n+                byte[] signature) throws SQLServerException {\n+            if (!allowEnclaveComputations) {\n+                return false;\n             }\n \n-            // Validate the signature\n-            return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+                KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n+\n+                try {\n+                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+                        md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+                        md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+                        // value of allowEnclaveComputations is always true here\n+                        md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+\n+                        byte[] dataToVerify = md.digest();\n+                        if (null == dataToVerify) {\n+                                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+                        }\n+\n+                        // Sign the hash\n+                        byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n+                        if (null == signedHash) {\n+                                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"),\n+                                        null);\n+                        }\n+\n+                        // Validate the signature\n+                        return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n+                } catch (NoSuchAlgorithmException e) {\n+                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+                }\n         }\n-    }\n-\n-    private static List<String> getTrustedEndpoints() {\n-        Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n-        List<String> trustedEndpoints = new ArrayList<String>();\n-        boolean append = true;\n-        if (null != mssqlJdbcProperties) {\n-            String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n-            if (null != endpoints && !endpoints.trim().isEmpty()) {\n-                endpoints = endpoints.trim();\n-                // Append if the list starts with a semicolon.\n-                if (';' != endpoints.charAt(0)) {\n-                    append = false;\n-                } else {\n-                    endpoints = endpoints.substring(1);\n+\n+        private static List<String> getTrustedEndpoints() {\n+                Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n+                List<String> trustedEndpoints = new ArrayList<String>();\n+                boolean append = true;\n+                if (null != mssqlJdbcProperties) {\n+                        String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n+                        if (null != endpoints && !endpoints.trim().isEmpty()) {\n+                                endpoints = endpoints.trim();\n+                                // Append if the list starts with a semicolon.\n+                                if (';' != endpoints.charAt(0)) {\n+                                        append = false;\n+                                } else {\n+                                        endpoints = endpoints.substring(1);\n+                                }\n+                                String[] entries = endpoints.split(\";\");\n+                                for (String entry : entries) {\n+                                        if (null != entry && !entry.trim().isEmpty()) {\n+                                                trustedEndpoints.add(entry.trim());\n+                                        }\n+                                }\n+                        }\n                 }\n-                String[] entries = endpoints.split(\";\");\n-                for (String entry : entries) {\n-                    if (null != entry && !entry.trim().isEmpty()) {\n-                        trustedEndpoints.add(entry.trim());\n-                    }\n+                /*\n+                 * List of Azure trusted endpoints\n+                 * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n+                 */\n+                if (append) {\n+                        trustedEndpoints.add(\"vault.azure.net\");\n+                        trustedEndpoints.add(\"vault.azure.cn\");\n+                        trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n+                        trustedEndpoints.add(\"vault.microsoftazure.de\");\n                 }\n-            }\n+                return trustedEndpoints;\n         }\n-        /*\n-         * List of Azure trusted endpoints\n-         * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n+\n+        /**\n+         * Attempt to read MSSQL_JDBC_PROPERTIES.\n+         *\n+         * @return corresponding Properties object or null if failed to read the file.\n          */\n-        if (append) {\n-            trustedEndpoints.add(\"vault.azure.net\");\n-            trustedEndpoints.add(\"vault.azure.cn\");\n-            trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n-            trustedEndpoints.add(\"vault.microsoftazure.de\");\n-        }\n-        return trustedEndpoints;\n-    }\n-\n-    /**\n-     * Attempt to read MSSQL_JDBC_PROPERTIES.\n-     *\n-     * @return corresponding Properties object or null if failed to read the file.\n-     */\n-    private static Properties getMssqlJdbcProperties() {\n-        Properties props = null;\n-        try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n-            props = new Properties();\n-            props.load(in);\n-        } catch (IOException e) {\n-            if (akvLogger.isLoggable(Level.FINER)) {\n-                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n-            }\n+        private static Properties getMssqlJdbcProperties() {\n+                Properties props = null;\n+                try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n+                        props = new Properties();\n+                        props.load(in);\n+                } catch (IOException e) {\n+                        if (akvLogger.isLoggable(Level.FINER)) {\n+                                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n+                        }\n+                }\n+                return (null != props && !props.isEmpty()) ? props : null;\n         }\n-        return (null != props && !props.isEmpty()) ? props : null;\n-    }\n }\n", "next_change": {"commit": "04c05bdbcf9de991536d7972a6874d3dfc58148c", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 8d18bb85..6cfe473f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -53,681 +54,691 @@ import com.azure.security.keyvault.keys.models.KeyVaultKey;\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-        private HttpPipeline keyVaultPipeline;\n-        private KeyVaultCredential keyVaultCredential;\n-        /**\n-         * Column Encryption Key Store Provider string\n-         */\n-        String name = \"AZURE_KEY_VAULT\";\n-\n-        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n-        private static final List<String> akvTrustedEndpoints;\n-        /**\n-         * Algorithm version\n-         */\n-        private final byte[] firstVersion = new byte[] {0x01};\n-\n-        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-        private TokenCredential credential;\n-\n-        static {\n-                akvTrustedEndpoints = getTrustedEndpoints();\n+    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultCredential keyVaultCredential;\n+    /**\n+     * Column Encryption Key Store Provider string\n+     */\n+    String name = \"AZURE_KEY_VAULT\";\n+\n+    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+    private static final List<String> akvTrustedEndpoints;\n+    /**\n+     * Algorithm version\n+     */\n+    private final byte[] firstVersion = new byte[] {0x01};\n+\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n+\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * @param clientKey\n+     *        Secret key of the client requesting the token.\n+     * @throws SQLServerException\n+     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        public void setName(String name) {\n-                this.name = name;\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        public String getName() {\n-                return this.name;\n+        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n-         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-         * @param clientId Identifier of the client requesting the token.\n-         * @param clientKey Secret key of the client requesting the token.\n-         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n-                throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                if (null == clientKey || clientKey.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client Key\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-\n-                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n-                        .buildPipeline();\n+        createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) {\n+        createKeyvaultClients(tokenCredential);\n+    }\n+\n+    private void createKeyvaultClients(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential);\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key\n+     * @return Plain text column encryption key\n+     */\n+    @Override\n+    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param clientId Identifier of the client requesting the token.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+\n+        // Validate and decrypt the EncryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        //\n+        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n+        // asymmetric key pair and\n+        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n+\n+        // Validate the version byte\n+        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n+            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n+                    String.format(\"%02X \", firstVersion[0])};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n-         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) {\n-                createKeyvaultClients(tokenCredential);\n+        // Get key path length\n+        int currentIndex = firstVersion.length;\n+        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        // We just read 2 bytes\n+        currentIndex += 2;\n+\n+        // Get ciphertext length\n+        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        currentIndex += 2;\n+\n+        // Skip KeyPath\n+        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n+        currentIndex += keyPathLength;\n+\n+        // validate the ciphertext length\n+        if (cipherTextLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n+            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        private void createKeyvaultClients(TokenCredential credential) {\n-                this.credential = Objects.requireNonNull(credential);\n-        }\n-\n-        /**\n-         * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key\n-         * @return Plain text column encryption key\n-         */\n-        @Override public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-                // Validate and decrypt the EncryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                //\n-                // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-                // asymmetric key pair and\n-                // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-                // Validate the version byte\n-                if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-                        Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                                String.format(\"%02X \", firstVersion[0])};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get key path length\n-                int currentIndex = firstVersion.length;\n-                short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                // We just read 2 bytes\n-                currentIndex += 2;\n-\n-                // Get ciphertext length\n-                short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                currentIndex += 2;\n-\n-                // Skip KeyPath\n-                // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-                currentIndex += keyPathLength;\n-\n-                // validate the ciphertext length\n-                if (cipherTextLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-                        Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Validate the signature length\n-                int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n-\n-                if (signatureLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-                        Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get ciphertext\n-                byte[] cipherText = new byte[cipherTextLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n-                currentIndex += cipherTextLength;\n-\n-                // Get signature\n-                byte[] signature = new byte[signatureLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n+        // Validate the signature length\n+        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n \n-                // Compute the hash to validate the signature\n-                byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n-\n-                System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n-                        encryptedColumnEncryptionKey.length - signature.length);\n-\n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(hash);\n-                byte dataToVerify[] = md.digest();\n-\n-                if (null == dataToVerify) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                }\n-\n-                // Validate the signature\n-                if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Decrypt the CEK\n-                byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n-\n-                return decryptedCEK;\n+        if (signatureLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n+            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n+        // Get ciphertext\n+        byte[] cipherText = new byte[cipherTextLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n+        currentIndex += cipherTextLength;\n \n-                short shortVal;\n-                if (index + 1 >= input.length) {\n-                        throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"),\n-                                null, 0, false);\n-                }\n-                ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n-                byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n-                byteBuffer.put(input[index]);\n-                byteBuffer.put(input[index + 1]);\n-                shortVal = byteBuffer.getShort(0);\n-                return shortVal;\n-\n-        }\n-\n-        /**\n-         * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param columnEncryptionKey - Plain text column encryption key\n-         * @return Encrypted column encryption key\n-         */\n-        @Override public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n+        // Get signature\n+        byte[] signature = new byte[signatureLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n \n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n+        // Compute the hash to validate the signature\n+        byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n \n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"),\n-                                null);\n-                }\n-\n-                if (0 == columnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n-                }\n+        System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n+                encryptedColumnEncryptionKey.length - signature.length);\n \n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(hash);\n+        byte dataToVerify[] = md.digest();\n \n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+        if (null == dataToVerify) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+        }\n \n-                // Construct the encryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n-                //\n-                // We currently only support one version\n-                byte[] version = new byte[] {firstVersion[0]};\n+        // Validate the signature\n+        if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n-                byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n+        // Decrypt the CEK\n+        byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n \n-                byte[] keyPathLength = new byte[2];\n-                keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n-                keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n+        return decryptedCEK;\n+    }\n \n-                // Encrypt the plain text\n-                byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n+    private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n \n-                byte[] cipherTextLength = new byte[2];\n-                cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n-                cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n+        short shortVal;\n+        if (index + 1 >= input.length) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"), null, 0,\n+                    false);\n+        }\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n+        byteBuffer.put(input[index]);\n+        byteBuffer.put(input[index + 1]);\n+        shortVal = byteBuffer.getShort(0);\n+        return shortVal;\n+\n+    }\n+\n+    /**\n+     * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param columnEncryptionKey\n+     *        - Plain text column encryption key\n+     * @return Encrypted column encryption key\n+     */\n+    @Override\n+    public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"), null);\n+        }\n \n-                if (cipherText.length != keySizeInBytes) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n-                }\n+        if (0 == columnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+        }\n \n-                // Compute hash\n-                // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n-                byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n-                        + masterKeyPathBytes.length + cipherText.length];\n-                int destinationPosition = version.length;\n-                System.arraycopy(version, 0, dataToHash, 0, version.length);\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n-                System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n-                destinationPosition += keyPathLength.length;\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n \n-                System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n-                destinationPosition += cipherTextLength.length;\n+        // Construct the encryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n+        //\n+        // We currently only support one version\n+        byte[] version = new byte[] {firstVersion[0]};\n \n-                System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n-                destinationPosition += masterKeyPathBytes.length;\n+        // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n+        byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n \n-                System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n+        byte[] keyPathLength = new byte[2];\n+        keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n+        keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n \n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(dataToHash);\n-                byte dataToSign[] = md.digest();\n+        // Encrypt the plain text\n+        byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n \n-                // Sign the hash\n-                byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n+        byte[] cipherTextLength = new byte[2];\n+        cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n+        cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n \n-                if (signedHash.length != keySizeInBytes) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n-                }\n+        if (cipherText.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n+        }\n \n-                if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"),\n-                                null);\n-                }\n+        // Compute hash\n+        // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n+        byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n+                + masterKeyPathBytes.length + cipherText.length];\n+        int destinationPosition = version.length;\n+        System.arraycopy(version, 0, dataToHash, 0, version.length);\n \n-                // Construct the encrypted column encryption key\n-                // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                int encryptedColumnEncryptionKeyLength =\n-                        version.length + cipherTextLength.length + keyPathLength.length + cipherText.length\n-                                + masterKeyPathBytes.length + signedHash.length;\n-                byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+        System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n+        destinationPosition += keyPathLength.length;\n \n-                // Copy version byte\n-                int currentIndex = 0;\n-                System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n-                currentIndex += version.length;\n+        System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n+        destinationPosition += cipherTextLength.length;\n \n-                // Copy key path length\n-                System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n-                currentIndex += keyPathLength.length;\n+        System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n+        destinationPosition += masterKeyPathBytes.length;\n \n-                // Copy ciphertext length\n-                System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        cipherTextLength.length);\n-                currentIndex += cipherTextLength.length;\n+        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n \n-                // Copy key path\n-                System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        masterKeyPathBytes.length);\n-                currentIndex += masterKeyPathBytes.length;\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(dataToHash);\n+        byte dataToSign[] = md.digest();\n \n-                // Copy ciphertext\n-                System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n-                currentIndex += cipherText.length;\n+        // Sign the hash\n+        byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n \n-                // copy the signature\n-                System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+        if (signedHash.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n+        }\n \n-                return encryptedColumnEncryptionKey;\n+        if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"), null);\n         }\n \n-        /**\n-         * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n-         *\n-         * @param encryptionAlgorithm - Asymmetric key encryptio algorithm\n-         * @return The encryption algorithm that is going to be used.\n-         * @throws SQLServerException\n-         */\n-        private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+        // Construct the encrypted column encryption key\n+        // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        int encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length\n+                + cipherText.length + masterKeyPathBytes.length + signedHash.length;\n+        byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+\n+        // Copy version byte\n+        int currentIndex = 0;\n+        System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n+        currentIndex += version.length;\n+\n+        // Copy key path length\n+        System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n+        currentIndex += keyPathLength.length;\n+\n+        // Copy ciphertext length\n+        System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex, cipherTextLength.length);\n+        currentIndex += cipherTextLength.length;\n+\n+        // Copy key path\n+        System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex, masterKeyPathBytes.length);\n+        currentIndex += masterKeyPathBytes.length;\n+\n+        // Copy ciphertext\n+        System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n+        currentIndex += cipherText.length;\n+\n+        // copy the signature\n+        System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+\n+        return encryptedColumnEncryptionKey;\n+    }\n+\n+    /**\n+     * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n+     *\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric key encryptio algorithm\n+     * @return The encryption algorithm that is going to be used.\n+     * @throws SQLServerException\n+     */\n+    private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+\n+        if (null == encryptionAlgorithm) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0,\n+                    false);\n+        }\n \n-                if (null == encryptionAlgorithm) {\n-                        throw new SQLServerException(null,\n-                                SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0, false);\n-                }\n+        // Transform to standard format (dash instead of underscore) to support enum lookup\n+        if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n+            encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n+        }\n \n-                // Transform to standard format (dash instead of underscore) to support enum lookup\n-                if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n-                        encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n-                }\n+        if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n+            Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n-                        Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+    }\n+\n+    /**\n+     * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n+     *\n+     * @param masterKeyPath\n+     * @throws SQLServerException\n+     */\n+    private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n+        // throw appropriate error if masterKeyPath is null or empty\n+        if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+        } else {\n+            URI parsedUri = null;\n+            try {\n+                parsedUri = new URI(masterKeyPath);\n+\n+                // A valid URI.\n+                // Check if it is pointing to a trusted endpoint.\n+                String host = parsedUri.getHost();\n+                if (null != host) {\n+                    host = host.toLowerCase(Locale.ENGLISH);\n+                }\n+                for (final String endpoint : akvTrustedEndpoints) {\n+                    if (null != host && host.endsWith(endpoint)) {\n+                        return;\n+                    }\n+                }\n+            } catch (URISyntaxException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n+                Object[] msgArgs = {masterKeyPath};\n+                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n+            }\n \n-                return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n-\n-        /**\n-         * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n-         *\n-         * @param masterKeyPath\n-         * @throws SQLServerException\n-         */\n-        private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n-                // throw appropriate error if masterKeyPath is null or empty\n-                if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                } else {\n-                        URI parsedUri = null;\n-                        try {\n-                                parsedUri = new URI(masterKeyPath);\n-\n-                                // A valid URI.\n-                                // Check if it is pointing to a trusted endpoint.\n-                                String host = parsedUri.getHost();\n-                                if (null != host) {\n-                                        host = host.toLowerCase(Locale.ENGLISH);\n-                                }\n-                                for (final String endpoint : akvTrustedEndpoints) {\n-                                        if (null != host && host.endsWith(endpoint)) {\n-                                                return;\n-                                        }\n-                                }\n-                        } catch (URISyntaxException e) {\n-                                MessageFormat form = new MessageFormat(\n-                                        SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n-                                Object[] msgArgs = {masterKeyPath};\n-                                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n-                        }\n-\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encryption Algorithm.\n+     * @param columnEncryptionKey\n+     *        - Plain text Column Encryption Key.\n+     * @return Returns an encrypted blob or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encryption Algorithm.\n-         * @param columnEncryptionKey - Plain text Column Encryption Key.\n-         * @return Returns an encrypted blob or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n-                }\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n-                return wrappedKey.getEncryptedKey();\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n+        return wrappedKey.getEncryptedKey();\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encrypted Column Encryption Key.\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key.\n+     * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encrypted Column Encryption Key.\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key.\n-         * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n-                }\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+        }\n \n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n-                }\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n \n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n \n-                UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n+        return unwrappedKey.getKey();\n+    }\n \n-                return unwrappedKey.getKey();\n+    private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n+        if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n+            return cachedCryptographyClients.get(masterKeyPath);\n         }\n \n-        private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n-                if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n-                        return cachedCryptographyClients.get(masterKeyPath);\n-                }\n-\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n \n-                CryptographyClient cryptoClient;\n-                if (null != credential) {\n-                        cryptoClient = new CryptographyClientBuilder().credential(credential)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                } else {\n-                        cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                }\n-                cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n-                return cachedCryptographyClients.get(masterKeyPath);\n+        CryptographyClient cryptoClient;\n+        if (null != credential) {\n+            cryptoClient = new CryptographyClientBuilder().credential(credential).keyIdentifier(retrievedKey.getId())\n+                    .buildClient();\n+        } else {\n+            cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n+                    .keyIdentifier(retrievedKey.getId()).buildClient();\n+        }\n+        cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n+        return cachedCryptographyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n+     *\n+     * @param dataToSign\n+     *        - Text to sign.\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return Signature\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToSign) && (0 != dataToSign.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n+        return signedData.getSignature();\n+    }\n+\n+    /**\n+     * Verifies the given RSA PKCSv1.5 signature.\n+     *\n+     * @param dataToVerify\n+     * @param signature\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return true if signature is valid, false if it is not valid\n+     * @throws SQLServerException\n+     */\n+    private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature,\n+            String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToVerify) && (0 != dataToVerify.length));\n+        assert ((null != signature) && (0 != signature.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+\n+        return valid.isValid();\n+    }\n+\n+    /**\n+     * Returns the public Key size in bytes.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault Key path\n+     * @return Key size in bytes\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        return retrievedKey.getKey().getN().length;\n+    }\n+\n+    private KeyVaultKey getKeyVaultKey(String masterKeyPath) throws SQLServerException {\n+        String[] keyTokens = masterKeyPath.split(\"/\");\n+        String keyName = keyTokens[keyTokens.length - 2];\n+        String keyVersion = keyTokens[keyTokens.length - 1];\n+        KeyClient keyClient = getKeyClient(masterKeyPath);\n+        KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n+\n+        if (null == retrievedKey) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n+            Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n \n-        /**\n-         * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n-         *\n-         * @param dataToSign - Text to sign.\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return Signature\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n-                assert ((null != dataToSign) && (0 != dataToSign.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n-                return signedData.getSignature();\n-        }\n-\n-        /**\n-         * Verifies the given RSA PKCSv1.5 signature.\n-         *\n-         * @param dataToVerify\n-         * @param signature\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return true if signature is valid, false if it is not valid\n-         * @throws SQLServerException\n-         */\n-        private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature, String masterKeyPath)\n-                throws SQLServerException {\n-                assert ((null != dataToVerify) && (0 != dataToVerify.length));\n-                assert ((null != signature) && (0 != signature.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n-\n-                return valid.isValid();\n+        if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n+            Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n+        return retrievedKey;\n+    }\n \n-        /**\n-         * Returns the public Key size in bytes.\n-         *\n-         * @param masterKeyPath - Azure Key Vault Key path\n-         * @return Key size in bytes\n-         * @throws SQLServerException when an error occurs\n-         */\n-        private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-                return retrievedKey.getKey().getN().length;\n-        }\n-\n-        private KeyVaultKey getKeyVaultKey(String masterKeyPath)\n-                throws SQLServerException {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String keyName = keyTokens[keyTokens.length - 2];\n-                String keyVersion = keyTokens[keyTokens.length - 1];\n-                KeyClient keyClient = getKeyClient(masterKeyPath);\n-                KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n-\n-                if (null == retrievedKey) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n-                        Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    private KeyClient getKeyClient(String masterKeyPath) {\n+        if (cachedKeyClients.containsKey(masterKeyPath)) {\n+            return cachedKeyClients.get(masterKeyPath);\n+        }\n+        String vaultUrl = getVaultUrl(masterKeyPath);\n \n-                if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n-                        Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n-                return retrievedKey;\n+        KeyClient keyClient;\n+        if (null != credential) {\n+            keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n+        } else {\n+            keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n+        }\n+        cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n+        return cachedKeyClients.get(masterKeyPath);\n+    }\n+\n+    private static String getVaultUrl(String masterKeyPath) {\n+        String[] keyTokens = masterKeyPath.split(\"/\");\n+        String hostName = keyTokens[2];\n+        return \"https://\" + hostName;\n+    }\n+\n+    @Override\n+    public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n+            byte[] signature) throws SQLServerException {\n+        if (!allowEnclaveComputations) {\n+            return false;\n         }\n \n-        private KeyClient getKeyClient(String masterKeyPath) {\n-                if (cachedKeyClients.containsKey(masterKeyPath)) {\n-                        return cachedKeyClients.get(masterKeyPath);\n-                }\n-                String vaultUrl = getVaultUrl(masterKeyPath);\n+        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n \n-                KeyClient keyClient;\n-                if (null != credential) {\n-                        keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n-                } else {\n-                        keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n-                }\n-                cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n-                return cachedKeyClients.get(masterKeyPath);\n-        }\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            // value of allowEnclaveComputations is always true here\n+            md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n \n-        private static String getVaultUrl(String masterKeyPath) {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String hostName = keyTokens[2];\n-                return \"https://\" + hostName;\n-        }\n+            byte[] dataToVerify = md.digest();\n+            if (null == dataToVerify) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+            }\n \n-        @Override public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n-                byte[] signature) throws SQLServerException {\n-            if (!allowEnclaveComputations) {\n-                return false;\n+            // Sign the hash\n+            byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n+            if (null == signedHash) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n             }\n \n-                KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n-\n-                try {\n-                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n-                        md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        // value of allowEnclaveComputations is always true here\n-                        md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-\n-                        byte[] dataToVerify = md.digest();\n-                        if (null == dataToVerify) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                        }\n-\n-                        // Sign the hash\n-                        byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n-                        if (null == signedHash) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"),\n-                                        null);\n-                        }\n-\n-                        // Validate the signature\n-                        return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n+            // Validate the signature\n+            return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n-\n-        private static List<String> getTrustedEndpoints() {\n-                Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n-                List<String> trustedEndpoints = new ArrayList<String>();\n-                boolean append = true;\n-                if (null != mssqlJdbcProperties) {\n-                        String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n-                        if (null != endpoints && !endpoints.trim().isEmpty()) {\n-                                endpoints = endpoints.trim();\n-                                // Append if the list starts with a semicolon.\n-                                if (';' != endpoints.charAt(0)) {\n-                                        append = false;\n-                                } else {\n-                                        endpoints = endpoints.substring(1);\n-                                }\n-                                String[] entries = endpoints.split(\";\");\n-                                for (String entry : entries) {\n-                                        if (null != entry && !entry.trim().isEmpty()) {\n-                                                trustedEndpoints.add(entry.trim());\n-                                        }\n-                                }\n-                        }\n+    }\n+\n+    private static List<String> getTrustedEndpoints() {\n+        Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n+        List<String> trustedEndpoints = new ArrayList<String>();\n+        boolean append = true;\n+        if (null != mssqlJdbcProperties) {\n+            String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n+            if (null != endpoints && !endpoints.trim().isEmpty()) {\n+                endpoints = endpoints.trim();\n+                // Append if the list starts with a semicolon.\n+                if (';' != endpoints.charAt(0)) {\n+                    append = false;\n+                } else {\n+                    endpoints = endpoints.substring(1);\n                 }\n-                /*\n-                 * List of Azure trusted endpoints\n-                 * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n-                 */\n-                if (append) {\n-                        trustedEndpoints.add(\"vault.azure.net\");\n-                        trustedEndpoints.add(\"vault.azure.cn\");\n-                        trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n-                        trustedEndpoints.add(\"vault.microsoftazure.de\");\n+                String[] entries = endpoints.split(\";\");\n+                for (String entry : entries) {\n+                    if (null != entry && !entry.trim().isEmpty()) {\n+                        trustedEndpoints.add(entry.trim());\n+                    }\n                 }\n-                return trustedEndpoints;\n+            }\n         }\n-\n-        /**\n-         * Attempt to read MSSQL_JDBC_PROPERTIES.\n-         *\n-         * @return corresponding Properties object or null if failed to read the file.\n+        /*\n+         * List of Azure trusted endpoints\n+         * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n          */\n-        private static Properties getMssqlJdbcProperties() {\n-                Properties props = null;\n-                try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n-                        props = new Properties();\n-                        props.load(in);\n-                } catch (IOException e) {\n-                        if (akvLogger.isLoggable(Level.FINER)) {\n-                                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n-                        }\n-                }\n-                return (null != props && !props.isEmpty()) ? props : null;\n+        if (append) {\n+            trustedEndpoints.add(\"vault.azure.net\");\n+            trustedEndpoints.add(\"vault.azure.cn\");\n+            trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"vault.microsoftazure.de\");\n+        }\n+        return trustedEndpoints;\n+    }\n+\n+    /**\n+     * Attempt to read MSSQL_JDBC_PROPERTIES.\n+     *\n+     * @return corresponding Properties object or null if failed to read the file.\n+     */\n+    private static Properties getMssqlJdbcProperties() {\n+        Properties props = null;\n+        try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n+            props = new Properties();\n+            props.load(in);\n+        } catch (IOException e) {\n+            if (akvLogger.isLoggable(Level.FINER)) {\n+                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n+            }\n         }\n+        return (null != props && !props.isEmpty()) ? props : null;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b76ca77d..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -53,682 +53,789 @@ import com.azure.security.keyvault.keys.models.KeyVaultKey;\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-        private HttpPipeline keyVaultPipeline;\n-        private KeyVaultCredential keyVaultCredential;\n-        /**\n-         * Column Encryption Key Store Provider string\n-         */\n-        String name = \"AZURE_KEY_VAULT\";\n-\n-        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n-        private static final List<String> akvTrustedEndpoints;\n-        /**\n-         * Algorithm version\n-         */\n-        private final byte[] firstVersion = new byte[] {0x01};\n-\n-        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-        private TokenCredential credential;\n-\n-        static {\n-                akvTrustedEndpoints = getTrustedEndpoints();\n+    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Column Encryption Key Store Provider string\n+     */\n+    String name = \"AZURE_KEY_VAULT\";\n+\n+    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n+\n+    /**\n+     * Algorithm version\n+     */\n+    private final byte[] firstVersion = new byte[] {0x01};\n+\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * @param clientKey\n+     *        Secret key of the client requesting the token.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        public void setName(String name) {\n-                this.name = name;\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        public String getName() {\n-                return this.name;\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n-         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-         * @param clientId Identifier of the client requesting the token.\n-         * @param clientKey Secret key of the client requesting the token.\n-         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n-                throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                if (null == clientKey || clientKey.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client Key\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-\n-                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n-                        .buildPipeline();\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        setCredential(tokenCredential);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param clientId Identifier of the client requesting the token.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+    }\n+\n+    /**\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n+     * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n-         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n-                throws SQLServerException {\n-                createKeyvaultClients(tokenCredential);\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key\n+     * @return Plain text column encryption key\n+     */\n+    @Override\n+    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-                this.credential = Objects.requireNonNull(credential);\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        /**\n-         * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key\n-         * @return Plain text column encryption key\n-         */\n-        @Override public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-                // Validate and decrypt the EncryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                //\n-                // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-                // asymmetric key pair and\n-                // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-                // Validate the version byte\n-                if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-                        Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                                String.format(\"%02X \", firstVersion[0])};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get key path length\n-                int currentIndex = firstVersion.length;\n-                short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                // We just read 2 bytes\n-                currentIndex += 2;\n-\n-                // Get ciphertext length\n-                short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                currentIndex += 2;\n-\n-                // Skip KeyPath\n-                // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-                currentIndex += keyPathLength;\n-\n-                // validate the ciphertext length\n-                if (cipherTextLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-                        Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Validate the signature length\n-                int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n-\n-                if (signatureLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-                        Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get ciphertext\n-                byte[] cipherText = new byte[cipherTextLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n-                currentIndex += cipherTextLength;\n-\n-                // Get signature\n-                byte[] signature = new byte[signatureLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n-\n-                // Compute the hash to validate the signature\n-                byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n-\n-                System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n-                        encryptedColumnEncryptionKey.length - signature.length);\n-\n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(hash);\n-                byte dataToVerify[] = md.digest();\n-\n-                if (null == dataToVerify) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                }\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+\n+        // Validate and decrypt the EncryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        //\n+        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n+        // asymmetric key pair and\n+        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n+\n+        // Validate the version byte\n+        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n+            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n+                    String.format(\"%02X \", firstVersion[0])};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Validate the signature\n-                if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        // Get key path length\n+        int currentIndex = firstVersion.length;\n+        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        // We just read 2 bytes\n+        currentIndex += 2;\n+\n+        // Get ciphertext length\n+        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        currentIndex += 2;\n+\n+        // Skip KeyPath\n+        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n+        currentIndex += keyPathLength;\n+\n+        // validate the ciphertext length\n+        if (cipherTextLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n+            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Decrypt the CEK\n-                byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n+        // Validate the signature length\n+        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n \n-                return decryptedCEK;\n+        if (signatureLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n+            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n+        // Get ciphertext\n+        byte[] cipherText = new byte[cipherTextLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n+        currentIndex += cipherTextLength;\n \n-                short shortVal;\n-                if (index + 1 >= input.length) {\n-                        throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"),\n-                                null, 0, false);\n-                }\n-                ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n-                byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n-                byteBuffer.put(input[index]);\n-                byteBuffer.put(input[index + 1]);\n-                shortVal = byteBuffer.getShort(0);\n-                return shortVal;\n-\n-        }\n-\n-        /**\n-         * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param columnEncryptionKey - Plain text column encryption key\n-         * @return Encrypted column encryption key\n-         */\n-        @Override public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n+        // Get signature\n+        byte[] signature = new byte[signatureLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n \n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n+        // Compute the hash to validate the signature\n+        byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n \n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"),\n-                                null);\n-                }\n+        System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n+                encryptedColumnEncryptionKey.length - signature.length);\n \n-                if (0 == columnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(hash);\n+        byte dataToVerify[] = md.digest();\n \n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+        if (null == dataToVerify) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+        }\n \n-                // Construct the encryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n-                //\n-                // We currently only support one version\n-                byte[] version = new byte[] {firstVersion[0]};\n+        // Validate the signature\n+        if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n-                byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n+        // Decrypt the CEK\n+        byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, keyWrapAlgorithm, cipherText);\n \n-                byte[] keyPathLength = new byte[2];\n-                keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n-                keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n+        return decryptedCEK;\n+    }\n \n-                // Encrypt the plain text\n-                byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n+    private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n \n-                byte[] cipherTextLength = new byte[2];\n-                cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n-                cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n+        short shortVal;\n+        if (index + 1 >= input.length) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"), null, 0,\n+                    false);\n+        }\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n+        byteBuffer.put(input[index]);\n+        byteBuffer.put(input[index + 1]);\n+        shortVal = byteBuffer.getShort(0);\n+        return shortVal;\n+\n+    }\n+\n+    /**\n+     * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n+     *\n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param columnEncryptionKey\n+     *        - Plain text column encryption key\n+     * @return Encrypted column encryption key\n+     */\n+    @Override\n+    public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"), null);\n+        }\n \n-                if (cipherText.length != keySizeInBytes) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n-                }\n+        if (0 == columnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+        }\n \n-                // Compute hash\n-                // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n-                byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n-                        + masterKeyPathBytes.length + cipherText.length];\n-                int destinationPosition = version.length;\n-                System.arraycopy(version, 0, dataToHash, 0, version.length);\n+        // Validate encryptionAlgorithm\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n-                System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n-                destinationPosition += keyPathLength.length;\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n \n-                System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n-                destinationPosition += cipherTextLength.length;\n+        // Construct the encryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n+        //\n+        // We currently only support one version\n+        byte[] version = new byte[] {firstVersion[0]};\n \n-                System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n-                destinationPosition += masterKeyPathBytes.length;\n+        // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n+        byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n \n-                System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n+        byte[] keyPathLength = new byte[2];\n+        keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n+        keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n \n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(dataToHash);\n-                byte dataToSign[] = md.digest();\n+        // Encrypt the plain text\n+        byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, keyWrapAlgorithm, columnEncryptionKey);\n \n-                // Sign the hash\n-                byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n+        byte[] cipherTextLength = new byte[2];\n+        cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n+        cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n \n-                if (signedHash.length != keySizeInBytes) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n-                }\n+        if (cipherText.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n+        }\n \n-                if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"),\n-                                null);\n-                }\n+        // Compute hash\n+        // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n+        byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n+                + masterKeyPathBytes.length + cipherText.length];\n+        int destinationPosition = version.length;\n+        System.arraycopy(version, 0, dataToHash, 0, version.length);\n \n-                // Construct the encrypted column encryption key\n-                // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                int encryptedColumnEncryptionKeyLength =\n-                        version.length + cipherTextLength.length + keyPathLength.length + cipherText.length\n-                                + masterKeyPathBytes.length + signedHash.length;\n-                byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+        System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n+        destinationPosition += keyPathLength.length;\n \n-                // Copy version byte\n-                int currentIndex = 0;\n-                System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n-                currentIndex += version.length;\n+        System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n+        destinationPosition += cipherTextLength.length;\n \n-                // Copy key path length\n-                System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n-                currentIndex += keyPathLength.length;\n+        System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n+        destinationPosition += masterKeyPathBytes.length;\n \n-                // Copy ciphertext length\n-                System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        cipherTextLength.length);\n-                currentIndex += cipherTextLength.length;\n+        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n \n-                // Copy key path\n-                System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        masterKeyPathBytes.length);\n-                currentIndex += masterKeyPathBytes.length;\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n+        }\n+        md.update(dataToHash);\n+        byte dataToSign[] = md.digest();\n \n-                // Copy ciphertext\n-                System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n-                currentIndex += cipherText.length;\n+        // Sign the hash\n+        byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n \n-                // copy the signature\n-                System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+        if (signedHash.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n+        }\n \n-                return encryptedColumnEncryptionKey;\n+        if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"), null);\n         }\n \n-        /**\n-         * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n-         *\n-         * @param encryptionAlgorithm - Asymmetric key encryptio algorithm\n-         * @return The encryption algorithm that is going to be used.\n-         * @throws SQLServerException\n-         */\n-        private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+        // Construct the encrypted column encryption key\n+        // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        int encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length\n+                + cipherText.length + masterKeyPathBytes.length + signedHash.length;\n+        byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+\n+        // Copy version byte\n+        int currentIndex = 0;\n+        System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n+        currentIndex += version.length;\n+\n+        // Copy key path length\n+        System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n+        currentIndex += keyPathLength.length;\n+\n+        // Copy ciphertext length\n+        System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex, cipherTextLength.length);\n+        currentIndex += cipherTextLength.length;\n+\n+        // Copy key path\n+        System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex, masterKeyPathBytes.length);\n+        currentIndex += masterKeyPathBytes.length;\n+\n+        // Copy ciphertext\n+        System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n+        currentIndex += cipherText.length;\n+\n+        // copy the signature\n+        System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+\n+        return encryptedColumnEncryptionKey;\n+    }\n+\n+    /**\n+     * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n+     *\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric key encryptio algorithm\n+     * @return The encryption algorithm that is going to be used.\n+     * @throws SQLServerException\n+     */\n+    private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+\n+        if (null == encryptionAlgorithm) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0,\n+                    false);\n+        }\n \n-                if (null == encryptionAlgorithm) {\n-                        throw new SQLServerException(null,\n-                                SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0, false);\n-                }\n+        // Transform to standard format (dash instead of underscore) to support enum lookup\n+        if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n+            encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n+        }\n \n-                // Transform to standard format (dash instead of underscore) to support enum lookup\n-                if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n-                        encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n-                }\n+        if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n+            Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n-                        Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+    }\n+\n+    /**\n+     * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n+     *\n+     * @param masterKeyPath\n+     * @throws SQLServerException\n+     */\n+    private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n+        // throw appropriate error if masterKeyPath is null or empty\n+        if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+        } else {\n+            URI parsedUri = null;\n+            try {\n+                parsedUri = new URI(masterKeyPath);\n+\n+                // A valid URI.\n+                // Check if it is pointing to a trusted endpoint.\n+                String host = parsedUri.getHost();\n+                if (null != host) {\n+                    host = host.toLowerCase(Locale.ENGLISH);\n+                }\n+                for (final String endpoint : akvTrustedEndpoints) {\n+                    if (null != host && host.endsWith(endpoint)) {\n+                        return;\n+                    }\n+                }\n+            } catch (URISyntaxException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n+                Object[] msgArgs = {masterKeyPath};\n+                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n+            }\n \n-                return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n-\n-        /**\n-         * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n-         *\n-         * @param masterKeyPath\n-         * @throws SQLServerException\n-         */\n-        private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n-                // throw appropriate error if masterKeyPath is null or empty\n-                if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                } else {\n-                        URI parsedUri = null;\n-                        try {\n-                                parsedUri = new URI(masterKeyPath);\n-\n-                                // A valid URI.\n-                                // Check if it is pointing to a trusted endpoint.\n-                                String host = parsedUri.getHost();\n-                                if (null != host) {\n-                                        host = host.toLowerCase(Locale.ENGLISH);\n-                                }\n-                                for (final String endpoint : akvTrustedEndpoints) {\n-                                        if (null != host && host.endsWith(endpoint)) {\n-                                                return;\n-                                        }\n-                                }\n-                        } catch (URISyntaxException e) {\n-                                MessageFormat form = new MessageFormat(\n-                                        SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n-                                Object[] msgArgs = {masterKeyPath};\n-                                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n-                        }\n-\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encryption Algorithm.\n+     * @param columnEncryptionKey\n+     *        - Plain text Column Encryption Key.\n+     * @return Returns an encrypted blob or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encryption Algorithm.\n-         * @param columnEncryptionKey - Plain text Column Encryption Key.\n-         * @return Returns an encrypted blob or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n-                }\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n-                return wrappedKey.getEncryptedKey();\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n+        return wrappedKey.getEncryptedKey();\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encrypted Column Encryption Key.\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key.\n+     * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encrypted Column Encryption Key.\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key.\n-         * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n-                }\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+        }\n \n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n-                }\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n \n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n \n-                UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n+        return unwrappedKey.getKey();\n+    }\n \n-                return unwrappedKey.getKey();\n+    private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n+        if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n+            return cachedCryptographyClients.get(masterKeyPath);\n         }\n \n-        private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n-                if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n-                        return cachedCryptographyClients.get(masterKeyPath);\n-                }\n-\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n \n-                CryptographyClient cryptoClient;\n-                if (null != credential) {\n-                        cryptoClient = new CryptographyClientBuilder().credential(credential)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                } else {\n-                        cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                }\n-                cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n-                return cachedCryptographyClients.get(masterKeyPath);\n+        CryptographyClient cryptoClient;\n+        if (null != credential) {\n+            cryptoClient = new CryptographyClientBuilder().credential(credential).keyIdentifier(retrievedKey.getId())\n+                    .buildClient();\n+        } else {\n+            cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n+                    .keyIdentifier(retrievedKey.getId()).buildClient();\n+        }\n+        cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n+        return cachedCryptographyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n+     *\n+     * @param dataToSign\n+     *        - Text to sign.\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return Signature\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToSign) && (0 != dataToSign.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n+        return signedData.getSignature();\n+    }\n+\n+    /**\n+     * Verifies the given RSA PKCSv1.5 signature.\n+     *\n+     * @param dataToVerify\n+     * @param signature\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return true if signature is valid, false if it is not valid\n+     * @throws SQLServerException\n+     */\n+    private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature,\n+            String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToVerify) && (0 != dataToVerify.length));\n+        assert ((null != signature) && (0 != signature.length));\n+\n+        CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n+        VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+\n+        return valid.isValid();\n+    }\n+\n+    /**\n+     * Returns the public Key size in bytes.\n+     *\n+     * @param masterKeyPath\n+     *        - Azure Key Vault Key path\n+     * @return Key size in bytes\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n+        KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n+        return retrievedKey.getKey().getN().length;\n+    }\n+\n+    /**\n+     * Fetches the key from Azure Key Vault for given key path. If the key path includes a version, then that specific\n+     * version of the key is retrieved, otherwise the latest key will be retrieved.\n+     * \n+     * @param masterKeyPath\n+     *        The key path associated with the key\n+     * @return The Key Vault key.\n+     * @throws SQLServerException\n+     *         If there was an error retrieving the key from Key Vault.\n+     */\n+    private KeyVaultKey getKeyVaultKey(String masterKeyPath) throws SQLServerException {\n+        String[] keyTokens = masterKeyPath.split(KEY_URL_DELIMITER);\n+        String keyName = keyTokens[KEY_NAME_INDEX];\n+        String keyVersion = null;\n+        if (keyTokens.length == KEY_URL_SPLIT_LENGTH_WITH_VERSION) {\n+            keyVersion = keyTokens[keyTokens.length - 1];\n         }\n \n-        /**\n-         * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n-         *\n-         * @param dataToSign - Text to sign.\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return Signature\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n-                assert ((null != dataToSign) && (0 != dataToSign.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n-                return signedData.getSignature();\n-        }\n-\n-        /**\n-         * Verifies the given RSA PKCSv1.5 signature.\n-         *\n-         * @param dataToVerify\n-         * @param signature\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return true if signature is valid, false if it is not valid\n-         * @throws SQLServerException\n-         */\n-        private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature, String masterKeyPath)\n-                throws SQLServerException {\n-                assert ((null != dataToVerify) && (0 != dataToVerify.length));\n-                assert ((null != signature) && (0 != signature.length));\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+        try {\n+            KeyClient keyClient = getKeyClient(masterKeyPath);\n+            KeyVaultKey retrievedKey;\n+            if (null != keyVersion) {\n+                retrievedKey = keyClient.getKey(keyName, keyVersion);\n+            } else {\n+                retrievedKey = keyClient.getKey(keyName);\n+            }\n+            if (null == retrievedKey) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n+                Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n+                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+            }\n \n-                return valid.isValid();\n+            if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n+                Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n+                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+            }\n+            return retrievedKey;\n+        } catch (RuntimeException e) {\n+            throw new SQLServerException(e.getMessage(), e);\n         }\n \n-        /**\n-         * Returns the public Key size in bytes.\n-         *\n-         * @param masterKeyPath - Azure Key Vault Key path\n-         * @return Key size in bytes\n-         * @throws SQLServerException when an error occurs\n-         */\n-        private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-                return retrievedKey.getKey().getN().length;\n-        }\n-\n-        private KeyVaultKey getKeyVaultKey(String masterKeyPath)\n-                throws SQLServerException {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String keyName = keyTokens[keyTokens.length - 2];\n-                String keyVersion = keyTokens[keyTokens.length - 1];\n-                KeyClient keyClient = getKeyClient(masterKeyPath);\n-                KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n-\n-                if (null == retrievedKey) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n-                        Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+    }\n+\n+    /**\n+     * Creates a new {@link KeyClient} if one does not exist for the given key path. If the client already exists, the\n+     * client is returned from the cache. As the client is stateless, it's safe to cache the client for each key path.\n+     * \n+     * @param masterKeyPath\n+     *        The key path for which the {@link KeyClient} will be created, if it does not exist.\n+     * @return The {@link KeyClient} associated with the key path.\n+     */\n+    private KeyClient getKeyClient(String masterKeyPath) {\n+        if (cachedKeyClients.containsKey(masterKeyPath)) {\n+            return cachedKeyClients.get(masterKeyPath);\n+        }\n+        String vaultUrl = getVaultUrl(masterKeyPath);\n \n-                if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n-                        Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n-                return retrievedKey;\n+        KeyClient keyClient;\n+        if (null != credential) {\n+            keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n+        } else {\n+            keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n+        }\n+        cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n+        return cachedKeyClients.get(masterKeyPath);\n+    }\n+\n+    /**\n+     * Returns the vault url extracted from the master key path.\n+     * \n+     * @param masterKeyPath\n+     *        The master key path.\n+     * @return The vault url.\n+     */\n+    private static String getVaultUrl(String masterKeyPath) {\n+        String[] keyTokens = masterKeyPath.split(\"/\");\n+        String hostName = keyTokens[2];\n+        return \"https://\" + hostName;\n+    }\n+\n+    @Override\n+    public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n+            byte[] signature) throws SQLServerException {\n+        if (!allowEnclaveComputations) {\n+            return false;\n         }\n \n-        private KeyClient getKeyClient(String masterKeyPath) {\n-                if (cachedKeyClients.containsKey(masterKeyPath)) {\n-                        return cachedKeyClients.get(masterKeyPath);\n-                }\n-                String vaultUrl = getVaultUrl(masterKeyPath);\n+        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n \n-                KeyClient keyClient;\n-                if (null != credential) {\n-                        keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n-                } else {\n-                        keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n-                }\n-                cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n-                return cachedKeyClients.get(masterKeyPath);\n-        }\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            // value of allowEnclaveComputations is always true here\n+            md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n \n-        private static String getVaultUrl(String masterKeyPath) {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String hostName = keyTokens[2];\n-                return \"https://\" + hostName;\n-        }\n+            byte[] dataToVerify = md.digest();\n+            if (null == dataToVerify) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+            }\n \n-        @Override public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n-                byte[] signature) throws SQLServerException {\n-            if (!allowEnclaveComputations) {\n-                return false;\n+            // Sign the hash\n+            byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n+            if (null == signedHash) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n             }\n \n-                KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n-\n-                try {\n-                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n-                        md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        // value of allowEnclaveComputations is always true here\n-                        md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-\n-                        byte[] dataToVerify = md.digest();\n-                        if (null == dataToVerify) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                        }\n-\n-                        // Sign the hash\n-                        byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n-                        if (null == signedHash) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"),\n-                                        null);\n-                        }\n-\n-                        // Validate the signature\n-                        return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n+            // Validate the signature\n+            return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n-\n-        private static List<String> getTrustedEndpoints() {\n-                Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n-                List<String> trustedEndpoints = new ArrayList<String>();\n-                boolean append = true;\n-                if (null != mssqlJdbcProperties) {\n-                        String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n-                        if (null != endpoints && !endpoints.trim().isEmpty()) {\n-                                endpoints = endpoints.trim();\n-                                // Append if the list starts with a semicolon.\n-                                if (';' != endpoints.charAt(0)) {\n-                                        append = false;\n-                                } else {\n-                                        endpoints = endpoints.substring(1);\n-                                }\n-                                String[] entries = endpoints.split(\";\");\n-                                for (String entry : entries) {\n-                                        if (null != entry && !entry.trim().isEmpty()) {\n-                                                trustedEndpoints.add(entry.trim());\n-                                        }\n-                                }\n-                        }\n+    }\n+\n+    private static List<String> getTrustedEndpoints() {\n+        Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n+        List<String> trustedEndpoints = new ArrayList<String>();\n+        boolean append = true;\n+        if (null != mssqlJdbcProperties) {\n+            String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n+            if (null != endpoints && !endpoints.trim().isEmpty()) {\n+                endpoints = endpoints.trim();\n+                // Append if the list starts with a semicolon.\n+                if (';' != endpoints.charAt(0)) {\n+                    append = false;\n+                } else {\n+                    endpoints = endpoints.substring(1);\n                 }\n-                /*\n-                 * List of Azure trusted endpoints\n-                 * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n-                 */\n-                if (append) {\n-                        trustedEndpoints.add(\"vault.azure.net\");\n-                        trustedEndpoints.add(\"vault.azure.cn\");\n-                        trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n-                        trustedEndpoints.add(\"vault.microsoftazure.de\");\n+                String[] entries = endpoints.split(\";\");\n+                for (String entry : entries) {\n+                    if (null != entry && !entry.trim().isEmpty()) {\n+                        trustedEndpoints.add(entry.trim());\n+                    }\n                 }\n-                return trustedEndpoints;\n+            }\n         }\n-\n-        /**\n-         * Attempt to read MSSQL_JDBC_PROPERTIES.\n-         *\n-         * @return corresponding Properties object or null if failed to read the file.\n+        /*\n+         * List of Azure trusted endpoints\n+         * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n          */\n-        private static Properties getMssqlJdbcProperties() {\n-                Properties props = null;\n-                try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n-                        props = new Properties();\n-                        props.load(in);\n-                } catch (IOException e) {\n-                        if (akvLogger.isLoggable(Level.FINER)) {\n-                                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n-                        }\n-                }\n-                return (null != props && !props.isEmpty()) ? props : null;\n+        if (append) {\n+            trustedEndpoints.add(\"vault.azure.net\");\n+            trustedEndpoints.add(\"vault.azure.cn\");\n+            trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"vault.microsoftazure.de\");\n+            trustedEndpoints.add(\"managedhsm.azure.net\");\n+            trustedEndpoints.add(\"managedhsm.azure.cn\");\n+            trustedEndpoints.add(\"managedhsm.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"managedhsm.microsoftazure.de\");\n+        }\n+        return trustedEndpoints;\n+    }\n+\n+    /**\n+     * Attempt to read MSSQL_JDBC_PROPERTIES.\n+     *\n+     * @return corresponding Properties object or null if failed to read the file.\n+     */\n+    private static Properties getMssqlJdbcProperties() {\n+        Properties props = null;\n+        try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n+            props = new Properties();\n+            props.load(in);\n+        } catch (IOException e) {\n+            if (akvLogger.isLoggable(Level.FINER)) {\n+                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n+            }\n         }\n+        return (null != props && !props.isEmpty()) ? props : null;\n+    }\n }\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..a39efccb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -838,4 +957,12 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n         return (null != props && !props.isEmpty()) ? props : null;\n     }\n+\n+    int getColumnEncryptionKeyCacheSize() {\n+        return columnEncryptionKeyCache.getCacheSize();\n+    }\n+\n+    int getCmkMetadataSignatureVerificationCacheSize() {\n+        return cmkMetadataSignatureVerificationCache.getCacheSize();\n+    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "message": "Merge commit", "committedDate": null}, {"oid": "428f14764f910ec527ce00ede0cdee74c2a6de13", "committedDate": "2021-01-25 12:19:07 -0800", "message": "Fix "}, {"oid": "7f3af328177744039f76be1d891d1529a387b884", "committedDate": "2021-08-17 17:45:06 -0700", "message": "Add support for multi-user key store providers (#1614)"}, {"oid": "9de35042413d1edfc76ba0ab9e787355823d62f5", "committedDate": "2021-08-20 13:44:17 -0700", "message": "checkclose and minor test fies and formatting (#1644)"}, {"oid": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "committedDate": "2022-10-26 14:24:24 -0700", "message": "Managed Identity dev experience improvements (#1936)"}, {"oid": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "committedDate": "2022-11-22 13:42:57 -0800", "message": "More fixes for SonarQube warnings and coding standards (#1969)"}, {"oid": "8f5f9dacd646385aa08eb9047d56361756cd3a76", "committedDate": "2022-12-22 13:46:18 -0800", "message": "More code clean up to fix SonarQube issues (#1977)"}, {"oid": "e487251f14df934f77491e38824abb73d60d52cc", "committedDate": "2023-01-19 13:02:03 -0800", "message": "More minor fixes for SonarQube (#2041)"}, {"oid": "1f67567fee6b0c9a6c4bd9db9fa5fa75d8299ee2", "committedDate": "2023-02-23 14:45:38 -0800", "message": "Fixed issues detected by SonarQube (#2080)"}]}, {"oid": "8d1f4622295ed6fa69a2d57c57797f6dc1261620", "url": "https://github.com/microsoft/mssql-jdbc/commit/8d1f4622295ed6fa69a2d57c57797f6dc1261620", "message": "Update javadoc", "committedDate": "2020-08-27T23:12:23Z", "type": "commit"}, {"oid": "22515502167d60947676e4cebf7e210bf5ceafc7", "url": "https://github.com/microsoft/mssql-jdbc/commit/22515502167d60947676e4cebf7e210bf5ceafc7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-28T00:19:08Z", "type": "commit"}, {"oid": "fd9837610a9c3c0201fa691257d79474f2e5be0c", "url": "https://github.com/microsoft/mssql-jdbc/commit/fd9837610a9c3c0201fa691257d79474f2e5be0c", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-28T00:19:22Z", "type": "commit"}, {"oid": "04c05bdbcf9de991536d7972a6874d3dfc58148c", "url": "https://github.com/microsoft/mssql-jdbc/commit/04c05bdbcf9de991536d7972a6874d3dfc58148c", "message": "formatting", "committedDate": "2020-08-28T00:30:07Z", "type": "commit"}]}