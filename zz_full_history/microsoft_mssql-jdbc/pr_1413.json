{"pr_number": 1413, "pr_title": "Upgrading to new Key Vault (and MSAL) libraries", "pr_author": "srnagar", "pr_createdAt": "2020-08-25T21:43:24Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1413", "timeline": [{"oid": "9fbc98936839a5b38ab504a69887c75be90c501b", "url": "https://github.com/microsoft/mssql-jdbc/commit/9fbc98936839a5b38ab504a69887c75be90c501b", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-10-10T01:30:25Z", "type": "commit"}, {"oid": "a011ea785fa37b356746671fa1d06ae99f5274f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/a011ea785fa37b356746671fa1d06ae99f5274f4", "message": "Merge pull request #9 from lilgreenbird/msal\n\nadd tenantID to pipeline and merged with dev", "committedDate": "2020-10-10T02:06:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3Mjc4Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r504172782", "body": "Please search for `ADAL` in SQLServerResource and make similar changes to the error messages that mentioned ADAL.", "bodyText": "Please search for ADAL in SQLServerResource and make similar changes to the error messages that mentioned ADAL.", "bodyHTML": "<p dir=\"auto\">Please search for <code>ADAL</code> in SQLServerResource and make similar changes to the error messages that mentioned ADAL.</p>", "author": "ulvii", "createdAt": "2020-10-13T18:32:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -404,7 +404,7 @@ static String getResource(String key) {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},", "originalCommit": "a011ea785fa37b356746671fa1d06ae99f5274f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 8045d1f8..754f1391 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -404,7 +373,7 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n             {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n             {\"R_FedAuthFeatureAckContainsExtraData\",\n                     \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..391a1377 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -373,7 +404,7 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_ADALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n             {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n             {\"R_FedAuthFeatureAckContainsExtraData\",\n                     \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n", "next_change": {"commit": "bd776c2b48691897cee900cc6e821d171f18513a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 391a1377..33e27f31 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -405,6 +409,7 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n                     \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n             {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n             {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n             {\"R_FedAuthFeatureAckContainsExtraData\",\n                     \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n", "next_change": {"commit": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 33e27f31..278197bc 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -21,645 +21,474 @@ public final class SQLServerResource extends ListResourceBundle {\n         return CONTENTS;\n     }\n \n-    // The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n-    // camelCasing convention and be descriptive\n-    static final Object[][] CONTENTS = {\n-            // LOCALIZE THIS\n-            {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n-            {\"R_invalidRoutingInfo\",\n-                    \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_multipleRedirections\",\n-                    \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n-            {\"R_dbMirroringWithMultiSubnetFailover\",\n-                    \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n-            {\"R_dbMirroringWithReadOnlyIntent\",\n-                    \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n-            {\"R_ipAddressLimitWithMultiSubnetFailover\",\n-                    \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n-            {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n-            {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n-            {\"R_invalidLength\", \"The length {0} is not valid.\"},\n-            {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n-            {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n-            {\"R_notSQLServer\",\n-                    \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting \"\n-                            + \"TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n-            {\"R_tcpOpenFailed\",\n-                    \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP \"\n-                            + \"connections to the port are not blocked by a firewall.\"},\n-            {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n-            {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n-            {\"R_truncatedServerResponse\",\n-                    \"SQL Server returned an incomplete response. The connection has been closed.\"},\n-            {\"R_queryTimedOut\", \"The query has timed out.\"}, {\"R_queryCancelled\", \"The query was canceled.\"},\n-            {\"R_errorReadingStream\",\n-                    \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n-            {\"R_streamReadReturnedInvalidValue\",\n-                    \"The stream read operation returned an invalid value for the amount of data read.\"},\n-            {\"R_mismatchedStreamLength\",\n-                    \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n-            {\"R_notSupported\", \"This operation is not supported.\"},\n-            {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n-            {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n-            {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n-            {\"R_connectionIsClosed\", \"The connection is closed.\"},\n-            {\"R_invalidBooleanValue\",\n-                    \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n-            {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n-            {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n-            {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n-            {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n-            {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n-            {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n-            {\"R_packetSizeTooBigForSSL\",\n-                    \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n-            {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n-            {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n-            {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_sqlServerHoldability\",\n-                    \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n-            {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n-            {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n-            {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n-            {\"R_sqlBrowserFailed\",\n-                    \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. \"\n-                            + \" For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n-            {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n-            {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n-            {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n-            {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n-            {\"R_noMetadata\", \"There is no metadata.\"}, {\"R_resultsetClosed\", \"The result set is closed.\"},\n-            {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n-            {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n-            {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n-            {\"R_savepointNotNamed\", \"The savepoint is not named.\"}, {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n-            {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n-            {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n-            {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n-            {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n-            {\"R_noResultset\", \"The statement did not return a result set.\"},\n-            {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n-            {\"R_statementIsClosed\", \"The statement is closed.\"},\n-            {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n-            {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n-            {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n-            {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n-            {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n-            {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n-            {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n-            {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n-            {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n-            {\"R_invalidOffset\", \"The offset {0} is not valid.\"}, {\"R_nullConnection\", \"The connection URL is null.\"},\n-            {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n-            {\"R_cannotTakeArgumentsPreparedOrCallable\",\n-                    \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n-            // Invalid conversion (e.g. MONEY to Timestamp)\n-            {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n-            // Invalid conversion to an unknown type\n-            {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n-            // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n-            {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n-            {\"R_streamIsClosed\", \"The stream is closed.\"}, {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n-            {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n-            {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n-            {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n-            {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n-            {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n-            {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n-            {\"R_encodingErrorWritingTDS\",\n-                    \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n-            {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n-            {\"R_requestedOpNotSupportedOnForward\",\n-                    \"The requested operation is not supported on forward only result sets.\"},\n-            {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n-            {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n-            {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n-            {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n-            {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n-            {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n-            {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n-            {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n-            {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n-            {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n-            {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n-            {\"R_cantGetUpdatedColumnValue\",\n-                    \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n-            {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n-            {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n-            {\"R_invalidAutoGeneratedKeys\",\n-                    \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n-            {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n-            {\"R_failoverPartnerWithoutDB\",\n-                    \"databaseName is required when using the failoverPartner connection property.\"},\n-            {\"R_invalidPartnerConfiguration\",\n-                    \"The database {0} on server {1} is not configured for database mirroring.\"},\n-            {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n-            {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n-            {\"R_invalidpropertyValue\",\n-                    \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n-            {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n-            {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n-            {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n-            {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n-            {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n-            {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n-            {\"R_sslRequiredNoServerSupport\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. \"\n-                            + \"The application requested encryption but the server is not configured to support SSL.\"},\n-            {\"R_sslRequiredByServer\",\n-                    \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n-            {\"R_sslFailed\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n-            {\"R_certNameFailed\",\n-                    \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n-            {\"R_failedToInitializeXA\",\n-                    \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n-            {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n-            {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n-            {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n-            {\"R_userPropertyDescription\", \"The database user.\"},\n-            {\"R_passwordPropertyDescription\", \"The database password.\"},\n-            {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n-            {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n-            {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n-            {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n-            {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n-            {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n-            {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n-            {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n-            {\"R_serverNameAsACEPropertyDescription\",\n-                    \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n-            {\"R_sendStringParametersAsUnicodePropertyDescription\",\n-                    \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n-            {\"R_multiSubnetFailoverPropertyDescription\",\n-                    \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n-            {\"R_applicationNamePropertyDescription\",\n-                    \"The application name for SQL Server profiling and logging tools.\"},\n-            {\"R_lastUpdateCountPropertyDescription\",\n-                    \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n-            {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n-            {\"R_integratedSecurityPropertyDescription\",\n-                    \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n-            {\"R_authenticationSchemePropertyDescription\",\n-                    \"The authentication scheme to be used for integrated authentication.\"},\n-            {\"R_lockTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n-            {\"R_loginTimeoutPropertyDescription\",\n-                    \"The number of seconds the driver should wait before timing out a failed connection.\"},\n-            {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n-            {\"R_xopenStatesPropertyDescription\",\n-                    \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n-            {\"R_selectMethodPropertyDescription\",\n-                    \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n-            {\"R_responseBufferingPropertyDescription\",\n-                    \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n-            {\"R_applicationIntentPropertyDescription\",\n-                    \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n-            {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n-            {\"R_failoverPartnerPropertyDescription\",\n-                    \"The name of the failover server used in a database mirroring configuration.\"},\n-            {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n-            {\"R_encryptPropertyDescription\",\n-                    \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n-            {\"R_socketFactoryClassPropertyDescription\",\n-                    \"The class to instantiate as the SocketFactory for connections\"},\n-            {\"R_socketFactoryConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n-            {\"R_trustServerCertificatePropertyDescription\",\n-                    \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n-            {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n-            {\"R_trustStorePasswordPropertyDescription\",\n-                    \"The password used to check the integrity of the trust store data.\"},\n-            {\"R_trustManagerClassPropertyDescription\",\n-                    \"The class to instantiate as the TrustManager for SSL connections.\"},\n-            {\"R_trustManagerConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n-            {\"R_hostNameInCertificatePropertyDescription\",\n-                    \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_sendTimeAsDatetimePropertyDescription\",\n-                    \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n-            {\"R_TransparentNetworkIPResolutionPropertyDescription\",\n-                    \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n-            {\"R_queryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait before the database reports a query time-out.\"},\n-            {\"R_socketTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n-            {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\",\n-                    \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). \"\n-                            + \"A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n-            {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\",\n-                    \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n-            {\"R_statementPoolingCacheSizePropertyDescription\",\n-                    \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n-            {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n-            {\"R_msiClientIdPropertyDescription\",\n-                    \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n-            {\"R_clientCertificatePropertyDescription\",\n-                    \"Client certificate path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPasswordPropertyDescription\",\n-                    \"Password for private key if the private key is password protected.\"},\n-            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n-                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n-            {\"R_delayLoadingLobsPropertyDescription\",\n-                    \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n-            {\"R_AADSecurePrincipalIdPropertyDescription\",\n-                    \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n-            {\"R_AADSecurePrincipalSecretPropertyDescription\",\n-                    \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n-            {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n-            {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n-            {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n-            {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n-            {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n-            {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n-            {\"R_cantSetNull\", \"Cannot set a null value.\"},\n-            {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n-            {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n-            {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n-            {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n-            {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n-            {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n-            {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n-            {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n-            {\"R_getSchemaError\", \"Error getting default schema name.\"},\n-            {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n-            {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n-            {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n-            {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n-            {\"R_featureNotSupported\", \"{0} is not supported.\"},\n-            {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n-            {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n-            {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n-            {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n-            {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n-            {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n-            {\"R_invalidDestConnection\",\n-                    \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n-            {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n-            {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n-            {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n-            {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n-            {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n-            {\"R_invalidTransactionOption\",\n-                    \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n-            {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n-            {\"R_BulkColumnMappingsIsEmpty\",\n-                    \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n-            {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n-            {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n-            {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n-            {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n-            {\"R_UnexpectedDescribeParamFormat\",\n-                    \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n-            {\"R_InvalidEncryptionKeyOrdinal\",\n-                    \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n-            {\"R_MissingParamEncryptionMetadata\",\n-                    \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n-            {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n-            {\"R_InvalidCipherTextSize\",\n-                    \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n-            {\"R_InvalidAlgorithmVersion\",\n-                    \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n-            {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n-            {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n-            {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n-            {\"R_InvalidKeySize\",\n-                    \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". \"\n-                            + \"Verify the encrypted value of the column encryption key in the database.\"},\n-            {\"R_InvalidEncryptionType\",\n-                    \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n-            {\"R_UnknownColumnEncryptionAlgorithm\",\n-                    \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n-            {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n-            {\"R_UntrustedKeyPath\",\n-                    \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path \"\n-                            + \"using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n-            {\"R_UnrecognizedKeyStoreProviderName\",\n-                    \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider \"\n-                            + \"or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: \"\n-                            + \"{2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers \"\n-                            + \"used in your application are registered properly.\"},\n-            {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n-            {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n-            {\"R_UnsupportedNormalizationVersionAE\",\n-                    \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n-            {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n-            {\"R_NullColumnEncryptionAlgorithmAE\",\n-                    \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n-            {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n-            {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n-            {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n-            {\"R_AE_NotSupportedByServer\", \"SQL Server instance in use does not support column encryption.\"},\n-            {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n-                                                                                                           // Server\n-            {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n-            {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n-            {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n-            {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n-            {\"R_InvalidCertificateSignature\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n-            {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n-            {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithm\",\n-                    \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithmInternal\",\n-                    \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n-            {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n-            {\"R_CertificateNotFoundForAlias\",\n-                    \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. \"\n-                    + \" Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n-            {\"R_KeyStoreNotFound\",\n-                    \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n-            {\"R_CustomKeyStoreProviderMapNull\",\n-                    \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n-            {\"R_EmptyCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n-            {\"R_InvalidCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n-            {\"R_CustomKeyStoreProviderValueNull\",\n-                    \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n-            {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n-            {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n-            {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n-            {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n-            {\"R_InvalidDataForAE\",\n-                    \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n-            {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n-            {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n-            {\"R_FedAuthRequiredPreLoginResponseInvalidValue\",\n-                    \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n-            {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\",\n-                    \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n-            {\"R_FedAuthInfoInvalidOffset\",\n-                    \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n-            {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n-            {\"R_FedAuthInfoLengthTooShortForData\",\n-                    \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n-            {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n-                    \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n-            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n-            {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n-            {\"R_FedAuthFeatureAckContainsExtraData\",\n-                    \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n-            {\"R_FedAuthFeatureAckUnknownLibraryType\",\n-                    \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n-            {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n-            {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n-                    \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n-            {\"R_NtlmNoUserPasswordDomain\",\n-                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n-            {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n-                    \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n-            {\"R_IntegratedAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_MSIAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_AccessTokenWithUserPassword\",\n-                    \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n-            {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n-            {\"R_SetBothAuthenticationAndAccessToken\",\n-                    \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n-            {\"R_NoUserPasswordForActivePassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\",\n-                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n-            {\"R_NoUserPasswordForSqlPassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalse\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\",\n-                    \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalseRS\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\",\n-                    \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_NullValue\", \"{0} cannot be null.\"}, {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n-            {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n-            {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n-            {\"R_ManagedIdentityInitFail\",\n-                    \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n-            {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n-            {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n-            {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n-            {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n-            {\"R_InvalidEcryptionAlgorithmVersion\",\n-                    \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n-            {\"R_AKVKeyLengthError\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_AKVSignatureLengthError\",\n-                    \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n-            {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n-            {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n-            {\"R_CEKSignatureNotMatchCMK\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n-            {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n-            {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n-            {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n-            {\"R_UnableLoadADALSqlDll\",\n-                    \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n-            {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n-            {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n-            {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n-            {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n-            {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n-            {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n-            {\"R_TVPMixedSource\",\n-                    \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n-            {\"R_TVPEmptyMetadata\",\n-                    \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n-            {\"R_TVPInvalidValue\",\n-                    \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n-            {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n-            {\"R_TVPSortOrdinalGreaterThanFieldCount\",\n-                    \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n-            {\"R_TVPMissingSortOrderOrOrdinal\",\n-                    \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n-            {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n-            {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n-            {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n-            // This is used for connection settings. {0}-> property name as is, {1}-> value\n-            {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n-            {\"R_InvalidWindowsCertificateStoreEncryption\",\n-                    \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n-            {\"R_AEKeypathEmpty\",\n-                    \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n-            {\"R_AECertpathBad\",\n-                    \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertLocBad\",\n-                    \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertStoreBad\",\n-                    \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n-            {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n-            {\"R_AECertNotFound\",\n-                    \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition \"\n-                            + \"in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_AEMaloc\", \"Memory allocation failure.\"},\n-            {\"R_AEKeypathLong\",\n-                    \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n-            {\"R_AEECEKLenBad\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEECEKSigLenBad\",\n-                    \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEKeyPathEmptyOrReserved\",\n-                    \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n-            {\"R_AEKeyPathCurUser\",\n-                    \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n-            {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n-            {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n-            {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n-            {\"R_keyStoreSecretPropertyDescription\",\n-                    \"The authentication secret or information needed to locate the secret.\"},\n-            {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n-            {\"R_keyStoreAuthenticationNotSet\",\n-                    \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n-            {\"R_keyStoreSecretOrLocationNotSet\",\n-                    \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n-            {\"R_keyStoreSecretNotSet\",\n-                    \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreInvalidKeyword\",\n-                    \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreLocationNotSet\",\n-                    \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStorePlatformInvalid\",\n-                    \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n-            {\"R_invalidKeyStoreFile\",\n-                    \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n-                                                                                                                  // JKS/PKCS\n-            {\"R_invalidCEKCacheTtl\",\n-                    \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n-            {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n-            {\"R_TVPnotWorkWithSetObjectResultSet\",\n-                    \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n-            {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n-            {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n-            {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n-            {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n-            {\"R_serverPreparedStatementDiscardThreshold\",\n-                    \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n-            {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n-            {\"R_kerberosLoginFailedForUsername\",\n-                    \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n-            {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n-            {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n-            {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n-            {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n-            {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n-            {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n-            {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n-            {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n-            {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n-            {\"R_sslProtocolPropertyDescription\",\n-                    \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n-            {\"R_invalidSSLProtocol\",\n-                    \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n-            {\"R_cancelQueryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait to cancel sending a query timeout.\"},\n-            {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n-            {\"R_useBulkCopyForBatchInsertPropertyDescription\",\n-                    \"Whether the driver will use bulk copy API for batch insert operations\"},\n-            {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n-            {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n-            {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n-            {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n-            {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n-            {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n-            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n-            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n-            {\"R_maxResultBufferPropertyDescription\",\n-                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n-            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n-            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+    /*\n+     * The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n+     * camelCasing convention and be descriptive.\n+     */\n+    // @formatter:off\n+    // Disable formatting for localization parser: use 1 line per error message and do not use \"+\"\n+    // @formatter:off\n+    static final Object[][] CONTENTS =\n+    {\n+        // LOCALIZE THIS\n+        {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n+        {\"R_invalidRoutingInfo\", \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_multipleRedirections\", \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n+        {\"R_dbMirroringWithMultiSubnetFailover\", \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n+        {\"R_dbMirroringWithReadOnlyIntent\", \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n+        {\"R_ipAddressLimitWithMultiSubnetFailover\", \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n+        {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n+        {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n+        {\"R_invalidLength\", \"The length {0} is not valid.\"},\n+        {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n+        {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n+        {\"R_notSQLServer\", \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n+        {\"R_tcpOpenFailed\", \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP connections to the port are not blocked by a firewall.\"},\n+        {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n+        {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n+        {\"R_truncatedServerResponse\", \"SQL Server returned an incomplete response. The connection has been closed.\"},\n+        {\"R_queryTimedOut\", \"The query has timed out.\"},\n+        {\"R_queryCancelled\", \"The query was canceled.\"},\n+        {\"R_errorReadingStream\", \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n+        {\"R_streamReadReturnedInvalidValue\", \"The stream read operation returned an invalid value for the amount of data read.\"},\n+        {\"R_mismatchedStreamLength\", \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n+        {\"R_notSupported\", \"This operation is not supported.\"},\n+        {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n+        {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n+        {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n+        {\"R_connectionIsClosed\", \"The connection is closed.\"},\n+        {\"R_invalidBooleanValue\", \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n+        {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n+        {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n+        {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n+        {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n+        {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n+        {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n+        {\"R_packetSizeTooBigForSSL\", \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n+        {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n+        {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n+        {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_sqlServerHoldability\", \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n+        {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n+        {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n+        {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n+        {\"R_sqlBrowserFailed\", \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n+        {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n+        {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n+        {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n+        {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n+        {\"R_noMetadata\", \"There is no metadata.\"},\n+        {\"R_resultsetClosed\", \"The result set is closed.\"},\n+        {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n+        {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n+        {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n+        {\"R_savepointNotNamed\", \"The savepoint is not named.\"},\n+        {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n+        {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n+        {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n+        {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n+        {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n+        {\"R_noResultset\", \"The statement did not return a result set.\"},\n+        {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n+        {\"R_statementIsClosed\", \"The statement is closed.\"},\n+        {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n+        {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n+        {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n+        {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n+        {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n+        {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n+        {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n+        {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n+        {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n+        {\"R_invalidOffset\", \"The offset {0} is not valid.\"},\n+        {\"R_nullConnection\", \"The connection URL is null.\"},\n+        {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n+        {\"R_cannotTakeArgumentsPreparedOrCallable\", \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n+        // Invalid conversion (e.g. MONEY to Timestamp)\n+        {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n+        // Invalid conversion to an unknown type\n+        {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n+        // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n+        {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n+        {\"R_streamIsClosed\", \"The stream is closed.\"},\n+        {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n+        {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n+        {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n+        {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n+        {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n+        {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n+        {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n+        {\"R_encodingErrorWritingTDS\", \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n+        {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n+        {\"R_requestedOpNotSupportedOnForward\", \"The requested operation is not supported on forward only result sets.\"},\n+        {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n+        {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n+        {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n+        {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n+        {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n+        {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n+        {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n+        {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n+        {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n+        {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n+        {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n+        {\"R_cantGetUpdatedColumnValue\", \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n+        {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n+        {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n+        {\"R_invalidAutoGeneratedKeys\", \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n+        {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n+        {\"R_failoverPartnerWithoutDB\", \"databaseName is required when using the failoverPartner connection property.\"},\n+        {\"R_invalidPartnerConfiguration\", \"The database {0} on server {1} is not configured for database mirroring.\"},\n+        {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n+        {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n+        {\"R_invalidpropertyValue\", \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n+        {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n+        {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n+        {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n+        {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n+        {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n+        {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n+        {\"R_sslRequiredNoServerSupport\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. The application requested encryption but the server is not configured to support SSL.\"},\n+        {\"R_sslRequiredByServer\", \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n+        {\"R_sslFailed\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n+        {\"R_certNameFailed\", \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n+        {\"R_failedToInitializeXA\", \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n+        {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n+        {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n+        {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n+        {\"R_userPropertyDescription\", \"The database user.\"},\n+        {\"R_passwordPropertyDescription\", \"The database password.\"},\n+        {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n+        {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n+        {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n+        {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n+        {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n+        {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n+        {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n+        {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n+        {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n+        {\"R_serverNameAsACEPropertyDescription\", \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n+        {\"R_sendStringParametersAsUnicodePropertyDescription\", \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n+        {\"R_multiSubnetFailoverPropertyDescription\", \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n+        {\"R_applicationNamePropertyDescription\", \"The application name for SQL Server profiling and logging tools.\"},\n+        {\"R_lastUpdateCountPropertyDescription\", \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n+        {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n+        {\"R_integratedSecurityPropertyDescription\", \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n+        {\"R_authenticationSchemePropertyDescription\", \"The authentication scheme to be used for integrated authentication.\"},\n+        {\"R_lockTimeoutPropertyDescription\", \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The number of reconnection attempts if there is a connection failure.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The number of seconds between each connection retry attempt.\"},\n+        {\"R_loginTimeoutPropertyDescription\", \"The number of seconds the driver should wait before timing out a failed connection.\"},\n+        {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n+        {\"R_xopenStatesPropertyDescription\", \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n+        {\"R_selectMethodPropertyDescription\", \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n+        {\"R_responseBufferingPropertyDescription\", \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n+        {\"R_applicationIntentPropertyDescription\", \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n+        {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n+        {\"R_failoverPartnerPropertyDescription\", \"The name of the failover server used in a database mirroring configuration.\"},\n+        {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n+        {\"R_encryptPropertyDescription\", \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n+        {\"R_socketFactoryClassPropertyDescription\", \"The class to instantiate as the SocketFactory for connections\"},\n+        {\"R_socketFactoryConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n+        {\"R_trustServerCertificatePropertyDescription\", \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n+        {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n+        {\"R_trustStorePasswordPropertyDescription\", \"The password used to check the integrity of the trust store data.\"},\n+        {\"R_trustManagerClassPropertyDescription\", \"The class to instantiate as the TrustManager for SSL connections.\"},\n+        {\"R_trustManagerConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n+        {\"R_hostNameInCertificatePropertyDescription\", \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_replicationPropertyDescription\", \"This setting tells the server if the connection is used for replication.\"},\n+        {\"R_sendTimeAsDatetimePropertyDescription\", \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n+        {\"R_TransparentNetworkIPResolutionPropertyDescription\", \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n+        {\"R_queryTimeoutPropertyDescription\", \"The number of seconds to wait before the database reports a query time-out.\"},\n+        {\"R_socketTimeoutPropertyDescription\", \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n+        {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\", \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n+        {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\", \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n+        {\"R_statementPoolingCacheSizePropertyDescription\", \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n+        {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n+        {\"R_msiClientIdPropertyDescription\", \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n+        {\"R_clientCertificatePropertyDescription\", \"Client certificate path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPasswordPropertyDescription\", \"Password for private key if the private key is password protected.\"},\n+        {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\", \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n+        {\"R_delayLoadingLobsPropertyDescription\", \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n+        {\"R_AADSecurePrincipalIdPropertyDescription\", \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n+        {\"R_AADSecurePrincipalSecretPropertyDescription\", \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n+        {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n+        {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n+        {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n+        {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n+        {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n+        {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n+        {\"R_cantSetNull\", \"Cannot set a null value.\"},\n+        {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n+        {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n+        {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n+        {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n+        {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n+        {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n+        {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n+        {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n+        {\"R_getSchemaError\", \"Error getting default schema name.\"},\n+        {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n+        {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n+        {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n+        {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n+        {\"R_featureNotSupported\", \"{0} is not supported.\"},\n+        {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n+        {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n+        {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n+        {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n+        {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n+        {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n+        {\"R_invalidDestConnection\", \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n+        {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n+        {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n+        {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n+        {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n+        {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n+        {\"R_invalidTransactionOption\", \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n+        {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n+        {\"R_BulkColumnMappingsIsEmpty\", \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n+        {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n+        {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n+        {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n+        {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n+        {\"R_UnexpectedDescribeParamFormat\", \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n+        {\"R_InvalidEncryptionKeyOrdinal\", \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n+        {\"R_MissingParamEncryptionMetadata\", \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n+        {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n+        {\"R_InvalidCipherTextSize\", \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n+        {\"R_InvalidAlgorithmVersion\", \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n+        {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n+        {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n+        {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n+        {\"R_InvalidKeySize\", \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". Verify the encrypted value of the column encryption key in the database.\"},\n+        {\"R_InvalidEncryptionType\", \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n+        {\"R_UnknownColumnEncryptionAlgorithm\", \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n+        {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n+        {\"R_UntrustedKeyPath\", \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n+        {\"R_UnrecognizedKeyStoreProviderName\", \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: {2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers used in your application are registered properly.\"},\n+        {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n+        {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n+        {\"R_UnsupportedNormalizationVersionAE\", \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n+        {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n+        {\"R_NullColumnEncryptionAlgorithmAE\", \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n+        {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n+        {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n+        {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n+        {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n+        {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n+                                                                                                       // Server\n+        {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n+        {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n+        {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n+        {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n+        {\"R_InvalidCertificateSignature\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n+        {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n+        {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithm\", \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithmInternal\", \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n+        {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n+        {\"R_CertificateNotFoundForAlias\", \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n+        {\"R_KeyStoreNotFound\", \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n+        {\"R_CustomKeyStoreProviderMapNull\", \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n+        {\"R_EmptyCustomKeyStoreProviderName\", \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n+        {\"R_InvalidCustomKeyStoreProviderName\", \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n+        {\"R_CustomKeyStoreProviderValueNull\", \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n+        {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n+        {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n+        {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n+        {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n+        {\"R_InvalidDataForAE\", \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n+        {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n+        {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n+        {\"R_FedAuthRequiredPreLoginResponseInvalidValue\", \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n+        {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\", \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n+        {\"R_FedAuthInfoInvalidOffset\", \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n+        {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n+        {\"R_FedAuthInfoLengthTooShortForData\", \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n+        {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\", \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n+        {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+        {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n+        {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n+        {\"R_FedAuthFeatureAckContainsExtraData\", \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n+        {\"R_FedAuthFeatureAckUnknownLibraryType\", \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n+        {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n+        {\"R_SetAuthenticationWhenIntegratedSecurityTrue\", \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+        {\"R_NtlmNoUserPasswordDomain\", \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n+        {\"R_SetAccesstokenWhenIntegratedSecurityTrue\", \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n+        {\"R_IntegratedAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_MSIAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_AccessTokenWithUserPassword\", \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n+        {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n+        {\"R_SetBothAuthenticationAndAccessToken\", \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n+        {\"R_NoUserPasswordForActivePassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+        {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+        {\"R_NoUserPasswordForSqlPassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalse\", \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\", \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalseRS\", \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\", \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_NullValue\", \"{0} cannot be null.\"},\n+        {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n+        {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n+        {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n+        {\"R_ManagedIdentityInitFail\", \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n+        {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n+        {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n+        {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n+        {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n+        {\"R_InvalidEcryptionAlgorithmVersion\", \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n+        {\"R_AKVKeyLengthError\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_AKVSignatureLengthError\", \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n+        {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n+        {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n+        {\"R_CEKSignatureNotMatchCMK\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n+        {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n+        {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n+        {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n+        {\"R_UnableLoadADALSqlDll\", \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n+        {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n+        {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n+        {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n+        {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n+        {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n+        {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n+        {\"R_TVPMixedSource\", \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n+        {\"R_TVPEmptyMetadata\", \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n+        {\"R_TVPInvalidValue\", \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n+        {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n+        {\"R_TVPSortOrdinalGreaterThanFieldCount\", \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n+        {\"R_TVPMissingSortOrderOrOrdinal\", \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n+        {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n+        {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n+        {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n+        // This is used for connection settings. {0}-> property name as is, {1}-> value\n+        {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n+        {\"R_InvalidWindowsCertificateStoreEncryption\", \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n+        {\"R_AEKeypathEmpty\", \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n+        {\"R_AECertpathBad\", \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertLocBad\", \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertStoreBad\", \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n+        {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n+        {\"R_AECertNotFound\", \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_AEMaloc\", \"Memory allocation failure.\"},\n+        {\"R_AEKeypathLong\", \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n+        {\"R_AEECEKLenBad\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEECEKSigLenBad\", \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEKeyPathEmptyOrReserved\", \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n+        {\"R_AEKeyPathCurUser\", \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n+        {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n+        {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n+        {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n+        {\"R_keyStoreSecretPropertyDescription\", \"The authentication secret or information needed to locate the secret.\"},\n+        {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n+        {\"R_keyStoreAuthenticationNotSet\", \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n+        {\"R_keyStoreSecretOrLocationNotSet\", \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n+        {\"R_keyStoreSecretNotSet\", \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderClientKeyNotSet\", \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\", \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n+        {\"R_certificateStoreInvalidKeyword\", \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStoreLocationNotSet\", \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStorePlatformInvalid\", \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n+        {\"R_invalidKeyStoreFile\", \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n+                                                                                                                                // JKS/PKCS\n+        {\"R_invalidCEKCacheTtl\", \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n+        {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n+        {\"R_TVPnotWorkWithSetObjectResultSet\", \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n+        {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n+        {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n+        {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n+        {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n+        {\"R_serverPreparedStatementDiscardThreshold\", \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n+        {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n+        {\"R_kerberosLoginFailedForUsername\", \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n+        {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n+        {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n+        {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n+        {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n+        {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n+        {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n+        {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n+        {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n+        {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n+        {\"R_sslProtocolPropertyDescription\", \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n+        {\"R_invalidSSLProtocol\", \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n+        {\"R_cancelQueryTimeoutPropertyDescription\", \"The number of seconds to wait to cancel sending a query timeout.\"},\n+        {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n+        {\"R_useBulkCopyForBatchInsertPropertyDescription\", \"Whether the driver will use bulk copy API for batch insert operations\"},\n+        {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n+        {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n+        {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+        {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n+        {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n+        {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n+        {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n+        {\"R_keyVaultProviderClientIdPropertyDescription\", \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyVaultProviderClientKeyPropertyDescription\", \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+        {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+        {\"R_DLLandMSALMissing\", \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+        {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+        {\"R_MSITokenFailureImdsClientId\", \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+        {\"R_MSITokenFailureUnexpected\", \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+        {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+        {\"R_propertyNotSupported\", \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+        {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+        {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+        {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+        {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+        {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+        {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+        {\"R_useFmtOnlyPropertyDescription\", \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+        {\"R_invalidOpenqueryCall\", \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+        {\"R_invalidCTEFormat\", \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+        {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+        {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+        {\"R_invalidInsertValuesQuery\", \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+        {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+        {\"R_enclaveNotSupported\", \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclavePropertiesError\", \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclaveResponseLengthError\", \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePackageLengthError\", \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePKLengthError\", \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+        {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+        {\"R_HealthCertError\", \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidHealthCert\", \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidSignedStatement\", \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidDHKeySignature\", \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+        {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+        {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+        {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+        {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+        {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+        {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+        {\"R_InvalidCSVQuotes\", \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+        {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+        {\"R_maxResultBufferPropertyDescription\", \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+        {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+        {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+        {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+    };\n }\n+// @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 278197bc..3e3ba8e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,6 +489,14 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 3e3ba8e9..054cab87 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,14 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 054cab87..76210ff7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +489,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 76210ff7..02224d0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,15 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b32966371c5da329e3f8414b66b28fb3635ab646", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 02224d0a..5929f5c3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +491,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 5929f5c3..4f80d4f4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,4 +502,4 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n-// @formatter:on\n\\ No newline at end of file\n+// @formatter:on\n", "next_change": {"commit": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4f80d4f4..ffe08fbe 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -500,6 +500,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex ffe08fbe..2240bd47 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -501,6 +501,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 2240bd47..f1186553 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n+        {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex f1186553..da1b8d3d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n", "next_change": {"commit": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex da1b8d3d..bb98b34d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -507,6 +507,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex bb98b34d..c178c31e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -506,7 +506,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n-        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n", "next_change": {"commit": "0c703a74888da1897d2feb261d0ca91693caa422", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex c178c31e..85d91df1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -508,6 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n+        {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 85d91df1..be53aadd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,6 +519,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex be53aadd..fcab79f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -520,6 +515,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex fcab79f5..b264d3db 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -514,7 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n-        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b264d3db..96bd1847 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,7 +516,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n-        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n // @formatter:on\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..391a1377 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -382,10 +413,14 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n             {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n                     \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+            {\"R_NtlmNoUserPasswordDomain\",\n+                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n             {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n                     \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n             {\"R_IntegratedAuthenticationWithUserPassword\",\n                     \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+            {\"R_MSIAuthenticationWithUserPassword\",\n+                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n             {\"R_AccessTokenWithUserPassword\",\n                     \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n             {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n", "next_change": {"commit": "9f7b5c6445ad0c0e4b73fb5f95cd3cb91a3b9b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 391a1377..e772d9d0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -428,6 +430,7 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n             {\"R_NoUserPasswordForActivePassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+            {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n             {\"R_NoUserPasswordForSqlPassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n             {\"R_ForceEncryptionTrue_HonorAEFalse\",\n", "next_change": {"commit": "bd776c2b48691897cee900cc6e821d171f18513a", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex e772d9d0..33e27f31 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -430,7 +433,8 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n             {\"R_NoUserPasswordForActivePassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+            {\"R_NoUserPasswordForActiveServicePrincipal\",\n+                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n             {\"R_NoUserPasswordForSqlPassword\",\n                     \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n             {\"R_ForceEncryptionTrue_HonorAEFalse\",\n", "next_change": {"commit": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 33e27f31..278197bc 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -21,645 +21,474 @@ public final class SQLServerResource extends ListResourceBundle {\n         return CONTENTS;\n     }\n \n-    // The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n-    // camelCasing convention and be descriptive\n-    static final Object[][] CONTENTS = {\n-            // LOCALIZE THIS\n-            {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n-            {\"R_invalidRoutingInfo\",\n-                    \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_multipleRedirections\",\n-                    \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n-            {\"R_dbMirroringWithMultiSubnetFailover\",\n-                    \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n-            {\"R_dbMirroringWithReadOnlyIntent\",\n-                    \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n-            {\"R_ipAddressLimitWithMultiSubnetFailover\",\n-                    \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n-            {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n-            {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n-            {\"R_invalidLength\", \"The length {0} is not valid.\"},\n-            {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n-            {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n-            {\"R_notSQLServer\",\n-                    \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting \"\n-                            + \"TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n-            {\"R_tcpOpenFailed\",\n-                    \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP \"\n-                            + \"connections to the port are not blocked by a firewall.\"},\n-            {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n-            {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n-            {\"R_truncatedServerResponse\",\n-                    \"SQL Server returned an incomplete response. The connection has been closed.\"},\n-            {\"R_queryTimedOut\", \"The query has timed out.\"}, {\"R_queryCancelled\", \"The query was canceled.\"},\n-            {\"R_errorReadingStream\",\n-                    \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n-            {\"R_streamReadReturnedInvalidValue\",\n-                    \"The stream read operation returned an invalid value for the amount of data read.\"},\n-            {\"R_mismatchedStreamLength\",\n-                    \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n-            {\"R_notSupported\", \"This operation is not supported.\"},\n-            {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n-            {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n-            {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n-            {\"R_connectionIsClosed\", \"The connection is closed.\"},\n-            {\"R_invalidBooleanValue\",\n-                    \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n-            {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n-            {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n-            {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n-            {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n-            {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n-            {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n-            {\"R_packetSizeTooBigForSSL\",\n-                    \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n-            {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n-            {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n-            {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_sqlServerHoldability\",\n-                    \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n-            {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n-            {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n-            {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n-            {\"R_sqlBrowserFailed\",\n-                    \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. \"\n-                            + \" For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n-            {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n-            {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n-            {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n-            {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n-            {\"R_noMetadata\", \"There is no metadata.\"}, {\"R_resultsetClosed\", \"The result set is closed.\"},\n-            {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n-            {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n-            {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n-            {\"R_savepointNotNamed\", \"The savepoint is not named.\"}, {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n-            {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n-            {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n-            {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n-            {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n-            {\"R_noResultset\", \"The statement did not return a result set.\"},\n-            {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n-            {\"R_statementIsClosed\", \"The statement is closed.\"},\n-            {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n-            {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n-            {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n-            {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n-            {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n-            {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n-            {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n-            {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n-            {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n-            {\"R_invalidOffset\", \"The offset {0} is not valid.\"}, {\"R_nullConnection\", \"The connection URL is null.\"},\n-            {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n-            {\"R_cannotTakeArgumentsPreparedOrCallable\",\n-                    \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n-            // Invalid conversion (e.g. MONEY to Timestamp)\n-            {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n-            // Invalid conversion to an unknown type\n-            {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n-            // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n-            {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n-            {\"R_streamIsClosed\", \"The stream is closed.\"}, {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n-            {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n-            {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n-            {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n-            {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n-            {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n-            {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n-            {\"R_encodingErrorWritingTDS\",\n-                    \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n-            {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n-            {\"R_requestedOpNotSupportedOnForward\",\n-                    \"The requested operation is not supported on forward only result sets.\"},\n-            {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n-            {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n-            {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n-            {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n-            {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n-            {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n-            {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n-            {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n-            {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n-            {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n-            {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n-            {\"R_cantGetUpdatedColumnValue\",\n-                    \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n-            {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n-            {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n-            {\"R_invalidAutoGeneratedKeys\",\n-                    \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n-            {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n-            {\"R_failoverPartnerWithoutDB\",\n-                    \"databaseName is required when using the failoverPartner connection property.\"},\n-            {\"R_invalidPartnerConfiguration\",\n-                    \"The database {0} on server {1} is not configured for database mirroring.\"},\n-            {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n-            {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n-            {\"R_invalidpropertyValue\",\n-                    \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n-            {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n-            {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n-            {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n-            {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n-            {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n-            {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n-            {\"R_sslRequiredNoServerSupport\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. \"\n-                            + \"The application requested encryption but the server is not configured to support SSL.\"},\n-            {\"R_sslRequiredByServer\",\n-                    \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n-            {\"R_sslFailed\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n-            {\"R_certNameFailed\",\n-                    \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n-            {\"R_failedToInitializeXA\",\n-                    \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n-            {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n-            {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n-            {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n-            {\"R_userPropertyDescription\", \"The database user.\"},\n-            {\"R_passwordPropertyDescription\", \"The database password.\"},\n-            {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n-            {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n-            {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n-            {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n-            {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n-            {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n-            {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n-            {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n-            {\"R_serverNameAsACEPropertyDescription\",\n-                    \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n-            {\"R_sendStringParametersAsUnicodePropertyDescription\",\n-                    \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n-            {\"R_multiSubnetFailoverPropertyDescription\",\n-                    \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n-            {\"R_applicationNamePropertyDescription\",\n-                    \"The application name for SQL Server profiling and logging tools.\"},\n-            {\"R_lastUpdateCountPropertyDescription\",\n-                    \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n-            {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n-            {\"R_integratedSecurityPropertyDescription\",\n-                    \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n-            {\"R_authenticationSchemePropertyDescription\",\n-                    \"The authentication scheme to be used for integrated authentication.\"},\n-            {\"R_lockTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n-            {\"R_loginTimeoutPropertyDescription\",\n-                    \"The number of seconds the driver should wait before timing out a failed connection.\"},\n-            {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n-            {\"R_xopenStatesPropertyDescription\",\n-                    \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n-            {\"R_selectMethodPropertyDescription\",\n-                    \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n-            {\"R_responseBufferingPropertyDescription\",\n-                    \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n-            {\"R_applicationIntentPropertyDescription\",\n-                    \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n-            {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n-            {\"R_failoverPartnerPropertyDescription\",\n-                    \"The name of the failover server used in a database mirroring configuration.\"},\n-            {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n-            {\"R_encryptPropertyDescription\",\n-                    \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n-            {\"R_socketFactoryClassPropertyDescription\",\n-                    \"The class to instantiate as the SocketFactory for connections\"},\n-            {\"R_socketFactoryConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n-            {\"R_trustServerCertificatePropertyDescription\",\n-                    \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n-            {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n-            {\"R_trustStorePasswordPropertyDescription\",\n-                    \"The password used to check the integrity of the trust store data.\"},\n-            {\"R_trustManagerClassPropertyDescription\",\n-                    \"The class to instantiate as the TrustManager for SSL connections.\"},\n-            {\"R_trustManagerConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n-            {\"R_hostNameInCertificatePropertyDescription\",\n-                    \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_sendTimeAsDatetimePropertyDescription\",\n-                    \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n-            {\"R_TransparentNetworkIPResolutionPropertyDescription\",\n-                    \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n-            {\"R_queryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait before the database reports a query time-out.\"},\n-            {\"R_socketTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n-            {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\",\n-                    \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). \"\n-                            + \"A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n-            {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\",\n-                    \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n-            {\"R_statementPoolingCacheSizePropertyDescription\",\n-                    \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n-            {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n-            {\"R_msiClientIdPropertyDescription\",\n-                    \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n-            {\"R_clientCertificatePropertyDescription\",\n-                    \"Client certificate path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPasswordPropertyDescription\",\n-                    \"Password for private key if the private key is password protected.\"},\n-            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n-                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n-            {\"R_delayLoadingLobsPropertyDescription\",\n-                    \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n-            {\"R_AADSecurePrincipalIdPropertyDescription\",\n-                    \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n-            {\"R_AADSecurePrincipalSecretPropertyDescription\",\n-                    \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n-            {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n-            {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n-            {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n-            {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n-            {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n-            {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n-            {\"R_cantSetNull\", \"Cannot set a null value.\"},\n-            {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n-            {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n-            {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n-            {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n-            {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n-            {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n-            {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n-            {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n-            {\"R_getSchemaError\", \"Error getting default schema name.\"},\n-            {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n-            {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n-            {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n-            {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n-            {\"R_featureNotSupported\", \"{0} is not supported.\"},\n-            {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n-            {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n-            {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n-            {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n-            {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n-            {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n-            {\"R_invalidDestConnection\",\n-                    \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n-            {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n-            {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n-            {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n-            {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n-            {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n-            {\"R_invalidTransactionOption\",\n-                    \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n-            {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n-            {\"R_BulkColumnMappingsIsEmpty\",\n-                    \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n-            {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n-            {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n-            {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n-            {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n-            {\"R_UnexpectedDescribeParamFormat\",\n-                    \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n-            {\"R_InvalidEncryptionKeyOrdinal\",\n-                    \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n-            {\"R_MissingParamEncryptionMetadata\",\n-                    \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n-            {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n-            {\"R_InvalidCipherTextSize\",\n-                    \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n-            {\"R_InvalidAlgorithmVersion\",\n-                    \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n-            {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n-            {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n-            {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n-            {\"R_InvalidKeySize\",\n-                    \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". \"\n-                            + \"Verify the encrypted value of the column encryption key in the database.\"},\n-            {\"R_InvalidEncryptionType\",\n-                    \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n-            {\"R_UnknownColumnEncryptionAlgorithm\",\n-                    \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n-            {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n-            {\"R_UntrustedKeyPath\",\n-                    \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path \"\n-                            + \"using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n-            {\"R_UnrecognizedKeyStoreProviderName\",\n-                    \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider \"\n-                            + \"or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: \"\n-                            + \"{2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers \"\n-                            + \"used in your application are registered properly.\"},\n-            {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n-            {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n-            {\"R_UnsupportedNormalizationVersionAE\",\n-                    \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n-            {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n-            {\"R_NullColumnEncryptionAlgorithmAE\",\n-                    \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n-            {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n-            {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n-            {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n-            {\"R_AE_NotSupportedByServer\", \"SQL Server instance in use does not support column encryption.\"},\n-            {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n-                                                                                                           // Server\n-            {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n-            {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n-            {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n-            {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n-            {\"R_InvalidCertificateSignature\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n-            {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n-            {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithm\",\n-                    \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithmInternal\",\n-                    \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n-            {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n-            {\"R_CertificateNotFoundForAlias\",\n-                    \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. \"\n-                    + \" Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n-            {\"R_KeyStoreNotFound\",\n-                    \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n-            {\"R_CustomKeyStoreProviderMapNull\",\n-                    \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n-            {\"R_EmptyCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n-            {\"R_InvalidCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n-            {\"R_CustomKeyStoreProviderValueNull\",\n-                    \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n-            {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n-            {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n-            {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n-            {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n-            {\"R_InvalidDataForAE\",\n-                    \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n-            {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n-            {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n-            {\"R_FedAuthRequiredPreLoginResponseInvalidValue\",\n-                    \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n-            {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\",\n-                    \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n-            {\"R_FedAuthInfoInvalidOffset\",\n-                    \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n-            {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n-            {\"R_FedAuthInfoLengthTooShortForData\",\n-                    \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n-            {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n-                    \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n-            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n-            {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n-            {\"R_FedAuthFeatureAckContainsExtraData\",\n-                    \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n-            {\"R_FedAuthFeatureAckUnknownLibraryType\",\n-                    \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n-            {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n-            {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n-                    \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n-            {\"R_NtlmNoUserPasswordDomain\",\n-                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n-            {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n-                    \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n-            {\"R_IntegratedAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_MSIAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_AccessTokenWithUserPassword\",\n-                    \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n-            {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n-            {\"R_SetBothAuthenticationAndAccessToken\",\n-                    \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n-            {\"R_NoUserPasswordForActivePassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\",\n-                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n-            {\"R_NoUserPasswordForSqlPassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalse\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\",\n-                    \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalseRS\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\",\n-                    \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_NullValue\", \"{0} cannot be null.\"}, {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n-            {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n-            {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n-            {\"R_ManagedIdentityInitFail\",\n-                    \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n-            {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n-            {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n-            {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n-            {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n-            {\"R_InvalidEcryptionAlgorithmVersion\",\n-                    \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n-            {\"R_AKVKeyLengthError\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_AKVSignatureLengthError\",\n-                    \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n-            {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n-            {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n-            {\"R_CEKSignatureNotMatchCMK\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n-            {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n-            {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n-            {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n-            {\"R_UnableLoadADALSqlDll\",\n-                    \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n-            {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n-            {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n-            {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n-            {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n-            {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n-            {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n-            {\"R_TVPMixedSource\",\n-                    \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n-            {\"R_TVPEmptyMetadata\",\n-                    \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n-            {\"R_TVPInvalidValue\",\n-                    \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n-            {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n-            {\"R_TVPSortOrdinalGreaterThanFieldCount\",\n-                    \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n-            {\"R_TVPMissingSortOrderOrOrdinal\",\n-                    \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n-            {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n-            {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n-            {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n-            // This is used for connection settings. {0}-> property name as is, {1}-> value\n-            {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n-            {\"R_InvalidWindowsCertificateStoreEncryption\",\n-                    \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n-            {\"R_AEKeypathEmpty\",\n-                    \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n-            {\"R_AECertpathBad\",\n-                    \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertLocBad\",\n-                    \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertStoreBad\",\n-                    \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n-            {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n-            {\"R_AECertNotFound\",\n-                    \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition \"\n-                            + \"in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_AEMaloc\", \"Memory allocation failure.\"},\n-            {\"R_AEKeypathLong\",\n-                    \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n-            {\"R_AEECEKLenBad\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEECEKSigLenBad\",\n-                    \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEKeyPathEmptyOrReserved\",\n-                    \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n-            {\"R_AEKeyPathCurUser\",\n-                    \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n-            {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n-            {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n-            {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n-            {\"R_keyStoreSecretPropertyDescription\",\n-                    \"The authentication secret or information needed to locate the secret.\"},\n-            {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n-            {\"R_keyStoreAuthenticationNotSet\",\n-                    \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n-            {\"R_keyStoreSecretOrLocationNotSet\",\n-                    \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n-            {\"R_keyStoreSecretNotSet\",\n-                    \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreInvalidKeyword\",\n-                    \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreLocationNotSet\",\n-                    \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStorePlatformInvalid\",\n-                    \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n-            {\"R_invalidKeyStoreFile\",\n-                    \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n-                                                                                                                  // JKS/PKCS\n-            {\"R_invalidCEKCacheTtl\",\n-                    \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n-            {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n-            {\"R_TVPnotWorkWithSetObjectResultSet\",\n-                    \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n-            {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n-            {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n-            {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n-            {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n-            {\"R_serverPreparedStatementDiscardThreshold\",\n-                    \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n-            {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n-            {\"R_kerberosLoginFailedForUsername\",\n-                    \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n-            {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n-            {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n-            {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n-            {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n-            {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n-            {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n-            {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n-            {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n-            {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n-            {\"R_sslProtocolPropertyDescription\",\n-                    \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n-            {\"R_invalidSSLProtocol\",\n-                    \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n-            {\"R_cancelQueryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait to cancel sending a query timeout.\"},\n-            {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n-            {\"R_useBulkCopyForBatchInsertPropertyDescription\",\n-                    \"Whether the driver will use bulk copy API for batch insert operations\"},\n-            {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n-            {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n-            {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n-            {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n-            {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n-            {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n-            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n-            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n-            {\"R_maxResultBufferPropertyDescription\",\n-                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n-            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n-            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+    /*\n+     * The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n+     * camelCasing convention and be descriptive.\n+     */\n+    // @formatter:off\n+    // Disable formatting for localization parser: use 1 line per error message and do not use \"+\"\n+    // @formatter:off\n+    static final Object[][] CONTENTS =\n+    {\n+        // LOCALIZE THIS\n+        {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n+        {\"R_invalidRoutingInfo\", \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_multipleRedirections\", \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n+        {\"R_dbMirroringWithMultiSubnetFailover\", \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n+        {\"R_dbMirroringWithReadOnlyIntent\", \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n+        {\"R_ipAddressLimitWithMultiSubnetFailover\", \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n+        {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n+        {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n+        {\"R_invalidLength\", \"The length {0} is not valid.\"},\n+        {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n+        {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n+        {\"R_notSQLServer\", \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n+        {\"R_tcpOpenFailed\", \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP connections to the port are not blocked by a firewall.\"},\n+        {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n+        {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n+        {\"R_truncatedServerResponse\", \"SQL Server returned an incomplete response. The connection has been closed.\"},\n+        {\"R_queryTimedOut\", \"The query has timed out.\"},\n+        {\"R_queryCancelled\", \"The query was canceled.\"},\n+        {\"R_errorReadingStream\", \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n+        {\"R_streamReadReturnedInvalidValue\", \"The stream read operation returned an invalid value for the amount of data read.\"},\n+        {\"R_mismatchedStreamLength\", \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n+        {\"R_notSupported\", \"This operation is not supported.\"},\n+        {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n+        {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n+        {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n+        {\"R_connectionIsClosed\", \"The connection is closed.\"},\n+        {\"R_invalidBooleanValue\", \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n+        {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n+        {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n+        {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n+        {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n+        {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n+        {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n+        {\"R_packetSizeTooBigForSSL\", \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n+        {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n+        {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n+        {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_sqlServerHoldability\", \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n+        {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n+        {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n+        {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n+        {\"R_sqlBrowserFailed\", \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n+        {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n+        {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n+        {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n+        {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n+        {\"R_noMetadata\", \"There is no metadata.\"},\n+        {\"R_resultsetClosed\", \"The result set is closed.\"},\n+        {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n+        {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n+        {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n+        {\"R_savepointNotNamed\", \"The savepoint is not named.\"},\n+        {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n+        {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n+        {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n+        {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n+        {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n+        {\"R_noResultset\", \"The statement did not return a result set.\"},\n+        {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n+        {\"R_statementIsClosed\", \"The statement is closed.\"},\n+        {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n+        {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n+        {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n+        {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n+        {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n+        {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n+        {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n+        {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n+        {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n+        {\"R_invalidOffset\", \"The offset {0} is not valid.\"},\n+        {\"R_nullConnection\", \"The connection URL is null.\"},\n+        {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n+        {\"R_cannotTakeArgumentsPreparedOrCallable\", \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n+        // Invalid conversion (e.g. MONEY to Timestamp)\n+        {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n+        // Invalid conversion to an unknown type\n+        {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n+        // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n+        {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n+        {\"R_streamIsClosed\", \"The stream is closed.\"},\n+        {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n+        {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n+        {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n+        {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n+        {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n+        {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n+        {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n+        {\"R_encodingErrorWritingTDS\", \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n+        {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n+        {\"R_requestedOpNotSupportedOnForward\", \"The requested operation is not supported on forward only result sets.\"},\n+        {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n+        {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n+        {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n+        {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n+        {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n+        {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n+        {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n+        {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n+        {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n+        {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n+        {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n+        {\"R_cantGetUpdatedColumnValue\", \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n+        {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n+        {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n+        {\"R_invalidAutoGeneratedKeys\", \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n+        {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n+        {\"R_failoverPartnerWithoutDB\", \"databaseName is required when using the failoverPartner connection property.\"},\n+        {\"R_invalidPartnerConfiguration\", \"The database {0} on server {1} is not configured for database mirroring.\"},\n+        {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n+        {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n+        {\"R_invalidpropertyValue\", \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n+        {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n+        {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n+        {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n+        {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n+        {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n+        {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n+        {\"R_sslRequiredNoServerSupport\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. The application requested encryption but the server is not configured to support SSL.\"},\n+        {\"R_sslRequiredByServer\", \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n+        {\"R_sslFailed\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n+        {\"R_certNameFailed\", \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n+        {\"R_failedToInitializeXA\", \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n+        {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n+        {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n+        {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n+        {\"R_userPropertyDescription\", \"The database user.\"},\n+        {\"R_passwordPropertyDescription\", \"The database password.\"},\n+        {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n+        {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n+        {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n+        {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n+        {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n+        {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n+        {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n+        {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n+        {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n+        {\"R_serverNameAsACEPropertyDescription\", \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n+        {\"R_sendStringParametersAsUnicodePropertyDescription\", \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n+        {\"R_multiSubnetFailoverPropertyDescription\", \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n+        {\"R_applicationNamePropertyDescription\", \"The application name for SQL Server profiling and logging tools.\"},\n+        {\"R_lastUpdateCountPropertyDescription\", \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n+        {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n+        {\"R_integratedSecurityPropertyDescription\", \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n+        {\"R_authenticationSchemePropertyDescription\", \"The authentication scheme to be used for integrated authentication.\"},\n+        {\"R_lockTimeoutPropertyDescription\", \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The number of reconnection attempts if there is a connection failure.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The number of seconds between each connection retry attempt.\"},\n+        {\"R_loginTimeoutPropertyDescription\", \"The number of seconds the driver should wait before timing out a failed connection.\"},\n+        {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n+        {\"R_xopenStatesPropertyDescription\", \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n+        {\"R_selectMethodPropertyDescription\", \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n+        {\"R_responseBufferingPropertyDescription\", \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n+        {\"R_applicationIntentPropertyDescription\", \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n+        {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n+        {\"R_failoverPartnerPropertyDescription\", \"The name of the failover server used in a database mirroring configuration.\"},\n+        {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n+        {\"R_encryptPropertyDescription\", \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n+        {\"R_socketFactoryClassPropertyDescription\", \"The class to instantiate as the SocketFactory for connections\"},\n+        {\"R_socketFactoryConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n+        {\"R_trustServerCertificatePropertyDescription\", \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n+        {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n+        {\"R_trustStorePasswordPropertyDescription\", \"The password used to check the integrity of the trust store data.\"},\n+        {\"R_trustManagerClassPropertyDescription\", \"The class to instantiate as the TrustManager for SSL connections.\"},\n+        {\"R_trustManagerConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n+        {\"R_hostNameInCertificatePropertyDescription\", \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_replicationPropertyDescription\", \"This setting tells the server if the connection is used for replication.\"},\n+        {\"R_sendTimeAsDatetimePropertyDescription\", \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n+        {\"R_TransparentNetworkIPResolutionPropertyDescription\", \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n+        {\"R_queryTimeoutPropertyDescription\", \"The number of seconds to wait before the database reports a query time-out.\"},\n+        {\"R_socketTimeoutPropertyDescription\", \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n+        {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\", \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n+        {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\", \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n+        {\"R_statementPoolingCacheSizePropertyDescription\", \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n+        {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n+        {\"R_msiClientIdPropertyDescription\", \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n+        {\"R_clientCertificatePropertyDescription\", \"Client certificate path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPasswordPropertyDescription\", \"Password for private key if the private key is password protected.\"},\n+        {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\", \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n+        {\"R_delayLoadingLobsPropertyDescription\", \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n+        {\"R_AADSecurePrincipalIdPropertyDescription\", \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n+        {\"R_AADSecurePrincipalSecretPropertyDescription\", \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n+        {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n+        {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n+        {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n+        {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n+        {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n+        {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n+        {\"R_cantSetNull\", \"Cannot set a null value.\"},\n+        {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n+        {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n+        {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n+        {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n+        {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n+        {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n+        {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n+        {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n+        {\"R_getSchemaError\", \"Error getting default schema name.\"},\n+        {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n+        {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n+        {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n+        {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n+        {\"R_featureNotSupported\", \"{0} is not supported.\"},\n+        {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n+        {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n+        {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n+        {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n+        {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n+        {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n+        {\"R_invalidDestConnection\", \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n+        {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n+        {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n+        {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n+        {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n+        {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n+        {\"R_invalidTransactionOption\", \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n+        {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n+        {\"R_BulkColumnMappingsIsEmpty\", \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n+        {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n+        {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n+        {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n+        {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n+        {\"R_UnexpectedDescribeParamFormat\", \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n+        {\"R_InvalidEncryptionKeyOrdinal\", \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n+        {\"R_MissingParamEncryptionMetadata\", \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n+        {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n+        {\"R_InvalidCipherTextSize\", \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n+        {\"R_InvalidAlgorithmVersion\", \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n+        {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n+        {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n+        {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n+        {\"R_InvalidKeySize\", \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". Verify the encrypted value of the column encryption key in the database.\"},\n+        {\"R_InvalidEncryptionType\", \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n+        {\"R_UnknownColumnEncryptionAlgorithm\", \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n+        {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n+        {\"R_UntrustedKeyPath\", \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n+        {\"R_UnrecognizedKeyStoreProviderName\", \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: {2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers used in your application are registered properly.\"},\n+        {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n+        {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n+        {\"R_UnsupportedNormalizationVersionAE\", \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n+        {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n+        {\"R_NullColumnEncryptionAlgorithmAE\", \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n+        {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n+        {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n+        {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n+        {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n+        {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n+                                                                                                       // Server\n+        {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n+        {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n+        {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n+        {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n+        {\"R_InvalidCertificateSignature\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n+        {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n+        {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithm\", \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithmInternal\", \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n+        {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n+        {\"R_CertificateNotFoundForAlias\", \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n+        {\"R_KeyStoreNotFound\", \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n+        {\"R_CustomKeyStoreProviderMapNull\", \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n+        {\"R_EmptyCustomKeyStoreProviderName\", \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n+        {\"R_InvalidCustomKeyStoreProviderName\", \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n+        {\"R_CustomKeyStoreProviderValueNull\", \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n+        {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n+        {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n+        {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n+        {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n+        {\"R_InvalidDataForAE\", \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n+        {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n+        {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n+        {\"R_FedAuthRequiredPreLoginResponseInvalidValue\", \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n+        {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\", \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n+        {\"R_FedAuthInfoInvalidOffset\", \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n+        {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n+        {\"R_FedAuthInfoLengthTooShortForData\", \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n+        {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\", \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n+        {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+        {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n+        {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n+        {\"R_FedAuthFeatureAckContainsExtraData\", \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n+        {\"R_FedAuthFeatureAckUnknownLibraryType\", \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n+        {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n+        {\"R_SetAuthenticationWhenIntegratedSecurityTrue\", \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+        {\"R_NtlmNoUserPasswordDomain\", \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n+        {\"R_SetAccesstokenWhenIntegratedSecurityTrue\", \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n+        {\"R_IntegratedAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_MSIAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_AccessTokenWithUserPassword\", \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n+        {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n+        {\"R_SetBothAuthenticationAndAccessToken\", \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n+        {\"R_NoUserPasswordForActivePassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+        {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+        {\"R_NoUserPasswordForSqlPassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalse\", \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\", \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalseRS\", \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\", \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_NullValue\", \"{0} cannot be null.\"},\n+        {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n+        {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n+        {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n+        {\"R_ManagedIdentityInitFail\", \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n+        {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n+        {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n+        {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n+        {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n+        {\"R_InvalidEcryptionAlgorithmVersion\", \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n+        {\"R_AKVKeyLengthError\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_AKVSignatureLengthError\", \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n+        {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n+        {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n+        {\"R_CEKSignatureNotMatchCMK\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n+        {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n+        {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n+        {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n+        {\"R_UnableLoadADALSqlDll\", \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n+        {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n+        {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n+        {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n+        {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n+        {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n+        {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n+        {\"R_TVPMixedSource\", \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n+        {\"R_TVPEmptyMetadata\", \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n+        {\"R_TVPInvalidValue\", \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n+        {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n+        {\"R_TVPSortOrdinalGreaterThanFieldCount\", \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n+        {\"R_TVPMissingSortOrderOrOrdinal\", \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n+        {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n+        {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n+        {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n+        // This is used for connection settings. {0}-> property name as is, {1}-> value\n+        {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n+        {\"R_InvalidWindowsCertificateStoreEncryption\", \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n+        {\"R_AEKeypathEmpty\", \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n+        {\"R_AECertpathBad\", \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertLocBad\", \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertStoreBad\", \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n+        {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n+        {\"R_AECertNotFound\", \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_AEMaloc\", \"Memory allocation failure.\"},\n+        {\"R_AEKeypathLong\", \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n+        {\"R_AEECEKLenBad\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEECEKSigLenBad\", \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEKeyPathEmptyOrReserved\", \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n+        {\"R_AEKeyPathCurUser\", \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n+        {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n+        {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n+        {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n+        {\"R_keyStoreSecretPropertyDescription\", \"The authentication secret or information needed to locate the secret.\"},\n+        {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n+        {\"R_keyStoreAuthenticationNotSet\", \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n+        {\"R_keyStoreSecretOrLocationNotSet\", \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n+        {\"R_keyStoreSecretNotSet\", \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderClientKeyNotSet\", \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\", \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n+        {\"R_certificateStoreInvalidKeyword\", \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStoreLocationNotSet\", \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStorePlatformInvalid\", \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n+        {\"R_invalidKeyStoreFile\", \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n+                                                                                                                                // JKS/PKCS\n+        {\"R_invalidCEKCacheTtl\", \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n+        {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n+        {\"R_TVPnotWorkWithSetObjectResultSet\", \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n+        {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n+        {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n+        {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n+        {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n+        {\"R_serverPreparedStatementDiscardThreshold\", \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n+        {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n+        {\"R_kerberosLoginFailedForUsername\", \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n+        {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n+        {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n+        {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n+        {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n+        {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n+        {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n+        {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n+        {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n+        {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n+        {\"R_sslProtocolPropertyDescription\", \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n+        {\"R_invalidSSLProtocol\", \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n+        {\"R_cancelQueryTimeoutPropertyDescription\", \"The number of seconds to wait to cancel sending a query timeout.\"},\n+        {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n+        {\"R_useBulkCopyForBatchInsertPropertyDescription\", \"Whether the driver will use bulk copy API for batch insert operations\"},\n+        {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n+        {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n+        {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+        {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n+        {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n+        {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n+        {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n+        {\"R_keyVaultProviderClientIdPropertyDescription\", \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyVaultProviderClientKeyPropertyDescription\", \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+        {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+        {\"R_DLLandMSALMissing\", \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+        {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+        {\"R_MSITokenFailureImdsClientId\", \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+        {\"R_MSITokenFailureUnexpected\", \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+        {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+        {\"R_propertyNotSupported\", \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+        {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+        {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+        {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+        {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+        {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+        {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+        {\"R_useFmtOnlyPropertyDescription\", \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+        {\"R_invalidOpenqueryCall\", \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+        {\"R_invalidCTEFormat\", \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+        {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+        {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+        {\"R_invalidInsertValuesQuery\", \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+        {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+        {\"R_enclaveNotSupported\", \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclavePropertiesError\", \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclaveResponseLengthError\", \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePackageLengthError\", \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePKLengthError\", \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+        {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+        {\"R_HealthCertError\", \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidHealthCert\", \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidSignedStatement\", \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidDHKeySignature\", \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+        {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+        {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+        {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+        {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+        {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+        {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+        {\"R_InvalidCSVQuotes\", \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+        {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+        {\"R_maxResultBufferPropertyDescription\", \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+        {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+        {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+        {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+    };\n }\n+// @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 278197bc..3e3ba8e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,6 +489,14 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 3e3ba8e9..054cab87 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,14 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 054cab87..76210ff7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +489,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 76210ff7..02224d0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,15 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b32966371c5da329e3f8414b66b28fb3635ab646", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 02224d0a..5929f5c3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +491,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 5929f5c3..4f80d4f4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,4 +502,4 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n-// @formatter:on\n\\ No newline at end of file\n+// @formatter:on\n", "next_change": {"commit": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4f80d4f4..ffe08fbe 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -500,6 +500,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex ffe08fbe..2240bd47 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -501,6 +501,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 2240bd47..f1186553 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n+        {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex f1186553..da1b8d3d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n", "next_change": {"commit": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex da1b8d3d..bb98b34d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -507,6 +507,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex bb98b34d..c178c31e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -506,7 +506,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n-        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n", "next_change": {"commit": "0c703a74888da1897d2feb261d0ca91693caa422", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex c178c31e..85d91df1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -508,6 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n+        {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 85d91df1..be53aadd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,6 +519,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex be53aadd..fcab79f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -520,6 +515,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex fcab79f5..b264d3db 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -514,7 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n-        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b264d3db..96bd1847 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,7 +516,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n-        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n // @formatter:on\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "d8f20da4cfd2156c8ca08d54b6eaa8718493e85e", "url": "https://github.com/microsoft/mssql-jdbc/commit/d8f20da4cfd2156c8ca08d54b6eaa8718493e85e", "message": "updated error msgs", "committedDate": "2020-10-13T19:11:35Z", "type": "commit"}, {"oid": "c6d444cae4b34e9b56c6870c0c4bcc731bbae4ba", "url": "https://github.com/microsoft/mssql-jdbc/commit/c6d444cae4b34e9b56c6870c0c4bcc731bbae4ba", "message": "update version", "committedDate": "2020-10-13T19:16:56Z", "type": "commit"}, {"oid": "f7aeb12a67a165f6f09448bc958c0d22f4d617cc", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7aeb12a67a165f6f09448bc958c0d22f4d617cc", "message": "Update README.md\n\nupdated for MSAL", "committedDate": "2020-10-13T21:20:46Z", "type": "commit"}, {"oid": "61ee2d4c1131ec15530a10105f4cbd8c759bc2d9", "url": "https://github.com/microsoft/mssql-jdbc/commit/61ee2d4c1131ec15530a10105f4cbd8c759bc2d9", "message": "Merge pull request #10 from lilgreenbird/msal\n\nFixed error msgs", "committedDate": "2020-10-13T22:26:21Z", "type": "commit"}, {"oid": "53d44087620cbda9bcce55aad1d2cb810c9d50f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/53d44087620cbda9bcce55aad1d2cb810c9d50f7", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-28T00:38:19Z", "type": "commit"}, {"oid": "5bc675535eb3db983b094164a2b898855e6b57a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/5bc675535eb3db983b094164a2b898855e6b57a7", "message": "Merge pull request #1 from lilgreenbird/msal\n\nformatting and merged with latest dev", "committedDate": "2020-08-28T00:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5Mjg5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481492899", "body": "@lilgreenbird \r\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences. ", "bodyText": "@lilgreenbird\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lilgreenbird/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lilgreenbird\">@lilgreenbird</a><br>\nThis is not how we handle exception messages. Error messages need to be localized and also make sure to throw SQLServerException. Please make sure to change this in all occurrences.</p>", "author": "ulvii", "createdAt": "2020-09-01T23:47:01Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MzM4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481493389", "body": "`.` at the end.", "bodyText": ". at the end.", "bodyHTML": "<p dir=\"auto\"><code>.</code> at the end.</p>", "author": "ulvii", "createdAt": "2020-09-01T23:48:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MjM3OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481492378", "body": "We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.", "bodyText": "We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.", "bodyHTML": "<p dir=\"auto\">We'll need to doc this. Since it's been deprecated for prior major version bumps, do we need to bump the major version for this change? I'm leaning towards yes.</p>", "author": "David-Engel", "createdAt": "2020-09-01T23:45:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -84,76 +90,38 @@ public String getName() {\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n-     *         when an error occurs\n+     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -90,38 +84,76 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n-     *         If either {@code clientId} or {@code clientKey} are {@code null}.\n+     *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n      * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n      */\n     SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -84,96 +90,129 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        setCredential(tokenCredential);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n      * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MzkyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481493924", "body": "```suggestion\r\n/*\r\n * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n */\r\n\r\npackage com.microsoft.sqlserver.jdbc;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package com.microsoft.sqlserver.jdbc;\n          \n          \n            \n            /*\n          \n          \n            \n             * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n          \n          \n            \n             * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            package com.microsoft.sqlserver.jdbc;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"5\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k x x-first\">package</span><span class=\"x\"> </span><span class=\"pl-smi x\">com.microsoft.sqlserver.jdbc</span><span class=\"x x-last\">;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"5\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-c\"><span class=\"pl-c x x-first x-last\">/*</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"6\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Microsoft</span> <span class=\"pl-c1\">JDBC</span> <span class=\"pl-smi\">Driver</span> <span class=\"pl-k\">for</span> <span class=\"pl-c1\">SQL</span> <span class=\"pl-smi\">Server</span> Copyright(c) <span class=\"pl-smi\">Microsoft</span> <span class=\"pl-smi\">Corporation</span> <span class=\"pl-smi\">All</span> rights reserved. <span class=\"pl-smi\">This</span> program is made</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"7\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> available under the terms of the <span class=\"pl-c1\">MIT</span> <span class=\"pl-smi\">License</span>. <span class=\"pl-smi\">See</span> the <span class=\"pl-c1\">LICENSE</span> file in the project root <span class=\"pl-k\">for</span> more information.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"8\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"9\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"10\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">package</span> <span class=\"pl-smi\">com.microsoft.sqlserver.jdbc</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "David-Engel", "createdAt": "2020-09-01T23:50:26Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5OTgxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481499810", "body": "This is not how exception are handled in the driver, @lilgreenbird please make sure to follow the guidelines. ", "bodyText": "This is not how exception are handled in the driver, @lilgreenbird please make sure to follow the guidelines.", "bodyHTML": "<p dir=\"auto\">This is not how exception are handled in the driver, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lilgreenbird/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lilgreenbird\">@lilgreenbird</a> please make sure to follow the guidelines.</p>", "author": "ulvii", "createdAt": "2020-09-02T00:10:48Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n     }\n \n-    KeyVaultCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n-        this.authenticationCallback = authenticationCallback;\n+    public KeyVaultCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n     }\n \n-    public String doAuthenticate(String authorization, String resource, String scope) {\n-        String accessToken = null;\n-        if (null == authenticationCallback) {\n-            if (null == clientKey) {\n-                try {\n-                    SqlFedAuthToken token = SQLServerSecurityUtility.getMSIAuthToken(resource, clientId);\n-                    accessToken = (null != token) ? token.accessToken : null;\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId,\n-                        clientKey);\n-                accessToken = token.getAccessToken();\n-            }\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwMzc4Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481503786", "body": "Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.", "bodyText": "Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.", "bodyHTML": "<p dir=\"auto\">Please pay attention  to public APIs. We don't want to create public APIs unless it is by design.</p>", "author": "ulvii", "createdAt": "2020-09-02T00:24:10Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java", "diffHunk": "@@ -5,86 +5,118 @@\n \n package com.microsoft.sqlserver.jdbc;\n \n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.microsoft.aad.adal4j.AuthenticationContext;\n-import com.microsoft.aad.adal4j.AuthenticationResult;\n-import com.microsoft.aad.adal4j.ClientCredential;\n-import com.microsoft.azure.keyvault.authentication.KeyVaultCredentials;\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n \n \n /**\n- * \n- * An implementation of ServiceClientCredentials that supports automatic bearer token refresh.\n- *\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n  */\n-class KeyVaultCredential extends KeyVaultCredentials {\n-\n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = null;\n-    String clientId = null;\n-    String clientKey = null;\n-    String accessToken = null;\n+@Immutable\n+class KeyVaultCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n \n-    KeyVaultCredential(String clientId) throws SQLServerException {\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application.\n+     */\n+    KeyVaultCredential(String clientId, String clientSecret) {\n+        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n+        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n     }\n \n-    KeyVaultCredential() {}\n-\n-    KeyVaultCredential(String clientId, String clientKey) {\n-        this.clientId = clientId;\n-        this.clientKey = clientKey;\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\ndeleted file mode 100644\nindex bc1ceea6..00000000\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCredential.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-import com.azure.core.annotation.Immutable;\n-import com.azure.core.credential.AccessToken;\n-import com.azure.core.credential.TokenCredential;\n-import com.azure.core.credential.TokenRequestContext;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.microsoft.aad.msal4j.ClientCredentialFactory;\n-import com.microsoft.aad.msal4j.ClientCredentialParameters;\n-import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n-import com.microsoft.aad.msal4j.IAuthenticationResult;\n-import com.microsoft.aad.msal4j.IClientCredential;\n-import com.microsoft.aad.msal4j.SilentParameters;\n-import java.net.MalformedURLException;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import reactor.core.publisher.Mono;\n-\n-\n-/**\n- * An AAD credential that acquires a token with a client secret for an AAD application.\n- */\n-@Immutable\n-class KeyVaultCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultCredential.class);\n-    private final String clientId;\n-    private final String clientSecret;\n-    private String authorization;\n-    private ConfidentialClientApplication confidentialClientApplication;\n-\n-    /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n-     *\n-     * @param clientId\n-     *        the client ID of the application\n-     * @param clientSecret\n-     *        the secret value of the AAD application.\n-     */\n-    KeyVaultCredential(String clientId, String clientSecret) {\n-        Objects.requireNonNull(clientSecret, \"'clientSecret' cannot be null.\");\n-        Objects.requireNonNull(clientSecret, \"'clientId' cannot be null.\");\n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-    }\n-\n-    @Override\n-    public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n-                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n-    }\n-\n-    public KeyVaultCredential setAuthorization(String authorization) {\n-        if (null != this.authorization && this.authorization.equals(authorization)) {\n-            return this;\n-        }\n-        this.authorization = authorization;\n-        confidentialClientApplication = getConfidentialClientApplication();\n-        return this;\n-    }\n-\n-    private ConfidentialClientApplication getConfidentialClientApplication() {\n-        if (null == clientId) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for client ID must be provided for user authentication.\"));\n-        }\n-\n-        if (null == authorization) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\n-                    \"A non-null value for authorization must be provided for user authentication.\"));\n-        }\n-\n-        IClientCredential credential;\n-        if (null != clientSecret) {\n-            credential = ClientCredentialFactory.create(clientSecret);\n-        } else {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"Must provide client secret.\"));\n-        }\n-        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n-                credential);\n-        try {\n-            applicationBuilder = applicationBuilder.authority(authorization);\n-        } catch (MalformedURLException e) {\n-            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n-        }\n-        return applicationBuilder.build();\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n-        return Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n-                    .builder(new HashSet<>(request.getScopes()));\n-            try {\n-                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n-            } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n-            }\n-        }).map(ar -> new AccessToken(ar.accessToken(),\n-                OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n-    }\n-\n-    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n-        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n-        completableFuture.completeExceptionally(e);\n-        return completableFuture;\n-    }\n-\n-    private Mono<AccessToken> authenticateWithConfidentialClient(TokenRequestContext request) {\n-        return Mono\n-                .fromFuture(() -> confidentialClientApplication\n-                        .acquireToken(ClientCredentialParameters.builder(new HashSet<>(request.getScopes())).build()))\n-                .map(ar -> new AccessToken(ar.accessToken(),\n-                        OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC)));\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODQ3Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481518473", "body": "Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .", "bodyText": "Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .", "bodyHTML": "<p dir=\"auto\">Driver should not throw a NullPointerException . Better add a null check to the constructor and throw SQLServerException .</p>", "author": "ulvii", "createdAt": "2020-09-02T01:03:29Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -134,10 +126,10 @@ public void testBadAkv(String serverName, String url, String protocol) throws Ex\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        } catch (NullPointerException exception) {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 73b11a85..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -116,20 +132,38 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n-        } catch (NullPointerException exception) {\n-            assertNull(exception.getMessage());\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n         }\n     }\n \n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 55cad5f1..4829af34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -163,7 +164,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")), e.getMessage());\n         }\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODY2Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481518667", "body": "Need to add license header here.", "bodyText": "Need to add license header here.", "bodyHTML": "<p dir=\"auto\">Need to add license header here.</p>", "author": "ulvii", "createdAt": "2020-09-02T01:04:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.microsoft.sqlserver.jdbc;", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\nindex 91d54f94..b36ccba2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n", "chunk": "@@ -1,3 +1,7 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n package com.microsoft.sqlserver.jdbc;\n \n import com.azure.core.credential.AccessToken;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNzQ1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481527451", "body": "CamelCase here", "bodyText": "CamelCase here", "bodyHTML": "<p dir=\"auto\">CamelCase here</p>", "author": "ulvii", "createdAt": "2020-09-02T01:28:25Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -198,7 +182,7 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 6cfe473f..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -182,7 +198,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,7 +237,7 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n \n         // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyWrapAlgorithm keyWrapAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n         // Validate whether the key is RSA one or not and then get the key size\n         int keySizeInBytes = getAKVKeySize(masterKeyPath);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTYxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481531617", "body": "The methods in this class should probably not be public.", "bodyText": "The methods in this class should probably not be public.", "bodyHTML": "<p dir=\"auto\">The methods in this class should probably not be public.</p>", "author": "ulvii", "createdAt": "2020-09-02T01:34:53Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\n+final class KeyVaultHttpPipelineBuilder {", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NDQ4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r482254481", "bodyText": "I will change the visibility of these methods to package-private.", "author": "srnagar", "createdAt": "2020-09-02T17:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex ca5c3d44..51ff4eeb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -12,46 +12,41 @@ import com.azure.core.http.policy.HttpLoggingPolicy;\n import com.azure.core.http.policy.HttpPipelinePolicy;\n import com.azure.core.http.policy.HttpPolicyProviders;\n import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.http.policy.UserAgentPolicy;\n-import com.azure.core.util.Configuration;\n-import com.azure.core.util.logging.ClientLogger;\n+\n+import java.text.MessageFormat;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Objects;\n-\n \n+/**\n+ * The HTTP pipeline builder which includes all the necessary HTTP pipeline policies that will be applied for\n+ * sending and receiving HTTP requests to the Key Vault service.\n+ */\n final class KeyVaultHttpPipelineBuilder {\n-    public static final String APPLICATION_ID = \"ms-sql-jdbc\";\n-    private static final String SDK_NAME = \"azure-security-keyvault-keys\";\n-    private static final String SDK_VERSION = \"4.2.0\";\n-\n-    private final ClientLogger logger = new ClientLogger(KeyVaultHttpPipelineBuilder.class);\n \n     private final List<HttpPipelinePolicy> policies;\n-    private KeyVaultCredential credential;\n+    private KeyVaultTokenCredential credential;\n     private HttpLogOptions httpLogOptions;\n     private final RetryPolicy retryPolicy;\n \n     /**\n-     * The constructor with defaults.\n+     * The constructor with default retry policy and log options.\n      */\n-    public KeyVaultHttpPipelineBuilder() {\n+    KeyVaultHttpPipelineBuilder() {\n         retryPolicy = new RetryPolicy();\n         httpLogOptions = new HttpLogOptions();\n         policies = new ArrayList<>();\n     }\n \n-    public HttpPipeline buildPipeline() {\n-        Configuration buildConfiguration = Configuration.getGlobalConfiguration().clone();\n-\n-        if (null == credential) {\n-            throw logger.logExceptionAsError(new IllegalStateException(\"Token Credential should be specified.\"));\n-        }\n-\n+    /**\n+     * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n+     *\n+     * @return A fully built HTTP pipeline including the default HTTP client.\n+     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n+     */\n+    HttpPipeline buildPipeline() throws SQLServerException {\n         // Closest to API goes first, closest to wire goes last.\n         final List<HttpPipelinePolicy> policies = new ArrayList<>();\n \n-        policies.add(new UserAgentPolicy(APPLICATION_ID, SDK_NAME, SDK_VERSION, buildConfiguration));\n         HttpPolicyProviders.addBeforeRetryPolicies(policies);\n         policies.add(retryPolicy);\n         policies.add(new KeyVaultCustomCredentialPolicy(credential));\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\nindex 51ff4eeb..b635d846 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java\n", "chunk": "@@ -41,20 +42,21 @@ final class KeyVaultHttpPipelineBuilder {\n      * Builds the HTTP pipeline with all the necessary HTTP policies included in the pipeline.\n      *\n      * @return A fully built HTTP pipeline including the default HTTP client.\n-     * @throws SQLServerException If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n+     * @throws SQLServerException\n+     *         If the {@link KeyVaultCustomCredentialPolicy} policy cannot be added to the pipeline.\n      */\n     HttpPipeline buildPipeline() throws SQLServerException {\n         // Closest to API goes first, closest to wire goes last.\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+        final List<HttpPipelinePolicy> pol = new ArrayList<>();\n \n-        HttpPolicyProviders.addBeforeRetryPolicies(policies);\n-        policies.add(retryPolicy);\n-        policies.add(new KeyVaultCustomCredentialPolicy(credential));\n-        policies.addAll(this.policies);\n-        HttpPolicyProviders.addAfterRetryPolicies(policies);\n-        policies.add(new HttpLoggingPolicy(httpLogOptions));\n+        HttpPolicyProviders.addBeforeRetryPolicies(pol);\n+        pol.add(retryPolicy);\n+        pol.add(new KeyVaultCustomCredentialPolicy(credential));\n+        pol.addAll(this.policies);\n+        HttpPolicyProviders.addAfterRetryPolicies(pol);\n+        pol.add(new HttpLoggingPolicy(httpLogOptions));\n \n-        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();\n+        return new HttpPipelineBuilder().policies(pol.toArray(new HttpPipelinePolicy[0])).build();\n     }\n \n     /**\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjAzNQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r481532035", "body": "The methods in this class should probably not be public.", "bodyText": "The methods in this class should probably not be public.", "bodyHTML": "<p dir=\"auto\">The methods in this class should probably not be public.</p>", "author": "ulvii", "createdAt": "2020-09-02T01:35:34Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*", "originalCommit": "5bc675535eb3db983b094164a2b898855e6b57a7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "url": "https://github.com/microsoft/mssql-jdbc/commit/3303022e8803a05cf9f03c4eaac74b5cfcb9dac5", "message": "Update src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java\n\nCo-authored-by: David Engel <dengel1012@gmail.com>", "committedDate": "2020-09-02T05:25:49Z", "type": "commit"}, {"oid": "d9bad87bda75441fad79010fb31e90c7de8b6a5d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d9bad87bda75441fad79010fb31e90c7de8b6a5d", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-02T05:47:37Z", "type": "commit"}, {"oid": "d24dbff950d63d622a54555fca81d7a0e50451ea", "url": "https://github.com/microsoft/mssql-jdbc/commit/d24dbff950d63d622a54555fca81d7a0e50451ea", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-02T05:48:23Z", "type": "commit"}, {"oid": "59aebe6a2f663c70638530cba96e898ee0b3d03f", "url": "https://github.com/microsoft/mssql-jdbc/commit/59aebe6a2f663c70638530cba96e898ee0b3d03f", "message": "exception handling and removed unnecessary public apis", "committedDate": "2020-09-02T18:30:20Z", "type": "commit"}, {"oid": "6b2f1a2c2490d7cfb090ed889e0d9bf2f1329508", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b2f1a2c2490d7cfb090ed889e0d9bf2f1329508", "message": "added header", "committedDate": "2020-09-02T18:38:56Z", "type": "commit"}, {"oid": "2e6180f8ae90791f662a2da9d6f0f2a5112c5ec3", "url": "https://github.com/microsoft/mssql-jdbc/commit/2e6180f8ae90791f662a2da9d6f0f2a5112c5ec3", "message": "merged", "committedDate": "2020-09-02T18:42:01Z", "type": "commit"}, {"oid": "c7cd5984f0e7d02a52d2bcaba154ddf32acaabe7", "url": "https://github.com/microsoft/mssql-jdbc/commit/c7cd5984f0e7d02a52d2bcaba154ddf32acaabe7", "message": "Merge pull request #2 from lilgreenbird/msal\n\nUpdates", "committedDate": "2020-09-02T18:47:26Z", "type": "commit"}, {"oid": "4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "url": "https://github.com/microsoft/mssql-jdbc/commit/4ef6a37eb23996361d8d0c0200ce1bbed71052c7", "message": "more updates", "committedDate": "2020-09-02T22:27:44Z", "type": "commit"}, {"oid": "a0644beb6235fa466ac8998d8dd21284b92e239e", "url": "https://github.com/microsoft/mssql-jdbc/commit/a0644beb6235fa466ac8998d8dd21284b92e239e", "message": "update", "committedDate": "2020-09-02T22:36:37Z", "type": "commit"}, {"oid": "042ade5a8b3c75658b4d72fa04566f682781601a", "url": "https://github.com/microsoft/mssql-jdbc/commit/042ade5a8b3c75658b4d72fa04566f682781601a", "message": "Merge pull request #3 from lilgreenbird/msal\n\nmore updates", "committedDate": "2020-09-02T22:47:54Z", "type": "commit"}, {"oid": "abdf38daab8061c05458362a62496e79fb5e3dae", "url": "https://github.com/microsoft/mssql-jdbc/commit/abdf38daab8061c05458362a62496e79fb5e3dae", "message": "merged", "committedDate": "2020-09-04T06:16:43Z", "type": "commit"}, {"oid": "573dfb93fcd1c7e12c19c760d7160377f5dc04a3", "url": "https://github.com/microsoft/mssql-jdbc/commit/573dfb93fcd1c7e12c19c760d7160377f5dc04a3", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-04T06:16:57Z", "type": "commit"}, {"oid": "48fbe2c381292e7358d074e6efb098de837d26f8", "url": "https://github.com/microsoft/mssql-jdbc/commit/48fbe2c381292e7358d074e6efb098de837d26f8", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-05T02:08:55Z", "type": "commit"}, {"oid": "a2e50b9b66d9207415d6853fa449fc55e968a44a", "url": "https://github.com/microsoft/mssql-jdbc/commit/a2e50b9b66d9207415d6853fa449fc55e968a44a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-09T19:00:26Z", "type": "commit"}, {"oid": "7ff97dee94ec4144ef22e5d12ba76f1a84ebe3c9", "url": "https://github.com/microsoft/mssql-jdbc/commit/7ff97dee94ec4144ef22e5d12ba76f1a84ebe3c9", "message": "enable ADintegrated tests for non-windows", "committedDate": "2020-09-09T23:20:13Z", "type": "commit"}, {"oid": "887d9b14be71883977d8d2dc0bde233b59ec7759", "url": "https://github.com/microsoft/mssql-jdbc/commit/887d9b14be71883977d8d2dc0bde233b59ec7759", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-10T00:32:20Z", "type": "commit"}, {"oid": "4a8b4f389937aed352098be48709a04ed50a9519", "url": "https://github.com/microsoft/mssql-jdbc/commit/4a8b4f389937aed352098be48709a04ed50a9519", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-10T23:32:02Z", "type": "commit"}, {"oid": "7cae3b431dc533e07042f1bbc810995f78b64510", "url": "https://github.com/microsoft/mssql-jdbc/commit/7cae3b431dc533e07042f1bbc810995f78b64510", "message": "fixed user test for kerberos", "committedDate": "2020-09-11T05:34:42Z", "type": "commit"}, {"oid": "c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "url": "https://github.com/microsoft/mssql-jdbc/commit/c180e5fca8f03b6c76bc0f1f9575a4a40506989d", "message": "Update to latest version of KV and Identity", "committedDate": "2020-09-16T20:05:04Z", "type": "commit"}, {"oid": "d0186a9dec2411976db528bb90ece338a5f61a9a", "url": "https://github.com/microsoft/mssql-jdbc/commit/d0186a9dec2411976db528bb90ece338a5f61a9a", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-16T22:11:51Z", "type": "commit"}, {"oid": "4c9b6277174d8bb12de84b310a4296a6577075c1", "url": "https://github.com/microsoft/mssql-jdbc/commit/4c9b6277174d8bb12de84b310a4296a6577075c1", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-16T22:18:03Z", "type": "commit"}, {"oid": "e863c056cb2d36309c757e25bcf1bdc708bb9b26", "url": "https://github.com/microsoft/mssql-jdbc/commit/e863c056cb2d36309c757e25bcf1bdc708bb9b26", "message": "user name check", "committedDate": "2020-09-16T22:33:25Z", "type": "commit"}, {"oid": "43060f9fb25d71ab6724d2aa12712745d899c562", "url": "https://github.com/microsoft/mssql-jdbc/commit/43060f9fb25d71ab6724d2aa12712745d899c562", "message": "Bring back deprecated constructors", "committedDate": "2020-09-16T22:33:29Z", "type": "commit"}, {"oid": "c8c5a2977c700d62815ab8073ea11a8d40885deb", "url": "https://github.com/microsoft/mssql-jdbc/commit/c8c5a2977c700d62815ab8073ea11a8d40885deb", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-16T22:34:15Z", "type": "commit"}, {"oid": "1550a9771ba87a07d1e767e63e3afe9133be6759", "url": "https://github.com/microsoft/mssql-jdbc/commit/1550a9771ba87a07d1e767e63e3afe9133be6759", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-16T22:35:05Z", "type": "commit"}, {"oid": "f4825dbdfdfb4ea3d1a64df845527e6532076196", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4825dbdfdfb4ea3d1a64df845527e6532076196", "message": "Resolve merge conflicts", "committedDate": "2020-09-16T22:39:20Z", "type": "commit"}, {"oid": "b85e3c20207d7119b4e8e1e671de905c3e3589db", "url": "https://github.com/microsoft/mssql-jdbc/commit/b85e3c20207d7119b4e8e1e671de905c3e3589db", "message": "merged", "committedDate": "2020-09-17T21:37:24Z", "type": "commit"}, {"oid": "7d4274f06582ee91a43eff1e6b276a93f785f688", "url": "https://github.com/microsoft/mssql-jdbc/commit/7d4274f06582ee91a43eff1e6b276a93f785f688", "message": "Add auth callback tests", "committedDate": "2020-09-18T20:49:14Z", "type": "commit"}, {"oid": "2a92d4dc6b373d166fe85200586b33730a5e71ab", "url": "https://github.com/microsoft/mssql-jdbc/commit/2a92d4dc6b373d166fe85200586b33730a5e71ab", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-09-19T00:48:44Z", "type": "commit"}, {"oid": "61b787f737ddf8c9d1fd0342be7c1d8826c42fe0", "url": "https://github.com/microsoft/mssql-jdbc/commit/61b787f737ddf8c9d1fd0342be7c1d8826c42fe0", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-09-22T04:13:14Z", "type": "commit"}, {"oid": "360a8d4bb6f6e680e3ee0043f32d738b806cf22e", "url": "https://github.com/microsoft/mssql-jdbc/commit/360a8d4bb6f6e680e3ee0043f32d738b806cf22e", "message": "lib conflict", "committedDate": "2020-09-22T05:04:17Z", "type": "commit"}, {"oid": "d76368aedf39c5dbc573f7449e91524b1227daf7", "url": "https://github.com/microsoft/mssql-jdbc/commit/d76368aedf39c5dbc573f7449e91524b1227daf7", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-09-22T05:08:08Z", "type": "commit"}, {"oid": "e5aafd300061bee1968463cf7ad1d07d6da8356d", "url": "https://github.com/microsoft/mssql-jdbc/commit/e5aafd300061bee1968463cf7ad1d07d6da8356d", "message": "Merge branch 'dev' of https://github.com/lilgreenbird/mssql-jdbc into dev", "committedDate": "2020-09-22T05:08:27Z", "type": "commit"}, {"oid": "1108103183860d69b772d9902c434d59c5f239af", "url": "https://github.com/microsoft/mssql-jdbc/commit/1108103183860d69b772d9902c434d59c5f239af", "message": "merged", "committedDate": "2020-09-22T05:15:41Z", "type": "commit"}, {"oid": "950677fd4de54a43fd5b085da4b71e371058dbf5", "url": "https://github.com/microsoft/mssql-jdbc/commit/950677fd4de54a43fd5b085da4b71e371058dbf5", "message": "merged", "committedDate": "2020-09-22T05:19:56Z", "type": "commit"}, {"oid": "12f2da986ea6412b19d6d6e14eb27de7af224966", "url": "https://github.com/microsoft/mssql-jdbc/commit/12f2da986ea6412b19d6d6e14eb27de7af224966", "message": "back to prev lib version", "committedDate": "2020-09-22T06:49:51Z", "type": "commit"}, {"oid": "2b3ccd6930333ac63f25320c5a3a0ea0c243b07d", "url": "https://github.com/microsoft/mssql-jdbc/commit/2b3ccd6930333ac63f25320c5a3a0ea0c243b07d", "message": "fix", "committedDate": "2020-09-23T05:33:46Z", "type": "commit"}, {"oid": "497f1bead6faa74a53460e4182727ab22a772489", "url": "https://github.com/microsoft/mssql-jdbc/commit/497f1bead6faa74a53460e4182727ab22a772489", "message": "merged", "committedDate": "2020-09-23T05:36:57Z", "type": "commit"}, {"oid": "972f95c65fcfd3bc9a99064ccb22ce2f7e2147e9", "url": "https://github.com/microsoft/mssql-jdbc/commit/972f95c65fcfd3bc9a99064ccb22ce2f7e2147e9", "message": "Merge branch 'msal' of https://github.com/lilgreenbird/mssql-jdbc into msal", "committedDate": "2020-09-23T05:37:44Z", "type": "commit"}, {"oid": "216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "url": "https://github.com/microsoft/mssql-jdbc/commit/216d77aa795dfd7b1ea89d9626ad0c94341c5f91", "message": "fixed", "committedDate": "2020-09-23T05:51:29Z", "type": "commit"}, {"oid": "791e2b6b473f6cac5a9ecde7359527c78921d3f0", "url": "https://github.com/microsoft/mssql-jdbc/commit/791e2b6b473f6cac5a9ecde7359527c78921d3f0", "message": "update", "committedDate": "2020-09-23T06:02:38Z", "type": "commit"}, {"oid": "a7119131d567639e5a97a35f20ffe8759745d89d", "url": "https://github.com/microsoft/mssql-jdbc/commit/a7119131d567639e5a97a35f20ffe8759745d89d", "message": "merged", "committedDate": "2020-09-23T06:04:34Z", "type": "commit"}, {"oid": "122e408633ef0aca67e2a1358ce19c4caead5904", "url": "https://github.com/microsoft/mssql-jdbc/commit/122e408633ef0aca67e2a1358ce19c4caead5904", "message": "Merge pull request #4 from lilgreenbird/msal\n\nMsal", "committedDate": "2020-09-23T06:10:11Z", "type": "commit"}, {"oid": "b4799ca4f4028d82b0791e9f89e81103e9191c7d", "url": "https://github.com/microsoft/mssql-jdbc/commit/b4799ca4f4028d82b0791e9f89e81103e9191c7d", "message": "Remove hardcoded version and package name", "committedDate": "2020-09-24T19:27:53Z", "type": "commit"}, {"oid": "c722d34e80fc7d8c9954ebb9a859bb2e90e11107", "url": "https://github.com/microsoft/mssql-jdbc/commit/c722d34e80fc7d8c9954ebb9a859bb2e90e11107", "message": "clean and exclude lib", "committedDate": "2020-09-25T18:03:41Z", "type": "commit"}, {"oid": "9c28d9844c1e30f210f1b685859396653a5d7363", "url": "https://github.com/microsoft/mssql-jdbc/commit/9c28d9844c1e30f210f1b685859396653a5d7363", "message": "Add code comments and javadoc", "committedDate": "2020-09-29T08:05:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499748260", "body": "Can the url be HTTP? Also please add a `.` to the end of the error message.", "bodyText": "Can the url be HTTP? Also please add a . to the end of the error message.", "bodyHTML": "<p dir=\"auto\">Can the url be HTTP? Also please add a <code>.</code> to the end of the error message.</p>", "author": "ulvii", "createdAt": "2020-10-05T17:09:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "diffHunk": "@@ -648,5 +648,6 @@ static String getResource(String key) {\n             {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},};\n+                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NDkyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499754924", "bodyText": "I figured HTTP is not supported, so the question can be ignored.", "author": "ulvii", "createdAt": "2020-10-05T17:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MDkzMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r501860931", "bodyText": "@lilgreenbird  please add . to the end of the error message.", "author": "ulvii", "createdAt": "2020-10-08T16:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b83772f3..754f1391 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -581,73 +532,11 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n             {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n             {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n             {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n             {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n             {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_ADALMissing\", \"Failed to load ADAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandADALMissing\",\n-                    \"Failed to load both {0} and ADAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n-            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n-            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme\"},};\n-};\n+            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n+}\n", "next_change": {"commit": "cc192d36986c1c13fda64f1fa9f2e141e822d26d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..6f87b8bf 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -538,5 +538,6 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n             {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+    };\n }\n", "next_change": {"commit": "dfb4cadc777b3cd9e9217a5c08721b455dba4442", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 6f87b8bf..754f1391 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -538,6 +538,5 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n             {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-    };\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n }\n", "next_change": {"commit": "252cbfc41198e3412558f359cef8b220f5bad546", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 754f1391..df8bcc73 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -538,5 +538,7 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n             {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},};\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+    };\n }\n", "next_change": {"commit": "4877145e9dbc6a1178aa688afe5a14876db5a65f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex df8bcc73..cb70c10d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -540,5 +540,6 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n             {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n             {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n     };\n }\n", "next_change": {"commit": "503076fe213e018506f690177c32011f8ec22b62", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex cb70c10d..8acb6917 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -541,5 +541,6 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n             {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n             {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n", "next_change": {"commit": "0170f891a15e70c7bf10af283f35a4a55e42a874", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 8acb6917..453cc896 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -540,6 +540,7 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n             {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n             {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n             {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n             {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 453cc896..391a1377 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -532,16 +581,73 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n             {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n             {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n             {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n             {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n             {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n-    };\n-}\n+            {\"R_keyVaultProviderClientIdPropertyDescription\",\n+                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n+                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+            {\"R_MSALLMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+            {\"R_DLLandMSALLMissing\",\n+                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+            {\"R_MSITokenFailureImdsClientId\",\n+                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+            {\"R_MSITokenFailureUnexpected\",\n+                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+            {\"R_propertyNotSupported\",\n+                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+            {\"R_useFmtOnlyPropertyDescription\",\n+                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+            {\"R_invalidOpenqueryCall\",\n+                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+            {\"R_invalidCTEFormat\",\n+                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+            {\"R_invalidInsertValuesQuery\",\n+                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+            {\"R_enclaveNotSupported\", \"The SQL Server instance does not support enclave based computations.\"},\n+            {\"R_enclavePropertiesError\",\n+                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves.\"},\n+            {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid.\"},\n+            {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver.\"},\n+            {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0}.\"},\n+            {\"R_EnclaveResponseLengthError\",\n+                    \"More bytes from the server were received than expected when parsing the enclave attestation response.\"},\n+            {\"R_EnclavePackageLengthError\",\n+                    \"More bytes from the server were received than expected when parsing the enclave package.\"},\n+            {\"R_EnclavePKLengthError\",\n+                    \"More bytes from the server were received than expected when parsing the enclave public key.\"},\n+            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+            {\"R_HealthCertError\",\n+                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0}.\"},\n+            {\"R_InvalidHealthCert\",\n+                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS.\"},\n+            {\"R_InvalidSignedStatement\",\n+                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate.\"},\n+            {\"R_InvalidDHKeySignature\",\n+                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key.\"},\n+            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+            {\"R_InvalidCSVQuotes\",\n+                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n+};\n", "next_change": {"commit": "d9909748368af7d2944dab4fa382ee513f2b76f4", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 391a1377..1be1847f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -649,5 +652,10 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n             {\"R_InvalidCSVQuotes\",\n                     \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},};\n-};\n+            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+            {\"R_maxResultBufferPropertyDescription\",\n+                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+}\n", "next_change": {"commit": "90b9b249cc866d6134e4ba94039e36e80cacfff8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 1be1847f..4a29d517 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -657,5 +665,6 @@ public final class SQLServerResource extends ListResourceBundle {\n                     \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n             {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n             {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+            {\"R_maxResultBufferPropertyExceeded\",\n+                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n }\n", "next_change": {"commit": "ac78f50479ab2f33a4f3107d2f1608bf9eaf8fed", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4a29d517..96eeaf10 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -666,5 +677,15 @@ public final class SQLServerResource extends ListResourceBundle {\n             {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n             {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n             {\"R_maxResultBufferPropertyExceeded\",\n-                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},};\n+                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+//Todo new conn res from ulvii\n+            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+    };\n }\n", "next_change": {"commit": "9f04aa52fb3b692c76769bb953fd098a2b7a6ddc", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 96eeaf10..278197bc 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -21,671 +21,474 @@ public final class SQLServerResource extends ListResourceBundle {\n         return CONTENTS;\n     }\n \n-    // The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n-    // camelCasing convention and be descriptive\n-    static final Object[][] CONTENTS = {\n-            // LOCALIZE THIS\n-            {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n-            {\"R_invalidRoutingInfo\",\n-                    \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_multipleRedirections\",\n-                    \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n-            {\"R_dbMirroringWithMultiSubnetFailover\",\n-                    \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n-            {\"R_dbMirroringWithReadOnlyIntent\",\n-                    \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n-            {\"R_ipAddressLimitWithMultiSubnetFailover\",\n-                    \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n-            {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n-            {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n-            {\"R_invalidLength\", \"The length {0} is not valid.\"},\n-            {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n-            {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n-            {\"R_notSQLServer\",\n-                    \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting \"\n-                            + \"TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n-            {\"R_tcpOpenFailed\",\n-                    \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP \"\n-                            + \"connections to the port are not blocked by a firewall.\"},\n-            {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n-            {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n-            {\"R_truncatedServerResponse\",\n-                    \"SQL Server returned an incomplete response. The connection has been closed.\"},\n-            {\"R_queryTimedOut\", \"The query has timed out.\"}, {\"R_queryCancelled\", \"The query was canceled.\"},\n-            {\"R_errorReadingStream\",\n-                    \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n-            {\"R_streamReadReturnedInvalidValue\",\n-                    \"The stream read operation returned an invalid value for the amount of data read.\"},\n-            {\"R_mismatchedStreamLength\",\n-                    \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n-            {\"R_notSupported\", \"This operation is not supported.\"},\n-            {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n-            {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n-            {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n-            {\"R_connectionIsClosed\", \"The connection is closed.\"},\n-            {\"R_invalidBooleanValue\",\n-                    \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n-            {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n-            {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n-            {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n-            {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n-            {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n-            {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n-            {\"R_packetSizeTooBigForSSL\",\n-                    \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n-            {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n-            {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n-            {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n-            {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n-            {\"R_sqlServerHoldability\",\n-                    \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n-            {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n-            {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n-            {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n-            {\"R_sqlBrowserFailed\",\n-                    \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. \"\n-                            + \" For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n-            {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n-            {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n-            {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n-            {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n-            {\"R_noMetadata\", \"There is no metadata.\"}, {\"R_resultsetClosed\", \"The result set is closed.\"},\n-            {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n-            {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n-            {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n-            {\"R_savepointNotNamed\", \"The savepoint is not named.\"}, {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n-            {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n-            {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n-            {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n-            {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n-            {\"R_noResultset\", \"The statement did not return a result set.\"},\n-            {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n-            {\"R_statementIsClosed\", \"The statement is closed.\"},\n-            {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n-            {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n-            {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n-            {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n-            {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n-            {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n-            {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n-            {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n-            {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n-            {\"R_invalidOffset\", \"The offset {0} is not valid.\"}, {\"R_nullConnection\", \"The connection URL is null.\"},\n-            {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n-            {\"R_cannotTakeArgumentsPreparedOrCallable\",\n-                    \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n-            // Invalid conversion (e.g. MONEY to Timestamp)\n-            {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n-            // Invalid conversion to an unknown type\n-            {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n-            // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n-            {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n-            {\"R_streamIsClosed\", \"The stream is closed.\"}, {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n-            {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n-            {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n-            {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n-            {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n-            {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n-            {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n-            {\"R_encodingErrorWritingTDS\",\n-                    \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n-            {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n-            {\"R_requestedOpNotSupportedOnForward\",\n-                    \"The requested operation is not supported on forward only result sets.\"},\n-            {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n-            {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n-            {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n-            {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n-            {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n-            {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n-            {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n-            {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n-            {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n-            {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n-            {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n-            {\"R_cantGetUpdatedColumnValue\",\n-                    \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n-            {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n-            {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n-            {\"R_invalidAutoGeneratedKeys\",\n-                    \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n-            {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n-            {\"R_failoverPartnerWithoutDB\",\n-                    \"databaseName is required when using the failoverPartner connection property.\"},\n-            {\"R_invalidPartnerConfiguration\",\n-                    \"The database {0} on server {1} is not configured for database mirroring.\"},\n-            {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n-            {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n-            {\"R_invalidpropertyValue\",\n-                    \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n-            {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n-            {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n-            {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n-            {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n-            {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n-            {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n-            {\"R_sslRequiredNoServerSupport\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. \"\n-                            + \"The application requested encryption but the server is not configured to support SSL.\"},\n-            {\"R_sslRequiredByServer\",\n-                    \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n-            {\"R_sslFailed\",\n-                    \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n-            {\"R_certNameFailed\",\n-                    \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n-            {\"R_failedToInitializeXA\",\n-                    \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n-            {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n-            {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n-            {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n-            {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n-            {\"R_userPropertyDescription\", \"The database user.\"},\n-            {\"R_passwordPropertyDescription\", \"The database password.\"},\n-            {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n-            {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n-            {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n-            {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n-            {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n-            {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n-            {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n-            {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n-            {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n-            {\"R_serverNameAsACEPropertyDescription\",\n-                    \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n-            {\"R_sendStringParametersAsUnicodePropertyDescription\",\n-                    \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n-            {\"R_multiSubnetFailoverPropertyDescription\",\n-                    \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n-            {\"R_applicationNamePropertyDescription\",\n-                    \"The application name for SQL Server profiling and logging tools.\"},\n-            {\"R_lastUpdateCountPropertyDescription\",\n-                    \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n-            {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n-            {\"R_integratedSecurityPropertyDescription\",\n-                    \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n-            {\"R_authenticationSchemePropertyDescription\",\n-                    \"The authentication scheme to be used for integrated authentication.\"},\n-            {\"R_lockTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n-            {\"R_connectRetryCountPropertyDescription\",\n-                    \"The number of reconnection attempts if there is a connection failure.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\",\n-                    \"The number of seconds between each connection retry attempt.\"},\n-            {\"R_loginTimeoutPropertyDescription\",\n-                    \"The number of seconds the driver should wait before timing out a failed connection.\"},\n-            {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n-            {\"R_xopenStatesPropertyDescription\",\n-                    \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n-            {\"R_selectMethodPropertyDescription\",\n-                    \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n-            {\"R_responseBufferingPropertyDescription\",\n-                    \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n-            {\"R_applicationIntentPropertyDescription\",\n-                    \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n-            {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n-            {\"R_failoverPartnerPropertyDescription\",\n-                    \"The name of the failover server used in a database mirroring configuration.\"},\n-            {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n-            {\"R_encryptPropertyDescription\",\n-                    \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n-            {\"R_socketFactoryClassPropertyDescription\",\n-                    \"The class to instantiate as the SocketFactory for connections\"},\n-            {\"R_socketFactoryConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n-            {\"R_trustServerCertificatePropertyDescription\",\n-                    \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n-            {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n-            {\"R_trustStorePasswordPropertyDescription\",\n-                    \"The password used to check the integrity of the trust store data.\"},\n-            {\"R_trustManagerClassPropertyDescription\",\n-                    \"The class to instantiate as the TrustManager for SSL connections.\"},\n-            {\"R_trustManagerConstructorArgPropertyDescription\",\n-                    \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n-            {\"R_hostNameInCertificatePropertyDescription\",\n-                    \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n-            {\"R_replicationPropertyDescription\",\n-                    \"This setting tells the server if the connection is used for replication.\"},\n-            {\"R_sendTimeAsDatetimePropertyDescription\",\n-                    \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n-            {\"R_TransparentNetworkIPResolutionPropertyDescription\",\n-                    \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n-            {\"R_queryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait before the database reports a query time-out.\"},\n-            {\"R_socketTimeoutPropertyDescription\",\n-                    \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n-            {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\",\n-                    \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). \"\n-                            + \"A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n-            {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\",\n-                    \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n-            {\"R_statementPoolingCacheSizePropertyDescription\",\n-                    \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n-            {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n-            {\"R_msiClientIdPropertyDescription\",\n-                    \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n-            {\"R_clientCertificatePropertyDescription\",\n-                    \"Client certificate path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n-            {\"R_clientKeyPasswordPropertyDescription\",\n-                    \"Password for private key if the private key is password protected.\"},\n-            {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\",\n-                    \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n-            {\"R_delayLoadingLobsPropertyDescription\",\n-                    \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n-            {\"R_AADSecurePrincipalIdPropertyDescription\",\n-                    \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n-            {\"R_AADSecurePrincipalSecretPropertyDescription\",\n-                    \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n-            {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n-            {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n-            {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n-            {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n-            {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n-            {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n-            {\"R_cantSetNull\", \"Cannot set a null value.\"},\n-            {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n-            {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n-            {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n-            {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n-            {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n-            {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n-            {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n-            {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n-            {\"R_getSchemaError\", \"Error getting default schema name.\"},\n-            {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n-            {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n-            {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n-            {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n-            {\"R_featureNotSupported\", \"{0} is not supported.\"},\n-            {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n-            {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n-            {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n-            {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n-            {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n-            {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n-            {\"R_invalidDestConnection\",\n-                    \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n-            {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n-            {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n-            {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n-            {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n-            {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n-            {\"R_invalidTransactionOption\",\n-                    \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n-            {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n-            {\"R_BulkColumnMappingsIsEmpty\",\n-                    \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n-            {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n-            {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n-            {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n-            {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n-            {\"R_UnexpectedDescribeParamFormat\",\n-                    \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n-            {\"R_InvalidEncryptionKeyOrdinal\",\n-                    \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n-            {\"R_MissingParamEncryptionMetadata\",\n-                    \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n-            {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n-            {\"R_InvalidCipherTextSize\",\n-                    \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n-            {\"R_InvalidAlgorithmVersion\",\n-                    \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n-            {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n-            {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n-            {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n-            {\"R_InvalidKeySize\",\n-                    \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". \"\n-                            + \"Verify the encrypted value of the column encryption key in the database.\"},\n-            {\"R_InvalidEncryptionType\",\n-                    \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n-            {\"R_UnknownColumnEncryptionAlgorithm\",\n-                    \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n-            {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n-            {\"R_UntrustedKeyPath\",\n-                    \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path \"\n-                            + \"using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n-            {\"R_UnrecognizedKeyStoreProviderName\",\n-                    \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider \"\n-                            + \"or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: \"\n-                            + \"{2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers \"\n-                            + \"used in your application are registered properly.\"},\n-            {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n-            {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n-            {\"R_UnsupportedNormalizationVersionAE\",\n-                    \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n-            {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n-            {\"R_NullColumnEncryptionAlgorithmAE\",\n-                    \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n-            {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n-            {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n-            {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n-            {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n-            {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n-                                                                                                           // Server\n-            {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n-            {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n-            {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n-            {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n-            {\"R_InvalidCertificateSignature\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n-            {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n-            {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithm\",\n-                    \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_InvalidKeyEncryptionAlgorithmInternal\",\n-                    \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n-            {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n-            {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n-            {\"R_CertificateNotFoundForAlias\",\n-                    \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. \"\n-                    + \" Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n-            {\"R_KeyStoreNotFound\",\n-                    \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n-            {\"R_CustomKeyStoreProviderMapNull\",\n-                    \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n-            {\"R_EmptyCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n-            {\"R_InvalidCustomKeyStoreProviderName\",\n-                    \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n-            {\"R_CustomKeyStoreProviderValueNull\",\n-                    \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n-            {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n-            {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n-            {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n-            {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n-            {\"R_InvalidDataForAE\",\n-                    \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n-            {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n-            {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n-            {\"R_FedAuthRequiredPreLoginResponseInvalidValue\",\n-                    \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n-            {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\",\n-                    \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n-            {\"R_FedAuthInfoInvalidOffset\",\n-                    \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n-            {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n-            {\"R_FedAuthInfoLengthTooShortForData\",\n-                    \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n-            {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\",\n-                    \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n-            {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n-            {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n-            {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n-            {\"R_FedAuthFeatureAckContainsExtraData\",\n-                    \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n-            {\"R_FedAuthFeatureAckUnknownLibraryType\",\n-                    \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n-            {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n-            {\"R_SetAuthenticationWhenIntegratedSecurityTrue\",\n-                    \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n-            {\"R_NtlmNoUserPasswordDomain\",\n-                    \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n-            {\"R_SetAccesstokenWhenIntegratedSecurityTrue\",\n-                    \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n-            {\"R_IntegratedAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_MSIAuthenticationWithUserPassword\",\n-                    \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n-            {\"R_AccessTokenWithUserPassword\",\n-                    \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n-            {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n-            {\"R_SetBothAuthenticationAndAccessToken\",\n-                    \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n-            {\"R_NoUserPasswordForActivePassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n-            {\"R_NoUserPasswordForActiveServicePrincipal\",\n-                    \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n-            {\"R_NoUserPasswordForSqlPassword\",\n-                    \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalse\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\",\n-                    \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_ForceEncryptionTrue_HonorAEFalseRS\",\n-                    \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n-            {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\",\n-                    \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. \"\n-                            + \"This may be due to a configuration error.\"},\n-            {\"R_NullValue\", \"{0} cannot be null.\"}, {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n-            {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n-            {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n-            {\"R_ManagedIdentityInitFail\",\n-                    \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n-            {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n-            {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n-            {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n-            {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n-            {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n-            {\"R_InvalidEcryptionAlgorithmVersion\",\n-                    \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n-            {\"R_AKVKeyLengthError\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_AKVSignatureLengthError\",\n-                    \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n-            {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n-            {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n-            {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n-            {\"R_CEKSignatureNotMatchCMK\",\n-                    \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n-            {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n-            {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n-            {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n-            {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n-            {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n-            {\"R_UnableLoadADALSqlDll\",\n-                    \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n-            {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n-            {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n-            {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n-            {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n-            {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n-            {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n-            {\"R_TVPMixedSource\",\n-                    \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n-            {\"R_TVPEmptyMetadata\",\n-                    \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n-            {\"R_TVPInvalidValue\",\n-                    \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n-            {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n-            {\"R_TVPSortOrdinalGreaterThanFieldCount\",\n-                    \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n-            {\"R_TVPMissingSortOrderOrOrdinal\",\n-                    \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n-            {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n-            {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n-            {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n-            // This is used for connection settings. {0}-> property name as is, {1}-> value\n-            {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n-            {\"R_InvalidWindowsCertificateStoreEncryption\",\n-                    \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n-            {\"R_AEKeypathEmpty\",\n-                    \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n-            {\"R_AECertpathBad\",\n-                    \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertLocBad\",\n-                    \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", \"\n-                            + \"where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n-            {\"R_AECertStoreBad\",\n-                    \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n-            {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n-            {\"R_AECertNotFound\",\n-                    \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition \"\n-                            + \"in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n-            {\"R_AEMaloc\", \"Memory allocation failure.\"},\n-            {\"R_AEKeypathLong\",\n-                    \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n-            {\"R_AEECEKLenBad\",\n-                    \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEECEKSigLenBad\",\n-                    \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". \"\n-                            + \"The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n-            {\"R_AEKeyPathEmptyOrReserved\",\n-                    \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n-            {\"R_AEKeyPathCurUser\",\n-                    \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n-            {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n-            {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n-            {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n-            {\"R_keyStoreSecretPropertyDescription\",\n-                    \"The authentication secret or information needed to locate the secret.\"},\n-            {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n-            {\"R_keyStoreAuthenticationNotSet\",\n-                    \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n-            {\"R_keyStoreSecretOrLocationNotSet\",\n-                    \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n-            {\"R_keyStoreSecretNotSet\",\n-                    \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n-            {\"R_keyVaultProviderClientKeyNotSet\",\n-                    \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n-            {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\",\n-                    \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n-            {\"R_certificateStoreInvalidKeyword\",\n-                    \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStoreLocationNotSet\",\n-                    \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n-            {\"R_certificateStorePlatformInvalid\",\n-                    \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n-            {\"R_invalidKeyStoreFile\",\n-                    \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n-                                                                                                                  // JKS/PKCS\n-            {\"R_invalidCEKCacheTtl\",\n-                    \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n-            {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n-            {\"R_TVPnotWorkWithSetObjectResultSet\",\n-                    \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n-            {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n-            {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n-            {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n-            {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n-            {\"R_serverPreparedStatementDiscardThreshold\",\n-                    \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n-            {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n-            {\"R_kerberosLoginFailedForUsername\",\n-                    \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n-            {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n-            {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n-            {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n-            {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n-            {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n-            {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n-            {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n-            {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n-            {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n-            {\"R_sslProtocolPropertyDescription\",\n-                    \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n-            {\"R_invalidSSLProtocol\",\n-                    \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n-            {\"R_cancelQueryTimeoutPropertyDescription\",\n-                    \"The number of seconds to wait to cancel sending a query timeout.\"},\n-            {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n-            {\"R_useBulkCopyForBatchInsertPropertyDescription\",\n-                    \"Whether the driver will use bulk copy API for batch insert operations\"},\n-            {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n-            {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n-            {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n-            {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n-            {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n-            {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n-            {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n-            {\"R_keyVaultProviderClientIdPropertyDescription\",\n-                    \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyVaultProviderClientKeyPropertyDescription\",\n-                    \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n-            {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n-            {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n-            {\"R_DLLandMSALMissing\",\n-                    \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n-            {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n-            {\"R_MSITokenFailureImdsClientId\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n-            {\"R_MSITokenFailureUnexpected\",\n-                    \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n-            {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n-            {\"R_propertyNotSupported\",\n-                    \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n-            {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n-            {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n-            {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n-            {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n-            {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n-            {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n-            {\"R_useFmtOnlyPropertyDescription\",\n-                    \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n-            {\"R_invalidOpenqueryCall\",\n-                    \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n-            {\"R_invalidCTEFormat\",\n-                    \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n-            {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n-            {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n-            {\"R_invalidInsertValuesQuery\",\n-                    \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n-            {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n-            {\"R_enclaveNotSupported\",\n-                    \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_enclavePropertiesError\",\n-                    \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_enclaveInvalidAttestationProtocol\",\n-                    \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_enclaveTypeInvalid\",\n-                    \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_attestationUrlInvalid\",\n-                    \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_EnclaveResponseLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_EnclavePackageLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_EnclavePKLengthError\",\n-                    \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n-            {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n-            {\"R_HealthCertError\",\n-                    \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_InvalidHealthCert\",\n-                    \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_InvalidSignedStatement\",\n-                    \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_InvalidDHKeySignature\",\n-                    \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n-            {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n-            {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n-            {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n-            {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n-            {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n-            {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n-            {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n-            {\"R_InvalidCSVQuotes\",\n-                    \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n-            {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n-            {\"R_maxResultBufferPropertyDescription\",\n-                    \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n-            {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n-            {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n-            {\"R_maxResultBufferPropertyExceeded\",\n-                    \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-//Todo new conn res from ulvii\n-            {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-            {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-            {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-            {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-            {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-            {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-            {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-            {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+    /*\n+     * The keys must be prefixed with R_ to denote they are resource strings and their names should follow the\n+     * camelCasing convention and be descriptive.\n+     */\n+    // @formatter:off\n+    // Disable formatting for localization parser: use 1 line per error message and do not use \"+\"\n+    // @formatter:off\n+    static final Object[][] CONTENTS =\n+    {\n+        // LOCALIZE THIS\n+        {\"R_timedOutBeforeRouting\", \"The timeout expired before connecting to the routing destination.\"},\n+        {\"R_invalidRoutingInfo\", \"Unexpected routing information received. Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_multipleRedirections\", \"Two or more redirections have occurred. Only one redirection per login attempt is allowed.\"},\n+        {\"R_dbMirroringWithMultiSubnetFailover\", \"Connecting to a mirrored SQL Server instance using the multiSubnetFailover connection property is not supported.\"},\n+        {\"R_dbMirroringWithReadOnlyIntent\", \"Connecting to a mirrored SQL Server instance using the ApplicationIntent ReadOnly connection property is not supported.\"},\n+        {\"R_ipAddressLimitWithMultiSubnetFailover\", \"Connecting with the multiSubnetFailover connection property to a SQL Server instance configured with more than {0} IP addresses is not supported.\"},\n+        {\"R_connectionTimedOut\", \"Connection timed out: no further information.\"},\n+        {\"R_invalidPositionIndex\", \"The position index {0} is not valid.\"},\n+        {\"R_invalidLength\", \"The length {0} is not valid.\"},\n+        {\"R_unknownSSType\", \"Invalid SQL Server data type {0}.\"},\n+        {\"R_unknownJDBCType\", \"Invalid JDBC data type {0}.\"},\n+        {\"R_notSQLServer\", \"The driver received an unexpected pre-login response. Verify the connection properties and check that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. This driver can be used only with SQL Server 2005 or later.\"},\n+        {\"R_tcpOpenFailed\", \"{0}. Verify the connection properties. Make sure that an instance of SQL Server is running on the host and accepting TCP/IP connections at the port. Make sure that TCP connections to the port are not blocked by a firewall.\"},\n+        {\"R_unsupportedServerVersion\", \"SQL Server version {0} is not supported by this driver.\"},\n+        {\"R_noServerResponse\", \"SQL Server did not return a response. The connection has been closed.\"},\n+        {\"R_truncatedServerResponse\", \"SQL Server returned an incomplete response. The connection has been closed.\"},\n+        {\"R_queryTimedOut\", \"The query has timed out.\"},\n+        {\"R_queryCancelled\", \"The query was canceled.\"},\n+        {\"R_errorReadingStream\", \"An error occurred while reading the value from the stream object. Error: \\\"{0}\\\"\"},\n+        {\"R_streamReadReturnedInvalidValue\", \"The stream read operation returned an invalid value for the amount of data read.\"},\n+        {\"R_mismatchedStreamLength\", \"The stream value is not the specified length. The specified length was {0}, the actual length is {1}.\"},\n+        {\"R_notSupported\", \"This operation is not supported.\"},\n+        {\"R_invalidOutputParameter\", \"The index {0} of the output parameter is not valid.\"},\n+        {\"R_outputParameterNotRegisteredForOutput\", \"The output parameter {0} was not registered for output.\"},\n+        {\"R_parameterNotDefinedForProcedure\", \"Parameter {0} was not defined for stored procedure {1}.\"},\n+        {\"R_connectionIsClosed\", \"The connection is closed.\"},\n+        {\"R_invalidBooleanValue\", \"The property {0} does not contain a valid boolean value. Only true or false can be used.\"},\n+        {\"R_propertyMaximumExceedsChars\", \"The {0} property exceeds the maximum number of {1} characters.\"},\n+        {\"R_invalidPortNumber\", \"The port number {0} is not valid.\"},\n+        {\"R_invalidTimeOut\", \"The timeout {0} is not valid.\"},\n+        {\"R_invalidLockTimeOut\", \"The lockTimeOut {0} is not valid.\"},\n+        {\"R_invalidAuthenticationScheme\", \"The authenticationScheme {0} is not valid.\"},\n+        {\"R_invalidPacketSize\", \"The packetSize {0} is not valid.\"},\n+        {\"R_packetSizeTooBigForSSL\", \"SSL encryption cannot be used with a network packet size larger than {0} bytes.  Please check your connection properties and SQL Server configuration.\"},\n+        {\"R_redirectedFrom\", \"{0} (redirected from {1})\"},\n+        {\"R_tcpipConnectionFailed\", \"The TCP/IP connection to the host {0}, port {1} has failed. Error: \\\"{2}\\\".\"}, // <loccomment>{PlaceHolder=\"TCP/IP\"}</locomment>\n+        {\"R_invalidTransactionLevel\", \"The transaction level {0} is not valid.\"},\n+        {\"R_cantInvokeRollback\", \"Cannot invoke a rollback operation when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_cantSetSavepoint\", \"Cannot set a savepoint when the AutoCommit mode is set to \\\"true\\\".\"},\n+        {\"R_sqlServerHoldability\", \"SQL Server supports holdability at the connection level only. Use the connection.setHoldability() method.\"}, // <loccomment>{PlaceHolder=\"connection.setHoldability()\"}</locomment>\n+        {\"R_invalidHoldability\", \"The holdability value {0} is not valid.\"},\n+        {\"R_invalidColumnArrayLength\", \"The column array is not valid. Its length must be 1.\"},\n+        {\"R_valueNotSetForParameter\", \"The value is not set for the parameter number {0}.\"},\n+        {\"R_sqlBrowserFailed\", \"The connection to the host {0}, named instance {1} failed. Error: \\\"{2}\\\". Verify the server and instance names and check that no firewall is blocking UDP traffic to port 1434. For SQL Server 2005 or later, verify that the SQL Server Browser Service is running on the host.\"},\n+        {\"R_notConfiguredToListentcpip\", \"The server {0} is not configured to listen with TCP/IP.\"},\n+        {\"R_cantIdentifyTableMetadata\", \"Unable to identify the table {0} for the metadata.\"},\n+        {\"R_metaDataErrorForParameter\", \"A metadata error for the parameter {0} occurred.\"},\n+        {\"R_invalidParameterNumber\", \"The parameter number {0} is not valid.\"},\n+        {\"R_noMetadata\", \"There is no metadata.\"},\n+        {\"R_resultsetClosed\", \"The result set is closed.\"},\n+        {\"R_invalidColumnName\", \"The column name {0} is not valid.\"},\n+        {\"R_resultsetNotUpdatable\", \"The result set is not updatable.\"},\n+        {\"R_indexOutOfRange\", \"The index {0} is out of range.\"},\n+        {\"R_savepointNotNamed\", \"The savepoint is not named.\"},\n+        {\"R_savepointNamed\", \"The savepoint {0} is named.\"},\n+        {\"R_resultsetNoCurrentRow\", \"The result set has no current row.\"},\n+        {\"R_mustBeOnInsertRow\", \"The cursor is not on the insert row.\"},\n+        {\"R_mustNotBeOnInsertRow\", \"The requested operation is not valid on the insert row.\"},\n+        {\"R_cantUpdateDeletedRow\", \"A deleted row cannot be updated.\"},\n+        {\"R_noResultset\", \"The statement did not return a result set.\"},\n+        {\"R_resultsetGeneratedForUpdate\", \"A result set was generated for update.\"},\n+        {\"R_statementIsClosed\", \"The statement is closed.\"},\n+        {\"R_invalidRowcount\", \"The maximum row count {0} for a result set must be non-negative.\"},\n+        {\"R_invalidQueryTimeOutValue\", \"The query timeout value {0} is not valid.\"},\n+        {\"R_invalidFetchDirection\", \"The fetch direction {0} is not valid.\"},\n+        {\"R_invalidFetchSize\", \"The fetch size cannot be negative.\"},\n+        {\"R_noColumnParameterValue\", \"No column parameter values were specified to update the row.\"},\n+        {\"R_statementMustBeExecuted\", \"The statement must be executed before any results can be obtained.\"},\n+        {\"R_modeSuppliedNotValid\", \"The supplied mode is not valid.\"},\n+        {\"R_errorConnectionString\", \"The connection string contains a badly formed name or value.\"},\n+        {\"R_errorProcessingComplexQuery\", \"An error occurred while processing the complex query.\"},\n+        {\"R_invalidOffset\", \"The offset {0} is not valid.\"},\n+        {\"R_nullConnection\", \"The connection URL is null.\"},\n+        {\"R_invalidConnection\", \"The connection URL is invalid.\"},\n+        {\"R_cannotTakeArgumentsPreparedOrCallable\", \"The method {0} cannot take arguments on a PreparedStatement or CallableStatement.\"},\n+        // Invalid conversion (e.g. MONEY to Timestamp)\n+        {\"R_unsupportedConversionFromTo\", \"The conversion from {0} to {1} is unsupported.\"},\n+        // Invalid conversion to an unknown type\n+        {\"R_unsupportedConversionTo\", \"The conversion to {0} is unsupported.\"},\n+        // Data-dependent conversion failure (e.g. \"foo\" vs. \"123\", to Integer)\n+        {\"R_errorConvertingValue\", \"An error occurred while converting the {0} value to JDBC data type {1}.\"},\n+        {\"R_streamIsClosed\", \"The stream is closed.\"},\n+        {\"R_invalidTDS\", \"The TDS protocol stream is not valid.\"},\n+        {\"R_unexpectedToken\", \" Unexpected token {0}.\"},\n+        {\"R_selectNotPermittedinBatch\", \"The SELECT statement is not permitted in a batch.\"},\n+        {\"R_failedToCreateXAConnection\", \"Failed to create the XA control connection. Error: \\\"{0}\\\"\"},\n+        {\"R_codePageNotSupported\", \"Codepage {0} is not supported by the Java environment.\"},\n+        {\"R_unknownSortId\", \"SQL Server collation {0} is not supported by this driver.\"},\n+        {\"R_unknownLCID\", \"Windows collation {0} is not supported by this driver.\"},\n+        {\"R_encodingErrorWritingTDS\", \"An encoding error occurred while writing a string to the TDS buffer. Error: \\\"{0}\\\"\"},\n+        {\"R_processingError\", \"A processing error \\\"{0}\\\" occurred.\"},\n+        {\"R_requestedOpNotSupportedOnForward\", \"The requested operation is not supported on forward only result sets.\"},\n+        {\"R_unsupportedCursor\", \"The cursor type is not supported.\"},\n+        {\"R_unsupportedCursorOperation\", \"The requested operation is not supported with this cursor type.\"},\n+        {\"R_unsupportedConcurrency\", \"The concurrency is not supported.\"},\n+        {\"R_unsupportedCursorAndConcurrency\", \"The cursor type/concurrency combination is not supported.\"},\n+        {\"R_stringReadError\", \"A string read error occurred at offset:{0}.\"},\n+        {\"R_stringWriteError\", \"A string write error occurred at offset:{0}.\"},\n+        {\"R_stringNotInHex\", \"The string is not in a valid hex format.\"},\n+        {\"R_unknownType\", \"The Java type {0} is not a supported type.\"},\n+        {\"R_physicalConnectionIsClosed\", \"The physical connection is closed for this pooled connection.\"},\n+        {\"R_invalidDataSourceReference\", \"Invalid DataSource reference.\"},\n+        {\"R_cantGetColumnValueFromDeletedRow\", \"Cannot get a value from a deleted row.\"},\n+        {\"R_cantGetUpdatedColumnValue\", \"Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called.\"},\n+        {\"R_cantUpdateColumn\", \"The column value cannot be updated.\"},\n+        {\"R_positionedUpdatesNotSupported\", \"Positioned updates and deletes are not supported.\"},\n+        {\"R_invalidAutoGeneratedKeys\", \"The autoGeneratedKeys parameter value {0} is not valid. Only the values Statement.RETURN_GENERATED_KEYS and Statement.NO_GENERATED_KEYS can be used.\"},\n+        {\"R_notConfiguredForIntegrated\", \"This driver is not configured for integrated authentication.\"},\n+        {\"R_failoverPartnerWithoutDB\", \"databaseName is required when using the failoverPartner connection property.\"},\n+        {\"R_invalidPartnerConfiguration\", \"The database {0} on server {1} is not configured for database mirroring.\"},\n+        {\"R_invaliddisableStatementPooling\", \"The disableStatementPooling value {0} is not valid.\"},\n+        {\"R_invalidselectMethod\", \"The selectMethod {0} is not valid.\"},\n+        {\"R_invalidpropertyValue\", \"The data type of connection property {0} is not valid. All the properties for this connection must be of String type.\"},\n+        {\"R_invalidArgument\", \"The argument {0} is not valid.\"},\n+        {\"R_streamWasNotMarkedBefore\", \"The stream has not been marked.\"},\n+        {\"R_invalidresponseBuffering\", \"The responseBuffering connection property {0} is not valid.\"},\n+        {\"R_invalidapplicationIntent\", \"The applicationIntent connection property {0} is not valid.\"},\n+        {\"R_dataAlreadyAccessed\", \"The data has been accessed and is not available for this column or parameter.\"},\n+        {\"R_outParamsNotPermittedinBatch\", \"The OUT and INOUT parameters are not permitted in a batch.\"},\n+        {\"R_sslRequiredNoServerSupport\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. The application requested encryption but the server is not configured to support SSL.\"},\n+        {\"R_sslRequiredByServer\", \"SQL Server login requires an encrypted connection that uses Secure Sockets Layer (SSL).\"},\n+        {\"R_sslFailed\", \"The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \\\"{0}\\\".\"},\n+        {\"R_certNameFailed\", \"Failed to validate the server name in a certificate during Secure Sockets Layer (SSL) initialization.\"},\n+        {\"R_failedToInitializeXA\", \"Failed to initialize the stored procedure xp_sqljdbc_xa_init. The status is: {0}. Error: \\\"{1}\\\"\"},\n+        {\"R_failedFunctionXA\", \"The function {0} failed. The status is: {1}. Error: \\\"{2}\\\"\"},\n+        {\"R_noTransactionCookie\", \"The function {0} failed. No transaction cookie was returned.\"},\n+        {\"R_failedToEnlist\", \"Failed to enlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToUnEnlist\", \"Failed to unenlist. Error: \\\"{0}\\\"\"},\n+        {\"R_failedToReadRecoveryXIDs\", \"Failed to read recovery XA branch transaction IDs (XIDs). Error: \\\"{0}\\\"\"},\n+        {\"R_userPropertyDescription\", \"The database user.\"},\n+        {\"R_passwordPropertyDescription\", \"The database password.\"},\n+        {\"R_databaseNamePropertyDescription\", \"The name of the database to connect to.\"},\n+        {\"R_domainPropertyDescription\", \"The Windows domain to authenticate in using NTLM.\"},\n+        {\"R_serverNamePropertyDescription\", \"The computer running SQL Server.\"},\n+        {\"R_portNumberPropertyDescription\", \"The TCP port where an instance of SQL Server is listening.\"},\n+        {\"R_realmPropertyDescription\", \"The realm for Kerberos authentication.\"},\n+        {\"R_serverSpnPropertyDescription\", \"SQL Server SPN.\"},\n+        {\"R_columnEncryptionSettingPropertyDescription\", \"The column encryption setting.\"},\n+        {\"R_enclaveAttestationUrlPropertyDescription\", \"The enclave attestation URL.\"},\n+        {\"R_enclaveAttestationProtocolPropertyDescription\", \"The enclave attestation protocol.\"},\n+        {\"R_serverNameAsACEPropertyDescription\", \"Translates the serverName from Unicode to ASCII Compatible Encoding (ACE), as defined by the ToASCII operation of RFC 3490.\"},\n+        {\"R_sendStringParametersAsUnicodePropertyDescription\", \"Determines if the string parameters are sent to the server as Unicode or the database's character set.\"},\n+        {\"R_multiSubnetFailoverPropertyDescription\", \"Indicates that the application is connecting to the Availability Group Listener of an Availability Group or Failover Cluster Instance.\"},\n+        {\"R_applicationNamePropertyDescription\", \"The application name for SQL Server profiling and logging tools.\"},\n+        {\"R_lastUpdateCountPropertyDescription\", \"Ensures that only the last update count is returned from an SQL statement passed to the server.\"},\n+        {\"R_disableStatementPoolingPropertyDescription\", \"Disables the statement pooling feature.\"},\n+        {\"R_integratedSecurityPropertyDescription\", \"Indicates whether Windows authentication will be used to connect to SQL Server.\"},\n+        {\"R_authenticationSchemePropertyDescription\", \"The authentication scheme to be used for integrated authentication.\"},\n+        {\"R_lockTimeoutPropertyDescription\", \"The number of milliseconds to wait before the database reports a lock time-out.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The number of reconnection attempts if there is a connection failure.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The number of seconds between each connection retry attempt.\"},\n+        {\"R_loginTimeoutPropertyDescription\", \"The number of seconds the driver should wait before timing out a failed connection.\"},\n+        {\"R_instanceNamePropertyDescription\", \"The name of the SQL Server instance to connect to.\"},\n+        {\"R_xopenStatesPropertyDescription\", \"Determines if the driver returns XOPEN-compliant SQL state codes in exceptions.\"},\n+        {\"R_selectMethodPropertyDescription\", \"Enables the application to use server cursors to process forward only, read only result sets.\"},\n+        {\"R_responseBufferingPropertyDescription\", \"Controls the adaptive buffering behavior to allow the application to process large result sets without requiring server cursors.\"},\n+        {\"R_applicationIntentPropertyDescription\", \"Declares the application workload type when connecting to a server. Possible values are ReadOnly and ReadWrite.\"},\n+        {\"R_workstationIDPropertyDescription\", \"The host name of the workstation.\"},\n+        {\"R_failoverPartnerPropertyDescription\", \"The name of the failover server used in a database mirroring configuration.\"},\n+        {\"R_packetSizePropertyDescription\", \"The network packet size used to communicate with SQL Server.\"},\n+        {\"R_encryptPropertyDescription\", \"Determines if Secure Sockets Layer (SSL) encryption should be used between the client and the server.\"},\n+        {\"R_socketFactoryClassPropertyDescription\", \"The class to instantiate as the SocketFactory for connections\"},\n+        {\"R_socketFactoryConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by socketFactoryClass\"},\n+        {\"R_trustServerCertificatePropertyDescription\", \"Determines if the driver should validate the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_trustStoreTypePropertyDescription\", \"KeyStore type.\"},\n+        {\"R_trustStorePropertyDescription\", \"The path to the certificate TrustStore file.\"},\n+        {\"R_trustStorePasswordPropertyDescription\", \"The password used to check the integrity of the trust store data.\"},\n+        {\"R_trustManagerClassPropertyDescription\", \"The class to instantiate as the TrustManager for SSL connections.\"},\n+        {\"R_trustManagerConstructorArgPropertyDescription\", \"The optional argument to pass to the constructor specified by trustManagerClass.\"},\n+        {\"R_hostNameInCertificatePropertyDescription\", \"The host name to be used when validating the SQL Server Secure Sockets Layer (SSL) certificate.\"},\n+        {\"R_replicationPropertyDescription\", \"This setting tells the server if the connection is used for replication.\"},\n+        {\"R_sendTimeAsDatetimePropertyDescription\", \"Determines whether to use the SQL Server datetime data type to send java.sql.Time values to the database.\"},\n+        {\"R_TransparentNetworkIPResolutionPropertyDescription\", \"Determines whether to use the Transparent Network IP Resolution feature.\"},\n+        {\"R_queryTimeoutPropertyDescription\", \"The number of seconds to wait before the database reports a query time-out.\"},\n+        {\"R_socketTimeoutPropertyDescription\", \"The number of milliseconds to wait before the java.net.SocketTimeoutException is raised.\"},\n+        {\"R_serverPreparedStatementDiscardThresholdPropertyDescription\", \"The threshold for when to close discarded prepare statements on the server (calling a batch of sp_unprepares). A value of 1 or less will cause sp_unprepare to be called immediately on PreparedStatment close.\"},\n+        {\"R_enablePrepareOnFirstPreparedStatementCallPropertyDescription\", \"This setting specifies whether a prepared statement is prepared (sp_prepexec) on first use (property=true) or on second after first calling sp_executesql (property=false).\"},\n+        {\"R_statementPoolingCacheSizePropertyDescription\", \"This setting specifies the size of the prepared statement cache for a connection. A value less than 1 means no cache.\"},\n+        {\"R_gsscredentialPropertyDescription\", \"Impersonated GSS Credential to access SQL Server.\"},\n+        {\"R_msiClientIdPropertyDescription\", \"Client Id of User Assigned Managed Identity to be used for generating access token for Azure AD MSI Authentication\"},\n+        {\"R_clientCertificatePropertyDescription\", \"Client certificate path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPropertyDescription\", \"Private key file path for client certificate authentication feature.\"},\n+        {\"R_clientKeyPasswordPropertyDescription\", \"Password for private key if the private key is password protected.\"},\n+        {\"R_sendTemporalDataTypesAsStringForBulkCopyPropertyDescription\", \"Flag to indicate whether the driver will send temporal datatypes as String value to the server for bulk copy.\"},\n+        {\"R_delayLoadingLobsPropertyDescription\", \"Boolean flag which indicates whether the driver will load LOB datatypes into memory.\"},\n+        {\"R_AADSecurePrincipalIdPropertyDescription\", \"The Application Id of a registered application which has been granted permission to the database connected.\"},\n+        {\"R_AADSecurePrincipalSecretPropertyDescription\", \"A Secret defined for a registered application which has been granted permission to the database connected.\"},\n+        {\"R_noParserSupport\", \"An error occurred while instantiating the required parser. Error: \\\"{0}\\\"\"},\n+        {\"R_writeOnlyXML\", \"Cannot read from this SQLXML instance. This instance is for writing data only.\"},\n+        {\"R_dataHasBeenReadXML\", \"Cannot read from this SQLXML instance. The data has already been read.\"},\n+        {\"R_readOnlyXML\", \"Cannot write to this SQLXML instance. This instance is for reading data only.\"},\n+        {\"R_dataHasBeenSetXML\", \"Cannot write to this SQLXML instance. The data has already been set.\"},\n+        {\"R_noDataXML\", \"No data has been set in this SQLXML instance.\"},\n+        {\"R_cantSetNull\", \"Cannot set a null value.\"},\n+        {\"R_failedToParseXML\", \"Failed to parse the XML. Error: \\\"{0}\\\"\"},\n+        {\"R_isFreed\", \"This {0} object has been freed. It can no longer be accessed.\"},\n+        {\"R_invalidProperty\", \"This property is not supported: {0}.\"},\n+        {\"R_referencingFailedTSP\", \"The DataSource trustStore password needs to be set.\"},\n+        {\"R_valueOutOfRange\", \"One or more values is out of range of values for the {0} SQL Server data type.\"},\n+        {\"R_valueOutOfRangeSQLType\", \"One or more values is out of range of values for the {0} SQL type.\"},\n+        {\"R_integratedAuthenticationFailed\", \"Integrated authentication failed.\"},\n+        {\"R_permissionDenied\", \"Security violation. Permission to target \\\"{0}\\\" denied.\"},\n+        {\"R_getSchemaError\", \"Error getting default schema name.\"},\n+        {\"R_setSchemaWarning\", \"Warning: setSchema is a no-op in this driver version.\"},\n+        {\"R_updateCountOutofRange\", \"The update count value is out of range.\"},\n+        {\"R_limitOffsetNotSupported\", \"OFFSET clause in limit escape sequence is not supported.\"},\n+        {\"R_limitEscapeSyntaxError\", \"Error in limit escape syntax. Failed to parse query.\"},\n+        {\"R_featureNotSupported\", \"{0} is not supported.\"},\n+        {\"R_zoneOffsetError\", \"Error in retrieving zone offset.\"},\n+        {\"R_invalidMaxRows\", \"The supported maximum row count for a result set is Integer.MAX_VALUE or less.\"},\n+        {\"R_schemaMismatch\", \"Source and destination schemas do not match.\"},\n+        {\"R_invalidColumn\", \"Column {0} is invalid.  Please check your column mappings.\"},\n+        {\"R_invalidDestinationTable\", \"Destination table name is missing or invalid.\"},\n+        {\"R_unableRetrieveColMeta\", \"Unable to retrieve column metadata.\"},\n+        {\"R_invalidDestConnection\", \"Destination connection must be a connection from the Microsoft JDBC Driver for SQL Server.\"},\n+        {\"R_unableRetrieveSourceData\", \"Unable to retrieve data from the source.\"},\n+        {\"R_ParsingError\", \"Failed to parse data for the {0} type.\"},\n+        {\"R_ParsingDataError\", \"Failed to parse data {0} for the {1} type.\"},\n+        {\"R_BulkTypeNotSupported\", \"Data type {0} is not supported in bulk copy.\"},\n+        {\"R_BulkTypeNotSupportedDW\", \"Data type {0} is not supported in bulk copy against Azure Data Warehouse.\"},\n+        {\"R_invalidTransactionOption\", \"UseInternalTransaction option cannot be set to TRUE when used with a Connection object.\"},\n+        {\"R_invalidNegativeArg\", \"The {0} argument cannot be negative.\"},\n+        {\"R_BulkColumnMappingsIsEmpty\", \"Cannot perform bulk copy operation if the only mapping is an identity column and KeepIdentity is set to false.\"},\n+        {\"R_DataSchemaMismatch\", \"Source data does not match source schema.\"},\n+        {\"R_BulkDataDuplicateColumn\", \"Duplicate column names are not allowed.\"},\n+        {\"R_invalidColumnOrdinal\", \"Column {0} is invalid. Column number should be greater than zero.\"},\n+        {\"R_unsupportedEncoding\", \"The encoding {0} is not supported.\"},\n+        {\"R_UnexpectedDescribeParamFormat\", \"Internal error. The format of the resultset returned by sp_describe_parameter_encryption is invalid. One of the resultsets is missing.\"},\n+        {\"R_InvalidEncryptionKeyOrdinal\", \"Internal error. The referenced column encryption key ordinal \\\"{0}\\\" is missing in the encryption metadata returned by sp_describe_parameter_encryption. Max ordinal is \\\"{1}\\\".\"},\n+        {\"R_MissingParamEncryptionMetadata\", \"Internal error. Metadata for some parameters in statement or procedure \\\"{0}\\\" is missing in the resultset returned by sp_describe_parameter_encryption.\"},\n+        {\"R_UnableRetrieveParameterMetadata\", \"Unable to retrieve parameter encryption metadata.\"},\n+        {\"R_InvalidCipherTextSize\", \"Specified ciphertext has an invalid size of {0} bytes, which is below the minimum {1} bytes required for decryption.\"},\n+        {\"R_InvalidAlgorithmVersion\", \"The specified ciphertext''s encryption algorithm version {0} does not match the expected encryption algorithm version {1} .\"},\n+        {\"R_InvalidAuthenticationTag\", \"Specified ciphertext has an invalid authentication tag. \"},\n+        {\"R_EncryptionFailed\", \"Internal error while encryption:  {0} \"},\n+        {\"R_DecryptionFailed\", \"Internal error while decryption:  {0} \"},\n+        {\"R_InvalidKeySize\", \"The column encryption key has been successfully decrypted but it''s length: {0} does not match the length: {1} for algorithm \\\"{2}\\\". Verify the encrypted value of the column encryption key in the database.\"},\n+        {\"R_InvalidEncryptionType\", \"Encryption type {0} specified for the column in the database is either invalid or corrupted. Valid encryption types for algorithm {1} are: {2}.\"},\n+        {\"R_UnknownColumnEncryptionAlgorithm\", \"The Algorithm {0} does not exist. Algorithms registered in the factory are {1}.\"},\n+        {\"R_KeyExtractionFailed\", \"Key extraction failed : {0} .\"},\n+        {\"R_UntrustedKeyPath\", \"The column master key path {0} received from server {1} is not a trusted key path. The column master key path may be corrupt or you should set {0} as a trusted key path using SQLServerConnection.setColumnEncryptionTrustedMasterKeyPaths().\"},\n+        {\"R_UnrecognizedKeyStoreProviderName\", \"Failed to decrypt a column encryption key. Invalid key store provider name: {0}. A key store provider name must denote either a system key store provider or a registered custom key store provider. Valid system key provider names are: {1}. Valid (currently registered) custom key store provider names are: {2}. Please verify key store provider information in column master key definitions in the database, and verify all custom key store providers used in your application are registered properly.\"},\n+        {\"R_UnsupportedDataTypeAE\", \"Encryption and decryption of data type {0} is not supported.\"},\n+        {\"R_NormalizationErrorAE\", \"Decryption of the data type {0} failed. Normalization error.\"},\n+        {\"R_UnsupportedNormalizationVersionAE\", \"Normalization version \\\"{0}\\\" received from SQL Server is either invalid or corrupted. Valid normalization versions are: {1}.\"},\n+        {\"R_NullCipherTextAE\", \"Internal error. Ciphertext value cannot be null.\"},\n+        {\"R_NullColumnEncryptionAlgorithmAE\", \"Internal error. Encryption algorithm cannot be null. Valid algorithms are: {1}.\"},\n+        {\"R_CustomCipherAlgorithmNotSupportedAE\", \"Custom cipher algorithm not supported.\"},\n+        {\"R_PlainTextNullAE\", \"Internal error. Plaintext value cannot be null.\"},\n+        {\"R_StreamingDataTypeAE\", \"Data of length greater than {0} is not supported in encrypted {1} column.\"},\n+        {\"R_AE_NotSupportedByServer\", \"SQL Server in use does not support column encryption.\"},\n+        {\"R_InvalidAEVersionNumber\", \"Received invalid version number \\\"{0}\\\" for Always Encrypted.\"}, // From\n+                                                                                                       // Server\n+        {\"R_NullEncryptedColumnEncryptionKey\", \"Internal error. Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedColumnEncryptionKey\", \"Internal error. Empty encrypted column encryption key specified.\"},\n+        {\"R_InvalidMasterKeyDetails\", \"Invalid master key details specified.\"},\n+        {\"R_CertificateError\", \"Error occurred while retrieving certificate \\\"{0}\\\" from keystore \\\"{1}\\\".\"},\n+        {\"R_ByteToShortConversion\", \"Error occurred while decrypting column encryption key.\"},\n+        {\"R_InvalidCertificateSignature\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (certificate) in \\\"{0}\\\". The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_CEKDecryptionFailed\", \"Exception while decryption of encrypted column encryption key:  {0} \"},\n+        {\"R_NullKeyEncryptionAlgorithm\", \"Key encryption algorithm cannot be null.\"},\n+        {\"R_NullKeyEncryptionAlgorithmInternal\", \"Internal error. Key encryption algorithm cannot be null.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithm\", \"Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_InvalidKeyEncryptionAlgorithmInternal\", \"Internal error. Invalid key encryption algorithm specified: {0}. Expected value: {1}.\"},\n+        {\"R_NullColumnEncryptionKey\", \"Column encryption key cannot be null.\"},\n+        {\"R_EmptyColumnEncryptionKey\", \"Empty column encryption key specified.\"},\n+        {\"R_CertificateNotFoundForAlias\", \"Certificate with alias {0} not found in the store provided by {1}. Verify the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_UnrecoverableKeyAE\", \"Cannot recover private key from keystore with certificate details {0}. Verify that imported certificate for Always Encrypted contains private key and password provided for certificate is correct.\"},\n+        {\"R_KeyStoreNotFound\", \"System cannot find the key store file at the specified path. Verify that the path is correct and you have proper permissions to access it.\"},\n+        {\"R_CustomKeyStoreProviderMapNull\", \"Column encryption key store provider map cannot be null. Expecting a non-null value.\"},\n+        {\"R_EmptyCustomKeyStoreProviderName\", \"Invalid key store provider name specified. Key store provider names cannot be null or empty.\"},\n+        {\"R_InvalidCustomKeyStoreProviderName\", \"Invalid key store provider name {0}. {1} prefix is reserved for system key store providers.\"},\n+        {\"R_CustomKeyStoreProviderValueNull\", \"Null reference specified for key store provider {0}. Expecting a non-null value.\"},\n+        {\"R_CustomKeyStoreProviderSetOnce\", \"Key store providers cannot be set more than once.\"},\n+        {\"R_unknownColumnEncryptionType\", \"Invalid column encryption type {0}.\"},\n+        {\"R_unsupportedStmtColEncSetting\", \"SQLServerStatementColumnEncryptionSetting cannot be null.\"},\n+        {\"R_unsupportedConversionAE\", \"The conversion from {0} to {1} is unsupported for encrypted column.\"},\n+        {\"R_InvalidDataForAE\", \"The given value of type {0} from the data source cannot be converted to type {1} of the specified target column.\"},\n+        {\"R_authenticationPropertyDescription\", \"The authentication to use.\"},\n+        {\"R_accessTokenPropertyDescription\", \"The access token to use for Azure Active Directory.\"},\n+        {\"R_FedAuthRequiredPreLoginResponseInvalidValue\", \"Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was {0}.\"},\n+        {\"R_FedAuthInfoLengthTooShortForCountOfInfoIds\", \"The FedAuthInfo token must at least contain 4 bytes indicating the number of info IDs.\"},\n+        {\"R_FedAuthInfoInvalidOffset\", \"FedAuthInfoDataOffset points to an invalid location. Current dataOffset is {0}.\"},\n+        {\"R_FedAuthInfoFailedToReadData\", \"Failed to read FedAuthInfoData.\"},\n+        {\"R_FedAuthInfoLengthTooShortForData\", \"FEDAUTHINFO token stream is not long enough ({0}) to contain the data it claims to.\"},\n+        {\"R_FedAuthInfoDoesNotContainStsurlAndSpn\", \"FEDAUTHINFO token stream does not contain both STSURL and SPN.\"},\n+        {\"R_MSALExecution\", \"Failed to authenticate the user {0} in Active Directory (Authentication={1}).\"},\n+        {\"R_MSALAuthComplete\", \"Authentication complete. You can close the browser and return to the application.\"},\n+        {\"R_UnrequestedFeatureAckReceived\", \"Unrequested feature acknowledge is received. Feature ID: {0}.\"},\n+        {\"R_FedAuthFeatureAckContainsExtraData\", \"Federated authentication feature extension ack for ADAL and Security Token includes extra data.\"},\n+        {\"R_FedAuthFeatureAckUnknownLibraryType\", \"Attempting to use unknown federated authentication library. Library ID: {0}.\"},\n+        {\"R_UnknownFeatureAck\", \"Unknown feature acknowledge is received.\"},\n+        {\"R_SetAuthenticationWhenIntegratedSecurityTrue\", \"Cannot set \\\"Authentication\\\" with \\\"IntegratedSecurity\\\" set to \\\"true\\\".\"},\n+        {\"R_NtlmNoUserPasswordDomain\", \"\\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection properties must be specified for NTLM authentication.\"},\n+        {\"R_SetAccesstokenWhenIntegratedSecurityTrue\", \"Cannot set the AccessToken property if the \\\"IntegratedSecurity\\\" connection string keyword has been set to \\\"true\\\".\"},\n+        {\"R_IntegratedAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryIntegrated\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_MSIAuthenticationWithUserPassword\", \"Cannot use \\\"Authentication=ActiveDirectoryMSI\\\" with \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" connection string keywords.\"},\n+        {\"R_AccessTokenWithUserPassword\", \"Cannot set the AccessToken property if \\\"User\\\", \\\"UserName\\\" or \\\"Password\\\" has been specified in the connection string.\"},\n+        {\"R_AccessTokenCannotBeEmpty\", \"AccesToken cannot be empty.\"},\n+        {\"R_SetBothAuthenticationAndAccessToken\", \"Cannot set the AccessToken property if \\\"Authentication\\\" has been specified in the connection string.\"},\n+        {\"R_NoUserPasswordForActivePassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryPassword\\\".\"},\n+        {\"R_NoUserPasswordForActiveServicePrincipal\", \"Both \\\"AADSecurePrincipalId\\\" and \\\"AADSecurePrincipalSecret\\\" connection string keywords must be specified, if \\\"Authentication=ActiveDirectoryServicePrincipal\\\".\"},\n+        {\"R_NoUserPasswordForSqlPassword\", \"Both \\\"User\\\" (or \\\"UserName\\\") and \\\"Password\\\" connection string keywords must be specified, if \\\"Authentication=SqlPassword\\\".\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalse\", \"Cannot set Force Encryption to true for parameter {0} because enryption is not enabled for the statement or procedure {1}.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumn\", \"Cannot execute statement or procedure {0} because Force Encryption was set as true for parameter {1} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_ForceEncryptionTrue_HonorAEFalseRS\", \"Cannot set Force Encryption to true for parameter {0} because encryption is not enabled for the statement or procedure.\"},\n+        {\"R_ForceEncryptionTrue_HonorAETrue_UnencryptedColumnRS\", \"Cannot execute update because Force Encryption was set as true for parameter {0} and the database expects this parameter to be sent as plaintext. This may be due to a configuration error.\"},\n+        {\"R_NullValue\", \"{0} cannot be null.\"},\n+        {\"R_AKVPathNull\", \"Azure Key Vault key path cannot be null.\"},\n+        {\"R_AKVURLInvalid\", \"Invalid URL specified: {0}.\"},\n+        {\"R_AKVMasterKeyPathInvalid\", \"Invalid Azure Key Vault key path specified: {0}.\"},\n+        {\"R_ManagedIdentityInitFail\", \"Failed to initialize package to get Managed Identity token for Azure Key Vault.\"},\n+        {\"R_EmptyCEK\", \"Empty column encryption key specified.\"},\n+        {\"R_EncryptedCEKNull\", \"Encrypted column encryption key cannot be null.\"},\n+        {\"R_EmptyEncryptedCEK\", \"Encrypted Column Encryption Key length should not be zero.\"},\n+        {\"R_NonRSAKey\", \"Cannot use a non-RSA key: {0}.\"},\n+        {\"R_GetAKVKeySize\", \"Unable to get the Azure Key Vault public key size in bytes.\"},\n+        {\"R_InvalidEcryptionAlgorithmVersion\", \"Specified encrypted column encryption key contains an invalid encryption algorithm version {0}. Expected version is {1}.\"},\n+        {\"R_AKVKeyLengthError\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_AKVSignatureLengthError\", \"The specified encrypted column encryption key''s signature length: {0} does not match the signature length: {1} when using column master key (Azure Key Vault key) in {2}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.\"},\n+        {\"R_HashNull\", \"Hash should not be null while decrypting encrypted column encryption key.\"},\n+        {\"R_NoSHA256Algorithm\", \"SHA-256 Algorithm is not supported.\"},\n+        {\"R_VerifySignature\", \"Unable to verify signature of the column encryption key.\"},\n+        {\"R_CEKSignatureNotMatchCMK\", \"The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in {0}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.\"},\n+        {\"R_DecryptCEKError\", \"Unable to decrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_EncryptCEKError\", \"Unable to encrypt column encryption key using specified Azure Key Vault key.\"},\n+        {\"R_CipherTextLengthNotMatchRSASize\", \"CipherText length does not match the RSA key size.\"},\n+        {\"R_GenerateSignature\", \"Unable to generate signature using a specified Azure Key Vault Key URL.\"},\n+        {\"R_SignedHashLengthError\", \"Signed hash length does not match the RSA key size.\"},\n+        {\"R_InvalidSignatureComputed\", \"Invalid signature of the encrypted column encryption key computed.\"},\n+        {\"R_UnableLoadADALSqlDll\", \"Unable to load adalsql.dll. Error code: 0x{0}. For details, see: http://go.microsoft.com/fwlink/?LinkID=513072\"},\n+        {\"R_ADALAuthenticationMiddleErrorMessage\", \"Error code 0x{0}; state {1}.\"},\n+        {\"R_unsupportedDataTypeTVP\", \"Data type {0} not supported in Table-Valued Parameter.\"},\n+        {\"R_moreDataInRowThanColumnInTVP\", \"Input array is longer than the number of columns in this table.\"},\n+        {\"R_invalidTVPName\", \" The Table-Valued Parameter must have a valid type name.\"},\n+        {\"R_invalidThreePartName\", \"Invalid 3 part name format for TypeName.\"},\n+        {\"R_unsupportedConversionTVP\", \"The conversion from {0} to {1} is unsupported for Table-Valued Parameter.\"},\n+        {\"R_TVPMixedSource\", \"Cannot add column metadata. This Table-Valued Parameter has a ResultSet from which metadata will be derived.\"},\n+        {\"R_TVPEmptyMetadata\", \"There are not enough fields in the Structured type. Structured types must have at least one field.\"},\n+        {\"R_TVPInvalidValue\", \"The value provided for Table-Valued Parameter {0} is not valid. Only SQLServerDataTable, ResultSet and ISQLServerDataRecord objects are supported.\"},\n+        {\"R_TVPInvalidColumnValue\", \"Input data is not in correct format.\"},\n+        {\"R_TVPSortOrdinalGreaterThanFieldCount\", \"The sort ordinal {0} on field {1} exceeds the total number of fields.\"},\n+        {\"R_TVPMissingSortOrderOrOrdinal\", \"The sort order and ordinal must either both be specified, or neither should be specified (SortOrder.Unspecified and -1). The values given were: order = {0}, ordinal = {1}.\"},\n+        {\"R_TVPDuplicateSortOrdinal\", \"The sort ordinal {0} was specified twice.\"},\n+        {\"R_TVPMissingSortOrdinal\", \"The sort ordinal {0} was not specified.\"},\n+        {\"R_TVPDuplicateColumnName\", \"A column name {0} already belongs to this SQLServerDataTable.\"},\n+        // This is used for connection settings. {0}-> property name as is, {1}-> value\n+        {\"R_InvalidConnectionSetting\", \"The {0} value \\\"{1}\\\" is not valid.\"},\n+        {\"R_InvalidWindowsCertificateStoreEncryption\", \"Cannot encrypt a column encryption key with the Windows Certificate Store.\"},\n+        {\"R_AEKeypathEmpty\", \"Internal error. Certificate path cannot be null. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AEWinApiErr\", \"Windows Api native error.\"},\n+        {\"R_AECertpathBad\", \"Internal error. Invalid certificate path: {0}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertLocBad\", \"Internal error. Invalid certificate location {0} in certificate path {1}. Use the following format: \\\"certificate location/certificate store/certificate thumbprint\\\", where \\\"certificate location\\\" is either LocalMachine or CurrentUser.\"},\n+        {\"R_AECertStoreBad\", \"Internal error. Invalid certificate store {0} specified in certificate path {1}. Expected value: My.\"},\n+        {\"R_AECertHashEmpty\", \"Internal error. Empty certificate thumbprint specified in certificate path {0}.\"},\n+        {\"R_AECertNotFound\", \"Certificate with thumbprint {2} not found in certificate store {1} in certificate location {0}. Verify the certificate path in the column master key definition in the database is correct, and the certificate has been imported correctly into the certificate location/store.\"},\n+        {\"R_AEMaloc\", \"Memory allocation failure.\"},\n+        {\"R_AEKeypathLong\", \"Internal error. Specified certificate path has {0} bytes, which exceeds maximum length of {1} bytes.\"},\n+        {\"R_AEECEKLenBad\", \"The specified encrypted column encryption key''s ciphertext length: {0} does not match the ciphertext length: {1} when using column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEECEKSigLenBad\", \"The specified encrypted column encryption key''s signature length {0} does not match the length {1} when using the column master key (certificate) in \\\"{2}\\\". The encrypted column encryption key may be corrupt, or the specified certificate path may be incorrect.\"},\n+        {\"R_AEKeyPathEmptyOrReserved\", \"The certificate path \\\"{0}\\\" is invalid; it is empty or contains reserved directory names.\"},\n+        {\"R_AEKeyPathCurUser\", \"CurrentUser was specified in key path but an error occurred obtaining the current user''s initial working directory.\"},\n+        {\"R_AEKeyFileOpenError\", \"Error opening certificate file {0}.\"},\n+        {\"R_AEKeyFileReadError\", \"Error reading certificate file {0}.\"},\n+        {\"R_keyStoreAuthenticationPropertyDescription\", \"The name that identifies a key store.\"},\n+        {\"R_keyStoreSecretPropertyDescription\", \"The authentication secret or information needed to locate the secret.\"},\n+        {\"R_keyStoreLocationPropertyDescription\", \"The key store location.\"},\n+        {\"R_keyStoreAuthenticationNotSet\", \"\\\"keyStoreAuthentication\\\" connection string keyword must be specified, if \\\"{0}\\\" is specified.\"},\n+        {\"R_keyStoreSecretOrLocationNotSet\", \"Both \\\"keyStoreSecret\\\" and \\\"keyStoreLocation\\\" must be set, if \\\"keyStoreAuthentication=JavaKeyStorePassword\\\" has been specified in the connection string.\"},\n+        {\"R_keyStoreSecretNotSet\", \"\\\"keyStoreSecret\\\" must be set, if \\\"keyStoreAuthentication=KeyVaultClientSecret\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderClientKeyNotSet\", \"\\\"keyVaultProviderClientKey\\\" must be set, if \\\"keyVaultProviderClientId\\\" has been specified in the connection string.\"},\n+        {\"R_keyVaultProviderNotSupportedWithKeyStoreAuthentication\", \"\\\"keyStoreAuthentication\\\" cannot be used with \\\"keyVaultProviderClientId\\\" or \\\"keyVaultProviderClientKey\\\" in the connection string.\"},\n+        {\"R_certificateStoreInvalidKeyword\", \"Cannot set \\\"keyStoreSecret\\\", if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStoreLocationNotSet\", \"\\\"keyStoreLocation\\\" must be specified, if \\\"keyStoreAuthentication=CertificateStore\\\" has been specified in the connection string.\"},\n+        {\"R_certificateStorePlatformInvalid\", \"Cannot set \\\"keyStoreAuthentication=CertificateStore\\\" on a Windows operating system.\"},\n+        {\"R_invalidKeyStoreFile\", \"Cannot parse \\\"{0}\\\". Either the file format is not valid or the password is not correct.\"}, // for\n+                                                                                                                                // JKS/PKCS\n+        {\"R_invalidCEKCacheTtl\", \"Invalid column encryption key cache time-to-live specified. The columnEncryptionKeyCacheTtl value cannot be negative and timeUnit can only be DAYS, HOURS, MINUTES or SECONDS.\"},\n+        {\"R_sendTimeAsDateTimeForAE\", \"Use sendTimeAsDateTime=false with Always Encrypted.\"},\n+        {\"R_TVPnotWorkWithSetObjectResultSet\", \"setObject() with ResultSet is not supported for Table-Valued Parameter. Please use setStructured().\"},\n+        {\"R_invalidQueryTimeout\", \"The queryTimeout {0} is not valid.\"},\n+        {\"R_invalidSocketTimeout\", \"The socketTimeout {0} is not valid.\"},\n+        {\"R_fipsPropertyDescription\", \"Determines if FIPS mode is enabled.\"},\n+        {\"R_invalidFipsConfig\", \"Unable to verify FIPS mode settings.\"},\n+        {\"R_serverPreparedStatementDiscardThreshold\", \"The serverPreparedStatementDiscardThreshold {0} is not valid.\"},\n+        {\"R_statementPoolingCacheSize\", \"The statementPoolingCacheSize {0} is not valid.\"},\n+        {\"R_kerberosLoginFailedForUsername\", \"Cannot login with Kerberos principal {0}, check your credentials. {1}\"},\n+        {\"R_kerberosLoginFailed\", \"Kerberos Login failed: {0} due to {1} ({2})\"},\n+        {\"R_StoredProcedureNotFound\", \"Could not find stored procedure ''{0}''.\"},\n+        {\"R_jaasConfigurationNamePropertyDescription\", \"Login configuration file for Kerberos authentication.\"},\n+        {\"R_AKVKeyNotFound\", \"Key not found: {0}\"},\n+        {\"R_SQLVariantSupport\", \"SQL_VARIANT is not supported in versions of SQL Server before 2008.\"},\n+        {\"R_invalidProbbytes\", \"SQL_VARIANT: invalid probBytes for {0} type.\"},\n+        {\"R_invalidStringValue\", \"SQL_VARIANT does not support string values of length greater than 8000.\"},\n+        {\"R_invalidValueForTVPWithSQLVariant\", \"Use of TVPs containing null sql_variant columns is not supported.\"},\n+        {\"R_invalidDataTypeSupportForSQLVariant\", \"Unexpected TDS type ' '{0}' ' in SQL_VARIANT.\"},\n+        {\"R_sslProtocolPropertyDescription\", \"SSL protocol label from TLS, TLSv1, TLSv1.1, and TLSv1.2. The default is TLS.\"},\n+        {\"R_invalidSSLProtocol\", \"SSL Protocol {0} label is not valid. Only TLS, TLSv1, TLSv1.1, and TLSv1.2 are supported.\"},\n+        {\"R_cancelQueryTimeoutPropertyDescription\", \"The number of seconds to wait to cancel sending a query timeout.\"},\n+        {\"R_invalidCancelQueryTimeout\", \"The cancel timeout value {0} is not valid.\"},\n+        {\"R_useBulkCopyForBatchInsertPropertyDescription\", \"Whether the driver will use bulk copy API for batch insert operations\"},\n+        {\"R_UnknownDataClsTokenNumber\", \"Unknown token for Data Classification.\"}, // From Server\n+        {\"R_InvalidDataClsVersionNumber\", \"Invalid version number {0} for Data Classification.\"}, // From Server\n+        {\"R_unknownUTF8SupportValue\", \"Unknown value for UTF8 support.\"},\n+        {\"R_unknownAzureSQLDNSCachingValue\", \"Unknown value for Azure SQL DNS Caching.\"},\n+        {\"R_illegalWKT\", \"Illegal Well-Known text. Please make sure Well-Known text is valid.\"},\n+        {\"R_illegalTypeForGeometry\", \"{0} is not supported for Geometry.\"},\n+        {\"R_illegalWKTposition\", \"Illegal character in Well-Known text at position {0}.\"},\n+        {\"R_keyVaultProviderClientIdPropertyDescription\", \"The client ID used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyVaultProviderClientKeyPropertyDescription\", \"The client key used to access the Key Vault where the column encryption master key is stored.\"},\n+        {\"R_keyStorePrincipalIdPropertyDescription\", \"Principal Id of Azure Active Directory.\"},\n+        {\"R_MSALMissing\", \"Failed to load MSAL4J Java library for performing {0} authentication.\"},\n+        {\"R_DLLandMSALMissing\", \"Failed to load both {0} and MSAL4J Java library for performing {1} authentication. Please install one of them to proceed.\"},\n+        {\"R_MSITokenFailureImds\", \"MSI Token failure: Failed to acquire access token from IMDS\"},\n+        {\"R_MSITokenFailureImdsClientId\", \"MSI Token failure: Failed to acquire access token from IMDS, verify your clientId.\"},\n+        {\"R_MSITokenFailureUnexpected\", \"MSI Token failure: Failed to acquire access token from IMDS, unexpected error occurred.\"},\n+        {\"R_MSITokenFailureEndpoint\", \"MSI Token failure: Failed to acquire token from MSI Endpoint\"},\n+        {\"R_propertyNotSupported\", \"Microsoft JDBC Driver for SQL Server currently does not support the property: {0}\"},\n+        {\"R_ntlmHmacMD5Error\", \"Unable to initialize NTLM authentication: HMAC-MD5 initialization error.\"},\n+        {\"R_ntlmSignatureError\", \"NTLM Challenge Message signature error: {0}\"},\n+        {\"R_ntlmMessageTypeError\", \"NTLM Challenge Message type error: {0}\"},\n+        {\"R_ntlmAuthenticateError\", \"NTLM error when constructing Authenticate Message: {0}\"},\n+        {\"R_ntlmNoTargetInfo\", \"NTLM Challenge Message is missing TargetInfo.\"},\n+        {\"R_ntlmUnknownValue\", \"NTLM Challenge Message TargetInfo error: unknown value \\\"{0}\\\"\"},\n+        {\"R_useFmtOnlyPropertyDescription\", \"Determines whether to enable/disable use of SET FMTONLY to retrieve parameter metadata.\"},\n+        {\"R_invalidOpenqueryCall\", \"Invalid syntax: OPENQUERY/OPENJSON/OPENDATASOURCE/OPENROWSET/OPENXML must be preceded by round brackets\"},\n+        {\"R_invalidCTEFormat\", \"Invalid syntax: AS must be followed by round brackets in Common Table Expressions.\"},\n+        {\"R_noTokensFoundInUserQuery\", \"Invalid query: No tokens were parsed from the SQL provided.\"},\n+        {\"R_invalidUserSQL\", \"An error occurred when attempting to parse user SQL. Please verify SQL syntax.\"},\n+        {\"R_invalidInsertValuesQuery\", \"An error occurred when matching VALUES list to table columns. Please verify SQL syntax.\"},\n+        {\"R_invalidValuesList\", \"An error occurred when reading VALUES list. Please verify SQL syntax.\"},\n+        {\"R_enclaveNotSupported\", \"The SQL Server does not support enclave based computations -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclavePropertiesError\", \"The \\\"columnEncryptionSetting\\\" connection property must be enabled, along with valid \\\"enclaveAttestationUrl\\\" and \\\"enclaveAttestationProtocol\\\" connection properties when enabling Always Encrypted with secure enclaves - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveInvalidAttestationProtocol\", \"The \\\"enclaveAttestationProtocol\\\" is invalid - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_enclaveTypeInvalid\", \"The enclave type {0} is invalid or not supported by the driver -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_attestationUrlInvalid\", \"Unable to attest enclave specified by {0} - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclaveResponseLengthError\", \"More bytes from the server were received than expected when parsing the enclave attestation response - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePackageLengthError\", \"More bytes from the server were received than expected when parsing the enclave package - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_EnclavePKLengthError\", \"More bytes from the server were received than expected when parsing the enclave public key - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_MalformedECDHPublicKey\", \"The ECDH public key from the server must be 104 bits in length.\"},\n+        {\"R_MalformedECDHHeader\", \"Unexpected values for ECDH public key header from the server.\"},\n+        {\"R_HealthCertError\", \"Enclave attestation failed, could not retrieve health report certificates provided in the enclave: {0} -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidHealthCert\", \"Enclave attestation failed, the health report certificate provided in the enclave was not signed by the HGS - see\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidSignedStatement\", \"Enclave attestation failed, the statement bytes were not signed by the health certificate -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2160553\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_InvalidDHKeySignature\", \"Enclave attestation failed, the DH public key signature can't be verified with the enclave public key -\u202fsee\u202fhttps://go.microsoft.com/fwlink/?linkid=2157649\u202ffor\u202fmore\u202fdetails.\"},\n+        {\"R_AasJWTError\", \"An error occured when retrieving and validating the JSON web token.\"},\n+        {\"R_AasEhdError\", \"aas-ehd claim from JWT did not match enclave public key.\"},\n+        {\"R_VbsRpDataError\", \"rp_data claim from JWT did not match client nonce.\"},\n+        {\"R_pvkParseError\", \"Could not read Private Key from PVK, check the password provided.\"},\n+        {\"R_pvkHeaderError\", \"Cannot parse the PVK, PVK file does not contain the correct header.\"},\n+        {\"R_clientCertError\", \"Reading client certificate failed. Please verify the location of the certificate.\"},\n+        {\"R_unassignableError\", \"The class specified by the {0} property must be assignable to {1}.\"},\n+        {\"R_InvalidCSVQuotes\", \"Failed to parse the CSV file, verify that the fields are correctly enclosed in double quotes.\"},\n+        {\"R_TokenRequireUrl\", \"Token credentials require a URL using the HTTPS protocol scheme.\"},\n+        {\"R_maxResultBufferPropertyDescription\", \"Determines maximum amount of bytes that can be read during retrieval of result set\"},\n+        {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n+        {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n+        {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n     };\n }\n+// @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "a61fbb7cc39a55d66708de929589e165c7e9ccaf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 278197bc..3e3ba8e9 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,6 +489,14 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 3e3ba8e9..054cab87 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,14 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 054cab87..76210ff7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +489,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "c83c5dbb5cb3561f09a50920855f792ba1ea1d3d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 76210ff7..02224d0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -489,15 +491,6 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n-        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n-        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n-        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n-        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n-        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n-        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n-        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n-        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "b32966371c5da329e3f8414b66b28fb3635ab646", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 02224d0a..5929f5c3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -491,6 +491,15 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_maxResultBufferInvalidSyntax\", \"Invalid syntax: {0} in maxResultBuffer parameter.\"},\n         {\"R_maxResultBufferNegativeParameterValue\", \"MaxResultBuffer must have positive value: {0}.\"},\n         {\"R_maxResultBufferPropertyExceeded\", \"MaxResultBuffer property exceeded: {0}. MaxResultBuffer was set to: {1}.\"},\n+        {\"R_invalidConnectRetryCount\", \"Connection retry count {0} is not valid.\"},\n+        {\"R_connectRetryCountPropertyDescription\", \"The maximum number of attempts to reestablish a broken connection.\"},\n+        {\"R_invalidConnectRetryInterval\", \"Connection retry interval {0} is not valid.\"},\n+        {\"R_connectRetryIntervalPropertyDescription\", \"The interval, in seconds, between attempts to reestablish a connection.\"},\n+        {\"R_crClientAllRecoveryAttemptsFailed\", \"The connection is broken and recovery is not possible. The client driver attempted to recover the connection one or more times and all attempts failed. Increase the value of ConnectRetryCount to increase the number of recovery attempts.\"},\n+        {\"R_crClientNoRecoveryAckFromLogin\", \"The server did not acknowledge a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n+        {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n // @formatter:on\n\\ No newline at end of file\n", "next_change": {"commit": "21bdb7aad2830f7a1886baae5420ebdc3eea4d3b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 5929f5c3..4f80d4f4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,4 +502,4 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n     };\n }\n-// @formatter:on\n\\ No newline at end of file\n+// @formatter:on\n", "next_change": {"commit": "7cb16845fd7c26b0108bd57e8a7207c39f337b72", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 4f80d4f4..ffe08fbe 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -500,6 +500,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crServerSessionStateNotRecoverable\", \"The connection is broken and recovery is not possible. The connection is marked by the server as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n+        {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7a8fd43da6d2f2bf3039254edd72af32ce06a2c6", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex ffe08fbe..2240bd47 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -501,6 +501,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "c25825cdfcb823c36ff99653eb98ffc3f7eff2f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 2240bd47..f1186553 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n+        {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "4337c5728cc8255dd7fafc2c3cfcd9c75f217801", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex f1186553..da1b8d3d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -502,6 +503,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_crClientUnrecoverable\",\"The connection is broken and recovery is not possible. The connection is marked by the client driver as unrecoverable. No attempt was made to restore the connection.\"},\n         {\"R_crClientSSLStateNotRecoverable\", \"The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.\"},\n         {\"R_crCommandCannotTimeOut\", \"Request failed to time out and SQLServerConnection does not exist\"},\n+        {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n", "next_change": {"commit": "17b4799d7596c1053ca073dbb8f06ca509a8f9f2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex da1b8d3d..bb98b34d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -507,6 +507,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0042429113f117c9b7118e67c13d430e0ba3bcde", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex bb98b34d..c178c31e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -506,7 +506,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_InvalidIPAddressPreference\", \"IP address preference {0} is not valid.\"},\n         {\"R_UnableLoadAuthDll\", \"Unable to load authentication DLL {0}\"},\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n-        {\"R_serverCertError\", \"Error validating Server Certificate: {0}.\"},\n+        {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n     };\n }\n", "next_change": {"commit": "0c703a74888da1897d2feb261d0ca91693caa422", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex c178c31e..85d91df1 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -508,6 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_illegalArgumentTrustManager\", \"Interal error. Peer certificate chain or key exchange algorithem can not be null or empty.\"},\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n+        {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "0f9bf15456b5f4e86f86f52f74fb89ee78c08a02", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex 85d91df1..be53aadd 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,6 +519,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "095c7ee28e0a557e06ee2b913ee488daa3a9c64f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex be53aadd..fcab79f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -520,6 +515,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n // @formatter:on\n", "next_change": {"commit": "7e410aa3223493cfe03b39c65c7dd89b0447f79b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex fcab79f5..b264d3db 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -514,7 +514,7 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_serverCertError\", \"Error validating Server Certificate: {0}: {1}.\"},\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n-        {\"R_serverError\", \"An error occurred during the current command (Done status {0}).\"},\n+        {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n         {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n     };\n }\n", "next_change": {"commit": "8e2c15dbc82cd2d62df125076e31a33c527240f8", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\nindex b264d3db..96bd1847 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java\n", "chunk": "@@ -515,7 +516,8 @@ public final class SQLServerResource extends ListResourceBundle {\n         {\"R_SecureStringInitFailed\", \"Failed to initialize SecureStringUtil to store secure strings\"},\n         {\"R_ALPNFailed\", \"Failed to negotiate Application-Layer Protocol {0}. Server returned: {1}.\"},\n         {\"R_serverError\", \"An error occurred during the current command (Done status {0}). {1}\"},\n-        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"}\n+        {\"R_ManagedIdentityTokenAcquisitionFail\", \"Failed to acquire managed identity token. Request for the token succeeded, but no token was returned. The token is null.\"},\n+        {\"R_InvalidSqlQuery\", \"Invalid SQL Query: {0}\"}\n     };\n }\n // @formatter:on\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5NDIyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499794226", "body": "If only HTTPS supported lets change this to  `if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {`", "bodyText": "If only HTTPS supported lets change this to  if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "bodyHTML": "<p dir=\"auto\">If only HTTPS supported lets change this to  <code>if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {</code></p>", "author": "ulvii", "createdAt": "2020-10-05T18:35:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\nindex a51340d1..c9f85e23 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java\n", "chunk": "@@ -57,7 +58,7 @@ class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n      */\n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+        if (!\"https\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n         }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499800864", "body": "Please change this to multi-line comment.", "bodyText": "Please change this to multi-line comment.", "bodyHTML": "<p dir=\"auto\">Please change this to multi-line comment.</p>", "author": "ulvii", "createdAt": "2020-10-05T18:47:42Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultTokenCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.authenticationCallback = null;\n+    }\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param authenticationCallback The authentication callback that gets invoked when an access token is requested.\n+     */\n+    KeyVaultTokenCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+        this.clientId = null;\n+        this.clientSecret = null;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNDg1OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499904859", "bodyText": "Not resolved.", "author": "ulvii", "createdAt": "2020-10-05T22:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNTI4MA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r500505280", "bodyText": "sorry you're right, this change isn't merged to this PR yet..", "author": "lilgreenbird", "createdAt": "2020-10-06T18:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMDg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -80,9 +79,11 @@ class KeyVaultTokenCredential implements TokenCredential {\n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n         if (null != authenticationCallback) {\n-            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n-            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n-            // token each time it's invoked.\n+            /*\n+             * If the callback is not null, invoke the callback to get the token. This gets invoked each time this\n+             * method is called and will not cache the token. It's the callback's responsibility to return a valid token\n+             * each time it's invoked.\n+             */\n             String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n             return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNjUxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499806511", "body": "For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.", "bodyText": "For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.", "bodyHTML": "<p dir=\"auto\">For consistency, please change this to use the driver's logger.  You can take a look at KerbAuthentication.java for reference usage.</p>", "author": "ulvii", "createdAt": "2020-10-05T18:58:11Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -30,7 +29,6 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n-    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": {"commit": "428f14764f910ec527ce00ede0cdee74c2a6de13", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 06c09be4..3bedc589 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -29,6 +29,8 @@ import reactor.core.publisher.Mono;\n  */\n @Immutable\n class KeyVaultTokenCredential implements TokenCredential {\n+    private static final String NULL_VALUE = \"R_NullValue\";\n+\n     private final String clientId;\n     private final String clientSecret;\n     private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MDg4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499850889", "body": "Could you explain why we log a warning here instead of an exception?  ", "bodyText": "Could you explain why we log a warning here instead of an exception?", "bodyHTML": "<p dir=\"auto\">Could you explain why we log a warning here instead of an exception?</p>", "author": "ulvii", "createdAt": "2020-10-05T20:23:56Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final ClientLogger logger = new ClientLogger(KeyVaultTokenCredential.class);\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param clientId\n+     *        the client ID of the application\n+     * @param clientSecret\n+     *        the secret value of the AAD application\n+     * @throws SQLServerException\n+     */\n+    KeyVaultTokenCredential(String clientId, String clientSecret) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret || clientSecret.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.authenticationCallback = null;\n+    }\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.\n+     *\n+     * @param authenticationCallback The authentication callback that gets invoked when an access token is requested.\n+     */\n+    KeyVaultTokenCredential(SQLServerKeyVaultAuthenticationCallback authenticationCallback) {\n+        this.authenticationCallback = authenticationCallback;\n+        this.clientId = null;\n+        this.clientSecret = null;\n+    }\n+\n+    @Override\n+    public Mono<AccessToken> getToken(TokenRequestContext request) {\n+        if (null != authenticationCallback) {\n+            // If the callback is not null, invoke the callback to get the token. This gets invoked each time\n+            // this method is called and will not cache the token. It's the callback's responsibility to return a valid\n+            // token each time it's invoked.\n+            String accessToken = authenticationCallback.getAccessToken(this.authorization, this.resource, this.scope);\n+            return Mono.just(new AccessToken(accessToken, OffsetDateTime.MIN));\n+        }\n+\n+        // gets the token from MSAL\n+        return authenticateWithConfidentialClientCache(request).onErrorResume(t -> Mono.empty())\n+                .switchIfEmpty(Mono.defer(() -> authenticateWithConfidentialClient(request)));\n+    }\n+\n+    /**\n+     * Sets the authority that will be used for authentication.\n+     *\n+     * @param authorization The name of the authorization.\n+     * @return The updated {@link KeyVaultTokenCredential} instance.\n+     */\n+    KeyVaultTokenCredential setAuthorization(String authorization) {\n+        if (null != this.authorization && this.authorization.equals(authorization)) {\n+            return this;\n+        }\n+        this.authorization = authorization;\n+        confidentialClientApplication = getConfidentialClientApplication();\n+        return this;\n+    }\n+\n+    /**\n+     * Creates an instance of {@link ConfidentialClientApplication} using the provided client id and secret.\n+     *\n+     * @return An instance of {@link ConfidentialClientApplication}.\n+     */\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (null == clientId) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == authorization) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Authorization\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        if (null == clientSecret) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Secret\"};\n+            throw new IllegalArgumentException(form.format(msgArgs1), null);\n+        }\n+\n+        // Create the credential using the MSAL factory method.\n+        IClientCredential credential;\n+        credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        ConfidentialClientApplication.Builder applicationBuilder = ConfidentialClientApplication.builder(clientId,\n+                credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorization);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+        return applicationBuilder.build();\n+    }\n+\n+    /**\n+     * Attempts to get the access token from the client cache if it's not expired. If it's expired this returns an\n+     * empty response.\n+     * @param request The context for requesting the token including the scope.\n+     * @return The cached access token if it's not expired.\n+     */\n+    private Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters\n+                    .builder(new HashSet<>(request.getScopes()));\n+            try {\n+                return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n+            } catch (MalformedURLException e) {", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMDczOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499900738", "bodyText": "it doesn't it's actually throwing a RuntimeException and doesn't need to be logged as that's a fatal error", "author": "lilgreenbird", "createdAt": "2020-10-05T22:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MDg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex de46eed3..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -157,7 +161,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n             try {\n                 return confidentialClientApplication.acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n+                return getFailedCompletableFuture(new RuntimeException(e));\n             }\n         }).map(ar -> new AccessToken(ar.accessToken(),\n                 OffsetDateTime.ofInstant(ar.expiresOnDate().toInstant(), ZoneOffset.UTC))).filter(t -> !t.isExpired());\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzMxMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499853313", "body": "These variables shouldn't be public.", "bodyText": "These variables shouldn't be public.", "bodyHTML": "<p dir=\"auto\">These variables shouldn't be public.</p>", "author": "ulvii", "createdAt": "2020-10-05T20:28:23Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -51,29 +56,35 @@\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    public static final int KEY_NAME_INDEX = 4;", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -56,35 +51,29 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    public static final int KEY_NAME_INDEX = 4;\n-    public static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n-    public static final String KEY_URL_DELIMITER = \"/\";\n-    private HttpPipeline keyVaultPipeline;\n-    private KeyVaultTokenCredential keyVaultTokenCredential;\n-\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n+    private final String baseUrl = \"https://{vaultBaseUrl}\";\n+\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n     private static final List<String> akvTrustedEndpoints;\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }\n+    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-    private TokenCredential credential;\n+    private KeyVaultClient keyVaultClient;\n \n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n+    private KeyVaultCredential credentials;\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -51,29 +55,31 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private KeyVaultClient keyVaultClient;\n-\n-    private KeyVaultCredential credentials;\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..a39efccb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,6 +142,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n+    /**\n+     * A cache of column encryption keys (once they are unwrapped). This is useful for rapidly decrypting multiple data\n+     * values. The default expiration is set to 2 hours.\n+     */\n+    private final SimpleTtlCache<String, byte[]> columnEncryptionKeyCache = new SimpleTtlCache<>();\n+    \n+    /**\n+     * A cache for storing the results of signature verification of column master key metadata.\n+     * The default expiration is set to 10 days.\n+     */\n+    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(Duration.ofDays(10));\n+\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": {"commit": "9de35042413d1edfc76ba0ab9e787355823d62f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a39efccb..80ccba0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -147,12 +146,13 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * values. The default expiration is set to 2 hours.\n      */\n     private final SimpleTtlCache<String, byte[]> columnEncryptionKeyCache = new SimpleTtlCache<>();\n-    \n+\n     /**\n-     * A cache for storing the results of signature verification of column master key metadata.\n-     * The default expiration is set to 10 days.\n+     * A cache for storing the results of signature verification of column master key metadata. The default expiration\n+     * is set to 10 days.\n      */\n-    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(Duration.ofDays(10));\n+    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(\n+            Duration.ofDays(10));\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NzE2MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499857161", "body": "Please revert the changes to this file.", "bodyText": "Please revert the changes to this file.", "bodyHTML": "<p dir=\"auto\">Please revert the changes to this file.</p>", "author": "ulvii", "createdAt": "2020-10-05T20:35:55Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java", "diffHunk": "@@ -1,26 +1,26 @@\n-/*\n- * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n- * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n- */\n-\n-package com.microsoft.sqlserver.jdbc;\n-\n-/**\n- * Provides a callback delegate which is to be implemented by the client code\n- * \n- */\n-public interface SQLServerKeyVaultAuthenticationCallback {\n-\n-    /**\n-     * Returns the acesss token of the authentication request\n-     * \n-     * @param authority\n-     *        - Identifier of the authority, a URL.\n-     * @param resource\n-     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-     * @param scope\n-     *        - The scope of the authentication request.\n-     * @return access token\n-     */\n-    String getAccessToken(String authority, String resource, String scope);\n-}\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+/**\r\n+ * Provides a callback delegate which is to be implemented by the client code\r\n+ *\r\n+ */\r\n+public interface SQLServerKeyVaultAuthenticationCallback {\r\n+\r\n+        /**\r", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\nindex 21199c58..4a954388 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerKeyVaultAuthenticationCallback.java\n", "chunk": "@@ -11,16 +11,16 @@ package com.microsoft.sqlserver.jdbc;\n  */\n public interface SQLServerKeyVaultAuthenticationCallback {\n \n-        /**\n-         * Returns the acesss token of the authentication request\n-         *\n-         * @param authority\n-         *        - Identifier of the authority, a URL.\n-         * @param resource\n-         *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n-         * @param scope\n-         *        - The scope of the authentication request.\n-         * @return access token\n-         */\n-        String getAccessToken(String authority, String resource, String scope);\n+    /**\n+     * Returns the acesss token of the authentication request\n+     *\n+     * @param authority\n+     *        - Identifier of the authority, a URL.\n+     * @param resource\n+     *        - Identifier of the target resource that is the recipient of the requested token, a URL.\n+     * @param scope\n+     *        - The scope of the authentication request.\n+     * @return access token\n+     */\n+    String getAccessToken(String authority, String resource, String scope);\n }\n", "next_change": null}]}}, {"oid": "338f48051d001bf324b2a90de757c3572a6883c7", "url": "https://github.com/microsoft/mssql-jdbc/commit/338f48051d001bf324b2a90de757c3572a6883c7", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-10-05T20:58:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3OTMyOA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499879328", "body": "No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.", "bodyText": "No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.", "bodyHTML": "<p dir=\"auto\">No need to deprecate this constructor anymore, because authenticationCallback works with MSAL now.</p>", "author": "ulvii", "createdAt": "2020-10-05T21:21:03Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -124,56 +198,43 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n+     *\n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,13 +124,12 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -84,96 +90,129 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        setCredential(tokenCredential);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n      * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3ODE2NQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499878165", "body": "Do we need to deprecate this public interface? If so, why?\r\n\r\nI do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?", "bodyText": "Do we need to deprecate this public interface? If so, why?\nI do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?", "bodyHTML": "<p dir=\"auto\">Do we need to deprecate this public interface? If so, why?</p>\n<p dir=\"auto\">I do recall the previous discussion about removing it because we thought we couldn't support it via MSAL. But since we can support it, is there a compelling reason to push applications to the new interface?</p>", "author": "David-Engel", "createdAt": "2020-10-05T21:18:36Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -124,56 +198,43 @@ public SQLServerColumnEncryptionAzureKeyVaultProvider(\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n+     *\n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n+    @Deprecated", "originalCommit": "9c28d9844c1e30f210f1b685859396653a5d7363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMTEyNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499901124", "bodyText": "no it doesn't anymore, I've removed that", "author": "lilgreenbird", "createdAt": "2020-10-05T22:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3ODE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a3949ec5..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -198,13 +124,12 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     /**\n      * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n      * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n+     * \n      * @param authenticationCallback\n      *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(\n             SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n         if (null == authenticationCallback) {\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -84,96 +90,129 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        setCredential(tokenCredential);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n      * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}, {"oid": "9010b5fc89ddc188b425e303a0f99f6429203852", "url": "https://github.com/microsoft/mssql-jdbc/commit/9010b5fc89ddc188b425e303a0f99f6429203852", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-10-05T22:00:52Z", "type": "commit"}, {"oid": "da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "url": "https://github.com/microsoft/mssql-jdbc/commit/da75dccca5d12df3b5d558af7fc3b0e501b9aec0", "message": "updates", "committedDate": "2020-10-05T22:04:41Z", "type": "commit"}, {"oid": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "url": "https://github.com/microsoft/mssql-jdbc/commit/0d509af9f2c34faf3eb5636654af974d1e5528f5", "message": "Merge pull request #5 from lilgreenbird/msal\n\ncleanup and exclude lib", "committedDate": "2020-10-05T22:08:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMDgxMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499900810", "body": "This test should not be removed, it is the only test thats actually using `SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback)`. ", "bodyText": "This test should not be removed, it is the only test thats actually using SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback).", "bodyHTML": "<p dir=\"auto\">This test should not be removed, it is the only test thats actually using <code>SQLServerColumnEncryptionAzureKeyVaultProvider(authenticationCallback)</code>.</p>", "author": "ulvii", "createdAt": "2020-10-05T22:12:09Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java", "diffHunk": "@@ -128,7 +121,7 @@ public void testFedAuthWithAE_AKV() throws SQLException {\n             dropCMK(stmt, cmkName3);\r\n             setupCMK_AKVOld(cmkName3, stmt);\r\n \r\n-            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\r", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 573500cd..4193c9a6 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -121,7 +128,7 @@ public class FedauthWithAE extends FedauthCommon {\n             dropCMK(stmt, cmkName3);\n             setupCMK_AKVOld(cmkName3, stmt);\n \n-            createCEK(cmkName3, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n+            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n             createCharTable(stmt, charTableOld);\n \n             populateCharNormalCase(charValues, connection, charTableOld);\n", "next_change": {"commit": "cd78ffe7b94f194540671a16b510e663b2b904ba", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\nindex 4193c9a6..a34d4ee3 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/fedauth/FedauthWithAE.java\n", "chunk": "@@ -108,39 +102,28 @@ public class FedauthWithAE extends FedauthCommon {\n         try (Connection connection = ds.getConnection(); Statement stmt = connection.createStatement()) {\n             callDbccFreeProcCache();\n \n-            TestUtils.dropTableIfExists(charTableNew, stmt);\n+            TestUtils.dropTableIfExists(charTableAKV, stmt);\n             dropCEK(stmt);\n             dropCMK(stmt, cmkName2);\n-            setupCMK_AKVNew(cmkName2, stmt);\n+            setupCMK_AKV(cmkName2, stmt);\n \n-            createCEK(cmkName2, setupKeyStoreProvider_AKVNew(), stmt, keyIDs[0]);\n-            createCharTable(stmt, charTableNew);\n+            createCEK(cmkName2, setupKeyStoreProvider_AKV(), stmt, keyIDs[0]);\n+            createCharTable(stmt, charTableAKV);\n \n-            populateCharNormalCase(charValues, connection, charTableNew);\n-            testChar(charValues, stmt, charTableNew);\n+            populateCharNormalCase(charValues, connection, charTableAKV);\n+            testChar(charValues, stmt, charTableAKV);\n \n-            TestUtils.dropTableIfExists(charTableNew, stmt);\n+            TestUtils.dropTableIfExists(charTableAKV, stmt);\n             dropCEK(stmt);\n             dropCMK(stmt, cmkName2);\n \n             callDbccFreeProcCache();\n-\n-            dropCMK(stmt, cmkName3);\n-            setupCMK_AKVOld(cmkName3, stmt);\n-\n-            createCEK(cmkName3, setupKeyStoreProvider_AKVOld(), stmt, keyIDs[0]);\n-            createCharTable(stmt, charTableOld);\n-\n-            populateCharNormalCase(charValues, connection, charTableOld);\n-            testChar(charValues, stmt, charTableOld);\n-\n         } catch (SQLServerException e) {\n             fail(e.getMessage());\n         } finally {\n             if (null != ds) {\n                 try (Connection connection = ds.getConnection(); Statement stmt = connection.createStatement()) {\n-                    TestUtils.dropTableIfExists(charTableOld, stmt);\n-                    TestUtils.dropTableIfExists(charTableNew, stmt);\n+                    TestUtils.dropTableIfExists(charTableAKV, stmt);\n                     dropCEK(stmt);\n                     dropCMK(stmt, cmkName1);\n                     dropCMK(stmt, cmkName2);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjcwMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499906703", "body": "What is the actual exception type here? is it being thrown as SQLServerException?", "bodyText": "What is the actual exception type here? is it being thrown as SQLServerException?", "bodyHTML": "<p dir=\"auto\">What is the actual exception type here? is it being thrown as SQLServerException?</p>", "author": "ulvii", "createdAt": "2020-10-05T22:28:53Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java", "diffHunk": "@@ -299,7 +300,9 @@ public void testNumericAkvWithBadCred() throws SQLException {\n             testNumericAKV(connStr);\r\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\r\n         } catch (Exception e) {\r\n-            assert (e.getMessage().contains(\"AuthenticationException\"));\r\n+            assertTrue(e.getCause() instanceof MsalServiceException);\r", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex b4c28a17..7688b098 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -300,7 +300,6 @@ public class MSITest extends AESetup {\n             testNumericAKV(connStr);\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n-            assertTrue(e.getCause() instanceof MsalServiceException);\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n             assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n         }\n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 7688b098..306e23e0 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -301,7 +303,7 @@ public class MSITest extends AESetup {\n             fail(TestResource.getResource(\"R_expectedFailPassed\"));\n         } catch (Exception e) {\n             // https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-aadsts-error-codes\n-            assertTrue(e.getMessage().contains(\"AADSTS700016\"));\n+            assertTrue(e.getMessage().contains(\"AADSTS700016\"), e.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "17253cfcdc605ba5d8d17fccea8bdf1094eb1709", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\nindex 306e23e0..17814b34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/MSITest.java\n", "chunk": "@@ -312,9 +279,6 @@ public class MSITest extends AESetup {\n      */\n     @Test\n     public void testNumericAkvWithCred() throws SQLException {\n-        // unregister the custom providers registered in AESetup\n-        SQLServerConnection.unregisterColumnEncryptionKeyStoreProviders();\n-\n         // add credentials to connection string\n         String connStr = AETestConnectionString;\n         connStr = TestUtils.addOrOverrideProperty(connStr, Constants.KEYSTORE_AUTHENTICATION, \"KeyVaultClientSecret\");\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNjE5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499916192", "body": "Please do not remove this test, it is still valid.", "bodyText": "Please do not remove this test, it is still valid.", "bodyHTML": "<p dir=\"auto\">Please do not remove this test, it is still valid.</p>", "author": "ulvii", "createdAt": "2020-10-05T22:57:58Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -91,18 +92,15 @@ public void testJksName(String serverName, String url, String protocol) throws E\n      */\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n+    @Tag(Constants.reqExternalSetup)\n     public void testAkvName(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n-        try {", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3ODgzMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r502578833", "bodyText": "this is not removed, it's been renamed to testAkvNameWithAuthCallback", "author": "lilgreenbird", "createdAt": "2020-10-09T17:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNjE5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..4829af34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -100,7 +111,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n                 applicationClientID, applicationKey);\n         String keystoreName = \"keystoreName\";\n         akv.setName(keystoreName);\n-        assertTrue(akv.getName().equals(keystoreName));\n+        assertTrue(akv.getName().equals(keystoreName), \"AKV name: \" + akv.getName() + \" keystoreName: \" + keystoreName);\n     }\n \n     /*\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxNzI1MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499917251", "body": "There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.", "bodyText": "There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.", "bodyHTML": "<p dir=\"auto\">There is no tests for this constructor, please add a few tests. I could only find one test, which only tests bad AKV name.</p>", "author": "ulvii", "createdAt": "2020-10-05T23:01:13Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -84,96 +95,126 @@ public String getName() {\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex aae4be84..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -95,126 +84,96 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n-     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Secret key of the client requesting the token.\n+     *        Key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-        if (null == clientKey || clientKey.isEmpty()) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client Key\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        // create a token credential with given client id and secret which internally identifies the tenant id.\n-        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n-        // create the pipeline with the custom Key Vault credential\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n-     * client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        setCredential(new ManagedIdentityCredentialBuilder().build());\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n-     * client at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        if (null == clientId || clientId.isEmpty()) {\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Client ID\"};\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n-     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param tokenCredential\n-     *        The TokenCredential to use to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n-        if (null == tokenCredential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Token Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        setCredential(tokenCredential);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n      *\n-     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n-        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n-    }\n-\n-    /**\n-     * Sets the credential that will be used for authenticating requests to Key Vault service.\n-     * @param credential A credential of type {@link TokenCredential}.\n-     * @throws SQLServerException If the credential is null.\n-     */\n-    private void setCredential(TokenCredential credential) throws SQLServerException {\n-        if (null == credential) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"Credential\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n-        }\n-\n-        this.credential = credential;\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n     }\n \n     /**\n      * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     *\n+     * \n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -84,96 +90,129 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and client\n+     * key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      * \n      * @param clientId\n      *        Identifier of the client requesting the token.\n      * @param clientKey\n-     *        Key of the client requesting the token.\n+     *        Secret key of the client requesting the token.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n     public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+        if (null == clientId || clientId.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client ID\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+        if (null == clientKey || clientKey.isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Client Key\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        // create a token credential with given client id and secret which internally identifies the tenant id.\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(clientId, clientKey);\n+        // create the pipeline with the custom Key Vault credential\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        setCredential(new ManagedIdentityCredentialBuilder().build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by KeyVault\n+     * client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n      * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        if (null == clientId || clientId.isEmpty()) {\n             MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            Object[] msgArgs1 = {\"Client ID\"};\n             throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n+        setCredential(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to authenticate to\n+     * AAD. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param tokenCredential\n+     *        The TokenCredential to use to authenticate to Azure Key Vault.\n      * \n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential) throws SQLServerException {\n+        if (null == tokenCredential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Token Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        setCredential(tokenCredential);\n     }\n \n     /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n      *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n+     * This constructor is present to maintain backwards compatibility with 8.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n      * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n      * @throws SQLServerException\n      *         when an error occurs\n      */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        keyVaultTokenCredential = new KeyVaultTokenCredential(authenticationCallback);\n+        keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultTokenCredential).buildPipeline();\n     }\n \n     /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * Sets the credential that will be used for authenticating requests to Key Vault service.\n      * \n+     * @param credential\n+     *        A credential of type {@link TokenCredential}.\n+     * @throws SQLServerException\n+     *         If the credential is null.\n+     */\n+    private void setCredential(TokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     *\n      * @param masterKeyPath\n      *        - Complete path of an asymmetric key in AKV\n      * @param encryptionAlgorithm\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNzMwNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499927306", "body": "This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.", "bodyText": "This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.", "bodyHTML": "<p dir=\"auto\">This is very interesting syntax but can we either link a source for a spec detailing why we want these specific fields or add some comments to explain. The string field names should also be changed to constants incase it changes in the future.</p>", "author": "rene-ye", "createdAt": "2020-10-05T23:34:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.CoreUtils;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * A policy that authenticates requests with Azure Key Vault service.\n+ */\n+class KeyVaultCustomCredentialPolicy implements HttpPipelinePolicy {\n+    private static final String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n+    private static final String AUTHORIZATION = \"Authorization\";\n+    private final ScopeTokenCache cache;\n+    private final KeyVaultTokenCredential keyVaultTokenCredential;\n+\n+    /**\n+     * Creates KeyVaultCustomCredentialPolicy.\n+     *\n+     * @param credential\n+     *        the token credential to authenticate the request\n+     * @throws SQLServerException\n+     */\n+    KeyVaultCustomCredentialPolicy(KeyVaultTokenCredential credential) throws SQLServerException {\n+        if (null == credential) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"Credential\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n+        }\n+\n+        this.cache = new ScopeTokenCache(credential::getToken);\n+        this.keyVaultTokenCredential = credential;\n+    }\n+\n+    /**\n+     * Adds the required header to authenticate a request to Azure Key Vault service.\n+     *\n+     * @param context\n+     *        The request context\n+     * @param next\n+     *        The next HTTP pipeline policy to process the {@code context's} request after this policy completes.\n+     * @return A {@link Mono} representing the HTTP response that will arrive asynchronously.\n+     */\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(SQLServerException.getErrString(\"R_TokenRequireUrl\")));\n+        }\n+\n+        return next.clone().process()\n+                // Ignore body\n+                .doOnNext(HttpResponse::close).map(res -> res.getHeaderValue(WWW_AUTHENTICATE))\n+                .map(header -> extractChallenge(header, BEARER_TOKEN_PREFIX)).flatMap(map -> {\n+                    keyVaultTokenCredential.setAuthorization(map.get(\"authorization\"));\n+                    keyVaultTokenCredential.setResource(map.get(\"resource\"));\n+                    keyVaultTokenCredential.setScope(map.get(\"scope\"));\n+                    cache.setRequest(new TokenRequestContext().addScopes(map.get(\"resource\") + \"/.default\"));\n+                    return cache.getToken();\n+                }).flatMap(token -> {\n+                    context.getHttpRequest().setHeader(AUTHORIZATION, BEARER_TOKEN_PREFIX + token.getToken());\n+                    return next.process();\n+                });", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODA4OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499928088", "body": "None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  `SQLServerKeyVaultAuthenticationCallback.getAccessToken()` API in 2 ways:\r\n- Using adal4j library, see the sample [here](https://docs.microsoft.com/en-us/sql/connect/jdbc/azure-key-vault-sample-version-7.0?view=sql-server-ver15).\r\n- Using msal4j library, as implemented below.\r\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.", "bodyText": "None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  SQLServerKeyVaultAuthenticationCallback.getAccessToken() API in 2 ways:\n\nUsing adal4j library, see the sample here.\nUsing msal4j library, as implemented below.\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.", "bodyHTML": "<p dir=\"auto\">None of these new tests seem to actually test authenticationCallback .As far as I understand, driver applications will be able to implement  <code>SQLServerKeyVaultAuthenticationCallback.getAccessToken()</code> API in 2 ways:</p>\n<ul dir=\"auto\">\n<li>Using adal4j library, see the sample <a href=\"https://docs.microsoft.com/en-us/sql/connect/jdbc/azure-key-vault-sample-version-7.0?view=sql-server-ver15\" rel=\"nofollow\">here</a>.</li>\n<li>Using msal4j library, as implemented below.<br>\nRegardless of which method the application chooses to use, the driver needs to be able to handle both. Please add appropriate tests for both scenarios. Make sure to use actual CEKs/CMK to encrypt/decrypt instead of using empty CEK.</li>\n</ul>", "author": "ulvii", "createdAt": "2020-10-05T23:37:11Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -2244,22 +2234,69 @@ void testNumerics(SQLServerStatement stmt, String cekName, String[][] table, Str\n         }\n     }\n \n-    SQLServerKeyVaultAuthenticationCallback authenticationCallback = new SQLServerKeyVaultAuthenticationCallback() {\n-        // @Override\n-        ExecutorService service = Executors.newFixedThreadPool(2);\n+    @ParameterizedTest", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODY5Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499928693", "body": "Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.", "bodyText": "Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.", "bodyHTML": "<p dir=\"auto\">Again, we are not removing the SQLServerKeyVaultAuthenticationCallback anymore, so keep this test as it is and add a test for TokenCredential separately.</p>", "author": "ulvii", "createdAt": "2020-10-05T23:39:38Z", "path": "src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java", "diffHunk": "@@ -134,7 +132,7 @@ public void testBadAkv(String serverName, String url, String protocol) throws Ex\n \n         try {\n             SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n-                    (SQLServerKeyVaultAuthenticationCallback) null);\n+                    (TokenCredential) null);", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex c073fee2..55cad5f1 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -122,12 +132,30 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n     }\n \n     /*\n-     * Test bad Azure Key Vault\n+     * Test bad Azure Key Vault using SQLServerKeyVaultAuthenticationCallback\n      */\n     @SuppressWarnings(\"unused\")\n     @ParameterizedTest\n     @MethodSource(\"enclaveParams\")\n-    public void testBadAkv(String serverName, String url, String protocol) throws Exception {\n+    public void testBadAkvCallback(String serverName, String url, String protocol) throws Exception {\n+        setAEConnectionString(serverName, url, protocol);\n+\n+        try {\n+            SQLServerColumnEncryptionAzureKeyVaultProvider akv = new SQLServerColumnEncryptionAzureKeyVaultProvider(\n+                    (SQLServerKeyVaultAuthenticationCallback) null);\n+            fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+        }\n+    }\n+\n+    /*\n+     * Test bad Azure Key Vault using TokenCredential\n+     */\n+    @SuppressWarnings(\"unused\")\n+    @ParameterizedTest\n+    @MethodSource(\"enclaveParams\")\n+    public void testBadAkvTokenCredential(String serverName, String url, String protocol) throws Exception {\n         setAEConnectionString(serverName, url, protocol);\n \n         try {\n", "next_change": {"commit": "17569c6aa1347d1c691581055c4f7a98fc0ab813", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\nindex 55cad5f1..4829af34 100644\n--- a/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/jdbc/AlwaysEncrypted/JDBCEncryptionDecryptionTest.java\n", "chunk": "@@ -163,7 +164,7 @@ public class JDBCEncryptionDecryptionTest extends AESetup {\n                     (TokenCredential) null);\n             fail(TestResource.getResource(\"R_expectedExceptionNotThrown\"));\n         } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")));\n+            assertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_NullValue\")), e.getMessage());\n         }\n     }\n \n", "next_change": null}]}}]}}, {"oid": "33c276a47484a0dad04d71dd96f6325bba705847", "url": "https://github.com/microsoft/mssql-jdbc/commit/33c276a47484a0dad04d71dd96f6325bba705847", "message": "formatting and reive updates", "committedDate": "2020-10-06T00:01:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5ODA0Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r499998046", "body": "Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?", "bodyText": "Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?", "bodyHTML": "<p dir=\"auto\">Shouldn't the comment here and below for the constructors say \"Creates a KeyVaultTokenCredential\" instead of \"Creates  a KeyVaultCredential\"?</p>", "author": "peterbae", "createdAt": "2020-10-06T04:24:05Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\n+ */\n+\n+package com.microsoft.sqlserver.jdbc;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.microsoft.aad.msal4j.ClientCredentialFactory;\n+import com.microsoft.aad.msal4j.ClientCredentialParameters;\n+import com.microsoft.aad.msal4j.ConfidentialClientApplication;\n+import com.microsoft.aad.msal4j.IAuthenticationResult;\n+import com.microsoft.aad.msal4j.IClientCredential;\n+import com.microsoft.aad.msal4j.SilentParameters;\n+import java.net.MalformedURLException;\n+import java.text.MessageFormat;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import reactor.core.publisher.Mono;\n+\n+\n+/**\n+ * An AAD credential that acquires a token with a client secret for an AAD application.\n+ */\n+@Immutable\n+class KeyVaultTokenCredential implements TokenCredential {\n+    private final String clientId;\n+    private final String clientSecret;\n+    private final SQLServerKeyVaultAuthenticationCallback authenticationCallback;\n+    private String authorization;\n+    private ConfidentialClientApplication confidentialClientApplication;\n+    private String resource;\n+    private String scope;\n+\n+    /**\n+     * Creates a KeyVaultCredential with the given identity client options.", "originalCommit": "0d509af9f2c34faf3eb5636654af974d1e5528f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\nindex 0593bb83..06c09be4 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultTokenCredential.java\n", "chunk": "@@ -38,7 +38,7 @@ class KeyVaultTokenCredential implements TokenCredential {\n     private String scope;\n \n     /**\n-     * Creates a KeyVaultCredential with the given identity client options.\n+     * Creates a KeyVaultTokenCredential with the given identity client options.\n      *\n      * @param clientId\n      *        the client ID of the application\n", "next_change": null}]}}, {"oid": "ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "url": "https://github.com/microsoft/mssql-jdbc/commit/ad27b884cabfdd2b530b0b4a06b7f3dc5fc2d8dd", "message": "Rebase from remote branch", "committedDate": "2020-10-06T08:16:04Z", "type": "commit"}, {"oid": "089933342f5ea3e3c478f5b0152adbb91a456984", "url": "https://github.com/microsoft/mssql-jdbc/commit/089933342f5ea3e3c478f5b0152adbb91a456984", "message": "Update tests", "committedDate": "2020-10-06T08:17:41Z", "type": "commit"}, {"oid": "a4a99ec4da0e02a8413dfef87a91b0ee98b04b36", "url": "https://github.com/microsoft/mssql-jdbc/commit/a4a99ec4da0e02a8413dfef87a91b0ee98b04b36", "message": "Rebase from remote branch", "committedDate": "2020-10-06T08:18:10Z", "type": "commit"}, {"oid": "ca36f3469bdb927f1f01075b91e9a24e6a55f09d", "url": "https://github.com/microsoft/mssql-jdbc/commit/ca36f3469bdb927f1f01075b91e9a24e6a55f09d", "message": "Update pom.xml", "committedDate": "2020-10-06T08:21:38Z", "type": "commit"}, {"oid": "2bf012bdab01468aec967f17b8ae9bef86958deb", "url": "https://github.com/microsoft/mssql-jdbc/commit/2bf012bdab01468aec967f17b8ae9bef86958deb", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-10-06T21:34:36Z", "type": "commit"}, {"oid": "9e38cc336d505b58956d9674881763d5b9b70937", "url": "https://github.com/microsoft/mssql-jdbc/commit/9e38cc336d505b58956d9674881763d5b9b70937", "message": "Merge pull request #6 from lilgreenbird/msal\n\nMsal", "committedDate": "2020-10-06T21:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyODYxMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r500628613", "body": "Can just declare `private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();` since `getTrustedEndpoints` is static.", "bodyText": "Can just declare private static final List<String> akvTrustedEndpoints = getTrustedEndpoints(); since getTrustedEndpoints is static.", "bodyHTML": "<p dir=\"auto\">Can just declare <code>private static final List&lt;String&gt; akvTrustedEndpoints = getTrustedEndpoints();</code> since <code>getTrustedEndpoints</code> is static.</p>", "author": "rene-ye", "createdAt": "2020-10-06T22:20:31Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -51,29 +55,35 @@\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n     private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private KeyVaultClient keyVaultClient;\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n \n-    private KeyVaultCredential credentials;\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }", "originalCommit": "9e38cc336d505b58956d9674881763d5b9b70937", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 79383446..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -55,35 +51,29 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    private static final int KEY_NAME_INDEX = 4;\n-    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n-    private static final String KEY_URL_DELIMITER = \"/\";\n-    private HttpPipeline keyVaultPipeline;\n-    private KeyVaultTokenCredential keyVaultTokenCredential;\n-\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n+    private final String baseUrl = \"https://{vaultBaseUrl}\";\n+\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n     private static final List<String> akvTrustedEndpoints;\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }\n+    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-    private TokenCredential credential;\n+    private KeyVaultClient keyVaultClient;\n \n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n+    private KeyVaultCredential credentials;\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": {"commit": "6769d4ab4af1ae8fda7bcd1f4c1b30773be4bced", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..d5f0f237 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -51,29 +55,31 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n \n     private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n             .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    private static final int KEY_NAME_INDEX = 4;\n+    private static final int KEY_URL_SPLIT_LENGTH_WITH_VERSION = 6;\n+    private static final String KEY_URL_DELIMITER = \"/\";\n+    private HttpPipeline keyVaultPipeline;\n+    private KeyVaultTokenCredential keyVaultTokenCredential;\n+\n     /**\n      * Column Encryption Key Store Provider string\n      */\n     String name = \"AZURE_KEY_VAULT\";\n \n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n     private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n     private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n+    private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+    private static final List<String> akvTrustedEndpoints = getTrustedEndpoints();\n \n     /**\n      * Algorithm version\n      */\n     private final byte[] firstVersion = new byte[] {0x01};\n \n-    private KeyVaultClient keyVaultClient;\n-\n-    private KeyVaultCredential credentials;\n+    private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+    private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+    private TokenCredential credential;\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex d5f0f237..a39efccb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -81,6 +142,18 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n     private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n     private TokenCredential credential;\n \n+    /**\n+     * A cache of column encryption keys (once they are unwrapped). This is useful for rapidly decrypting multiple data\n+     * values. The default expiration is set to 2 hours.\n+     */\n+    private final SimpleTtlCache<String, byte[]> columnEncryptionKeyCache = new SimpleTtlCache<>();\n+    \n+    /**\n+     * A cache for storing the results of signature verification of column master key metadata.\n+     * The default expiration is set to 10 days.\n+     */\n+    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(Duration.ofDays(10));\n+\n     public void setName(String name) {\n         this.name = name;\n     }\n", "next_change": {"commit": "9de35042413d1edfc76ba0ab9e787355823d62f5", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex a39efccb..80ccba0a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -147,12 +146,13 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n      * values. The default expiration is set to 2 hours.\n      */\n     private final SimpleTtlCache<String, byte[]> columnEncryptionKeyCache = new SimpleTtlCache<>();\n-    \n+\n     /**\n-     * A cache for storing the results of signature verification of column master key metadata.\n-     * The default expiration is set to 10 days.\n+     * A cache for storing the results of signature verification of column master key metadata. The default expiration\n+     * is set to 10 days.\n      */\n-    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(Duration.ofDays(10));\n+    private final SimpleTtlCache<CMKMetadataSignatureInfo, Boolean> cmkMetadataSignatureVerificationCache = new SimpleTtlCache<>(\n+            Duration.ofDays(10));\n \n     public void setName(String name) {\n         this.name = name;\n", "next_change": null}]}}]}}]}}]}}, {"oid": "7a035c6333044677e99dbc96114959c49e10e954", "url": "https://github.com/microsoft/mssql-jdbc/commit/7a035c6333044677e99dbc96114959c49e10e954", "message": "review updates", "committedDate": "2020-10-08T23:36:11Z", "type": "commit"}, {"oid": "a6308974dfe7b2d7106292f069c697a83b5ad5de", "url": "https://github.com/microsoft/mssql-jdbc/commit/a6308974dfe7b2d7106292f069c697a83b5ad5de", "message": "catch exception", "committedDate": "2020-10-09T00:26:28Z", "type": "commit"}, {"oid": "48cacfad6362e53ec29bd3132187989c7bcadb15", "url": "https://github.com/microsoft/mssql-jdbc/commit/48cacfad6362e53ec29bd3132187989c7bcadb15", "message": "Merge pull request #7 from lilgreenbird/msal\n\nAdded tests and catch exception from getKeyClient", "committedDate": "2020-10-09T17:30:18Z", "type": "commit"}, {"oid": "793207e04ec7d1f9990044a64c3e6eabab8240f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/793207e04ec7d1f9990044a64c3e6eabab8240f4", "message": "added test for token credential", "committedDate": "2020-10-09T22:26:32Z", "type": "commit"}, {"oid": "1a22d786577af55749e218ac694a61b1944500c8", "url": "https://github.com/microsoft/mssql-jdbc/commit/1a22d786577af55749e218ac694a61b1944500c8", "message": "Merge pull request #8 from lilgreenbird/msal\n\nadded test for token credential and other cosmetic fixes", "committedDate": "2020-10-09T22:39:52Z", "type": "commit"}, {"oid": "8f483e2a14477e6410cd7380f2372c6a0bb28cea", "url": "https://github.com/microsoft/mssql-jdbc/commit/8f483e2a14477e6410cd7380f2372c6a0bb28cea", "message": "added tenantID property", "committedDate": "2020-10-10T00:25:07Z", "type": "commit"}, {"oid": "c97b863c95385bdcd1afc897ef39cbebaf495578", "url": "https://github.com/microsoft/mssql-jdbc/commit/c97b863c95385bdcd1afc897ef39cbebaf495578", "message": "Fix AEv2 tests exclude for reqExternalSetup and cleanup (#1247)", "committedDate": "2020-02-05T19:03:48Z", "type": "commit"}, {"oid": "54b5a194e5d46552419c86e0d1f8c800f42d3de8", "url": "https://github.com/microsoft/mssql-jdbc/commit/54b5a194e5d46552419c86e0d1f8c800f42d3de8", "message": "Fix | Add null check for getObject() with LocalTime and LocalDate (#1250)", "committedDate": "2020-02-08T00:19:05Z", "type": "commit"}, {"oid": "672b7d67caae75250c53f82a760e8d3880e62a37", "url": "https://github.com/microsoft/mssql-jdbc/commit/672b7d67caae75250c53f82a760e8d3880e62a37", "message": "added all AKV tests to use reqExternalSetup tag so they will be skipped by default (#1254)\n\n* skip AKV test properly\r\n\r\n* removed enclave properties string to failed errors as enclave tests could be skipped", "committedDate": "2020-02-10T19:04:22Z", "type": "commit"}, {"oid": "3c3331b7b0ff1b27b1e80271bf9ffdc6aae7be79", "url": "https://github.com/microsoft/mssql-jdbc/commit/3c3331b7b0ff1b27b1e80271bf9ffdc6aae7be79", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-25T06:21:47Z", "type": "commit"}, {"oid": "e2c5640370daa89c0d8c1559b5791e99656f78c8", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2c5640370daa89c0d8c1559b5791e99656f78c8", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-26T06:10:08Z", "type": "commit"}, {"oid": "aad696640378b75f3cb8cb24cc2fa299358db9ac", "url": "https://github.com/microsoft/mssql-jdbc/commit/aad696640378b75f3cb8cb24cc2fa299358db9ac", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-28T03:18:02Z", "type": "commit"}, {"oid": "92bf04c2787c3b2a704f641f50cb4a83193f1d6d", "url": "https://github.com/microsoft/mssql-jdbc/commit/92bf04c2787c3b2a704f641f50cb4a83193f1d6d", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-03-31T01:58:20Z", "type": "commit"}, {"oid": "3ba5ab72008501e23f43dbcbcc333775320ddafa", "url": "https://github.com/microsoft/mssql-jdbc/commit/3ba5ab72008501e23f43dbcbcc333775320ddafa", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-04T05:47:37Z", "type": "commit"}, {"oid": "d20823deffea162b2b17b079cc291f91269558aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/d20823deffea162b2b17b079cc291f91269558aa", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-07T00:45:05Z", "type": "commit"}, {"oid": "4cc959f7e76eedbf49e30e5b92de43c86d7eb803", "url": "https://github.com/microsoft/mssql-jdbc/commit/4cc959f7e76eedbf49e30e5b92de43c86d7eb803", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-29T02:59:23Z", "type": "commit"}, {"oid": "7b301f8184b26da4d99b2feab8b2aea886c01cea", "url": "https://github.com/microsoft/mssql-jdbc/commit/7b301f8184b26da4d99b2feab8b2aea886c01cea", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-04-30T06:36:21Z", "type": "commit"}, {"oid": "56bcf139fe6acd87c41b3829b4f157c59bd9f873", "url": "https://github.com/microsoft/mssql-jdbc/commit/56bcf139fe6acd87c41b3829b4f157c59bd9f873", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-07T22:26:03Z", "type": "commit"}, {"oid": "744e0ca78e57bc6c0db98910a9066d5b583c6ba8", "url": "https://github.com/microsoft/mssql-jdbc/commit/744e0ca78e57bc6c0db98910a9066d5b583c6ba8", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-12T22:47:18Z", "type": "commit"}, {"oid": "df8fd41ffa6005b18b0e328593faaeb495ce6547", "url": "https://github.com/microsoft/mssql-jdbc/commit/df8fd41ffa6005b18b0e328593faaeb495ce6547", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-19T01:06:51Z", "type": "commit"}, {"oid": "652e68b110828db6b172c1b02df6a06ab04c2b59", "url": "https://github.com/microsoft/mssql-jdbc/commit/652e68b110828db6b172c1b02df6a06ab04c2b59", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-26T07:07:35Z", "type": "commit"}, {"oid": "53736db944298004a4a383be14ae83370ffab717", "url": "https://github.com/microsoft/mssql-jdbc/commit/53736db944298004a4a383be14ae83370ffab717", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-05-26T23:02:59Z", "type": "commit"}, {"oid": "9ba6a42285fcc046a0a68e110454b62d8f7f6657", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ba6a42285fcc046a0a68e110454b62d8f7f6657", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-02T06:50:57Z", "type": "commit"}, {"oid": "6d156f728a1253dd469da1c6896189762b00097b", "url": "https://github.com/microsoft/mssql-jdbc/commit/6d156f728a1253dd469da1c6896189762b00097b", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-05T19:15:40Z", "type": "commit"}, {"oid": "e08ffe5f54050344920bc48d44dc8e04cd143866", "url": "https://github.com/microsoft/mssql-jdbc/commit/e08ffe5f54050344920bc48d44dc8e04cd143866", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-10T21:34:05Z", "type": "commit"}, {"oid": "6b6cab266b655c48858187f56071aa3e4ba87054", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b6cab266b655c48858187f56071aa3e4ba87054", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-18T19:14:21Z", "type": "commit"}, {"oid": "f4555d66335e5ea3b053b9af303383cbfd50ef42", "url": "https://github.com/microsoft/mssql-jdbc/commit/f4555d66335e5ea3b053b9af303383cbfd50ef42", "message": "First pass at porting to new Key Vault", "committedDate": "2020-06-24T04:57:40Z", "type": "commit"}, {"oid": "c2025901e1c9e8b279f42279da2f25ffd6c4232a", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2025901e1c9e8b279f42279da2f25ffd6c4232a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-24T18:58:46Z", "type": "commit"}, {"oid": "0515d4b0d51c3150b2149438f8b8a69be3dfc2bd", "url": "https://github.com/microsoft/mssql-jdbc/commit/0515d4b0d51c3150b2149438f8b8a69be3dfc2bd", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-24T20:34:25Z", "type": "commit"}, {"oid": "892eb2be48d9d9706004c96ca43e9400eaea1197", "url": "https://github.com/microsoft/mssql-jdbc/commit/892eb2be48d9d9706004c96ca43e9400eaea1197", "message": "Everything now compiles, but I'm sure there are numerous bugs, and testing has not been run yet.", "committedDate": "2020-06-25T01:42:07Z", "type": "commit"}, {"oid": "088d2f73cdd507404c2fe6398f78647c3b84a31c", "url": "https://github.com/microsoft/mssql-jdbc/commit/088d2f73cdd507404c2fe6398f78647c3b84a31c", "message": "Beginning to re-enable some disabled unit tests", "committedDate": "2020-06-25T02:39:22Z", "type": "commit"}, {"oid": "30e7fdf4c6b4a185132ca36d661e29371727e13f", "url": "https://github.com/microsoft/mssql-jdbc/commit/30e7fdf4c6b4a185132ca36d661e29371727e13f", "message": "Add requirement for a tenant ID to be set to run tests", "committedDate": "2020-06-25T03:48:10Z", "type": "commit"}, {"oid": "2c63b5828becf3f737f4edf95593d98ada4e273a", "url": "https://github.com/microsoft/mssql-jdbc/commit/2c63b5828becf3f737f4edf95593d98ada4e273a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-06-25T06:36:46Z", "type": "commit"}, {"oid": "2d62262aa453ecf96807f5f52b6f9a1bd908e4ca", "url": "https://github.com/microsoft/mssql-jdbc/commit/2d62262aa453ecf96807f5f52b6f9a1bd908e4ca", "message": "Minor tidy ups", "committedDate": "2020-06-30T02:04:24Z", "type": "commit"}, {"oid": "a6b75cdaf634a3899fd5586d0418df181d9e9cef", "url": "https://github.com/microsoft/mssql-jdbc/commit/a6b75cdaf634a3899fd5586d0418df181d9e9cef", "message": "Upgrade gradle file to include equivalent dependencies as in pom.xml, and remove try / catch in some test code where it is not required.", "committedDate": "2020-06-30T02:18:19Z", "type": "commit"}, {"oid": "78aa941fab02af4aef190c7da6141b1251a84b4b", "url": "https://github.com/microsoft/mssql-jdbc/commit/78aa941fab02af4aef190c7da6141b1251a84b4b", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-02T18:43:21Z", "type": "commit"}, {"oid": "90e99cd54a0cb4347f813d965ea38b0a9801e8b0", "url": "https://github.com/microsoft/mssql-jdbc/commit/90e99cd54a0cb4347f813d965ea38b0a9801e8b0", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-02T20:57:03Z", "type": "commit"}, {"oid": "5e373227bfc1deec11a6d8d5c820afabb00d38aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/5e373227bfc1deec11a6d8d5c820afabb00d38aa", "message": "add -DtenantID=$(tenantID)", "committedDate": "2020-07-03T20:28:32Z", "type": "commit"}, {"oid": "1df8828c03c162c6685f095f211fa8c8e51fccfc", "url": "https://github.com/microsoft/mssql-jdbc/commit/1df8828c03c162c6685f095f211fa8c8e51fccfc", "message": "Merge pull request #1 from peterbae/keyvault-upgrade\n\nAdd tenantID", "committedDate": "2020-07-05T20:44:52Z", "type": "commit"}, {"oid": "da1004bb9862d31941e537e77bd0e2ded5edef96", "url": "https://github.com/microsoft/mssql-jdbc/commit/da1004bb9862d31941e537e77bd0e2ded5edef96", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-06T22:39:35Z", "type": "commit"}, {"oid": "8c9a94473deee94dd40f928a710d2b2b279b45e3", "url": "https://github.com/microsoft/mssql-jdbc/commit/8c9a94473deee94dd40f928a710d2b2b279b45e3", "message": "Updating APIs to propagate tenantId. Still I am sure the tests will fail, but this is a step in the right direction.", "committedDate": "2020-07-06T23:25:56Z", "type": "commit"}, {"oid": "f7f12d9d6bb5a868e6bf4d127a34be75353727f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7f12d9d6bb5a868e6bf4d127a34be75353727f7", "message": "Merge branch 'keyvault-upgrade' of github.com:JonathanGiles/mssql-jdbc into keyvault-upgrade", "committedDate": "2020-07-06T23:26:24Z", "type": "commit"}, {"oid": "cc0ac7f33655ab1e105c12cd6da9abe06a6830bc", "url": "https://github.com/microsoft/mssql-jdbc/commit/cc0ac7f33655ab1e105c12cd6da9abe06a6830bc", "message": "Updating method call to add missing tenantId", "committedDate": "2020-07-06T23:31:09Z", "type": "commit"}, {"oid": "86fc00cbd8813fc9b2888a2dd078291753ffcf7c", "url": "https://github.com/microsoft/mssql-jdbc/commit/86fc00cbd8813fc9b2888a2dd078291753ffcf7c", "message": "Wiring in vaultBaseUrl env var lookup for Key Vault", "committedDate": "2020-07-06T23:50:31Z", "type": "commit"}, {"oid": "8fec202dca9cf413dfdadca1f99a89cd6d454fb3", "url": "https://github.com/microsoft/mssql-jdbc/commit/8fec202dca9cf413dfdadca1f99a89cd6d454fb3", "message": "Debugging key path format (hopefully)", "committedDate": "2020-07-07T00:01:29Z", "type": "commit"}, {"oid": "9f44f0f45a6daa99b2a121bfc62a59491e867821", "url": "https://github.com/microsoft/mssql-jdbc/commit/9f44f0f45a6daa99b2a121bfc62a59491e867821", "message": "Clean up algorithm code", "committedDate": "2020-07-07T00:10:22Z", "type": "commit"}, {"oid": "dab428f8ed0c1fce1dc3dc2158c1c233f701bb2e", "url": "https://github.com/microsoft/mssql-jdbc/commit/dab428f8ed0c1fce1dc3dc2158c1c233f701bb2e", "message": "Adding validation for vaultBaseURL", "committedDate": "2020-07-07T00:22:10Z", "type": "commit"}, {"oid": "9ca12848377fad04ad8f8d2a29258ea8500f70d2", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ca12848377fad04ad8f8d2a29258ea8500f70d2", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-07-28T07:45:46Z", "type": "commit"}, {"oid": "c67d8edea9341b2b94a075ecbbc4768e313f0658", "url": "https://github.com/microsoft/mssql-jdbc/commit/c67d8edea9341b2b94a075ecbbc4768e313f0658", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-01T00:41:25Z", "type": "commit"}, {"oid": "1d0a4adf7296966d52421ace5011fcc2fcc3147a", "url": "https://github.com/microsoft/mssql-jdbc/commit/1d0a4adf7296966d52421ace5011fcc2fcc3147a", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-05T00:02:31Z", "type": "commit"}, {"oid": "398c2d86514e4e31e61ddfd5cf9e2ac83b3c56cf", "url": "https://github.com/microsoft/mssql-jdbc/commit/398c2d86514e4e31e61ddfd5cf9e2ac83b3c56cf", "message": "Fixes for Key and Crypto client", "committedDate": "2020-08-12T21:10:43Z", "type": "commit"}, {"oid": "1b363f7659ec1ed2576b616c97608063a541812e", "url": "https://github.com/microsoft/mssql-jdbc/commit/1b363f7659ec1ed2576b616c97608063a541812e", "message": "Merge pull request #2 from srnagar/keyvault-upgrade\n\nFixes for Key and Crypto client", "committedDate": "2020-08-12T21:16:05Z", "type": "commit"}, {"oid": "948939f99833c8741f42c97fc82b80a33d16cbf1", "url": "https://github.com/microsoft/mssql-jdbc/commit/948939f99833c8741f42c97fc82b80a33d16cbf1", "message": "Merge from master", "committedDate": "2020-08-12T21:22:10Z", "type": "commit"}, {"oid": "6d014b55e3d91988b2c09223dbff95d975d95fd5", "url": "https://github.com/microsoft/mssql-jdbc/commit/6d014b55e3d91988b2c09223dbff95d975d95fd5", "message": "Merge pull request #3 from srnagar/keyvault-upgrade\n\nMerge from master to resolve conflicts.", "committedDate": "2020-08-12T21:25:11Z", "type": "commit"}, {"oid": "dcf2f79d8dae25e5dce29f6c8f132f60f0a52de4", "url": "https://github.com/microsoft/mssql-jdbc/commit/dcf2f79d8dae25e5dce29f6c8f132f60f0a52de4", "message": "Fix compilation errors after merging from master", "committedDate": "2020-08-12T23:33:34Z", "type": "commit"}, {"oid": "62a83e4ad025e0377552869844b0f2ce074ba2b6", "url": "https://github.com/microsoft/mssql-jdbc/commit/62a83e4ad025e0377552869844b0f2ce074ba2b6", "message": "Merge pull request #4 from srnagar/keyvault-upgrade\n\nFix compilation errors after merging from master", "committedDate": "2020-08-12T23:36:35Z", "type": "commit"}, {"oid": "73d160fb9b57cba324a766edadcc96a6b7bec5f1", "url": "https://github.com/microsoft/mssql-jdbc/commit/73d160fb9b57cba324a766edadcc96a6b7bec5f1", "message": "Add tenantID to pipeline yml", "committedDate": "2020-08-13T08:14:10Z", "type": "commit"}, {"oid": "fba2a23884398f5bd0b5ff012b317166db80bc1b", "url": "https://github.com/microsoft/mssql-jdbc/commit/fba2a23884398f5bd0b5ff012b317166db80bc1b", "message": "Merge pull request #5 from srnagar/keyvault-upgrade\n\nAdd tenantID to pipeline yml", "committedDate": "2020-08-13T08:17:24Z", "type": "commit"}, {"oid": "54642abbb1caf15cdd9148d7360a2684adf68460", "url": "https://github.com/microsoft/mssql-jdbc/commit/54642abbb1caf15cdd9148d7360a2684adf68460", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-13T18:56:11Z", "type": "commit"}, {"oid": "f006a63e331016e1a6bdfbe42095156711a21bde", "url": "https://github.com/microsoft/mssql-jdbc/commit/f006a63e331016e1a6bdfbe42095156711a21bde", "message": "Fix unit test", "committedDate": "2020-08-13T19:54:01Z", "type": "commit"}, {"oid": "b2db031c2e2aca675d9ba87068b14ab878cce5fc", "url": "https://github.com/microsoft/mssql-jdbc/commit/b2db031c2e2aca675d9ba87068b14ab878cce5fc", "message": "Merge pull request #6 from srnagar/keyvault-upgrade\n\nFix unit test", "committedDate": "2020-08-13T19:55:57Z", "type": "commit"}, {"oid": "96e32f4c156d31264f14b91f786bcf06044726d7", "url": "https://github.com/microsoft/mssql-jdbc/commit/96e32f4c156d31264f14b91f786bcf06044726d7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-13T22:22:11Z", "type": "commit"}, {"oid": "47a7b945ce8e84c88498c31d688556a24d4f0d7f", "url": "https://github.com/microsoft/mssql-jdbc/commit/47a7b945ce8e84c88498c31d688556a24d4f0d7f", "message": "Address PR comments", "committedDate": "2020-08-18T00:53:42Z", "type": "commit"}, {"oid": "9b1cac05c0bd83f343d95921b88b754a7ebe6707", "url": "https://github.com/microsoft/mssql-jdbc/commit/9b1cac05c0bd83f343d95921b88b754a7ebe6707", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-18T00:54:59Z", "type": "commit"}, {"oid": "fcf327e11ba401078d988e7c13da18120de14a44", "url": "https://github.com/microsoft/mssql-jdbc/commit/fcf327e11ba401078d988e7c13da18120de14a44", "message": "Merge pull request #7 from srnagar/keyvault-upgrade\n\nKeyvault upgrade", "committedDate": "2020-08-18T01:07:13Z", "type": "commit"}, {"oid": "23b7f6a96e404bf08237cd07e7c2ce9bfcf11589", "url": "https://github.com/microsoft/mssql-jdbc/commit/23b7f6a96e404bf08237cd07e7c2ce9bfcf11589", "message": "Remove tenant Id and fix adal issues", "committedDate": "2020-08-18T20:25:10Z", "type": "commit"}, {"oid": "4121bc57cb984891fef55cc5af6fce68304f0208", "url": "https://github.com/microsoft/mssql-jdbc/commit/4121bc57cb984891fef55cc5af6fce68304f0208", "message": "Merge pull request #8 from srnagar/keyvault-upgrade\n\nRemove tenant Id and fix adal issues", "committedDate": "2020-08-18T20:32:33Z", "type": "commit"}, {"oid": "bca00d2aa8c8e7968ef1641e1468cf4e8ea3fa69", "url": "https://github.com/microsoft/mssql-jdbc/commit/bca00d2aa8c8e7968ef1641e1468cf4e8ea3fa69", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-18T21:09:51Z", "type": "commit"}, {"oid": "37c676d7aea6b43c7d347e353476a544da38b29f", "url": "https://github.com/microsoft/mssql-jdbc/commit/37c676d7aea6b43c7d347e353476a544da38b29f", "message": "Fix test failures", "committedDate": "2020-08-18T23:25:18Z", "type": "commit"}, {"oid": "8e8517b4797d404c2ff65f9f34230fe421dd3c3a", "url": "https://github.com/microsoft/mssql-jdbc/commit/8e8517b4797d404c2ff65f9f34230fe421dd3c3a", "message": "Merge pull request #9 from srnagar/keyvault-upgrade\n\nFix test failures", "committedDate": "2020-08-18T23:26:53Z", "type": "commit"}, {"oid": "b2eb9cb166f80d496b3bbcd030397e12d9c85455", "url": "https://github.com/microsoft/mssql-jdbc/commit/b2eb9cb166f80d496b3bbcd030397e12d9c85455", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-19T00:10:13Z", "type": "commit"}, {"oid": "ee3b5c88ceb8542bef086ff2d109247f07491032", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee3b5c88ceb8542bef086ff2d109247f07491032", "message": "Use cached key and crypto clients", "committedDate": "2020-08-19T00:58:23Z", "type": "commit"}, {"oid": "48c6dac906e5d5553440105ec9f806a56255797a", "url": "https://github.com/microsoft/mssql-jdbc/commit/48c6dac906e5d5553440105ec9f806a56255797a", "message": "Merge pull request #10 from srnagar/keyvault-upgrade\n\nUse cached key and crypto clients", "committedDate": "2020-08-19T01:36:24Z", "type": "commit"}, {"oid": "6baad02d1a21995d197a88ab220616c56ea2c431", "url": "https://github.com/microsoft/mssql-jdbc/commit/6baad02d1a21995d197a88ab220616c56ea2c431", "message": "Update license header and cleanup pipeline builder", "committedDate": "2020-08-20T00:05:34Z", "type": "commit"}, {"oid": "a053426d5a30ccc86aaf6478810e1bba7dce5ccc", "url": "https://github.com/microsoft/mssql-jdbc/commit/a053426d5a30ccc86aaf6478810e1bba7dce5ccc", "message": "Merge pull request #11 from srnagar/keyvault-upgrade\n\nUpdate license header and cleanup pipeline builder", "committedDate": "2020-08-20T00:07:43Z", "type": "commit"}, {"oid": "0a3cb0f316c1d29ea29298402f02b15b8d872578", "url": "https://github.com/microsoft/mssql-jdbc/commit/0a3cb0f316c1d29ea29298402f02b15b8d872578", "message": "Fix unit tests", "committedDate": "2020-08-20T04:40:06Z", "type": "commit"}, {"oid": "1bf984a45b4d0b4478be3fdcbcd853a3bf088b96", "url": "https://github.com/microsoft/mssql-jdbc/commit/1bf984a45b4d0b4478be3fdcbcd853a3bf088b96", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-20T18:23:00Z", "type": "commit"}, {"oid": "684ecce1f043edeb5621f8b3dc956b3b59d7024f", "url": "https://github.com/microsoft/mssql-jdbc/commit/684ecce1f043edeb5621f8b3dc956b3b59d7024f", "message": "Merge pull request #12 from srnagar/keyvault-upgrade\n\nFix unit tests", "committedDate": "2020-08-20T18:27:52Z", "type": "commit"}, {"oid": "62ab01a648baa75f4c44940fb43b8c56b4142845", "url": "https://github.com/microsoft/mssql-jdbc/commit/62ab01a648baa75f4c44940fb43b8c56b4142845", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-21T06:14:21Z", "type": "commit"}, {"oid": "ef464f912bb19208c77d86f12fc2547ce0890288", "url": "https://github.com/microsoft/mssql-jdbc/commit/ef464f912bb19208c77d86f12fc2547ce0890288", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-22T03:59:10Z", "type": "commit"}, {"oid": "e4206e1d96aab063aeb7ec5d5a2e9b1c99aa855b", "url": "https://github.com/microsoft/mssql-jdbc/commit/e4206e1d96aab063aeb7ec5d5a2e9b1c99aa855b", "message": "Java 8 compatibility", "committedDate": "2020-08-24T05:03:57Z", "type": "commit"}, {"oid": "d7c23058a745beab1f10ffe9077b10b365783a13", "url": "https://github.com/microsoft/mssql-jdbc/commit/d7c23058a745beab1f10ffe9077b10b365783a13", "message": "Merge pull request #13 from srnagar/keyvault-upgrade\n\nJava 8 compatibility", "committedDate": "2020-08-24T05:07:14Z", "type": "commit"}, {"oid": "fccc5b7efa64a060d730252265904e4720bfce16", "url": "https://github.com/microsoft/mssql-jdbc/commit/fccc5b7efa64a060d730252265904e4720bfce16", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-24T17:35:46Z", "type": "commit"}, {"oid": "be1d739e84b0304d9b31e655108a2896a05eb86b", "url": "https://github.com/microsoft/mssql-jdbc/commit/be1d739e84b0304d9b31e655108a2896a05eb86b", "message": "Change Set.of to Collections.singleton()", "committedDate": "2020-08-24T18:43:15Z", "type": "commit"}, {"oid": "1423d9382cf7e1f8e3286e6e83fd5f67362ad6a7", "url": "https://github.com/microsoft/mssql-jdbc/commit/1423d9382cf7e1f8e3286e6e83fd5f67362ad6a7", "message": "Remote tenant id from JDBC tests", "committedDate": "2020-08-24T19:14:06Z", "type": "commit"}, {"oid": "e077ffe4fc5de650928c573f384015c8cba13b13", "url": "https://github.com/microsoft/mssql-jdbc/commit/e077ffe4fc5de650928c573f384015c8cba13b13", "message": "Merge pull request #14 from srnagar/keyvault-upgrade\n\nKeyvault upgrade", "committedDate": "2020-08-24T20:20:46Z", "type": "commit"}, {"oid": "9ad6edce5beaf5b97578d675f8462635dd07f9f7", "url": "https://github.com/microsoft/mssql-jdbc/commit/9ad6edce5beaf5b97578d675f8462635dd07f9f7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-24T20:57:06Z", "type": "commit"}, {"oid": "f7493610d9583abd6f2c4d4dc63efe6fe3c730a0", "url": "https://github.com/microsoft/mssql-jdbc/commit/f7493610d9583abd6f2c4d4dc63efe6fe3c730a0", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-24T23:49:23Z", "type": "commit"}, {"oid": "b08233c665cb54257a756169c216525f6add54c4", "url": "https://github.com/microsoft/mssql-jdbc/commit/b08233c665cb54257a756169c216525f6add54c4", "message": "Merge from dev", "committedDate": "2020-08-24T23:50:12Z", "type": "commit"}, {"oid": "49b802e1fc28bdfb1bac6ea247e895744f92f526", "url": "https://github.com/microsoft/mssql-jdbc/commit/49b802e1fc28bdfb1bac6ea247e895744f92f526", "message": "Merge pull request #15 from srnagar/keyvault-upgrade\n\nMerge from upstream dev branch", "committedDate": "2020-08-25T00:24:54Z", "type": "commit"}, {"oid": "c7bfe70cb9700d323f029d69792ae467a6a22906", "url": "https://github.com/microsoft/mssql-jdbc/commit/c7bfe70cb9700d323f029d69792ae467a6a22906", "message": "Merge branch 'keyvault-upgrade' of https://github.com/JonathanGiles/mssql-jdbc into msal", "committedDate": "2020-08-25T01:12:34Z", "type": "commit"}, {"oid": "e743268660f5506588ef578273246202d12e7a88", "url": "https://github.com/microsoft/mssql-jdbc/commit/e743268660f5506588ef578273246202d12e7a88", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-25T06:30:56Z", "type": "commit"}, {"oid": "c2622e46aa4001374e7aa69ff7ffd234ab061128", "url": "https://github.com/microsoft/mssql-jdbc/commit/c2622e46aa4001374e7aa69ff7ffd234ab061128", "message": "Merge remote-tracking branch 'upstream/dev' into keyvault-upgrade", "committedDate": "2020-08-25T21:39:30Z", "type": "commit"}, {"oid": "ffd6a7462323077d97ec3ad64047329288f08609", "url": "https://github.com/microsoft/mssql-jdbc/commit/ffd6a7462323077d97ec3ad64047329288f08609", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-26T18:06:10Z", "type": "commit"}, {"oid": "90ccde041653f327be0bddf55f0c4c31c6d4fcb1", "url": "https://github.com/microsoft/mssql-jdbc/commit/90ccde041653f327be0bddf55f0c4c31c6d4fcb1", "message": "Remove tenant id and reverse null checks", "committedDate": "2020-08-26T19:11:36Z", "type": "commit"}, {"oid": "f1b1dfbf14ed46682044e343a9e1e34e258827d3", "url": "https://github.com/microsoft/mssql-jdbc/commit/f1b1dfbf14ed46682044e343a9e1e34e258827d3", "message": "Merge remote-tracking branch 'upstream/dev' into dev", "committedDate": "2020-08-26T20:44:33Z", "type": "commit"}, {"oid": "d7c44b59affd57d3bb1c96557cc3711f7d99266d", "url": "https://github.com/microsoft/mssql-jdbc/commit/d7c44b59affd57d3bb1c96557cc3711f7d99266d", "message": "Fix compile errors", "committedDate": "2020-08-26T21:33:01Z", "type": "commit"}, {"oid": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "url": "https://github.com/microsoft/mssql-jdbc/commit/fe0953145cc7b3e61444fe92e372e57bc2b855c5", "message": "Remove tenant id from pipelines yml", "committedDate": "2020-08-26T23:10:15Z", "type": "commit"}, {"oid": "15db9cd8b34f8e0aba09f639bd278b7b7996b26d", "url": "https://github.com/microsoft/mssql-jdbc/commit/15db9cd8b34f8e0aba09f639bd278b7b7996b26d", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-27T19:21:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczMzkyMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r478733921", "body": "remove, no longer needed", "bodyText": "remove, no longer needed", "bodyHTML": "<p dir=\"auto\">remove, no longer needed</p>", "author": "lilgreenbird", "createdAt": "2020-08-27T22:39:19Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -669,6 +669,8 @@ boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n     String keyStoreLocation = null;\n     String keyStorePrincipalId = null;\n \n+    String keyVaultProviderTenantId = null;", "originalCommit": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79cef888c070a270ef09411ca2e86b7d2cad1365", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 466f362b..7e6320f2 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -657,68 +582,31 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         return (columnEncryptionSetting.equalsIgnoreCase(ColumnEncryptionSetting.Enabled.toString()));\n     }\n \n-    boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n-        return sendTemporalDataTypesAsStringForBulkCopy;\n-    }\n-\n-    String enclaveAttestationUrl = null;\n-    String enclaveAttestationProtocol = null;\n-\n     String keyStoreAuthentication = null;\n     String keyStoreSecret = null;\n     String keyStoreLocation = null;\n-    String keyStorePrincipalId = null;\n-\n-    String keyVaultProviderTenantId = null;\n-\n-    private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n \n-    private String enclaveType = null;\n+    private boolean serverSupportsColumnEncryption = false;\n \n     boolean getServerSupportsColumnEncryption() {\n-        return (serverColumnEncryptionVersion.value() > ColumnEncryptionVersion.AE_NotSupported.value());\n-    }\n-\n-    ColumnEncryptionVersion getServerColumnEncryptionVersion() {\n-        return serverColumnEncryptionVersion;\n+        return serverSupportsColumnEncryption;\n     }\n \n     private boolean serverSupportsDataClassification = false;\n-    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;\n \n     boolean getServerSupportsDataClassification() {\n         return serverSupportsDataClassification;\n     }\n \n-    private boolean serverSupportsDNSCaching = false;\n-    private static ConcurrentHashMap<String, InetSocketAddress> dnsCache = null;\n-\n-    static InetSocketAddress getDNSEntry(String key) {\n-        return (null != dnsCache) ? dnsCache.get(key) : null;\n-    }\n-\n-    byte getServerSupportedDataClassificationVersion() {\n-        return serverSupportedDataClassificationVersion;\n-    }\n-\n-    // Boolean that indicates whether LOB objects created by this connection should be loaded into memory\n-    private boolean delayLoadingLobs = SQLServerDriverBooleanProperty.DELAY_LOADING_LOBS.getDefaultValue();\n-\n-    @Override\n-    public boolean getDelayLoadingLobs() {\n-        return delayLoadingLobs;\n-    }\n-\n-    @Override\n-    public void setDelayLoadingLobs(boolean b) {\n-        delayLoadingLobs = b;\n-    }\n-\n+    static boolean isWindows;\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n+            isWindows = true;\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n+        } else {\n+            isWindows = false;\n         }\n     }\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n", "next_change": {"commit": "8ad2371ec899daf135e4bbd35b54bd17311e14d2", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 7e6320f2..f3c87e41 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -582,31 +657,66 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         return (columnEncryptionSetting.equalsIgnoreCase(ColumnEncryptionSetting.Enabled.toString()));\n     }\n \n+    boolean getSendTemporalDataTypesAsStringForBulkCopy() {\n+        return sendTemporalDataTypesAsStringForBulkCopy;\n+    }\n+\n+    String enclaveAttestationUrl = null;\n+    String enclaveAttestationProtocol = null;\n+\n     String keyStoreAuthentication = null;\n     String keyStoreSecret = null;\n     String keyStoreLocation = null;\n+    String keyStorePrincipalId = null;\n \n-    private boolean serverSupportsColumnEncryption = false;\n+    private ColumnEncryptionVersion serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_NotSupported;\n+\n+    private String enclaveType = null;\n \n     boolean getServerSupportsColumnEncryption() {\n-        return serverSupportsColumnEncryption;\n+        return (serverColumnEncryptionVersion.value() > ColumnEncryptionVersion.AE_NotSupported.value());\n+    }\n+\n+    ColumnEncryptionVersion getServerColumnEncryptionVersion() {\n+        return serverColumnEncryptionVersion;\n     }\n \n     private boolean serverSupportsDataClassification = false;\n+    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;\n \n     boolean getServerSupportsDataClassification() {\n         return serverSupportsDataClassification;\n     }\n \n-    static boolean isWindows;\n+    private boolean serverSupportsDNSCaching = false;\n+    private static ConcurrentHashMap<String, InetSocketAddress> dnsCache = null;\n+\n+    static InetSocketAddress getDNSEntry(String key) {\n+        return (null != dnsCache) ? dnsCache.get(key) : null;\n+    }\n+\n+    byte getServerSupportedDataClassificationVersion() {\n+        return serverSupportedDataClassificationVersion;\n+    }\n+\n+    // Boolean that indicates whether LOB objects created by this connection should be loaded into memory\n+    private boolean delayLoadingLobs = SQLServerDriverBooleanProperty.DELAY_LOADING_LOBS.getDefaultValue();\n+\n+    @Override\n+    public boolean getDelayLoadingLobs() {\n+        return delayLoadingLobs;\n+    }\n+\n+    @Override\n+    public void setDelayLoadingLobs(boolean b) {\n+        delayLoadingLobs = b;\n+    }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n-            isWindows = true;\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n-        } else {\n-            isWindows = false;\n         }\n     }\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n", "next_change": {"commit": "0f3e0a10f2f85b5b357811907fdb487d63e49830", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex f3c87e41..961811b8 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -720,7 +833,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         }\n     }\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n-    // This is a per-connection store provider. It can be JKS or AKV.\n+    /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n     /**\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 961811b8..a3c544cb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -826,13 +829,16 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n+\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n+\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "0641e315ebd547d407aa844177c05a68e577490d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex a3c544cb..74c71cc0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -827,18 +824,23 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         delayLoadingLobs = b;\n     }\n \n+    private SessionRecoveryFeature sessionRecovery = new SessionRecoveryFeature(this);\n+\n+    SessionRecoveryFeature getSessionRecovery() {\n+        return sessionRecovery;\n+    }\n+\n+    static boolean isWindows;\n+    \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n-\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n-\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n-\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "09d35bfc2338f1fc7c41a958d1e627fa0d6a2b65", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 74c71cc0..3f5730c7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -824,23 +827,18 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         delayLoadingLobs = b;\n     }\n \n-    private SessionRecoveryFeature sessionRecovery = new SessionRecoveryFeature(this);\n-\n-    SessionRecoveryFeature getSessionRecovery() {\n-        return sessionRecovery;\n-    }\n-\n-    static boolean isWindows;\n-    \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n+\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n+\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "b08500889f68eff2ba740b29c644980398c68003", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 3f5730c7..860a41ab 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -827,18 +851,23 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n         delayLoadingLobs = b;\n     }\n \n+    private SessionRecoveryFeature sessionRecovery = new SessionRecoveryFeature(this);\n+\n+    SessionRecoveryFeature getSessionRecovery() {\n+        return sessionRecovery;\n+    }\n+\n+    static boolean isWindows;\n+    \n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n-\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n-\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n-\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "11990186d8cdcd41d6192702805ece43134eb1ba", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 860a41ab..bfda7a2f 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -858,16 +865,19 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     }\n \n     static boolean isWindows;\n-    \n+\n     /** global system ColumnEncryptionKeyStoreProviders */\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalSystemColumnEncryptionKeyStoreProviders = new HashMap<>();\n+\n     static {\n         if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).startsWith(\"windows\")) {\n             SQLServerColumnEncryptionCertificateStoreProvider provider = new SQLServerColumnEncryptionCertificateStoreProvider();\n             globalSystemColumnEncryptionKeyStoreProviders.put(provider.getName(), provider);\n         }\n     }\n+\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n+\n     /** This is a per-connection store provider. It can be JKS or AKV. */\n     Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n", "next_change": {"commit": "b79396d699d9fa76fd704ce084230647facb1018", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex bfda7a2f..b49fea88 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -879,7 +932,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n     static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;\n \n     /** This is a per-connection store provider. It can be JKS or AKV. */\n-    Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n+    transient Map<String, SQLServerColumnEncryptionKeyStoreProvider> systemColumnEncryptionKeyStoreProvider = new HashMap<>();\n \n     /**\n      * Registers key store providers in the globalCustomColumnEncryptionKeyStoreProviders.\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNjAxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1413#discussion_r478736011", "body": "[WARNING] Javadoc Warnings\r\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no @throws for com.microsoft.sqlserver.jdbc.SQLServerException\r\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\r\n[WARNING] ^\r\n", "bodyText": "[WARNING] Javadoc Warnings\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no @throws for com.microsoft.sqlserver.jdbc.SQLServerException\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n[WARNING] ^", "bodyHTML": "<p dir=\"auto\">[WARNING] Javadoc Warnings<br>\n[WARNING] C:\\mssql-jdbc\\src\\main\\java\\com\\microsoft\\sqlserver\\jdbc\\SQLServerColumnEncryptionAzureKeyVaultProvider.java:145: warning: no <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/throws/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/throws\">@throws</a> for com.microsoft.sqlserver.jdbc.SQLServerException<br>\n[WARNING] public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)<br>\n[WARNING] ^</p>", "author": "lilgreenbird", "createdAt": "2020-08-27T22:45:21Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java", "diffHunk": "@@ -49,668 +53,682 @@\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-    /**\n-     * Column Encryption Key Store Provider string\n-     */\n-    String name = \"AZURE_KEY_VAULT\";\n-\n-    private final String baseUrl = \"https://{vaultBaseUrl}\";\n-\n-    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-    private static final List<String> akvTrustedEndpoints;\n-    static {\n-        akvTrustedEndpoints = getTrustedEndpoints();\n-    }\n-    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n-\n-    /**\n-     * Algorithm version\n-     */\n-    private final byte[] firstVersion = new byte[] {0x01};\n-\n-    private KeyVaultClient keyVaultClient;\n-\n-    private KeyVaultCredential credentials;\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return this.name;\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n-     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * @param clientKey\n-     *        Key of the client requesting the token.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId, clientKey);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n-     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n-     * removal in next stable release.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @param executorService\n-     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n-     *        parameter can be passed as 'null'\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    @Deprecated\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n-            ExecutorService executorService) throws SQLServerException {\n-        this(authenticationCallback);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n-     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @param authenticationCallback\n-     *        - Callback function used for authenticating to AAD.\n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n-            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n-        if (null == authenticationCallback) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n-            throw new SQLServerException(form.format(msgArgs1), null);\n+        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+        private HttpPipeline keyVaultPipeline;\n+        private KeyVaultCredential keyVaultCredential;\n+        /**\n+         * Column Encryption Key Store Provider string\n+         */\n+        String name = \"AZURE_KEY_VAULT\";\n+\n+        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n+\n+        private static final List<String> akvTrustedEndpoints;\n+        /**\n+         * Algorithm version\n+         */\n+        private final byte[] firstVersion = new byte[] {0x01};\n+\n+        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n+        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n+        private TokenCredential credential;\n+\n+        static {\n+                akvTrustedEndpoints = getTrustedEndpoints();\n         }\n-        credentials = new KeyVaultCredential(authenticationCallback);\n-        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n-                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n-                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n-        keyVaultClient = new KeyVaultClient(restClient);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-        credentials = new KeyVaultCredential();\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-     *\n-     * @param clientId\n-     *        Identifier of the client requesting the token.\n-     * \n-     * @throws SQLServerException\n-     *         when an error occurs\n-     */\n-    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-        credentials = new KeyVaultCredential(clientId);\n-        keyVaultClient = new KeyVaultClient(credentials);\n-    }\n-\n-    /**\n-     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-     * \n-     * @param masterKeyPath\n-     *        - Complete path of an asymmetric key in AKV\n-     * @param encryptionAlgorithm\n-     *        - Asymmetric Key Encryption Algorithm\n-     * @param encryptedColumnEncryptionKey\n-     *        - Encrypted Column Encryption Key\n-     * @return Plain text column encryption key\n-     */\n-    @Override\n-    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-        // Validate the input parameters\n-        this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-        if (null == encryptedColumnEncryptionKey) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n+\n+        public void setName(String name) {\n+                this.name = name;\n         }\n \n-        if (0 == encryptedColumnEncryptionKey.length) {\n-            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n+        public String getName() {\n+                return this.name;\n         }\n \n-        // Validate encryptionAlgorithm\n-        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-        // Validate whether the key is RSA one or not and then get the key size\n-        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-        // Validate and decrypt the EncryptedColumnEncryptionKey\n-        // Format is\n-        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-        //\n-        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-        // asymmetric key pair and\n-        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-        // Validate the version byte\n-        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-            MessageFormat form = new MessageFormat(\n-                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                    String.format(\"%02X \", firstVersion[0])};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n+         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n+         * @param clientId Identifier of the client requesting the token.\n+         * @param clientKey Secret key of the client requesting the token.\n+         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n+         */\n+        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n+                throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                if (null == clientKey || clientKey.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client Key\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+\n+                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n+                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n+                        .buildPipeline();\n         }\n \n-        // Get key path length\n-        int currentIndex = firstVersion.length;\n-        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        // We just read 2 bytes\n-        currentIndex += 2;\n-\n-        // Get ciphertext length\n-        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-        currentIndex += 2;\n-\n-        // Skip KeyPath\n-        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-        currentIndex += keyPathLength;\n-\n-        // validate the ciphertext length\n-        if (cipherTextLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n         }\n \n-        // Validate the signature length\n-        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param clientId Identifier of the client requesting the token.\n+         */\n+        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+                if (null == clientId || clientId.isEmpty()) {\n+                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+                        Object[] msgArgs1 = {\"Client ID\"};\n+                        throw new SQLServerException(form.format(msgArgs1), null);\n+                }\n+                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n+        }\n \n-        if (signatureLength != keySizeInBytes) {\n-            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        /**\n+         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n+         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+         *\n+         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n+         */", "originalCommit": "fe0953145cc7b3e61444fe92e372e57bc2b855c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47b41825b04aae18f95e473fe3375e8eae352506", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex b76ca77d..4a1c5b74 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -53,682 +49,672 @@ import com.azure.security.keyvault.keys.models.KeyVaultKey;\n  */\n public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {\n \n-        private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n-                .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n-        private HttpPipeline keyVaultPipeline;\n-        private KeyVaultCredential keyVaultCredential;\n-        /**\n-         * Column Encryption Key Store Provider string\n-         */\n-        String name = \"AZURE_KEY_VAULT\";\n-\n-        private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n-        private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n-        private static final String RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV = \"RSA-OAEP\";\n-\n-        private static final List<String> akvTrustedEndpoints;\n-        /**\n-         * Algorithm version\n-         */\n-        private final byte[] firstVersion = new byte[] {0x01};\n-\n-        private Map<String, KeyClient> cachedKeyClients = new ConcurrentHashMap<>();\n-        private Map<String, CryptographyClient> cachedCryptographyClients = new ConcurrentHashMap<>();\n-        private TokenCredential credential;\n-\n-        static {\n-                akvTrustedEndpoints = getTrustedEndpoints();\n+    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger\n+            .getLogger(\"com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider\");\n+    /**\n+     * Column Encryption Key Store Provider string\n+     */\n+    String name = \"AZURE_KEY_VAULT\";\n+\n+    private final String baseUrl = \"https://{vaultBaseUrl}\";\n+\n+    private static final String MSSQL_JDBC_PROPERTIES = \"mssql-jdbc.properties\";\n+    private static final String AKV_TRUSTED_ENDPOINTS_KEYWORD = \"AKVTrustedEndpoints\";\n+    private static final List<String> akvTrustedEndpoints;\n+    static {\n+        akvTrustedEndpoints = getTrustedEndpoints();\n+    }\n+    private final String rsaEncryptionAlgorithmWithOAEPForAKV = \"RSA-OAEP\";\n+\n+    /**\n+     * Algorithm version\n+     */\n+    private final byte[] firstVersion = new byte[] {0x01};\n+\n+    private KeyVaultClient keyVaultClient;\n+\n+    private KeyVaultCredential credentials;\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a client id and client key to authenticate to\n+     * AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * @param clientKey\n+     *        Key of the client requesting the token.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId, clientKey);\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD and\n+     * an executor service.. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * This constructor is present to maintain backwards compatibility with 6.0 version of the driver. Deprecated for\n+     * removal in next stable release.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @param executorService\n+     *        - The ExecutorService, previously used to create the keyVaultClient, but not in use anymore. - This\n+     *        parameter can be passed as 'null'\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    @Deprecated\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback,\n+            ExecutorService executorService) throws SQLServerException {\n+        this(authenticationCallback);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider with a callback function to authenticate to AAD. This\n+     * is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @param authenticationCallback\n+     *        - Callback function used for authenticating to AAD.\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    public SQLServerColumnEncryptionAzureKeyVaultProvider(\n+            SQLServerKeyVaultAuthenticationCallback authenticationCallback) throws SQLServerException {\n+        if (null == authenticationCallback) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n+            Object[] msgArgs1 = {\"SQLServerKeyVaultAuthenticationCallback\"};\n+            throw new SQLServerException(form.format(msgArgs1), null);\n         }\n-\n-        public void setName(String name) {\n-                this.name = name;\n+        credentials = new KeyVaultCredential(authenticationCallback);\n+        RestClient restClient = new RestClient.Builder(new OkHttpClient.Builder(), new Retrofit.Builder())\n+                .withBaseUrl(baseUrl).withCredentials(credentials).withSerializerAdapter(new AzureJacksonAdapter())\n+                .withResponseBuilderFactory(new AzureResponseBuilder.Factory()).build();\n+        keyVaultClient = new KeyVaultClient(restClient);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n+        credentials = new KeyVaultCredential();\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n+\n+    /**\n+     * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n+     * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n+     *\n+     * @param clientId\n+     *        Identifier of the client requesting the token.\n+     * \n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n+        credentials = new KeyVaultCredential(clientId);\n+        keyVaultClient = new KeyVaultClient(credentials);\n+    }\n+\n+    /**\n+     * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n+     * \n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key\n+     * @return Plain text column encryption key\n+     */\n+    @Override\n+    public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        public String getName() {\n-                return this.name;\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD using the client id and\n-         * client key. This is used by KeyVault client at runtime to authenticate to Azure Key Vault.\n-         * @param clientId Identifier of the client requesting the token.\n-         * @param clientKey Secret key of the client requesting the token.\n-         * @throws SQLServerException If either {@code clientId} or {@code clientKey} are {@code null}.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId, String clientKey)\n-                throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                if (null == clientKey || clientKey.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client Key\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-\n-                keyVaultCredential = new KeyVaultCredential(clientId, clientKey);\n-                keyVaultPipeline = new KeyVaultHttpPipelineBuilder().credential(keyVaultCredential)\n-                        .buildPipeline();\n+        // Validate encryptionAlgorithm\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n+\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n+\n+        // Validate and decrypt the EncryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        //\n+        // keyPath is present in the encrypted column encryption key for identifying the original source of the\n+        // asymmetric key pair and\n+        // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n+\n+        // Validate the version byte\n+        if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n+            MessageFormat form = new MessageFormat(\n+                    SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n+            Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n+                    String.format(\"%02X \", firstVersion[0])};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider() throws SQLServerException {\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().build());\n+        // Get key path length\n+        int currentIndex = firstVersion.length;\n+        short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        // We just read 2 bytes\n+        currentIndex += 2;\n+\n+        // Get ciphertext length\n+        short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n+        currentIndex += 2;\n+\n+        // Skip KeyPath\n+        // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n+        currentIndex += keyPathLength;\n+\n+        // validate the ciphertext length\n+        if (cipherTextLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n+            Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider to authenticate to AAD. This is used by\n-         * KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param clientId Identifier of the client requesting the token.\n-         */\n-        SQLServerColumnEncryptionAzureKeyVaultProvider(String clientId) throws SQLServerException {\n-                if (null == clientId || clientId.isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NullValue\"));\n-                        Object[] msgArgs1 = {\"Client ID\"};\n-                        throw new SQLServerException(form.format(msgArgs1), null);\n-                }\n-                createKeyvaultClients(new ManagedIdentityCredentialBuilder().clientId(clientId).build());\n-        }\n+        // Validate the signature length\n+        int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n \n-        /**\n-         * Constructs a SQLServerColumnEncryptionAzureKeyVaultProvider using the provided TokenCredential to\n-         * authenticate to AAD. This is used by KeyVaultClient at runtime to authenticate to Azure Key Vault.\n-         *\n-         * @param tokenCredential The TokenCredential to use to authenticate to Azure Key Vault.\n-         */\n-        public SQLServerColumnEncryptionAzureKeyVaultProvider(TokenCredential tokenCredential)\n-                throws SQLServerException {\n-                createKeyvaultClients(tokenCredential);\n+        if (signatureLength != keySizeInBytes) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n+            Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        private void createKeyvaultClients(TokenCredential credential) throws SQLServerException {\n-                this.credential = Objects.requireNonNull(credential);\n-        }\n-\n-        /**\n-         * Decrypts an encrypted CEK with RSA encryption algorithm using the asymmetric key specified by the key path\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key\n-         * @return Plain text column encryption key\n-         */\n-        @Override public byte[] decryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-\n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n+        // Get ciphertext\n+        byte[] cipherText = new byte[cipherTextLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n+        currentIndex += cipherTextLength;\n \n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_NullEncryptedColumnEncryptionKey\"), null);\n-                }\n+        // Get signature\n+        byte[] signature = new byte[signatureLength];\n+        System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n \n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_EmptyEncryptedColumnEncryptionKey\"), null);\n-                }\n+        // Compute the hash to validate the signature\n+        byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n \n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-                // Validate and decrypt the EncryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                //\n-                // keyPath is present in the encrypted column encryption key for identifying the original source of the\n-                // asymmetric key pair and\n-                // we will not validate it against the data contained in the CMK metadata (masterKeyPath).\n-\n-                // Validate the version byte\n-                if (encryptedColumnEncryptionKey[0] != firstVersion[0]) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidEcryptionAlgorithmVersion\"));\n-                        Object[] msgArgs = {String.format(\"%02X \", encryptedColumnEncryptionKey[0]),\n-                                String.format(\"%02X \", firstVersion[0])};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n+                encryptedColumnEncryptionKey.length - signature.length);\n \n-                // Get key path length\n-                int currentIndex = firstVersion.length;\n-                short keyPathLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                // We just read 2 bytes\n-                currentIndex += 2;\n-\n-                // Get ciphertext length\n-                short cipherTextLength = convertTwoBytesToShort(encryptedColumnEncryptionKey, currentIndex);\n-                currentIndex += 2;\n-\n-                // Skip KeyPath\n-                // KeyPath exists only for troubleshooting purposes and doesnt need validation.\n-                currentIndex += keyPathLength;\n-\n-                // validate the ciphertext length\n-                if (cipherTextLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyLengthError\"));\n-                        Object[] msgArgs = {cipherTextLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Validate the signature length\n-                int signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;\n-\n-                if (signatureLength != keySizeInBytes) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVSignatureLengthError\"));\n-                        Object[] msgArgs = {signatureLength, keySizeInBytes, masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Get ciphertext\n-                byte[] cipherText = new byte[cipherTextLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, cipherText, 0, cipherTextLength);\n-                currentIndex += cipherTextLength;\n-\n-                // Get signature\n-                byte[] signature = new byte[signatureLength];\n-                System.arraycopy(encryptedColumnEncryptionKey, currentIndex, signature, 0, signatureLength);\n-\n-                // Compute the hash to validate the signature\n-                byte[] hash = new byte[encryptedColumnEncryptionKey.length - signature.length];\n-\n-                System.arraycopy(encryptedColumnEncryptionKey, 0, hash, 0,\n-                        encryptedColumnEncryptionKey.length - signature.length);\n-\n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(hash);\n-                byte dataToVerify[] = md.digest();\n-\n-                if (null == dataToVerify) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                }\n-\n-                // Validate the signature\n-                if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n-\n-                // Decrypt the CEK\n-                byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, _encryptionAlgorithm, cipherText);\n-\n-                return decryptedCEK;\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n+        md.update(hash);\n+        byte dataToVerify[] = md.digest();\n \n-        private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n-\n-                short shortVal;\n-                if (index + 1 >= input.length) {\n-                        throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"),\n-                                null, 0, false);\n-                }\n-                ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n-                byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n-                byteBuffer.put(input[index]);\n-                byteBuffer.put(input[index + 1]);\n-                shortVal = byteBuffer.getShort(0);\n-                return shortVal;\n-\n+        if (null == dataToVerify) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n         }\n \n-        /**\n-         * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n-         *\n-         * @param masterKeyPath - Complete path of an asymmetric key in AKV\n-         * @param encryptionAlgorithm - Asymmetric Key Encryption Algorithm\n-         * @param columnEncryptionKey - Plain text column encryption key\n-         * @return Encrypted column encryption key\n-         */\n-        @Override public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n-\n-                // Validate the input parameters\n-                this.ValidateNonEmptyAKVPath(masterKeyPath);\n-\n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"),\n-                                null);\n-                }\n-\n-                if (0 == columnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n-                }\n-\n-                // Validate encryptionAlgorithm\n-                KeyWrapAlgorithm _encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n-\n-                // Validate whether the key is RSA one or not and then get the key size\n-                int keySizeInBytes = getAKVKeySize(masterKeyPath);\n-\n-                // Construct the encryptedColumnEncryptionKey\n-                // Format is\n-                // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n-                //\n-                // We currently only support one version\n-                byte[] version = new byte[] {firstVersion[0]};\n-\n-                // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n-                byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n-\n-                byte[] keyPathLength = new byte[2];\n-                keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n-                keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n-\n-                // Encrypt the plain text\n-                byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, _encryptionAlgorithm, columnEncryptionKey);\n+        // Validate the signature\n+        if (!AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath)) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_CEKSignatureNotMatchCMK\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n+        }\n \n-                byte[] cipherTextLength = new byte[2];\n-                cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n-                cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n+        // Decrypt the CEK\n+        byte[] decryptedCEK = this.AzureKeyVaultUnWrap(masterKeyPath, encryptionAlgorithm, cipherText);\n \n-                if (cipherText.length != keySizeInBytes) {\n-                        throw new SQLServerException(\n-                                SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n-                }\n+        return decryptedCEK;\n+    }\n \n-                // Compute hash\n-                // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n-                byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n-                        + masterKeyPathBytes.length + cipherText.length];\n-                int destinationPosition = version.length;\n-                System.arraycopy(version, 0, dataToHash, 0, version.length);\n+    private short convertTwoBytesToShort(byte[] input, int index) throws SQLServerException {\n \n-                System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n-                destinationPosition += keyPathLength.length;\n+        short shortVal;\n+        if (index + 1 >= input.length) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_ByteToShortConversion\"), null, 0,\n+                    false);\n+        }\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n+        byteBuffer.put(input[index]);\n+        byteBuffer.put(input[index + 1]);\n+        shortVal = byteBuffer.getShort(0);\n+        return shortVal;\n+\n+    }\n+\n+    /**\n+     * Encrypts CEK with RSA encryption algorithm using the asymmetric key specified by the key path.\n+     * \n+     * @param masterKeyPath\n+     *        - Complete path of an asymmetric key in AKV\n+     * @param encryptionAlgorithm\n+     *        - Asymmetric Key Encryption Algorithm\n+     * @param columnEncryptionKey\n+     *        - Plain text column encryption key\n+     * @return Encrypted column encryption key\n+     */\n+    @Override\n+    public byte[] encryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+\n+        // Validate the input parameters\n+        this.ValidateNonEmptyAKVPath(masterKeyPath);\n+\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NullColumnEncryptionKey\"), null);\n+        }\n \n-                System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n-                destinationPosition += cipherTextLength.length;\n+        if (0 == columnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyCEK\"), null);\n+        }\n \n-                System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n-                destinationPosition += masterKeyPathBytes.length;\n+        // Validate encryptionAlgorithm\n+        encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);\n \n-                System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n+        // Validate whether the key is RSA one or not and then get the key size\n+        int keySizeInBytes = getAKVKeySize(masterKeyPath);\n \n-                MessageDigest md = null;\n-                try {\n-                        md = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n-                md.update(dataToHash);\n-                byte dataToSign[] = md.digest();\n+        // Construct the encryptedColumnEncryptionKey\n+        // Format is\n+        // version + keyPathLength + ciphertextLength + ciphertext + keyPath + signature\n+        //\n+        // We currently only support one version\n+        byte[] version = new byte[] {firstVersion[0]};\n \n-                // Sign the hash\n-                byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n+        // Get the Unicode encoded bytes of cultureinvariant lower case masterKeyPath\n+        byte[] masterKeyPathBytes = masterKeyPath.toLowerCase(Locale.ENGLISH).getBytes(UTF_16LE);\n \n-                if (signedHash.length != keySizeInBytes) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n-                }\n+        byte[] keyPathLength = new byte[2];\n+        keyPathLength[0] = (byte) (((short) masterKeyPathBytes.length) & 0xff);\n+        keyPathLength[1] = (byte) (((short) masterKeyPathBytes.length) >> 8 & 0xff);\n \n-                if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"),\n-                                null);\n-                }\n+        // Encrypt the plain text\n+        byte[] cipherText = this.AzureKeyVaultWrap(masterKeyPath, encryptionAlgorithm, columnEncryptionKey);\n \n-                // Construct the encrypted column encryption key\n-                // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n-                int encryptedColumnEncryptionKeyLength =\n-                        version.length + cipherTextLength.length + keyPathLength.length + cipherText.length\n-                                + masterKeyPathBytes.length + signedHash.length;\n-                byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+        byte[] cipherTextLength = new byte[2];\n+        cipherTextLength[0] = (byte) (((short) cipherText.length) & 0xff);\n+        cipherTextLength[1] = (byte) (((short) cipherText.length) >> 8 & 0xff);\n \n-                // Copy version byte\n-                int currentIndex = 0;\n-                System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n-                currentIndex += version.length;\n+        if (cipherText.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CipherTextLengthNotMatchRSASize\"), null);\n+        }\n \n-                // Copy key path length\n-                System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n-                currentIndex += keyPathLength.length;\n+        // Compute hash\n+        // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext)\n+        byte[] dataToHash = new byte[version.length + keyPathLength.length + cipherTextLength.length\n+                + masterKeyPathBytes.length + cipherText.length];\n+        int destinationPosition = version.length;\n+        System.arraycopy(version, 0, dataToHash, 0, version.length);\n \n-                // Copy ciphertext length\n-                System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        cipherTextLength.length);\n-                currentIndex += cipherTextLength.length;\n+        System.arraycopy(keyPathLength, 0, dataToHash, destinationPosition, keyPathLength.length);\n+        destinationPosition += keyPathLength.length;\n \n-                // Copy key path\n-                System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex,\n-                        masterKeyPathBytes.length);\n-                currentIndex += masterKeyPathBytes.length;\n+        System.arraycopy(cipherTextLength, 0, dataToHash, destinationPosition, cipherTextLength.length);\n+        destinationPosition += cipherTextLength.length;\n \n-                // Copy ciphertext\n-                System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n-                currentIndex += cipherText.length;\n+        System.arraycopy(masterKeyPathBytes, 0, dataToHash, destinationPosition, masterKeyPathBytes.length);\n+        destinationPosition += masterKeyPathBytes.length;\n \n-                // copy the signature\n-                System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);\n \n-                return encryptedColumnEncryptionKey;\n+        MessageDigest md = null;\n+        try {\n+            md = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n+        md.update(dataToHash);\n+        byte dataToSign[] = md.digest();\n \n-        /**\n-         * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n-         *\n-         * @param encryptionAlgorithm - Asymmetric key encryptio algorithm\n-         * @return The encryption algorithm that is going to be used.\n-         * @throws SQLServerException\n-         */\n-        private KeyWrapAlgorithm validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n-\n-                if (null == encryptionAlgorithm) {\n-                        throw new SQLServerException(null,\n-                                SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0, false);\n-                }\n-\n-                // Transform to standard format (dash instead of underscore) to support enum lookup\n-                if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n-                        encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;\n-                }\n-\n-                if (!RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n-                        Object[] msgArgs = {encryptionAlgorithm, RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV};\n-                        throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n-                }\n+        // Sign the hash\n+        byte[] signedHash = AzureKeyVaultSignHashedData(dataToSign, masterKeyPath);\n \n-                return KeyWrapAlgorithm.fromString(encryptionAlgorithm);\n+        if (signedHash.length != keySizeInBytes) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n         }\n \n-        /**\n-         * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n-         *\n-         * @param masterKeyPath\n-         * @throws SQLServerException\n-         */\n-        private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n-                // throw appropriate error if masterKeyPath is null or empty\n-                if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                } else {\n-                        URI parsedUri = null;\n-                        try {\n-                                parsedUri = new URI(masterKeyPath);\n-\n-                                // A valid URI.\n-                                // Check if it is pointing to a trusted endpoint.\n-                                String host = parsedUri.getHost();\n-                                if (null != host) {\n-                                        host = host.toLowerCase(Locale.ENGLISH);\n-                                }\n-                                for (final String endpoint : akvTrustedEndpoints) {\n-                                        if (null != host && host.endsWith(endpoint)) {\n-                                                return;\n-                                        }\n-                                }\n-                        } catch (URISyntaxException e) {\n-                                MessageFormat form = new MessageFormat(\n-                                        SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n-                                Object[] msgArgs = {masterKeyPath};\n-                                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n-                        }\n-\n-                        MessageFormat form = new MessageFormat(\n-                                SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n-                        Object[] msgArgs = {masterKeyPath};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+        if (!this.AzureKeyVaultVerifySignature(dataToSign, signedHash, masterKeyPath)) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_InvalidSignatureComputed\"), null);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encryption Algorithm.\n-         * @param columnEncryptionKey - Plain text Column Encryption Key.\n-         * @return Returns an encrypted blob or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] columnEncryptionKey) throws SQLServerException {\n-                if (null == columnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n-                }\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                WrapResult wrappedKey = cryptoClient.wrapKey(KeyWrapAlgorithm.RSA_OAEP, columnEncryptionKey);\n-                return wrappedKey.getEncryptedKey();\n+        // Construct the encrypted column encryption key\n+        // EncryptedColumnEncryptionKey = version + keyPathLength + ciphertextLength + keyPath + ciphertext + signature\n+        int encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length\n+                + cipherText.length + masterKeyPathBytes.length + signedHash.length;\n+        byte[] encryptedColumnEncryptionKey = new byte[encryptedColumnEncryptionKeyLength];\n+\n+        // Copy version byte\n+        int currentIndex = 0;\n+        System.arraycopy(version, 0, encryptedColumnEncryptionKey, currentIndex, version.length);\n+        currentIndex += version.length;\n+\n+        // Copy key path length\n+        System.arraycopy(keyPathLength, 0, encryptedColumnEncryptionKey, currentIndex, keyPathLength.length);\n+        currentIndex += keyPathLength.length;\n+\n+        // Copy ciphertext length\n+        System.arraycopy(cipherTextLength, 0, encryptedColumnEncryptionKey, currentIndex, cipherTextLength.length);\n+        currentIndex += cipherTextLength.length;\n+\n+        // Copy key path\n+        System.arraycopy(masterKeyPathBytes, 0, encryptedColumnEncryptionKey, currentIndex, masterKeyPathBytes.length);\n+        currentIndex += masterKeyPathBytes.length;\n+\n+        // Copy ciphertext\n+        System.arraycopy(cipherText, 0, encryptedColumnEncryptionKey, currentIndex, cipherText.length);\n+        currentIndex += cipherText.length;\n+\n+        // copy the signature\n+        System.arraycopy(signedHash, 0, encryptedColumnEncryptionKey, currentIndex, signedHash.length);\n+\n+        return encryptedColumnEncryptionKey;\n+    }\n+\n+    /**\n+     * Validates that the encryption algorithm is RSA_OAEP and if it is not, then throws an exception.\n+     * \n+     * @param encryptionAlgorithm\n+     *        - Asymmetric key encryptio algorithm\n+     * @return The encryption algorithm that is going to be used.\n+     * @throws SQLServerException\n+     */\n+    private String validateEncryptionAlgorithm(String encryptionAlgorithm) throws SQLServerException {\n+\n+        if (null == encryptionAlgorithm) {\n+            throw new SQLServerException(null, SQLServerException.getErrString(\"R_NullKeyEncryptionAlgorithm\"), null, 0,\n+                    false);\n         }\n \n-        /**\n-         * Encrypts the text using specified Azure Key Vault key.\n-         *\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @param encryptionAlgorithm - Encrypted Column Encryption Key.\n-         * @param encryptedColumnEncryptionKey - Encrypted Column Encryption Key.\n-         * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultUnWrap(String masterKeyPath, KeyWrapAlgorithm encryptionAlgorithm,\n-                byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n-                if (null == encryptedColumnEncryptionKey) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n-                }\n-\n-                if (0 == encryptedColumnEncryptionKey.length) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n-                }\n-\n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-\n-                UnwrapResult unwrappedKey = cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);\n-\n-                return unwrappedKey.getKey();\n+        // Transform to standard format (dash instead of underscore) to support both \"RSA_OAEP\" and \"RSA-OAEP\"\n+        if (\"RSA_OAEP\".equalsIgnoreCase(encryptionAlgorithm)) {\n+            encryptionAlgorithm = \"RSA-OAEP\";\n         }\n \n-        private CryptographyClient getCryptographyClient(String masterKeyPath) throws SQLServerException {\n-                if (this.cachedCryptographyClients.containsKey(masterKeyPath)) {\n-                        return cachedCryptographyClients.get(masterKeyPath);\n-                }\n-\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-\n-                CryptographyClient cryptoClient;\n-                if (null != credential) {\n-                        cryptoClient = new CryptographyClientBuilder().credential(credential)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                } else {\n-                        cryptoClient = new CryptographyClientBuilder().pipeline(keyVaultPipeline)\n-                                .keyIdentifier(retrievedKey.getId()).buildClient();\n-                }\n-                cachedCryptographyClients.putIfAbsent(masterKeyPath, cryptoClient);\n-                return cachedCryptographyClients.get(masterKeyPath);\n+        if (!rsaEncryptionAlgorithmWithOAEPForAKV.equalsIgnoreCase(encryptionAlgorithm.trim())) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_InvalidKeyEncryptionAlgorithm\"));\n+            Object[] msgArgs = {encryptionAlgorithm, rsaEncryptionAlgorithmWithOAEPForAKV};\n+            throw new SQLServerException(this, form.format(msgArgs), null, 0, false);\n         }\n \n-        /**\n-         * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n-         *\n-         * @param dataToSign - Text to sign.\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return Signature\n-         * @throws SQLServerException\n-         */\n-        private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n-                assert ((null != dataToSign) && (0 != dataToSign.length));\n+        return encryptionAlgorithm;\n+    }\n+\n+    /**\n+     * Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).\n+     * \n+     * @param masterKeyPath\n+     * @throws SQLServerException\n+     */\n+    private void ValidateNonEmptyAKVPath(String masterKeyPath) throws SQLServerException {\n+        // throw appropriate error if masterKeyPath is null or empty\n+        if (null == masterKeyPath || masterKeyPath.trim().isEmpty()) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVPathNull\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+        } else {\n+            URI parsedUri = null;\n+            try {\n+                parsedUri = new URI(masterKeyPath);\n+\n+                // A valid URI.\n+                // Check if it is pointing to a trusted endpoint.\n+                String host = parsedUri.getHost();\n+                if (null != host) {\n+                    host = host.toLowerCase(Locale.ENGLISH);\n+                }\n+                for (final String endpoint : akvTrustedEndpoints) {\n+                    if (null != host && host.endsWith(endpoint)) {\n+                        return;\n+                    }\n+                }\n+            } catch (URISyntaxException e) {\n+                MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVURLInvalid\"));\n+                Object[] msgArgs = {masterKeyPath};\n+                throw new SQLServerException(form.format(msgArgs), null, 0, e);\n+            }\n \n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                SignResult signedData = cryptoClient.sign(SignatureAlgorithm.RS256, dataToSign);\n-                return signedData.getSignature();\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVMasterKeyPathInvalid\"));\n+            Object[] msgArgs = {masterKeyPath};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n+        }\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     * \n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encryption Algorithm.\n+     * @param columnEncryptionKey\n+     *        - Plain text Column Encryption Key.\n+     * @return Returns an encrypted blob or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultWrap(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] columnEncryptionKey) throws SQLServerException {\n+        if (null == columnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_CEKNull\"), null);\n         }\n \n-        /**\n-         * Verifies the given RSA PKCSv1.5 signature.\n-         *\n-         * @param dataToVerify\n-         * @param signature\n-         * @param masterKeyPath - Azure Key Vault key url.\n-         * @return true if signature is valid, false if it is not valid\n-         * @throws SQLServerException\n-         */\n-        private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature, String masterKeyPath)\n-                throws SQLServerException {\n-                assert ((null != dataToVerify) && (0 != dataToVerify.length));\n-                assert ((null != signature) && (0 != signature.length));\n+        JsonWebKeyEncryptionAlgorithm jsonEncryptionAlgorithm = new JsonWebKeyEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyOperationResult wrappedKey = keyVaultClient.wrapKey(masterKeyPath, jsonEncryptionAlgorithm,\n+                columnEncryptionKey);\n+\n+        return wrappedKey.result();\n+    }\n+\n+    /**\n+     * Encrypts the text using specified Azure Key Vault key.\n+     * \n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @param encryptionAlgorithm\n+     *        - Encrypted Column Encryption Key.\n+     * @param encryptedColumnEncryptionKey\n+     *        - Encrypted Column Encryption Key.\n+     * @return Returns the decrypted plaintext Column Encryption Key or throws an exception if there are any errors.\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultUnWrap(String masterKeyPath, String encryptionAlgorithm,\n+            byte[] encryptedColumnEncryptionKey) throws SQLServerException {\n+        if (null == encryptedColumnEncryptionKey) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EncryptedCEKNull\"), null);\n+        }\n \n-                CryptographyClient cryptoClient = getCryptographyClient(masterKeyPath);\n-                VerifyResult valid = cryptoClient.verify(SignatureAlgorithm.RS256, dataToVerify, signature);\n+        if (0 == encryptedColumnEncryptionKey.length) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_EmptyEncryptedCEK\"), null);\n+        }\n \n-                return valid.isValid();\n+        JsonWebKeyEncryptionAlgorithm jsonEncryptionAlgorithm = new JsonWebKeyEncryptionAlgorithm(encryptionAlgorithm);\n+        KeyOperationResult unwrappedKey = keyVaultClient.unwrapKey(masterKeyPath, jsonEncryptionAlgorithm,\n+                encryptedColumnEncryptionKey);\n+\n+        return unwrappedKey.result();\n+    }\n+\n+    /**\n+     * Generates signature based on RSA PKCS#v1.5 scheme using a specified Azure Key Vault Key URL.\n+     * \n+     * @param dataToSign\n+     *        - Text to sign.\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return Signature\n+     * @throws SQLServerException\n+     */\n+    private byte[] AzureKeyVaultSignHashedData(byte[] dataToSign, String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToSign) && (0 != dataToSign.length));\n+\n+        KeyOperationResult signedData = keyVaultClient.sign(masterKeyPath, JsonWebKeySignatureAlgorithm.RS256,\n+                dataToSign);\n+\n+        return signedData.result();\n+    }\n+\n+    /**\n+     * Verifies the given RSA PKCSv1.5 signature.\n+     * \n+     * @param dataToVerify\n+     * @param signature\n+     * @param masterKeyPath\n+     *        - Azure Key Vault key url.\n+     * @return true if signature is valid, false if it is not valid\n+     * @throws SQLServerException\n+     */\n+    private boolean AzureKeyVaultVerifySignature(byte[] dataToVerify, byte[] signature,\n+            String masterKeyPath) throws SQLServerException {\n+        assert ((null != dataToVerify) && (0 != dataToVerify.length));\n+        assert ((null != signature) && (0 != signature.length));\n+\n+        KeyVerifyResult valid = keyVaultClient.verify(masterKeyPath, JsonWebKeySignatureAlgorithm.RS256, dataToVerify,\n+                signature);\n+\n+        return valid.value();\n+    }\n+\n+    /**\n+     * Returns the public Key size in bytes.\n+     * \n+     * @param masterKeyPath\n+     *        - Azure Key Vault Key path\n+     * @return Key size in bytes\n+     * @throws SQLServerException\n+     *         when an error occurs\n+     */\n+    private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n+        KeyBundle retrievedKey = keyVaultClient.getKey(masterKeyPath);\n+\n+        if (null == retrievedKey) {\n+            String[] keyTokens = masterKeyPath.split(\"/\");\n+\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n+            Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n \n-        /**\n-         * Returns the public Key size in bytes.\n-         *\n-         * @param masterKeyPath - Azure Key Vault Key path\n-         * @return Key size in bytes\n-         * @throws SQLServerException when an error occurs\n-         */\n-        private int getAKVKeySize(String masterKeyPath) throws SQLServerException {\n-                KeyVaultKey retrievedKey = getKeyVaultKey(masterKeyPath);\n-                return retrievedKey.getKey().getN().length;\n+        if (!\"RSA\".equalsIgnoreCase(retrievedKey.key().kty().toString())\n+                && !\"RSA-HSM\".equalsIgnoreCase(retrievedKey.key().kty().toString())) {\n+            MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n+            Object[] msgArgs = {retrievedKey.key().kty().toString()};\n+            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n         }\n \n-        private KeyVaultKey getKeyVaultKey(String masterKeyPath)\n-                throws SQLServerException {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String keyName = keyTokens[keyTokens.length - 2];\n-                String keyVersion = keyTokens[keyTokens.length - 1];\n-                KeyClient keyClient = getKeyClient(masterKeyPath);\n-                KeyVaultKey retrievedKey = keyClient.getKey(keyName, keyVersion);\n-\n-                if (null == retrievedKey) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_AKVKeyNotFound\"));\n-                        Object[] msgArgs = {keyTokens[keyTokens.length - 1]};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n+        return retrievedKey.key().n().length;\n+    }\n \n-                if (retrievedKey.getKeyType() != KeyType.RSA && retrievedKey.getKeyType() != KeyType.RSA_HSM) {\n-                        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_NonRSAKey\"));\n-                        Object[] msgArgs = {retrievedKey.getKeyType().toString()};\n-                        throw new SQLServerException(null, form.format(msgArgs), null, 0, false);\n-                }\n-                return retrievedKey;\n-        }\n+    @Override\n+    public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n+            byte[] signature) throws SQLServerException {\n+        if (!allowEnclaveComputations)\n+            return false;\n \n-        private KeyClient getKeyClient(String masterKeyPath) {\n-                if (cachedKeyClients.containsKey(masterKeyPath)) {\n-                        return cachedKeyClients.get(masterKeyPath);\n-                }\n-                String vaultUrl = getVaultUrl(masterKeyPath);\n+        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n \n-                KeyClient keyClient;\n-                if (null != credential) {\n-                        keyClient = new KeyClientBuilder().credential(credential).vaultUrl(vaultUrl).buildClient();\n-                } else {\n-                        keyClient = new KeyClientBuilder().pipeline(keyVaultPipeline).vaultUrl(vaultUrl).buildClient();\n-                }\n-                cachedKeyClients.putIfAbsent(masterKeyPath, keyClient);\n-                return cachedKeyClients.get(masterKeyPath);\n-        }\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n+            // value of allowEnclaveComputations is always true here\n+            md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n \n-        private static String getVaultUrl(String masterKeyPath) {\n-                String[] keyTokens = masterKeyPath.split(\"/\");\n-                String hostName = keyTokens[2];\n-                return \"https://\" + hostName;\n-        }\n+            byte[] dataToVerify = md.digest();\n+            if (null == dataToVerify) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n+            }\n \n-        @Override public boolean verifyColumnMasterKeyMetadata(String masterKeyPath, boolean allowEnclaveComputations,\n-                byte[] signature) throws SQLServerException {\n-            if (!allowEnclaveComputations) {\n-                return false;\n+            // Sign the hash\n+            byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n+            if (null == signedHash) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"), null);\n             }\n \n-                KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);\n-\n-                try {\n-                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n-                        md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-                        // value of allowEnclaveComputations is always true here\n-                        md.update(\"true\".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));\n-\n-                        byte[] dataToVerify = md.digest();\n-                        if (null == dataToVerify) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_HashNull\"), null);\n-                        }\n-\n-                        // Sign the hash\n-                        byte[] signedHash = AzureKeyVaultSignHashedData(dataToVerify, masterKeyPath);\n-                        if (null == signedHash) {\n-                                throw new SQLServerException(SQLServerException.getErrString(\"R_SignedHashLengthError\"),\n-                                        null);\n-                        }\n-\n-                        // Validate the signature\n-                        return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n-                } catch (NoSuchAlgorithmException e) {\n-                        throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n-                }\n+            // Validate the signature\n+            return AzureKeyVaultVerifySignature(dataToVerify, signature, masterKeyPath);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new SQLServerException(SQLServerException.getErrString(\"R_NoSHA256Algorithm\"), e);\n         }\n-\n-        private static List<String> getTrustedEndpoints() {\n-                Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n-                List<String> trustedEndpoints = new ArrayList<String>();\n-                boolean append = true;\n-                if (null != mssqlJdbcProperties) {\n-                        String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n-                        if (null != endpoints && !endpoints.trim().isEmpty()) {\n-                                endpoints = endpoints.trim();\n-                                // Append if the list starts with a semicolon.\n-                                if (';' != endpoints.charAt(0)) {\n-                                        append = false;\n-                                } else {\n-                                        endpoints = endpoints.substring(1);\n-                                }\n-                                String[] entries = endpoints.split(\";\");\n-                                for (String entry : entries) {\n-                                        if (null != entry && !entry.trim().isEmpty()) {\n-                                                trustedEndpoints.add(entry.trim());\n-                                        }\n-                                }\n-                        }\n+    }\n+\n+    private static List<String> getTrustedEndpoints() {\n+        Properties mssqlJdbcProperties = getMssqlJdbcProperties();\n+        List<String> trustedEndpoints = new ArrayList<String>();\n+        boolean append = true;\n+        if (null != mssqlJdbcProperties) {\n+            String endpoints = mssqlJdbcProperties.getProperty(AKV_TRUSTED_ENDPOINTS_KEYWORD);\n+            if (null != endpoints && !endpoints.trim().isEmpty()) {\n+                endpoints = endpoints.trim();\n+                // Append if the list starts with a semicolon.\n+                if (';' != endpoints.charAt(0)) {\n+                    append = false;\n+                } else {\n+                    endpoints = endpoints.substring(1);\n                 }\n-                /*\n-                 * List of Azure trusted endpoints\n-                 * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n-                 */\n-                if (append) {\n-                        trustedEndpoints.add(\"vault.azure.net\");\n-                        trustedEndpoints.add(\"vault.azure.cn\");\n-                        trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n-                        trustedEndpoints.add(\"vault.microsoftazure.de\");\n+                String[] entries = endpoints.split(\";\");\n+                for (String entry : entries) {\n+                    if (null != entry && !entry.trim().isEmpty()) {\n+                        trustedEndpoints.add(entry.trim());\n+                    }\n                 }\n-                return trustedEndpoints;\n+            }\n         }\n-\n-        /**\n-         * Attempt to read MSSQL_JDBC_PROPERTIES.\n-         *\n-         * @return corresponding Properties object or null if failed to read the file.\n+        /*\n+         * List of Azure trusted endpoints\n+         * https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault\n          */\n-        private static Properties getMssqlJdbcProperties() {\n-                Properties props = null;\n-                try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n-                        props = new Properties();\n-                        props.load(in);\n-                } catch (IOException e) {\n-                        if (akvLogger.isLoggable(Level.FINER)) {\n-                                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n-                        }\n-                }\n-                return (null != props && !props.isEmpty()) ? props : null;\n+        if (append) {\n+            trustedEndpoints.add(\"vault.azure.net\");\n+            trustedEndpoints.add(\"vault.azure.cn\");\n+            trustedEndpoints.add(\"vault.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"vault.microsoftazure.de\");\n+            trustedEndpoints.add(\"managedhsm.azure.net\");\n+            trustedEndpoints.add(\"managedhsm.azure.cn\");\n+            trustedEndpoints.add(\"managedhsm.usgovcloudapi.net\");\n+            trustedEndpoints.add(\"managedhsm.microsoftazure.de\");\n+        }\n+        return trustedEndpoints;\n+    }\n+\n+    /**\n+     * Attempt to read MSSQL_JDBC_PROPERTIES.\n+     *\n+     * @return corresponding Properties object or null if failed to read the file.\n+     */\n+    private static Properties getMssqlJdbcProperties() {\n+        Properties props = null;\n+        try (FileInputStream in = new FileInputStream(MSSQL_JDBC_PROPERTIES)) {\n+            props = new Properties();\n+            props.load(in);\n+        } catch (IOException e) {\n+            if (akvLogger.isLoggable(Level.FINER)) {\n+                akvLogger.finer(\"Unable to load the mssql-jdbc.properties file: \" + e);\n+            }\n         }\n+        return (null != props && !props.isEmpty()) ? props : null;\n+    }\n }\n", "next_change": {"commit": "7f3af328177744039f76be1d891d1529a387b884", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\nindex 4a1c5b74..a39efccb 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java\n", "chunk": "@@ -717,4 +957,12 @@ public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerCol\n         }\n         return (null != props && !props.isEmpty()) ? props : null;\n     }\n+\n+    int getColumnEncryptionKeyCacheSize() {\n+        return columnEncryptionKeyCache.getCacheSize();\n+    }\n+\n+    int getCmkMetadataSignatureVerificationCacheSize() {\n+        return cmkMetadataSignatureVerificationCache.getCacheSize();\n+    }\n }\n", "next_change": null}]}}]}}, {"oid": "8d1f4622295ed6fa69a2d57c57797f6dc1261620", "url": "https://github.com/microsoft/mssql-jdbc/commit/8d1f4622295ed6fa69a2d57c57797f6dc1261620", "message": "Update javadoc", "committedDate": "2020-08-27T23:12:23Z", "type": "commit"}, {"oid": "22515502167d60947676e4cebf7e210bf5ceafc7", "url": "https://github.com/microsoft/mssql-jdbc/commit/22515502167d60947676e4cebf7e210bf5ceafc7", "message": "Merge branch 'keyvault-upgrade' of https://github.com/srnagar/mssql-jdbc into msal", "committedDate": "2020-08-28T00:19:08Z", "type": "commit"}, {"oid": "fd9837610a9c3c0201fa691257d79474f2e5be0c", "url": "https://github.com/microsoft/mssql-jdbc/commit/fd9837610a9c3c0201fa691257d79474f2e5be0c", "message": "Merge remote-tracking branch 'upstream/dev' into msal", "committedDate": "2020-08-28T00:19:22Z", "type": "commit"}, {"oid": "04c05bdbcf9de991536d7972a6874d3dfc58148c", "url": "https://github.com/microsoft/mssql-jdbc/commit/04c05bdbcf9de991536d7972a6874d3dfc58148c", "message": "formatting", "committedDate": "2020-08-28T00:30:07Z", "type": "commit"}]}