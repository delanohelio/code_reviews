{"pr_number": 9763, "pr_title": "Add new signature based function registry ", "pr_author": "seut", "pr_createdAt": "2020-03-13T14:46:42Z", "pr_url": "https://github.com/crate/crate/pull/9763", "merge_commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "timeline": [{"oid": "e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "url": "https://github.com/crate/crate/commit/e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [] Support iteration over registered function incl. all info\u2019s required by `pg_proc`\n - [x] Use type precendence and cast if needed\n - [] Move (down-)cast lucene optimization to a rule", "committedDate": "2020-03-13T15:04:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392279860", "body": "I think we output this in `information_schema` tables, so this may be a breaking change. If we do need to change it, maybe we  could go with `innerType.getName() + '[]'` for improved PostgreSQL compatibility?", "bodyText": "I think we output this in information_schema tables, so this may be a breaking change. If we do need to change it, maybe we  could go with innerType.getName() + '[]' for improved PostgreSQL compatibility?", "bodyHTML": "<p dir=\"auto\">I think we output this in <code>information_schema</code> tables, so this may be a breaking change. If we do need to change it, maybe we  could go with <code>innerType.getName() + '[]'</code> for improved PostgreSQL compatibility?</p>", "author": "mfussenegger", "createdAt": "2020-03-13T14:57:26Z", "path": "common/src/main/java/io/crate/types/ArrayType.java", "diffHunk": "@@ -83,7 +93,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n     @Override\n     public String getName() {\n-        return innerType.getName() + \"_\" + NAME;\n+        return NAME + \"(\" + innerType.getName() + \")\";", "originalCommit": "55fcc69ceb8ce55c02e299716218664eb06c6052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkwMDQzMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392900431", "bodyText": "I think we should change it as parsing a E_array (for declaring generic array type signatures) may be error prone, and also it is not good human readable IMO.\nTotally agree that we should try to change it in the right direction, will try to implement it using E[].", "author": "seut", "createdAt": "2020-03-16T10:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxOTIwOQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392919209", "bodyText": "Once you've confirmed that E[] works, could we extract the change into a dedicated PR?", "author": "mfussenegger", "createdAt": "2020-03-16T10:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyOTkyMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392929921", "bodyText": "Or maybe we split this into internalName() / externalName() and defer the breaking change to 5.0?", "author": "mfussenegger", "createdAt": "2020-03-16T10:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0ODEyMg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392948122", "bodyText": "I've just figured out that we don't need to change that as I've handling array signature resolving in concrete way anyway already. So changing this representation would be out of scope for the new signature binding.", "author": "seut", "createdAt": "2020-03-16T11:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}], "type": "inlineReview", "revised_code": {"commit": "a40611b8f14b1a4784ce0e26461ce5effffef895", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/ArrayType.java b/common/src/main/java/io/crate/types/ArrayType.java\nindex 0c86e89310..e5bc128e01 100644\n--- a/common/src/main/java/io/crate/types/ArrayType.java\n+++ b/common/src/main/java/io/crate/types/ArrayType.java\n", "chunk": "@@ -93,7 +93,7 @@ public class ArrayType<T> extends DataType<List<T>> {\n \n     @Override\n     public String getName() {\n-        return NAME + \"(\" + innerType.getName() + \")\";\n+        return innerType.getName() + \"_\" + NAME;\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/ArrayType.java b/common/src/main/java/io/crate/types/ArrayType.java\nindex 0c86e89310..76d7b893d6 100644\n--- a/common/src/main/java/io/crate/types/ArrayType.java\n+++ b/common/src/main/java/io/crate/types/ArrayType.java\n", "chunk": "@@ -93,7 +92,7 @@ public class ArrayType<T> extends DataType<List<T>> {\n \n     @Override\n     public String getName() {\n-        return NAME + \"(\" + innerType.getName() + \")\";\n+        return innerType.getName() + \"_\" + NAME;\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "478e8e6857feb2fbac8619ba7e82a8a91971b7c0", "committedDate": "2020-04-03 08:25:32 +0000", "message": "Add missing type precedence for timestamp types"}, {"oid": "801fcc9b1e070a209197e985ee2e8c168c1a0ec1", "committedDate": "2020-04-03 10:02:00 +0000", "message": "Change DataType to implement Comparator"}, {"oid": "3e999b8e3cc8d82fc135757a5bdd01adb2acfd7b", "committedDate": "2020-04-03 10:02:00 +0000", "message": "Use generics in DataType/Comparable"}, {"oid": "16857998dff6024193471974c24cc2c9b530cec0", "committedDate": "2020-05-11 09:47:56 +0000", "message": "Integrate common, blob, http and es-transport into server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392281372", "body": "What do you think of going for `module.register(signature, types -> impl)`, and omit the `FuncResolver` from the register API?", "bodyText": "What do you think of going for module.register(signature, types -> impl), and omit the FuncResolver from the register API?", "bodyHTML": "<p dir=\"auto\">What do you think of going for <code>module.register(signature, types -&gt; impl)</code>, and omit the <code>FuncResolver</code> from the register API?</p>", "author": "mfussenegger", "createdAt": "2020-03-13T14:59:52Z", "path": "sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java", "diffHunk": "@@ -21,36 +21,81 @@\n \n package io.crate.expression.scalar;\n \n-import com.google.common.base.Preconditions;\n import io.crate.data.Input;\n-import io.crate.exceptions.ConversionException;\n-import io.crate.expression.symbol.FuncArg;\n import io.crate.expression.symbol.Function;\n import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.FuncResolver;\n import io.crate.metadata.FunctionIdent;\n-import io.crate.metadata.FunctionImplementation;\n import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.FunctionName;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n-import io.crate.metadata.functions.params.FuncParams;\n-import io.crate.metadata.functions.params.Param;\n-import io.crate.types.ArrayType;\n-import io.crate.types.DataType;\n+import io.crate.metadata.functions.Signature;\n import io.crate.types.DataTypes;\n \n-import javax.annotation.Nullable;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Locale;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n \n public abstract class ConcatFunction extends Scalar<String, String> {\n \n     public static final String NAME = \"concat\";\n     private FunctionInfo functionInfo;\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        FunctionName name = new FunctionName(null, NAME);\n+\n+        module.register(\n+            new FuncResolver(", "originalCommit": "55fcc69ceb8ce55c02e299716218664eb06c6052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5NzM1OA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392897358", "bodyText": "You mean to create a FuncResolver instance only internally? Sure good point, we just need this class internally for the resolving anyway.", "author": "seut", "createdAt": "2020-03-16T09:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxOTUzOQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392919539", "bodyText": "You mean to create a FuncResolver instance only internally?\n\nyes", "author": "mfussenegger", "createdAt": "2020-03-16T10:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a40611b8f14b1a4784ce0e26461ce5effffef895", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\nindex a6a996a1f8..bd14582848 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n", "chunk": "@@ -49,52 +47,41 @@ public abstract class ConcatFunction extends Scalar<String, String> {\n         FunctionName name = new FunctionName(null, NAME);\n \n         module.register(\n-            new FuncResolver(\n-                new Signature(\n-                    name,\n-                    FunctionInfo.Type.SCALAR,\n-                    Collections.emptyList(),\n-                    List.of(parseTypeSignature(\"text\"), parseTypeSignature(\"text\")),\n-                    parseTypeSignature(\"text\"),\n-                    false),\n-                args -> new StringConcatFunction(\n-                    new FunctionInfo(\n-                        new FunctionIdent(NAME, args),\n-                        DataTypes.STRING))\n+            new Signature(\n+                name,\n+                FunctionInfo.Type.SCALAR,\n+                List.of(parseTypeSignature(\"text\"), parseTypeSignature(\"text\")),\n+                parseTypeSignature(\"text\"),\n+                false\n+            ),\n+            args -> new StringConcatFunction(\n+                new FunctionInfo(new FunctionIdent(NAME, args), DataTypes.STRING)\n             )\n         );\n \n         module.register(\n-            new FuncResolver(\n-                new Signature(\n-                    name,\n-                    FunctionInfo.Type.SCALAR,\n-                    Collections.emptyList(),\n-                    List.of(parseTypeSignature(\"text\")),\n-                    parseTypeSignature(\"text\"),\n-                    true),\n-                args -> new GenericConcatFunction(\n-                    new FunctionInfo(\n-                        new FunctionIdent(NAME, args),\n-                        DataTypes.STRING))\n+            new Signature(\n+                name,\n+                FunctionInfo.Type.SCALAR,\n+                List.of(parseTypeSignature(\"text\")),\n+                parseTypeSignature(\"text\"),\n+                true),\n+            args -> new GenericConcatFunction(\n+                new FunctionInfo(new FunctionIdent(NAME, args), DataTypes.STRING)\n             )\n         );\n \n         // concat(array[], array[]) -> same as `array_cat(...)`\n-        Signature signature = new Signature(\n-            name,\n-            FunctionInfo.Type.SCALAR,\n-            List.of(typeVariable(\"E\")),\n-            List.of(parseTypeSignature(\"array(E)\"), parseTypeSignature(\"array(E)\")),\n-            parseTypeSignature(\"array(E)\"),\n-            false\n-        );\n-\n         module.register(\n-            new FuncResolver(\n-                signature,\n-                args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n-            )\n+            new Signature(\n+                name,\n+                FunctionInfo.Type.SCALAR,\n+                List.of(typeVariable(\"E\")),\n+                List.of(parseTypeSignature(\"E[]\"), parseTypeSignature(\"E[]\")),\n+                parseTypeSignature(\"E[]\"),\n+                false\n+            ),\n+            args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n         );\n     }\n \n", "next_change": {"commit": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\nindex bd14582848..9ffb2bfe7e 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n", "chunk": "@@ -73,14 +69,14 @@ public abstract class ConcatFunction extends Scalar<String, String> {\n \n         // concat(array[], array[]) -> same as `array_cat(...)`\n         module.register(\n-            new Signature(\n-                name,\n-                FunctionInfo.Type.SCALAR,\n-                List.of(typeVariable(\"E\")),\n-                List.of(parseTypeSignature(\"E[]\"), parseTypeSignature(\"E[]\")),\n-                parseTypeSignature(\"E[]\"),\n-                false\n-            ),\n+            Signature.builder()\n+                .name(NAME)\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .typeVariableConstraints(typeVariable(\"E\"))\n+                .argumentTypes(parseTypeSignature(\"array(E)\"), parseTypeSignature(\"array(E)\"))\n+                .returnType(parseTypeSignature(\"array(E)\"))\n+                .setVariableArity(false)\n+                .build(),\n             args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n         );\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\nindex a6a996a1f8..9ffb2bfe7e 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n", "chunk": "@@ -46,55 +41,43 @@ public abstract class ConcatFunction extends Scalar<String, String> {\n     private FunctionInfo functionInfo;\n \n     public static void register(ScalarFunctionModule module) {\n-        FunctionName name = new FunctionName(null, NAME);\n-\n         module.register(\n-            new FuncResolver(\n-                new Signature(\n-                    name,\n-                    FunctionInfo.Type.SCALAR,\n-                    Collections.emptyList(),\n-                    List.of(parseTypeSignature(\"text\"), parseTypeSignature(\"text\")),\n-                    parseTypeSignature(\"text\"),\n-                    false),\n-                args -> new StringConcatFunction(\n-                    new FunctionInfo(\n-                        new FunctionIdent(NAME, args),\n-                        DataTypes.STRING))\n+            Signature.builder()\n+                .name(NAME)\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"text\"))\n+                .returnType(parseTypeSignature(\"text\"))\n+                .setVariableArity(false)\n+                .build(),\n+            args -> new StringConcatFunction(\n+                new FunctionInfo(new FunctionIdent(NAME, args), DataTypes.STRING)\n             )\n         );\n \n         module.register(\n-            new FuncResolver(\n-                new Signature(\n-                    name,\n-                    FunctionInfo.Type.SCALAR,\n-                    Collections.emptyList(),\n-                    List.of(parseTypeSignature(\"text\")),\n-                    parseTypeSignature(\"text\"),\n-                    true),\n-                args -> new GenericConcatFunction(\n-                    new FunctionInfo(\n-                        new FunctionIdent(NAME, args),\n-                        DataTypes.STRING))\n+            Signature.builder()\n+                .name(NAME)\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .argumentTypes(parseTypeSignature(\"text\"))\n+                .returnType(parseTypeSignature(\"text\"))\n+                .setVariableArity(true)\n+                .build(),\n+            args -> new GenericConcatFunction(\n+                new FunctionInfo(new FunctionIdent(NAME, args), DataTypes.STRING)\n             )\n         );\n \n         // concat(array[], array[]) -> same as `array_cat(...)`\n-        Signature signature = new Signature(\n-            name,\n-            FunctionInfo.Type.SCALAR,\n-            List.of(typeVariable(\"E\")),\n-            List.of(parseTypeSignature(\"array(E)\"), parseTypeSignature(\"array(E)\")),\n-            parseTypeSignature(\"array(E)\"),\n-            false\n-        );\n-\n         module.register(\n-            new FuncResolver(\n-                signature,\n-                args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n-            )\n+            Signature.builder()\n+                .name(NAME)\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .typeVariableConstraints(typeVariable(\"E\"))\n+                .argumentTypes(parseTypeSignature(\"array(E)\"), parseTypeSignature(\"array(E)\"))\n+                .returnType(parseTypeSignature(\"array(E)\"))\n+                .setVariableArity(false)\n+                .build(),\n+            args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n         );\n     }\n \n", "next_change": {"commit": "898b5c78acdcf2e117e6332103ecb08eda8c6c74", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\nindex 9ffb2bfe7e..141000acd5 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n", "chunk": "@@ -77,7 +77,7 @@ public abstract class ConcatFunction extends Scalar<String, String> {\n                 .returnType(parseTypeSignature(\"array(E)\"))\n                 .setVariableArity(false)\n                 .build(),\n-            args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n+            args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args, NAME))\n         );\n     }\n \n", "next_change": {"commit": "91795c06d68ae6b0289ccd383191aa6df12723ee", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\nindex 141000acd5..06e13c644e 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n", "chunk": "@@ -69,14 +67,13 @@ public abstract class ConcatFunction extends Scalar<String, String> {\n \n         // concat(array[], array[]) -> same as `array_cat(...)`\n         module.register(\n-            Signature.builder()\n-                .name(NAME)\n-                .kind(FunctionInfo.Type.SCALAR)\n-                .typeVariableConstraints(typeVariable(\"E\"))\n-                .argumentTypes(parseTypeSignature(\"array(E)\"), parseTypeSignature(\"array(E)\"))\n-                .returnType(parseTypeSignature(\"array(E)\"))\n-                .setVariableArity(false)\n-                .build(),\n+            Signature.scalar(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                parseTypeSignature(\"array(E)\"),\n+                parseTypeSignature(\"array(E)\")\n+            )\n+                .withTypeVariableConstraints(typeVariable(\"E\")),\n             args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args, NAME))\n         );\n     }\n", "next_change": {"commit": "8f29abc16157d4421773704cb3c0adecf3036c4c", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\nindex 06e13c644e..b30171bcff 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java\n", "chunk": "@@ -74,12 +79,20 @@ public abstract class ConcatFunction extends Scalar<String, String> {\n                 parseTypeSignature(\"array(E)\")\n             )\n                 .withTypeVariableConstraints(typeVariable(\"E\")),\n-            args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args, NAME))\n+            (signature, args) ->\n+                new ArrayCatFunction(\n+                    ArrayCatFunction.createInfo(args, NAME),\n+                    signature\n+                )\n         );\n     }\n \n-    ConcatFunction(FunctionInfo functionInfo) {\n+    private final FunctionInfo functionInfo;\n+    private final Signature signature;\n+\n+    ConcatFunction(FunctionInfo functionInfo, Signature signature) {\n         this.functionInfo = functionInfo;\n+        this.signature = signature;\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "898b5c78acdcf2e117e6332103ecb08eda8c6c74", "committedDate": "2020-03-31 15:30:51 +0000", "message": "Refactor all array scalars to new function registry"}, {"oid": "91795c06d68ae6b0289ccd383191aa6df12723ee", "committedDate": "2020-04-03 08:25:32 +0000", "message": "Add support for selecting most specific function"}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"oid": "a40611b8f14b1a4784ce0e26461ce5effffef895", "url": "https://github.com/crate/crate/commit/a40611b8f14b1a4784ce0e26461ce5effffef895", "message": "fixup! WIP: refactor function registration and resolving", "committedDate": "2020-03-16T21:31:02Z", "type": "forcePushed"}, {"oid": "9a7922b487370f2b3c300b8d2b34104445ac3241", "url": "https://github.com/crate/crate/commit/9a7922b487370f2b3c300b8d2b34104445ac3241", "message": "fixup! WIP: refactor function registration and resolving", "committedDate": "2020-03-16T21:33:28Z", "type": "forcePushed"}, {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "url": "https://github.com/crate/crate/commit/93edb2cb269dd2510ffe9de10ccc94961994a0c2", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed", "committedDate": "2020-03-20T13:27:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDMxMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r395640311", "body": "This is not really correct, depending on the argument types it will change to `object(text, V, text, V2, ...)` where `V` and `V2` may be bound to different types.\r\nCurrently the return type is not used so it won't matter, but will be later used for information of all registered functions (`pg_proc`).\r\nNot sure, shall we define it as `object()` (undefined inner types)? We could also discuss/change it when adding the signature information to `pg_proc`.", "bodyText": "This is not really correct, depending on the argument types it will change to object(text, V, text, V2, ...) where V and V2 may be bound to different types.\nCurrently the return type is not used so it won't matter, but will be later used for information of all registered functions (pg_proc).\nNot sure, shall we define it as object() (undefined inner types)? We could also discuss/change it when adding the signature information to pg_proc.", "bodyHTML": "<p dir=\"auto\">This is not really correct, depending on the argument types it will change to <code>object(text, V, text, V2, ...)</code> where <code>V</code> and <code>V2</code> may be bound to different types.<br>\nCurrently the return type is not used so it won't matter, but will be later used for information of all registered functions (<code>pg_proc</code>).<br>\nNot sure, shall we define it as <code>object()</code> (undefined inner types)? We could also discuss/change it when adding the signature information to <code>pg_proc</code>.</p>", "author": "seut", "createdAt": "2020-03-20T13:37:11Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java", "diffHunk": "@@ -90,7 +78,17 @@ public final Object evaluate(TransactionContext txnCtx, Input<Object>... args) {\n         return m;\n     }\n \n-    public static void register(ScalarFunctionModule scalarFunctionModule) {\n-        scalarFunctionModule.register(NAME, RESOLVER);\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.builder()\n+                .name(new FunctionName(null, NAME))\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n+                .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n+                .returnType(parseTypeSignature(\"object(text, V)\"))", "originalCommit": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxODczMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396318731", "bodyText": "Not sure how to deal with this, but maybe meanwhile add a comment inline to point this out.", "author": "mfussenegger", "createdAt": "2020-03-23T09:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\nindex 06a6df89e1..7c39f47bbe 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\n", "chunk": "@@ -85,6 +85,9 @@ public class MapFunction extends Scalar<Object, Object> {\n                 .kind(FunctionInfo.Type.SCALAR)\n                 .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n                 .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n+                // This is not 100% correct because each variadic `V` is type independent, resulting in a return type\n+                // of e.g. `object(text, int, text, geo_point, ...)`.\n+                // This is *ok* as the returnType is currently not used directly, only for function description.\n                 .returnType(parseTypeSignature(\"object(text, V)\"))\n                 .variableArityGroup(List.of(parseTypeSignature(\"text\"), parseTypeSignature(\"V\")))\n                 .build(),\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\nindex 06a6df89e1..7c39f47bbe 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\n", "chunk": "@@ -85,6 +85,9 @@ public class MapFunction extends Scalar<Object, Object> {\n                 .kind(FunctionInfo.Type.SCALAR)\n                 .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n                 .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n+                // This is not 100% correct because each variadic `V` is type independent, resulting in a return type\n+                // of e.g. `object(text, int, text, geo_point, ...)`.\n+                // This is *ok* as the returnType is currently not used directly, only for function description.\n                 .returnType(parseTypeSignature(\"object(text, V)\"))\n                 .variableArityGroup(List.of(parseTypeSignature(\"text\"), parseTypeSignature(\"V\")))\n                 .build(),\n", "next_change": {"commit": "8f29abc16157d4421773704cb3c0adecf3036c4c", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java b/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\nindex 7c39f47bbe..e42cfba0d9 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java\n", "chunk": "@@ -77,21 +107,4 @@ public class MapFunction extends Scalar<Object, Object> {\n         }\n         return m;\n     }\n-\n-    public static void register(ScalarFunctionModule module) {\n-        module.register(\n-            Signature.builder()\n-                .name(new FunctionName(null, NAME))\n-                .kind(FunctionInfo.Type.SCALAR)\n-                .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n-                .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n-                // This is not 100% correct because each variadic `V` is type independent, resulting in a return type\n-                // of e.g. `object(text, int, text, geo_point, ...)`.\n-                // This is *ok* as the returnType is currently not used directly, only for function description.\n-                .returnType(parseTypeSignature(\"object(text, V)\"))\n-                .variableArityGroup(List.of(parseTypeSignature(\"text\"), parseTypeSignature(\"V\")))\n-                .build(),\n-            args -> new MapFunction(createInfo(args))\n-        );\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "18302cd7f7671d745cd86888ccc35882f9077565", "committedDate": "2020-05-06 11:38:30 +0000", "message": "Use the static ObjectType instance instead of initializing it on call."}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTc1MQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r395641751", "body": "This class just acts a `Map` holder, we could also use the map directly and remove this class. I tend to keep it mainly for readability reasons inside the `SignatureBinder`. Any input?", "bodyText": "This class just acts a Map holder, we could also use the map directly and remove this class. I tend to keep it mainly for readability reasons inside the SignatureBinder. Any input?", "bodyHTML": "<p dir=\"auto\">This class just acts a <code>Map</code> holder, we could also use the map directly and remove this class. I tend to keep it mainly for readability reasons inside the <code>SignatureBinder</code>. Any input?</p>", "author": "seut", "createdAt": "2020-03-20T13:39:29Z", "path": "sql/src/main/java/io/crate/metadata/functions/BoundVariables.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.types.DataType;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class BoundVariables {\n+\n+    private final Map<String, DataType<?>> typeVariables;", "originalCommit": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTYzMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396319631", "bodyText": "I think it is okay to keep it, but if so it should fully encapsulate typeVariables. Currently it also leaks the map via  public Map<String, DataType<?>> getTypeVariables() {", "author": "mfussenegger", "createdAt": "2020-03-23T09:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java b/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java\nindex 637006abc8..d40d1b0979 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java\n", "chunk": "@@ -27,6 +27,7 @@ import io.crate.types.DataType;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Set;\n \n public class BoundVariables {\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java b/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java\nindex 637006abc8..d40d1b0979 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/BoundVariables.java\n", "chunk": "@@ -27,6 +27,7 @@ import io.crate.types.DataType;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Set;\n \n public class BoundVariables {\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"oid": "046cc3051132bb213b51dc22a8097c824d9129e4", "url": "https://github.com/crate/crate/commit/046cc3051132bb213b51dc22a8097c824d9129e4", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed", "committedDate": "2020-03-20T13:40:11Z", "type": "forcePushed"}, {"oid": "856c4ce868244694941c78ac38b2369da550943c", "url": "https://github.com/crate/crate/commit/856c4ce868244694941c78ac38b2369da550943c", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or \nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted, \nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-20T14:13:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5OTI0Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396299247", "body": "Would it make sense to have this method in `TypeSignature` ? `signature.createType()` or something like that?", "bodyText": "Would it make sense to have this method in TypeSignature ? signature.createType() or something like that?", "bodyHTML": "<p dir=\"auto\">Would it make sense to have this method in <code>TypeSignature</code> ? <code>signature.createType()</code> or something like that?</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:05:09Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMDE0OQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396300149", "body": "I'd inline this. It's a shallow method that adds no additional meaning.", "bodyText": "I'd inline this. It's a shallow method that adds no additional meaning.", "bodyHTML": "<p dir=\"auto\">I'd inline this. It's a shallow method that adds no additional meaning.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:06:48Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMjg4MA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396302880", "body": "Maybe make this top-level. I think if we move the `getType` into `TypeSignature` we could get rid of the `TypeSignatures` \"utils\" style class and expose the `getCommonSuperType` as part of the (then top-level) `TypeCompatibility` class. This would make the responsibility imho a bit clearer.\r\n\r\n", "bodyText": "Maybe make this top-level. I think if we move the getType into TypeSignature we could get rid of the TypeSignatures \"utils\" style class and expose the getCommonSuperType as part of the (then top-level) TypeCompatibility class. This would make the responsibility imho a bit clearer.", "bodyHTML": "<p dir=\"auto\">Maybe make this top-level. I think if we move the <code>getType</code> into <code>TypeSignature</code> we could get rid of the <code>TypeSignatures</code> \"utils\" style class and expose the <code>getCommonSuperType</code> as part of the (then top-level) <code>TypeCompatibility</code> class. This would make the responsibility imho a bit clearer.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:11:48Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            return compatibility(coercedType, toType);\n+        }\n+\n+        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n+            if (!typeCompatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n+        }\n+\n+        return TypeCompatibility.incompatible();\n+    }\n+\n+    @Nullable\n+    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n+        final DataType<?> higherPrecedenceArg;\n+        final DataType<?> lowerPrecedenceArg;\n+        if (arg1.precedes(arg2)) {\n+            higherPrecedenceArg = arg1;\n+            lowerPrecedenceArg = arg2;\n+        } else {\n+            higherPrecedenceArg = arg2;\n+            lowerPrecedenceArg = arg1;\n+        }\n+\n+        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n+        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n+\n+        if (lowerPrecedenceCastable) {\n+            return higherPrecedenceArg;\n+        } else if (higherPrecedenceCastable) {\n+            return lowerPrecedenceArg;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n+        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n+        if (resultType.equals(sourceType)) {\n+            return sourceType;\n+        }\n+        return convertTypeByPrecedence(sourceType, resultType);\n+    }\n+\n+    private static boolean isCovariantParametrizedType(DataType<?> type) {\n+        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n+        return type instanceof ObjectType || type instanceof ArrayType;\n+    }\n+\n+    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n+        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n+        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n+        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n+\n+        if (fromTypeParameters.size() != toTypeParameters.size()) {\n+            return TypeCompatibility.incompatible();\n+        }\n+\n+        boolean coercible = true;\n+        for (int i = 0; i < fromTypeParameters.size(); i++) {\n+            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n+            if (!compatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            coercible &= compatibility.isCoercible();\n+            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n+        }\n+        String typeBase = fromType.getTypeSignature().getBase();\n+        return TypeCompatibility.compatible(\n+            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n+            coercible);\n+    }\n+\n+    public static class TypeCompatibility {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMzI0NQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396303245", "body": "Is the cyclic dependency here really needed (TypeSignatureParameter has a reference to TypeSignature, TypeSignature has references to TypeSignatureParameter)", "bodyText": "Is the cyclic dependency here really needed (TypeSignatureParameter has a reference to TypeSignature, TypeSignature has references to TypeSignatureParameter)", "bodyHTML": "<p dir=\"auto\">Is the cyclic dependency here really needed (TypeSignatureParameter has a reference to TypeSignature, TypeSignature has references to TypeSignatureParameter)</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:12:33Z", "path": "common/src/main/java/io/crate/types/TypeSignatureParameter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.Objects;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class TypeSignatureParameter {\n+\n+    private final TypeSignature value;\n+\n+    public static TypeSignatureParameter of(TypeSignature typeSignature) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMjg1MQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396312851", "bodyText": "I think we could remove TypeSignatureParameter at all as it won't add any functionality.", "author": "seut", "createdAt": "2020-03-23T09:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMzI0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatureParameter.java b/common/src/main/java/io/crate/types/TypeSignatureParameter.java\ndeleted file mode 100644\nindex 03c3c789ac..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatureParameter.java\n+++ /dev/null\n", "chunk": "@@ -1,69 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import java.util.Objects;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-public class TypeSignatureParameter {\n-\n-    private final TypeSignature value;\n-\n-    public static TypeSignatureParameter of(TypeSignature typeSignature) {\n-        return new TypeSignatureParameter(typeSignature);\n-    }\n-\n-    private TypeSignatureParameter(TypeSignature value) {\n-        this.value = requireNonNull(value, \"value is null\");\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return value.toString();\n-    }\n-\n-    public TypeSignature getTypeSignature() {\n-        return value;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-\n-        TypeSignatureParameter other = (TypeSignatureParameter) o;\n-\n-        return Objects.equals(this.value, other.value);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(value);\n-    }\n-\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatureParameter.java b/common/src/main/java/io/crate/types/TypeSignatureParameter.java\ndeleted file mode 100644\nindex 03c3c789ac..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatureParameter.java\n+++ /dev/null\n", "chunk": "@@ -1,69 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import java.util.Objects;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-public class TypeSignatureParameter {\n-\n-    private final TypeSignature value;\n-\n-    public static TypeSignatureParameter of(TypeSignature typeSignature) {\n-        return new TypeSignatureParameter(typeSignature);\n-    }\n-\n-    private TypeSignatureParameter(TypeSignature value) {\n-        this.value = requireNonNull(value, \"value is null\");\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return value.toString();\n-    }\n-\n-    public TypeSignature getTypeSignature() {\n-        return value;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-\n-        TypeSignatureParameter other = (TypeSignatureParameter) o;\n-\n-        return Objects.equals(this.value, other.value);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(value);\n-    }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNzQ2NQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396307465", "body": "Maybe clarify that `base` is (part of) the type name.", "bodyText": "Maybe clarify that base is (part of) the type name.", "bodyHTML": "<p dir=\"auto\">Maybe clarify that <code>base</code> is (part of) the type name.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:19:57Z", "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    public static TypeSignature parseTypeSignature(String signature) {\n+        if (!signature.contains(\"(\")) {\n+            return new TypeSignature(signature);\n+        }\n+\n+        String baseName = null;\n+        List<TypeSignatureParameter> parameters = new ArrayList<>();\n+        int parameterStart = -1;\n+        int bracketCount = 0;\n+\n+        for (int i = 0; i < signature.length(); i++) {\n+            char c = signature.charAt(i);\n+            if (c == '(') {\n+                if (bracketCount == 0) {\n+                    assert baseName == null : \"Expected baseName to be null\";\n+                    baseName = signature.substring(0, i);\n+                    parameterStart = i + 1;\n+                }\n+                bracketCount++;\n+            } else if (c == ')') {\n+                bracketCount--;\n+                if (bracketCount == 0) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                    if (i == signature.length() - 1) {\n+                        return new TypeSignature(baseName, parameters);\n+                    }\n+                }\n+            } else if (c == ',') {\n+                if (bracketCount == 1) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(format(Locale.ENGLISH, \"Bad type signature: '%s'\", signature));\n+    }\n+\n+    private static TypeSignatureParameter parseTypeSignatureParameter(String signature, int begin, int end) {\n+        String parameterName = signature.substring(begin, end).trim();\n+        return TypeSignatureParameter.of(parseTypeSignature(parameterName));\n+    }\n+\n+    private final String base;\n+    private final List<TypeSignatureParameter> parameters;\n+\n+    public TypeSignature(String base) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignature.java b/common/src/main/java/io/crate/types/TypeSignature.java\nindex 4c992b45ae..9b8173ff6f 100644\n--- a/common/src/main/java/io/crate/types/TypeSignature.java\n+++ b/common/src/main/java/io/crate/types/TypeSignature.java\n", "chunk": "@@ -73,38 +91,62 @@ public class TypeSignature {\n         throw new IllegalArgumentException(format(Locale.ENGLISH, \"Bad type signature: '%s'\", signature));\n     }\n \n-    private static TypeSignatureParameter parseTypeSignatureParameter(String signature, int begin, int end) {\n+    private static TypeSignature parseTypeSignatureParameter(String signature, int begin, int end) {\n         String parameterName = signature.substring(begin, end).trim();\n-        return TypeSignatureParameter.of(parseTypeSignature(parameterName));\n+        return parseTypeSignature(parameterName);\n     }\n \n-    private final String base;\n-    private final List<TypeSignatureParameter> parameters;\n+    private final String baseTypeName;\n+    private final List<TypeSignature> parameters;\n \n-    public TypeSignature(String base) {\n-        this(base, Collections.emptyList());\n+    public TypeSignature(String baseTypeName) {\n+        this(baseTypeName, Collections.emptyList());\n     }\n \n-    public TypeSignature(String base, List<TypeSignatureParameter> parameters) {\n-        this.base = base;\n+    public TypeSignature(String baseTypeName, List<TypeSignature> parameters) {\n+        this.baseTypeName = baseTypeName;\n         this.parameters = parameters;\n     }\n \n-    public String getBase() {\n-        return base;\n+    public String getBaseTypeName() {\n+        return baseTypeName;\n     }\n \n-    public List<TypeSignatureParameter> getParameters() {\n+    public List<TypeSignature> getParameters() {\n         return parameters;\n     }\n \n+    /**\n+     * Create the concrete {@link DataType} for this type signature.\n+     * Only `array` and `object` parameterized type signatures are supported.\n+     */\n+    public DataType<?> createType() {\n+        if (baseTypeName.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = parameters.get(0).createType();\n+            return new ArrayType<>(innerType);\n+        }\n+        if (baseTypeName.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), valTypeSignature.createType());\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(baseTypeName);\n+    }\n+\n     @Override\n     public String toString() {\n         if (parameters.isEmpty()) {\n-            return base;\n+            return baseTypeName;\n         }\n \n-        StringBuilder typeName = new StringBuilder(base);\n+        StringBuilder typeName = new StringBuilder(baseTypeName);\n         typeName.append(\"(\").append(parameters.get(0));\n         for (int i = 1; i < parameters.size(); i++) {\n             typeName.append(\",\").append(parameters.get(i));\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignature.java b/common/src/main/java/io/crate/types/TypeSignature.java\nindex 4c992b45ae..9b8173ff6f 100644\n--- a/common/src/main/java/io/crate/types/TypeSignature.java\n+++ b/common/src/main/java/io/crate/types/TypeSignature.java\n", "chunk": "@@ -73,38 +91,62 @@ public class TypeSignature {\n         throw new IllegalArgumentException(format(Locale.ENGLISH, \"Bad type signature: '%s'\", signature));\n     }\n \n-    private static TypeSignatureParameter parseTypeSignatureParameter(String signature, int begin, int end) {\n+    private static TypeSignature parseTypeSignatureParameter(String signature, int begin, int end) {\n         String parameterName = signature.substring(begin, end).trim();\n-        return TypeSignatureParameter.of(parseTypeSignature(parameterName));\n+        return parseTypeSignature(parameterName);\n     }\n \n-    private final String base;\n-    private final List<TypeSignatureParameter> parameters;\n+    private final String baseTypeName;\n+    private final List<TypeSignature> parameters;\n \n-    public TypeSignature(String base) {\n-        this(base, Collections.emptyList());\n+    public TypeSignature(String baseTypeName) {\n+        this(baseTypeName, Collections.emptyList());\n     }\n \n-    public TypeSignature(String base, List<TypeSignatureParameter> parameters) {\n-        this.base = base;\n+    public TypeSignature(String baseTypeName, List<TypeSignature> parameters) {\n+        this.baseTypeName = baseTypeName;\n         this.parameters = parameters;\n     }\n \n-    public String getBase() {\n-        return base;\n+    public String getBaseTypeName() {\n+        return baseTypeName;\n     }\n \n-    public List<TypeSignatureParameter> getParameters() {\n+    public List<TypeSignature> getParameters() {\n         return parameters;\n     }\n \n+    /**\n+     * Create the concrete {@link DataType} for this type signature.\n+     * Only `array` and `object` parameterized type signatures are supported.\n+     */\n+    public DataType<?> createType() {\n+        if (baseTypeName.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = parameters.get(0).createType();\n+            return new ArrayType<>(innerType);\n+        }\n+        if (baseTypeName.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), valTypeSignature.createType());\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(baseTypeName);\n+    }\n+\n     @Override\n     public String toString() {\n         if (parameters.isEmpty()) {\n-            return base;\n+            return baseTypeName;\n         }\n \n-        StringBuilder typeName = new StringBuilder(base);\n+        StringBuilder typeName = new StringBuilder(baseTypeName);\n         typeName.append(\"(\").append(parameters.get(0));\n         for (int i = 1; i < parameters.size(); i++) {\n             typeName.append(\",\").append(parameters.get(i));\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "8ce9ae1425f396285b8e6d6efe8d4c27354ca53a", "committedDate": "2020-04-02 11:54:04 +0000", "message": "Fix setting inner object type names in TypeSignature#createType."}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "0d5adc08af6d217d8717b83e46cbbe93b6cdb34e", "committedDate": "2020-04-23 14:04:15 +0000", "message": "Add support for the record type signature parsing."}, {"oid": "16857998dff6024193471974c24cc2c9b530cec0", "committedDate": "2020-05-11 09:47:56 +0000", "message": "Integrate common, blob, http and es-transport into server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwODQ3Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396308477", "body": "Could you add a comment somewhere that explains why we \"default\" to covariant?  (This is not configurable so far as part of the Signature building, right?)", "bodyText": "Could you add a comment somewhere that explains why we \"default\" to covariant?  (This is not configurable so far as part of the Signature building, right?)", "bodyHTML": "<p dir=\"auto\">Could you add a comment somewhere that explains why we \"default\" to covariant?  (This is not configurable so far as part of the Signature building, right?)</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:21:49Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4ODI3OQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396488279", "bodyText": "I've changed this slightly and removed some other covariant logic as I think a covariant or invariant can already expressed by type variables.", "author": "seut", "createdAt": "2020-03-23T14:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwODQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMDg0OA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396310848", "body": "I'm not sure if `superType` is the right term, as we have no type hierarchies (?). So far in other places we used `targetType` - not sure if that's better.", "bodyText": "I'm not sure if superType is the right term, as we have no type hierarchies (?). So far in other places we used targetType - not sure if that's better.", "bodyHTML": "<p dir=\"auto\">I'm not sure if <code>superType</code> is the right term, as we have no type hierarchies (?). So far in other places we used <code>targetType</code> - not sure if that's better.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:25:43Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMjc1Mw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396312753", "body": "Would it make sense to have the `getBase()`  directly in `DataType` ? E.g. `type.getBaseName()`. Would make sure that we don't construct the `TypeSignature` multiple times. ", "bodyText": "Would it make sense to have the getBase()  directly in DataType ? E.g. type.getBaseName(). Would make sure that we don't construct the TypeSignature multiple times.", "bodyHTML": "<p dir=\"auto\">Would it make sense to have the <code>getBase()</code>  directly in <code>DataType</code> ? E.g. <code>type.getBaseName()</code>. Would make sure that we don't construct the <code>TypeSignature</code> multiple times.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:28:42Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDU3Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396314577", "body": "I think a \"why\" comment would be more useful here. Explain why the `commonSuperType` logic above can fail and which cases are enabled here.", "bodyText": "I think a \"why\" comment would be more useful here. Explain why the commonSuperType logic above can fail and which cases are enabled here.", "bodyHTML": "<p dir=\"auto\">I think a \"why\" comment would be more useful here. Explain why the <code>commonSuperType</code> logic above can fail and which cases are enabled here.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:31:49Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDg1Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396314857", "body": "This could probably be a singleton.", "bodyText": "This could probably be a singleton.", "bodyHTML": "<p dir=\"auto\">This could probably be a singleton.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:32:18Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            return compatibility(coercedType, toType);\n+        }\n+\n+        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n+            if (!typeCompatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n+        }\n+\n+        return TypeCompatibility.incompatible();\n+    }\n+\n+    @Nullable\n+    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n+        final DataType<?> higherPrecedenceArg;\n+        final DataType<?> lowerPrecedenceArg;\n+        if (arg1.precedes(arg2)) {\n+            higherPrecedenceArg = arg1;\n+            lowerPrecedenceArg = arg2;\n+        } else {\n+            higherPrecedenceArg = arg2;\n+            lowerPrecedenceArg = arg1;\n+        }\n+\n+        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n+        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n+\n+        if (lowerPrecedenceCastable) {\n+            return higherPrecedenceArg;\n+        } else if (higherPrecedenceCastable) {\n+            return lowerPrecedenceArg;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n+        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n+        if (resultType.equals(sourceType)) {\n+            return sourceType;\n+        }\n+        return convertTypeByPrecedence(sourceType, resultType);\n+    }\n+\n+    private static boolean isCovariantParametrizedType(DataType<?> type) {\n+        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n+        return type instanceof ObjectType || type instanceof ArrayType;\n+    }\n+\n+    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n+        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n+        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n+        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n+\n+        if (fromTypeParameters.size() != toTypeParameters.size()) {\n+            return TypeCompatibility.incompatible();\n+        }\n+\n+        boolean coercible = true;\n+        for (int i = 0; i < fromTypeParameters.size(); i++) {\n+            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n+            if (!compatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            coercible &= compatibility.isCoercible();\n+            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n+        }\n+        String typeBase = fromType.getTypeSignature().getBase();\n+        return TypeCompatibility.compatible(\n+            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n+            coercible);\n+    }\n+\n+    public static class TypeCompatibility {\n+        @Nullable\n+        private final DataType<?> commonSuperType;\n+        private final boolean coercible;\n+\n+        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n+            this.commonSuperType = commonSuperType;\n+            this.coercible = coercible;\n+        }\n+\n+        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n+            return new TypeCompatibility(commonSuperType, coercible);\n+        }\n+\n+        private static TypeCompatibility incompatible() {\n+            return new TypeCompatibility(null, false);", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignatures.java b/common/src/main/java/io/crate/types/TypeSignatures.java\ndeleted file mode 100644\nindex cbf9fba967..0000000000\n--- a/common/src/main/java/io/crate/types/TypeSignatures.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-/*\n- * Licensed to Crate under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional\n- * information regarding copyright ownership.  Crate licenses this file\n- * to you under the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.  You may\n- * obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n- * implied.  See the License for the specific language governing\n- * permissions and limitations under the License.\n- *\n- * However, if you have executed another commercial license agreement\n- * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial\n- * agreement.\n- */\n-\n-package io.crate.types;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static io.crate.types.TypeSignature.parseTypeSignature;\n-\n-public final class TypeSignatures {\n-\n-    /**\n-     * Gets the type with the specified signature.\n-     */\n-    public static DataType<?> getType(TypeSignature signature) {\n-        String base = signature.getBase();\n-        List<TypeSignatureParameter> parameters = signature.getParameters();\n-        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n-            if (parameters.size() == 0) {\n-                return new ArrayType<>(UndefinedType.INSTANCE);\n-            }\n-            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n-            return new ArrayType<>(innerType);\n-        }\n-        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n-            var builder = ObjectType.builder();\n-            for (int i = 0; i < parameters.size() - 1;) {\n-                var valTypeSignature = parameters.get(i + 1);\n-                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n-                i += 2;\n-            }\n-            return builder.build();\n-        }\n-        return DataTypes.ofName(signature.getBase());\n-    }\n-\n-    @Nullable\n-    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonSuperType();\n-    }\n-\n-    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n-        return fromType.isConvertableTo(toType);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n-        if (fromType.equals(toType)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(toType, true);\n-        }\n-\n-        if (toType.equals(UndefinedType.INSTANCE)) {\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n-        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n-        String toTypeBaseName = toType.getTypeSignature().getBase();\n-        if (fromTypeBaseName.equals(toTypeBaseName)) {\n-            if (isCovariantParametrizedType(fromType)) {\n-                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n-            }\n-            return TypeCompatibility.compatible(fromType, false);\n-        }\n-\n-        // Use possible common super type (safe conversion)\n-        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n-        if (commonSuperType != null) {\n-            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n-        }\n-\n-        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n-        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            return compatibility(coercedType, toType);\n-        }\n-\n-        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n-        if (coercedType != null) {\n-            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n-            if (!typeCompatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n-        }\n-\n-        return TypeCompatibility.incompatible();\n-    }\n-\n-    @Nullable\n-    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n-        final DataType<?> higherPrecedenceArg;\n-        final DataType<?> lowerPrecedenceArg;\n-        if (arg1.precedes(arg2)) {\n-            higherPrecedenceArg = arg1;\n-            lowerPrecedenceArg = arg2;\n-        } else {\n-            higherPrecedenceArg = arg2;\n-            lowerPrecedenceArg = arg1;\n-        }\n-\n-        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n-        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n-\n-        if (lowerPrecedenceCastable) {\n-            return higherPrecedenceArg;\n-        } else if (higherPrecedenceCastable) {\n-            return lowerPrecedenceArg;\n-        }\n-\n-        return null;\n-    }\n-\n-    @Nullable\n-    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n-        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n-        if (resultType.equals(sourceType)) {\n-            return sourceType;\n-        }\n-        return convertTypeByPrecedence(sourceType, resultType);\n-    }\n-\n-    private static boolean isCovariantParametrizedType(DataType<?> type) {\n-        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n-        return type instanceof ObjectType || type instanceof ArrayType;\n-    }\n-\n-    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n-        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n-        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n-        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n-\n-        if (fromTypeParameters.size() != toTypeParameters.size()) {\n-            return TypeCompatibility.incompatible();\n-        }\n-\n-        boolean coercible = true;\n-        for (int i = 0; i < fromTypeParameters.size(); i++) {\n-            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n-            if (!compatibility.isCompatible()) {\n-                return TypeCompatibility.incompatible();\n-            }\n-            coercible &= compatibility.isCoercible();\n-            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n-        }\n-        String typeBase = fromType.getTypeSignature().getBase();\n-        return TypeCompatibility.compatible(\n-            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n-            coercible);\n-    }\n-\n-    public static class TypeCompatibility {\n-        @Nullable\n-        private final DataType<?> commonSuperType;\n-        private final boolean coercible;\n-\n-        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n-            this.commonSuperType = commonSuperType;\n-            this.coercible = coercible;\n-        }\n-\n-        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-            return new TypeCompatibility(commonSuperType, coercible);\n-        }\n-\n-        private static TypeCompatibility incompatible() {\n-            return new TypeCompatibility(null, false);\n-        }\n-\n-        public boolean isCompatible() {\n-            return commonSuperType != null;\n-        }\n-\n-        public DataType<?> getCommonSuperType() {\n-            if (commonSuperType == null) {\n-                throw new IllegalStateException(\"Types are not compatible\");\n-            }\n-            return commonSuperType;\n-        }\n-\n-        public boolean isCoercible() {\n-            return coercible;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTk0Ng==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396315946", "body": "Do you think it would make sense to have a shortcut for the common case?\r\n\r\nLike `Signature.scalar(NAME, DataType<?> ... types)` where the last type is the return type.", "bodyText": "Do you think it would make sense to have a shortcut for the common case?\nLike Signature.scalar(NAME, DataType<?> ... types) where the last type is the return type.", "bodyHTML": "<p dir=\"auto\">Do you think it would make sense to have a shortcut for the common case?</p>\n<p dir=\"auto\">Like <code>Signature.scalar(NAME, DataType&lt;?&gt; ... types)</code> where the last type is the return type.</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:33:55Z", "path": "sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java", "diffHunk": "@@ -53,7 +54,17 @@ public static FunctionInfo createInfo(List<DataType> types) {\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        module.register(\n+            Signature.builder()", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4OTMwNw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396489307", "bodyText": "Yes sure, I've planned to add them later on when moving more functions to the new registry but maybe its worth doing already", "author": "seut", "createdAt": "2020-03-23T14:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTk0Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "898b5c78acdcf2e117e6332103ecb08eda8c6c74", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java\nindex 71a4a85647..b68c986643 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java\n", "chunk": "@@ -44,26 +43,25 @@ class ArrayCatFunction extends Scalar<List<Object>, List<Object>> {\n     public static final String NAME = \"array_cat\";\n     private final FunctionInfo functionInfo;\n \n-    public static FunctionInfo createInfo(List<DataType> types) {\n-        validateInnerTypes(types);\n-        ArrayType arrayType = (ArrayType) types.get(0);\n+    public static FunctionInfo createInfo(List<DataType> types, String name) {\n+        ensureBothInnerTypesAreNotUndefined(types, name);\n+        ArrayType<?> arrayType = (ArrayType<?>) types.get(0);\n         if (arrayType.innerType().equals(DataTypes.UNDEFINED)) {\n-            arrayType = (ArrayType) types.get(1);\n+            arrayType = (ArrayType<?>) types.get(1);\n         }\n         return new FunctionInfo(new FunctionIdent(NAME, types), arrayType);\n     }\n \n     public static void register(ScalarFunctionModule module) {\n         module.register(\n-            Signature.builder()\n-                .name(NAME)\n-                .kind(FunctionInfo.Type.SCALAR)\n-                .typeVariableConstraints(typeVariable(\"E\"))\n-                .argumentTypes(parseTypeSignature(\"array(E)\"), parseTypeSignature(\"array(E)\"))\n-                .returnType(parseTypeSignature(\"array(E)\"))\n-                .setVariableArity(false)\n-                .build(),\n-            args -> new ArrayCatFunction(ArrayCatFunction.createInfo(args))\n+            Signature.scalar(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                parseTypeSignature(\"array(E)\"),\n+                parseTypeSignature(\"array(E)\")\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            args ->\n+                new ArrayCatFunction(ArrayCatFunction.createInfo(args, NAME))\n         );\n     }\n \n", "next_change": {"commit": "8f29abc16157d4421773704cb3c0adecf3036c4c", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java b/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java\nindex b68c986643..65914173ad 100644\n--- a/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java\n+++ b/sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java\n", "chunk": "@@ -59,14 +59,22 @@ class ArrayCatFunction extends Scalar<List<Object>, List<Object>> {\n                 parseTypeSignature(\"array(E)\"),\n                 parseTypeSignature(\"array(E)\"),\n                 parseTypeSignature(\"array(E)\")\n-            ).withTypeVariableConstraints(typeVariable(\"E\")),\n-            args ->\n-                new ArrayCatFunction(ArrayCatFunction.createInfo(args, NAME))\n+            )\n+                .withTypeVariableConstraints(typeVariable(\"E\")),\n+            (signature, args) ->\n+                new ArrayCatFunction(\n+                    ArrayCatFunction.createInfo(args, NAME),\n+                    signature\n+                )\n         );\n     }\n \n-    ArrayCatFunction(FunctionInfo functionInfo) {\n+    private final FunctionInfo functionInfo;\n+    private final Signature signature;\n+\n+    ArrayCatFunction(FunctionInfo functionInfo, Signature signature) {\n         this.functionInfo = functionInfo;\n+        this.signature = signature;\n     }\n \n     @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "898b5c78acdcf2e117e6332103ecb08eda8c6c74", "committedDate": "2020-03-31 15:30:51 +0000", "message": "Refactor all array scalars to new function registry"}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNzYzNQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396317635", "body": "I think the `signature` here should be documented. For example that `array` and `object` is treated in a special way is important (via `TypeSignatures.getType`). ", "bodyText": "I think the signature here should be documented. For example that array and object is treated in a special way is important (via TypeSignatures.getType).", "bodyHTML": "<p dir=\"auto\">I think the <code>signature</code> here should be documented. For example that <code>array</code> and <code>object</code> is treated in a special way is important (via <code>TypeSignatures.getType</code>).</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:36:45Z", "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    public static TypeSignature parseTypeSignature(String signature) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignature.java b/common/src/main/java/io/crate/types/TypeSignature.java\nindex 4c992b45ae..9b8173ff6f 100644\n--- a/common/src/main/java/io/crate/types/TypeSignature.java\n+++ b/common/src/main/java/io/crate/types/TypeSignature.java\n", "chunk": "@@ -32,13 +32,31 @@ import static java.lang.String.format;\n \n public class TypeSignature {\n \n+    /**\n+     * Creates a type signature out of the given signature string.\n+     * A signature type string may contain parameters inside parenthesis:\n+     * <p>\n+     *   base_type_name(parameter [, parameter])\n+     * </p>\n+     *\n+     * Custom parameterized type handling must also be supported by {@link #createType()}.\n+     *\n+     * Some examples:\n+     * <p>\n+     *      integer\n+     *      array(integer)\n+     *      array(E)\n+     *      object(text, integer)\n+     *      object(text, V)\n+     * <p>\n+     */\n     public static TypeSignature parseTypeSignature(String signature) {\n         if (!signature.contains(\"(\")) {\n             return new TypeSignature(signature);\n         }\n \n         String baseName = null;\n-        List<TypeSignatureParameter> parameters = new ArrayList<>();\n+        List<TypeSignature> parameters = new ArrayList<>();\n         int parameterStart = -1;\n         int bracketCount = 0;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignature.java b/common/src/main/java/io/crate/types/TypeSignature.java\nindex 4c992b45ae..9b8173ff6f 100644\n--- a/common/src/main/java/io/crate/types/TypeSignature.java\n+++ b/common/src/main/java/io/crate/types/TypeSignature.java\n", "chunk": "@@ -32,13 +32,31 @@ import static java.lang.String.format;\n \n public class TypeSignature {\n \n+    /**\n+     * Creates a type signature out of the given signature string.\n+     * A signature type string may contain parameters inside parenthesis:\n+     * <p>\n+     *   base_type_name(parameter [, parameter])\n+     * </p>\n+     *\n+     * Custom parameterized type handling must also be supported by {@link #createType()}.\n+     *\n+     * Some examples:\n+     * <p>\n+     *      integer\n+     *      array(integer)\n+     *      array(E)\n+     *      object(text, integer)\n+     *      object(text, V)\n+     * <p>\n+     */\n     public static TypeSignature parseTypeSignature(String signature) {\n         if (!signature.contains(\"(\")) {\n             return new TypeSignature(signature);\n         }\n \n         String baseName = null;\n-        List<TypeSignatureParameter> parameters = new ArrayList<>();\n+        List<TypeSignature> parameters = new ArrayList<>();\n         int parameterStart = -1;\n         int bracketCount = 0;\n \n", "next_change": {"commit": "0d5adc08af6d217d8717b83e46cbbe93b6cdb34e", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignature.java b/common/src/main/java/io/crate/types/TypeSignature.java\nindex 9b8173ff6f..07d79d6f5d 100644\n--- a/common/src/main/java/io/crate/types/TypeSignature.java\n+++ b/common/src/main/java/io/crate/types/TypeSignature.java\n", "chunk": "@@ -52,7 +57,14 @@ public class TypeSignature {\n      */\n     public static TypeSignature parseTypeSignature(String signature) {\n         if (!signature.contains(\"(\")) {\n-            return new TypeSignature(signature);\n+            if (isNamedTypeSignature(signature)) {\n+                int split = signature.indexOf(\" \");\n+                return new ParameterTypeSignature(\n+                    signature.substring(0, split),\n+                    new TypeSignature(signature.substring(split + 1)));\n+            } else {\n+                return new TypeSignature(signature);\n+            }\n         }\n \n         String baseName = null;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "8ce9ae1425f396285b8e6d6efe8d4c27354ca53a", "committedDate": "2020-04-02 11:54:04 +0000", "message": "Fix setting inner object type names in TypeSignature#createType."}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "0d5adc08af6d217d8717b83e46cbbe93b6cdb34e", "committedDate": "2020-04-23 14:04:15 +0000", "message": "Add support for the record type signature parsing."}, {"oid": "16857998dff6024193471974c24cc2c9b530cec0", "committedDate": "2020-05-11 09:47:56 +0000", "message": "Integrate common, blob, http and es-transport into server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTA4NA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396319084", "body": "Can this TODO be resolved? ", "bodyText": "Can this TODO be resolved?", "bodyHTML": "<p dir=\"auto\">Can this TODO be resolved?</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:38:58Z", "path": "sql/src/main/java/io/crate/metadata/Functions.java", "diffHunk": "@@ -169,13 +193,51 @@ private FunctionImplementation getBuiltin(FunctionName functionName, List<DataTy\n     private FunctionImplementation getBuiltinByArgs(FunctionName functionName,\n                                                     List<? extends FuncArg> argumentsTypes,\n                                                     SearchPath searchPath) {\n+        // V2\n+        FunctionImplementation impl = resolveFunctionBySignature(\n+            functionName,\n+            Lists2.map(argumentsTypes, FuncArg::valueType),\n+            searchPath\n+        );\n+        if (impl != null) {\n+            return impl;\n+        }\n+\n         FunctionResolver resolver = lookupFunctionResolver(functionName, searchPath, functionResolvers::get);\n         if (resolver == null) {\n             return null;\n         }\n         return resolveFunctionForArgumentTypes(argumentsTypes, resolver);\n     }\n \n+    @Nullable\n+    private FunctionImplementation resolveFunctionBySignature(FunctionName name,\n+                                                              List<DataType> arguments,\n+                                                              SearchPath searchPath) {\n+        var candidates = functionImplementations.get(name);\n+        if (candidates == null && name.schema() == null) {\n+            for (String pathSchema : searchPath) {\n+                FunctionName searchPathFunctionName = new FunctionName(pathSchema, name.name());\n+                candidates = functionImplementations.get(searchPathFunctionName);\n+                if (candidates != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (candidates != null) {\n+            for (FuncResolver candidate : candidates) {\n+                Signature boundSignature = new SignatureBinder(candidate.getSignature(), true)\n+                    .bind(arguments);\n+                if (boundSignature != null) {\n+                    // TODO: check for more specific function", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5NjExNw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396496117", "bodyText": "I'll follow up on here later, maybe even on a dedicated commit.", "author": "seut", "createdAt": "2020-03-23T14:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTA4NA=="}], "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/Functions.java b/sql/src/main/java/io/crate/metadata/Functions.java\nindex 1c5f08bf01..60fd32813a 100644\n--- a/sql/src/main/java/io/crate/metadata/Functions.java\n+++ b/sql/src/main/java/io/crate/metadata/Functions.java\n", "chunk": "@@ -230,7 +230,7 @@ public class Functions {\n                     .bind(arguments);\n                 if (boundSignature != null) {\n                     // TODO: check for more specific function\n-                    return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignatures::getType));\n+                    return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignature::createType));\n                 }\n             }\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/Functions.java b/sql/src/main/java/io/crate/metadata/Functions.java\nindex 1c5f08bf01..60fd32813a 100644\n--- a/sql/src/main/java/io/crate/metadata/Functions.java\n+++ b/sql/src/main/java/io/crate/metadata/Functions.java\n", "chunk": "@@ -230,7 +230,7 @@ public class Functions {\n                     .bind(arguments);\n                 if (boundSignature != null) {\n                     // TODO: check for more specific function\n-                    return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignatures::getType));\n+                    return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignature::createType));\n                 }\n             }\n         }\n", "next_change": {"commit": "90d7d2bfd2937ccf1a1b2aee640b53bbb764d1c7", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/Functions.java b/sql/src/main/java/io/crate/metadata/Functions.java\nindex 60fd32813a..0fbbf30b75 100644\n--- a/sql/src/main/java/io/crate/metadata/Functions.java\n+++ b/sql/src/main/java/io/crate/metadata/Functions.java\n", "chunk": "@@ -225,13 +225,39 @@ public class Functions {\n             }\n         }\n         if (candidates != null) {\n-            for (FuncResolver candidate : candidates) {\n-                Signature boundSignature = new SignatureBinder(candidate.getSignature(), true)\n-                    .bind(arguments);\n-                if (boundSignature != null) {\n-                    // TODO: check for more specific function\n-                    return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignature::createType));\n-                }\n+            // First lets try exact candidates, no generic type variables, no coercion allowed.\n+            List<FuncResolver> exactCandidates = candidates.stream()\n+                .filter(function -> function.getSignature().getTypeVariableConstraints().isEmpty())\n+                .collect(Collectors.toList());\n+            var match = matchFunctionCandidates(exactCandidates, arguments, false);\n+            if (match != null) {\n+                return match;\n+            }\n+\n+            // Second, try candidates with generic type variables, still no coercion allowed.\n+            List<FuncResolver> genericCandidates = candidates.stream()\n+                .filter(function -> !function.getSignature().getTypeVariableConstraints().isEmpty())\n+                .collect(Collectors.toList());\n+            match = matchFunctionCandidates(genericCandidates, arguments, false);\n+            if (match != null) {\n+                return match;\n+            }\n+\n+            // Last, try all candidates with coercion allowed.\n+            return matchFunctionCandidates(candidates, arguments, true);\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static FunctionImplementation matchFunctionCandidates(List<FuncResolver> candidates,\n+                                                                  List<DataType> argumentTypes,\n+                                                                  boolean allowCoercion) {\n+        for (FuncResolver candidate : candidates) {\n+            Signature boundSignature = new SignatureBinder(candidate.getSignature(), allowCoercion)\n+                .bind(argumentTypes);\n+            if (boundSignature != null) {\n+                return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignature::createType));\n             }\n         }\n         return null;\n", "next_change": {"commit": "91795c06d68ae6b0289ccd383191aa6df12723ee", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/Functions.java b/sql/src/main/java/io/crate/metadata/Functions.java\nindex 0fbbf30b75..284fa1351c 100644\n--- a/sql/src/main/java/io/crate/metadata/Functions.java\n+++ b/sql/src/main/java/io/crate/metadata/Functions.java\n", "chunk": "@@ -253,13 +268,38 @@ public class Functions {\n     private static FunctionImplementation matchFunctionCandidates(List<FuncResolver> candidates,\n                                                                   List<DataType> argumentTypes,\n                                                                   boolean allowCoercion) {\n+        List<ApplicableFunction> applicableFunctions = new ArrayList<>();\n         for (FuncResolver candidate : candidates) {\n             Signature boundSignature = new SignatureBinder(candidate.getSignature(), allowCoercion)\n-                .bind(argumentTypes);\n+                .bind(Lists2.map(argumentTypes, DataType::getTypeSignature));\n             if (boundSignature != null) {\n-                return candidate.apply(Lists2.map(boundSignature.getArgumentTypes(), TypeSignature::createType));\n+                applicableFunctions.add(\n+                    new ApplicableFunction(\n+                        candidate.getSignature(),\n+                        boundSignature,\n+                        candidate.getFactory()\n+                    )\n+                );\n+            }\n+        }\n+\n+\n+        if (allowCoercion) {\n+            applicableFunctions = selectMostSpecificFunctions(applicableFunctions, argumentTypes);\n+            if (LOGGER.isDebugEnabled() && applicableFunctions.isEmpty()) {\n+                LOGGER.debug(\"At least single function must be left after selecting most specific one\");\n             }\n         }\n+\n+        if (applicableFunctions.size() == 1) {\n+            return getOnlyElement(applicableFunctions).get();\n+        }\n+        if (applicableFunctions.size() > 1) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debug(\"Multiple candidates match! \" + applicableFunctions);\n+            }\n+        }\n+\n         return null;\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "90d7d2bfd2937ccf1a1b2aee640b53bbb764d1c7", "committedDate": "2020-03-24 13:54:28 +0000", "message": "Fix exact matches of function signatures"}, {"oid": "d3b834f96a354b7b05049f29dabf402133059e67", "committedDate": "2020-03-27 10:27:33 +0000", "message": "Refactor UDF scalars to use new function registry."}, {"oid": "ec63cdf4411e95d992b17a27bb8f81ab1525fa2b", "committedDate": "2020-03-27 11:28:50 +0000", "message": "Refactor most arithmetic scalars to new function registry"}, {"oid": "ac8af037f046b1a7c8a8167dea4d6381348e1c8a", "committedDate": "2020-03-27 18:30:10 +0000", "message": "Fix flaky testConcurrentFunctionRegistering."}, {"oid": "91795c06d68ae6b0289ccd383191aa6df12723ee", "committedDate": "2020-04-03 08:25:32 +0000", "message": "Add support for selecting most specific function"}, {"oid": "764eb4e2ef9424c085993b20d5365ad619bfd933", "committedDate": "2020-04-21 14:32:42 +0000", "message": "Add logic to prefer function signatures with higher exact matches"}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "5ed808370bace035f53ca52d553468aa548e3fb9", "committedDate": "2020-04-24 10:58:40 +0000", "message": "Fix most specific function selection by exact type matches"}, {"oid": "89f7f4eb1dcc6eec9e1895729cf0cb1bfae07773", "committedDate": "2020-05-06 08:54:15 +0000", "message": "Extend pg_proc table based on the new function signatures."}, {"oid": "ed9e58364077bb7b144b6b73821a46b30c030b1b", "committedDate": "2020-05-06 16:00:07 +0000", "message": "Merge es packages in libs/shared into crate packages"}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMDQzMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396320431", "body": "Can you add some assertions that make sure all required properties are set? (name, kind, argument types..)", "bodyText": "Can you add some assertions that make sure all required properties are set? (name, kind, argument types..)", "bodyHTML": "<p dir=\"auto\">Can you add some assertions that make sure all required properties are set? (name, kind, argument types..)</p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:41:08Z", "path": "sql/src/main/java/io/crate/metadata/functions/Signature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Signature {\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private FunctionName name;\n+        private FunctionInfo.Type kind;\n+        private List<TypeSignature> argumentTypes = Collections.emptyList();\n+        private TypeSignature returnType;\n+        private List<TypeVariableConstraint> typeVariableConstraints = Collections.emptyList();\n+        private List<TypeSignature> variableArityGroup = Collections.emptyList();\n+        private boolean variableArity = false;\n+\n+        public Builder name(String name) {\n+            return name(new FunctionName(null, name));\n+        }\n+\n+        public Builder name(FunctionName name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder kind(FunctionInfo.Type kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+\n+        public Builder argumentTypes(TypeSignature... argumentTypes) {\n+            return argumentTypes(List.of(argumentTypes));\n+        }\n+\n+        public Builder argumentTypes(List<TypeSignature> argumentTypes) {\n+            this.argumentTypes = argumentTypes;\n+            return this;\n+        }\n+\n+        public Builder returnType(TypeSignature returnType) {\n+            this.returnType = returnType;\n+            return this;\n+        }\n+\n+        public Builder typeVariableConstraints(TypeVariableConstraint... typeVariableConstraints) {\n+            return typeVariableConstraints(List.of(typeVariableConstraints));\n+        }\n+\n+        public Builder typeVariableConstraints(List<TypeVariableConstraint> typeVariableConstraints) {\n+            this.typeVariableConstraints = typeVariableConstraints;\n+            return this;\n+        }\n+\n+        public Builder variableArityGroup(List<TypeSignature> variableArityGroup) {\n+            this.variableArityGroup = variableArityGroup;\n+            this.variableArity = !variableArityGroup.isEmpty();\n+            return this;\n+        }\n+\n+        public Builder setVariableArity(boolean variableArity) {\n+            this.variableArity = variableArity;\n+            return this;\n+        }\n+\n+        public Signature build() {\n+            return new Signature(", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex a102b6ef10..f422778403 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -94,6 +94,9 @@ public final class Signature {\n         }\n \n         public Signature build() {\n+            assert name != null : \"Signature requires the 'name' to be set\";\n+            assert kind != null : \"Signature requires the 'kind' to be set\";\n+            assert returnType != null : \"Signature requires the 'returnType' to be set\";\n             return new Signature(\n                 name,\n                 kind,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex a102b6ef10..f422778403 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -94,6 +94,9 @@ public final class Signature {\n         }\n \n         public Signature build() {\n+            assert name != null : \"Signature requires the 'name' to be set\";\n+            assert kind != null : \"Signature requires the 'kind' to be set\";\n+            assert returnType != null : \"Signature requires the 'returnType' to be set\";\n             return new Signature(\n                 name,\n                 kind,\n", "next_change": {"commit": "ec63cdf4411e95d992b17a27bb8f81ab1525fa2b", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex f422778403..983018615d 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -93,6 +136,11 @@ public final class Signature {\n             return this;\n         }\n \n+        public Builder forbidCoercion() {\n+            allowCoercion = false;\n+            return this;\n+        }\n+\n         public Signature build() {\n             assert name != null : \"Signature requires the 'name' to be set\";\n             assert kind != null : \"Signature requires the 'kind' to be set\";\n", "next_change": null}, {"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex f422778403..983018615d 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -104,7 +152,8 @@ public final class Signature {\n                 argumentTypes,\n                 returnType,\n                 variableArityGroup,\n-                variableArity);\n+                variableArity,\n+                allowCoercion);\n         }\n     }\n \n", "next_change": {"commit": "8f29abc16157d4421773704cb3c0adecf3036c4c", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex 983018615d..2ddc7f804a 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -162,10 +216,8 @@ public final class Signature {\n     private final FunctionInfo.Type kind;\n     private final List<TypeSignature> argumentTypes;\n     private final TypeSignature returnType;\n-    private final List<TypeVariableConstraint> typeVariableConstraints;\n-    private final List<TypeSignature> variableArityGroup;\n-    private final boolean variableArity;\n-    private final boolean allowCoercion;\n+    @Nullable\n+    private final SignatureBindingInfo bindingInfo;\n \n     private Signature(FunctionName name,\n                       FunctionInfo.Type kind,\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "90d7d2bfd2937ccf1a1b2aee640b53bbb764d1c7", "committedDate": "2020-03-24 13:54:28 +0000", "message": "Fix exact matches of function signatures"}, {"oid": "ec63cdf4411e95d992b17a27bb8f81ab1525fa2b", "committedDate": "2020-03-27 11:28:50 +0000", "message": "Refactor most arithmetic scalars to new function registry"}, {"oid": "a661261609ec73382cbc17b8d0eed2fa5605d353", "committedDate": "2020-03-31 14:52:29 +0000", "message": "Refactor all system information scalars to new function registry"}, {"oid": "f9e4c325dac3e3f0f2bae3f9ff6ca7ce06b4a517", "committedDate": "2020-03-31 20:48:29 +0000", "message": "Refactor format, ignore3vl, pi, substr  to new function registry"}, {"oid": "547eeda78fb02adeaa8a2c24adfd9742f5eabeec", "committedDate": "2020-04-02 13:18:23 +0000", "message": "Add a shortcut for building aggregate function signatures."}, {"oid": "841bc53ac5a8849b21fc33f29421245b631a0fd3", "committedDate": "2020-04-03 13:38:33 +0000", "message": "Use new function registry for nth/last/first value window functions."}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "c0691576ce30c717997f5ec1639de2022cac9ed1", "committedDate": "2020-04-23 14:04:15 +0000", "message": "Use new func registry for the pg_expand_array function."}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMDkzNg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396320936", "body": "No need to change but fyi: I recently added a `Lists2.joinOn`", "bodyText": "No need to change but fyi: I recently added a Lists2.joinOn", "bodyHTML": "<p dir=\"auto\">No need to change but fyi: I recently added a <code>Lists2.joinOn</code></p>", "author": "mfussenegger", "createdAt": "2020-03-23T09:42:01Z", "path": "sql/src/main/java/io/crate/metadata/functions/Signature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Signature {\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private FunctionName name;\n+        private FunctionInfo.Type kind;\n+        private List<TypeSignature> argumentTypes = Collections.emptyList();\n+        private TypeSignature returnType;\n+        private List<TypeVariableConstraint> typeVariableConstraints = Collections.emptyList();\n+        private List<TypeSignature> variableArityGroup = Collections.emptyList();\n+        private boolean variableArity = false;\n+\n+        public Builder name(String name) {\n+            return name(new FunctionName(null, name));\n+        }\n+\n+        public Builder name(FunctionName name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder kind(FunctionInfo.Type kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+\n+        public Builder argumentTypes(TypeSignature... argumentTypes) {\n+            return argumentTypes(List.of(argumentTypes));\n+        }\n+\n+        public Builder argumentTypes(List<TypeSignature> argumentTypes) {\n+            this.argumentTypes = argumentTypes;\n+            return this;\n+        }\n+\n+        public Builder returnType(TypeSignature returnType) {\n+            this.returnType = returnType;\n+            return this;\n+        }\n+\n+        public Builder typeVariableConstraints(TypeVariableConstraint... typeVariableConstraints) {\n+            return typeVariableConstraints(List.of(typeVariableConstraints));\n+        }\n+\n+        public Builder typeVariableConstraints(List<TypeVariableConstraint> typeVariableConstraints) {\n+            this.typeVariableConstraints = typeVariableConstraints;\n+            return this;\n+        }\n+\n+        public Builder variableArityGroup(List<TypeSignature> variableArityGroup) {\n+            this.variableArityGroup = variableArityGroup;\n+            this.variableArity = !variableArityGroup.isEmpty();\n+            return this;\n+        }\n+\n+        public Builder setVariableArity(boolean variableArity) {\n+            this.variableArity = variableArity;\n+            return this;\n+        }\n+\n+        public Signature build() {\n+            return new Signature(\n+                name,\n+                kind,\n+                typeVariableConstraints,\n+                argumentTypes,\n+                returnType,\n+                variableArityGroup,\n+                variableArity);\n+        }\n+    }\n+\n+\n+    private final FunctionName name;\n+    private final FunctionInfo.Type kind;\n+    private final List<TypeSignature> argumentTypes;\n+    private final TypeSignature returnType;\n+    private final List<TypeVariableConstraint> typeVariableConstraints;\n+    private final List<TypeSignature> variableArityGroup;\n+    private final boolean variableArity;\n+\n+    private Signature(FunctionName name,\n+                      FunctionInfo.Type kind,\n+                      List<TypeVariableConstraint> typeVariableConstraints,\n+                      List<TypeSignature> argumentTypes,\n+                      TypeSignature returnType,\n+                      List<TypeSignature> variableArityGroup,\n+                      boolean variableArity) {\n+        this.name = name;\n+        this.kind = kind;\n+        this.argumentTypes = argumentTypes;\n+        this.typeVariableConstraints = typeVariableConstraints;\n+        this.returnType = returnType;\n+        this.variableArityGroup = variableArityGroup;\n+        this.variableArity = variableArity;\n+    }\n+\n+    public FunctionName getName() {\n+        return name;\n+    }\n+\n+    public FunctionInfo.Type getKind() {\n+        return kind;\n+    }\n+\n+    public List<TypeSignature> getArgumentTypes() {\n+        return argumentTypes;\n+    }\n+\n+    public TypeSignature getReturnType() {\n+        return returnType;\n+    }\n+\n+    public List<TypeVariableConstraint> getTypeVariableConstraints() {\n+        return typeVariableConstraints;\n+    }\n+\n+    public List<TypeSignature> getVariableArityGroup() {\n+        return variableArityGroup;\n+    }\n+\n+    public boolean isVariableArity() {\n+        return variableArity;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        List<String> allConstraints = Lists2.map(typeVariableConstraints, TypeVariableConstraint::toString);\n+\n+        return name + (allConstraints.isEmpty() ? \"\" : \"<\" + String.join(\",\", allConstraints) + \">\") +\n+               \"(\" + String.join(\",\", Lists2.map(argumentTypes, TypeSignature::toString)) + \"):\" + returnType;", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex a102b6ef10..f422778403 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -163,6 +166,6 @@ public final class Signature {\n         List<String> allConstraints = Lists2.map(typeVariableConstraints, TypeVariableConstraint::toString);\n \n         return name + (allConstraints.isEmpty() ? \"\" : \"<\" + String.join(\",\", allConstraints) + \">\") +\n-               \"(\" + String.join(\",\", Lists2.map(argumentTypes, TypeSignature::toString)) + \"):\" + returnType;\n+               \"(\" + Lists2.joinOn(\",\", argumentTypes, TypeSignature::toString) + \"):\" + returnType;\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex a102b6ef10..f422778403 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -163,6 +166,6 @@ public final class Signature {\n         List<String> allConstraints = Lists2.map(typeVariableConstraints, TypeVariableConstraint::toString);\n \n         return name + (allConstraints.isEmpty() ? \"\" : \"<\" + String.join(\",\", allConstraints) + \">\") +\n-               \"(\" + String.join(\",\", Lists2.map(argumentTypes, TypeSignature::toString)) + \"):\" + returnType;\n+               \"(\" + Lists2.joinOn(\",\", argumentTypes, TypeSignature::toString) + \"):\" + returnType;\n     }\n }\n", "next_change": {"commit": "8f29abc16157d4421773704cb3c0adecf3036c4c", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/Signature.java b/sql/src/main/java/io/crate/metadata/functions/Signature.java\nindex f422778403..2ddc7f804a 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/Signature.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/Signature.java\n", "chunk": "@@ -149,21 +289,48 @@ public final class Signature {\n         return returnType;\n     }\n \n-    public List<TypeVariableConstraint> getTypeVariableConstraints() {\n-        return typeVariableConstraints;\n+    @Nullable\n+    public SignatureBindingInfo getBindingInfo() {\n+        return bindingInfo;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        name.writeTo(out);\n+        out.writeVInt(kind.ordinal());\n+        out.writeVInt(argumentTypes.size());\n+        for (TypeSignature typeSignature : argumentTypes) {\n+            TypeSignature.toStream(typeSignature, out);\n+        }\n+        TypeSignature.toStream(returnType, out);\n     }\n \n-    public List<TypeSignature> getVariableArityGroup() {\n-        return variableArityGroup;\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        Signature signature = (Signature) o;\n+        return name.equals(signature.name) &&\n+               kind == signature.kind &&\n+               argumentTypes.equals(signature.argumentTypes) &&\n+               returnType.equals(signature.returnType);\n     }\n \n-    public boolean isVariableArity() {\n-        return variableArity;\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, kind, argumentTypes, returnType);\n     }\n \n     @Override\n     public String toString() {\n-        List<String> allConstraints = Lists2.map(typeVariableConstraints, TypeVariableConstraint::toString);\n+        List<String> allConstraints = List.of();\n+        if (bindingInfo != null) {\n+            allConstraints = Lists2.map(bindingInfo.getTypeVariableConstraints(), TypeVariableConstraint::toString);\n+        }\n \n         return name + (allConstraints.isEmpty() ? \"\" : \"<\" + String.join(\",\", allConstraints) + \">\") +\n                \"(\" + Lists2.joinOn(\",\", argumentTypes, TypeSignature::toString) + \"):\" + returnType;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "90d7d2bfd2937ccf1a1b2aee640b53bbb764d1c7", "committedDate": "2020-03-24 13:54:28 +0000", "message": "Fix exact matches of function signatures"}, {"oid": "ec63cdf4411e95d992b17a27bb8f81ab1525fa2b", "committedDate": "2020-03-27 11:28:50 +0000", "message": "Refactor most arithmetic scalars to new function registry"}, {"oid": "a661261609ec73382cbc17b8d0eed2fa5605d353", "committedDate": "2020-03-31 14:52:29 +0000", "message": "Refactor all system information scalars to new function registry"}, {"oid": "f9e4c325dac3e3f0f2bae3f9ff6ca7ce06b4a517", "committedDate": "2020-03-31 20:48:29 +0000", "message": "Refactor format, ignore3vl, pi, substr  to new function registry"}, {"oid": "547eeda78fb02adeaa8a2c24adfd9742f5eabeec", "committedDate": "2020-04-02 13:18:23 +0000", "message": "Add a shortcut for building aggregate function signatures."}, {"oid": "841bc53ac5a8849b21fc33f29421245b631a0fd3", "committedDate": "2020-04-03 13:38:33 +0000", "message": "Use new function registry for nth/last/first value window functions."}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "c0691576ce30c717997f5ec1639de2022cac9ed1", "committedDate": "2020-04-23 14:04:15 +0000", "message": "Use new func registry for the pg_expand_array function."}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM5MzI4OQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396393289", "body": "Given that there are already static constructors for both cases I think this overload could be removed", "bodyText": "Given that there are already static constructors for both cases I think this overload could be removed", "bodyHTML": "<p dir=\"auto\">Given that there are already static constructors for both cases I think this overload could be removed</p>", "author": "mfussenegger", "createdAt": "2020-03-23T11:49:08Z", "path": "sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import java.util.Objects;\n+\n+public class TypeVariableConstraint {\n+\n+    public static TypeVariableConstraint typeVariable(String name) {\n+        return new TypeVariableConstraint(name);\n+    }\n+\n+    public static TypeVariableConstraint typeVariableOfAnyType(String name) {\n+        return new TypeVariableConstraint(name, true);\n+    }\n+\n+    private final String name;\n+    private final boolean anyAllowed;\n+\n+    private TypeVariableConstraint(String name) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java b/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\nindex d2014d27a5..8895216867 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\n", "chunk": "@@ -37,10 +37,6 @@ public class TypeVariableConstraint {\n     private final String name;\n     private final boolean anyAllowed;\n \n-    private TypeVariableConstraint(String name) {\n-        this(name, false);\n-    }\n-\n     private TypeVariableConstraint(String name, boolean anyAllowed) {\n         this.name = name;\n         this.anyAllowed = anyAllowed;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java b/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\nindex d2014d27a5..8895216867 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\n", "chunk": "@@ -37,10 +37,6 @@ public class TypeVariableConstraint {\n     private final String name;\n     private final boolean anyAllowed;\n \n-    private TypeVariableConstraint(String name) {\n-        this(name, false);\n-    }\n-\n     private TypeVariableConstraint(String name, boolean anyAllowed) {\n         this.name = name;\n         this.anyAllowed = anyAllowed;\n", "next_change": {"commit": "8f29abc16157d4421773704cb3c0adecf3036c4c", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java b/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\nindex 8895216867..7ebbce82f9 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java\n", "chunk": "@@ -42,6 +47,11 @@ public class TypeVariableConstraint {\n         this.anyAllowed = anyAllowed;\n     }\n \n+    public TypeVariableConstraint(StreamInput in) throws IOException {\n+        name = in.readString();\n+        anyAllowed = in.readBoolean();\n+    }\n+\n     public String getName() {\n         return name;\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjA2NA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396516064", "body": "Shouldn't this be compatible?", "bodyText": "Shouldn't this be compatible?", "bodyHTML": "<p dir=\"auto\">Shouldn't this be compatible?</p>", "author": "mfussenegger", "createdAt": "2020-03-23T15:00:00Z", "path": "common/src/main/java/io/crate/types/TypeCompatibility.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class TypeCompatibility {\n+\n+    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n+\n+    @Nullable\n+    public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonType();\n+    }\n+\n+    private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n+        return new TypeCompatibility(commonSuperType, coercible);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return compatible(fromType, false);\n+        }\n+\n+        String fromTypeBaseName = fromType.getTypeSignature().getBaseTypeName();\n+        String toTypeBaseName = toType.getTypeSignature().getBaseTypeName();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+            if (!fromType.getTypeParameters().isEmpty() || !toType.getTypeParameters().isEmpty()) {\n+                return typeCompatibilityForParametrizedType(fromType, toType);\n+            }\n+            return compatible(fromType, false);", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3OTQxMg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396579412", "bodyText": "It's compatible as both base names are equal and no parameters e.g. text and text.", "author": "seut", "createdAt": "2020-03-23T16:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeCompatibility.java b/common/src/main/java/io/crate/types/TypeCompatibility.java\nindex 527b1dc88c..ed34ceea0c 100644\n--- a/common/src/main/java/io/crate/types/TypeCompatibility.java\n+++ b/common/src/main/java/io/crate/types/TypeCompatibility.java\n", "chunk": "@@ -64,15 +55,10 @@ public final class TypeCompatibility {\n             if (!fromType.getTypeParameters().isEmpty() || !toType.getTypeParameters().isEmpty()) {\n                 return typeCompatibilityForParametrizedType(fromType, toType);\n             }\n-            return compatible(fromType, false);\n+            return fromType;\n         }\n \n-        DataType<?> commonType = convertTypeByPrecedence(fromType, toType);\n-        if (commonType != null) {\n-            return compatible(commonType, commonType.equals(toType));\n-        }\n-\n-        return INCOMPATIBLE;\n+        return convertTypeByPrecedence(fromType, toType);\n     }\n \n     @Nullable\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeCompatibility.java b/common/src/main/java/io/crate/types/TypeCompatibility.java\nindex 527b1dc88c..ed34ceea0c 100644\n--- a/common/src/main/java/io/crate/types/TypeCompatibility.java\n+++ b/common/src/main/java/io/crate/types/TypeCompatibility.java\n", "chunk": "@@ -64,15 +55,10 @@ public final class TypeCompatibility {\n             if (!fromType.getTypeParameters().isEmpty() || !toType.getTypeParameters().isEmpty()) {\n                 return typeCompatibilityForParametrizedType(fromType, toType);\n             }\n-            return compatible(fromType, false);\n+            return fromType;\n         }\n \n-        DataType<?> commonType = convertTypeByPrecedence(fromType, toType);\n-        if (commonType != null) {\n-            return compatible(commonType, commonType.equals(toType));\n-        }\n-\n-        return INCOMPATIBLE;\n+        return convertTypeByPrecedence(fromType, toType);\n     }\n \n     @Nullable\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "16857998dff6024193471974c24cc2c9b530cec0", "committedDate": "2020-05-11 09:47:56 +0000", "message": "Integrate common, blob, http and es-transport into server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODQ0NQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396518445", "body": "Not sure if it's worth changing, but I think for common cases the TypeCompatibility creation  could be avoided (if types match,  undefined  case,  maybe even the \"by precedence\" case)", "bodyText": "Not sure if it's worth changing, but I think for common cases the TypeCompatibility creation  could be avoided (if types match,  undefined  case,  maybe even the \"by precedence\" case)", "bodyHTML": "<p dir=\"auto\">Not sure if it's worth changing, but I think for common cases the TypeCompatibility creation  could be avoided (if types match,  undefined  case,  maybe even the \"by precedence\" case)</p>", "author": "mfussenegger", "createdAt": "2020-03-23T15:03:06Z", "path": "common/src/main/java/io/crate/types/TypeCompatibility.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class TypeCompatibility {\n+\n+    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n+\n+    @Nullable\n+    public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeCompatibility.java b/common/src/main/java/io/crate/types/TypeCompatibility.java\nindex 527b1dc88c..ed34ceea0c 100644\n--- a/common/src/main/java/io/crate/types/TypeCompatibility.java\n+++ b/common/src/main/java/io/crate/types/TypeCompatibility.java\n", "chunk": "@@ -29,32 +29,23 @@ import java.util.List;\n \n public final class TypeCompatibility {\n \n-    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n-\n     @Nullable\n     public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonType();\n+        return compatibility(firstType, secondType);\n     }\n \n-    private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-        return new TypeCompatibility(commonSuperType, coercible);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+    @Nullable\n+    private static DataType<?> compatibility(DataType<?> fromType, DataType<?> toType) {\n         if (fromType.equals(toType)) {\n-            return compatible(toType, true);\n+            return toType;\n         }\n \n         if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return compatible(toType, true);\n+            return toType;\n         }\n \n         if (toType.equals(UndefinedType.INSTANCE)) {\n-            return compatible(fromType, false);\n+            return fromType;\n         }\n \n         String fromTypeBaseName = fromType.getTypeSignature().getBaseTypeName();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeCompatibility.java b/common/src/main/java/io/crate/types/TypeCompatibility.java\nindex 527b1dc88c..ed34ceea0c 100644\n--- a/common/src/main/java/io/crate/types/TypeCompatibility.java\n+++ b/common/src/main/java/io/crate/types/TypeCompatibility.java\n", "chunk": "@@ -29,32 +29,23 @@ import java.util.List;\n \n public final class TypeCompatibility {\n \n-    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n-\n     @Nullable\n     public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n-        TypeCompatibility compatibility = compatibility(firstType, secondType);\n-        if (!compatibility.isCompatible()) {\n-            return null;\n-        }\n-        return compatibility.getCommonType();\n+        return compatibility(firstType, secondType);\n     }\n \n-    private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n-        return new TypeCompatibility(commonSuperType, coercible);\n-    }\n-\n-    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+    @Nullable\n+    private static DataType<?> compatibility(DataType<?> fromType, DataType<?> toType) {\n         if (fromType.equals(toType)) {\n-            return compatible(toType, true);\n+            return toType;\n         }\n \n         if (fromType.equals(UndefinedType.INSTANCE)) {\n-            return compatible(toType, true);\n+            return toType;\n         }\n \n         if (toType.equals(UndefinedType.INSTANCE)) {\n-            return compatible(fromType, false);\n+            return fromType;\n         }\n \n         String fromTypeBaseName = fromType.getTypeSignature().getBaseTypeName();\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "16857998dff6024193471974c24cc2c9b530cec0", "committedDate": "2020-05-11 09:47:56 +0000", "message": "Integrate common, blob, http and es-transport into server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTM1MQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396521351", "body": "Does/ should this work for nested cases? ", "bodyText": "Does/ should this work for nested cases?", "bodyHTML": "<p dir=\"auto\">Does/ should this work for nested cases?</p>", "author": "mfussenegger", "createdAt": "2020-03-23T15:07:14Z", "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    /**\n+     * Creates a type signature out of the given signature string.\n+     * A signature type string may contain parameters inside parenthesis:\n+     * <p>\n+     *   base_type_name(parameter [, parameter])\n+     * </p>\n+     *\n+     * Custom parameterized type handling must also be supported by {@link #createType()}.\n+     *\n+     * Some examples:\n+     * <p>\n+     *      integer\n+     *      array(integer)\n+     *      array(E)\n+     *      object(text, integer)\n+     *      object(text, V)\n+     * <p>\n+     */\n+    public static TypeSignature parseTypeSignature(String signature) {\n+        if (!signature.contains(\"(\")) {\n+            return new TypeSignature(signature);\n+        }\n+\n+        String baseName = null;\n+        List<TypeSignature> parameters = new ArrayList<>();\n+        int parameterStart = -1;\n+        int bracketCount = 0;\n+\n+        for (int i = 0; i < signature.length(); i++) {\n+            char c = signature.charAt(i);\n+            if (c == '(') {\n+                if (bracketCount == 0) {\n+                    assert baseName == null : \"Expected baseName to be null\";\n+                    baseName = signature.substring(0, i);\n+                    parameterStart = i + 1;\n+                }\n+                bracketCount++;\n+            } else if (c == ')') {\n+                bracketCount--;\n+                if (bracketCount == 0) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                    if (i == signature.length() - 1) {\n+                        return new TypeSignature(baseName, parameters);\n+                    }\n+                }\n+            } else if (c == ',') {\n+                if (bracketCount == 1) {", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTYwNg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396591606", "bodyText": "Yes it does, I've added a test case.", "author": "seut", "createdAt": "2020-03-23T16:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTM1MQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "0d5adc08af6d217d8717b83e46cbbe93b6cdb34e", "changed_code": [{"header": "diff --git a/common/src/main/java/io/crate/types/TypeSignature.java b/common/src/main/java/io/crate/types/TypeSignature.java\nindex 9b8173ff6f..07d79d6f5d 100644\n--- a/common/src/main/java/io/crate/types/TypeSignature.java\n+++ b/common/src/main/java/io/crate/types/TypeSignature.java\n", "chunk": "@@ -76,7 +88,14 @@ public class TypeSignature {\n                     parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n                     parameterStart = i + 1;\n                     if (i == signature.length() - 1) {\n-                        return new TypeSignature(baseName, parameters);\n+                        if (isNamedTypeSignature(baseName)) {\n+                            int split = baseName.indexOf(\" \");\n+                            return new ParameterTypeSignature(\n+                                baseName.substring(0, split),\n+                                new TypeSignature(baseName.substring(split + 1), parameters));\n+                        } else {\n+                            return new TypeSignature(baseName, parameters);\n+                        }\n                     }\n                 }\n             } else if (c == ',') {\n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "8ce9ae1425f396285b8e6d6efe8d4c27354ca53a", "committedDate": "2020-04-02 11:54:04 +0000", "message": "Fix setting inner object type names in TypeSignature#createType."}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "0d5adc08af6d217d8717b83e46cbbe93b6cdb34e", "committedDate": "2020-04-23 14:04:15 +0000", "message": "Add support for the record type signature parsing."}, {"oid": "16857998dff6024193471974c24cc2c9b530cec0", "committedDate": "2020-05-11 09:47:56 +0000", "message": "Integrate common, blob, http and es-transport into server"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyNDk5MA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396524990", "body": "```suggestion\r\n        // The logic can be summarized as finding the right most item (based on the list below) seen so far:\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:\n          \n          \n            \n                    // The logic can be summarized as finding the right most item (based on the list below) seen so far:", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">//</span> The logic <span class=\"x x-first x-last\">is simple and </span>can be summarized as finding the right most item (based on the list below) seen so far:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">//</span> The logic can be summarized as finding the right most item (based on the list below) seen so far:</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "mfussenegger", "createdAt": "2020-03-23T15:11:56Z", "path": "sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.types.DataType;\n+import io.crate.types.TypeSignature;\n+import io.crate.types.UndefinedType;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.logging.Loggers;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariableOfAnyType;\n+import static io.crate.types.TypeCompatibility.getCommonType;\n+import static java.lang.String.format;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+\n+/**\n+ * Determines whether, and how, a callsite matches a generic function signature.\n+ * Which is equivalent to finding assignments for the variables in the generic signature,\n+ * such that all of the function's declared parameters are super types of the corresponding\n+ * arguments, and also satisfy the declared constraints (such as a given type parameter must\n+ * be of the same type or not)\n+ */\n+public class SignatureBinder {\n+    // 4 is chosen arbitrarily here. This limit is set to avoid having infinite loops in iterative solving.\n+    private static final int SOLVE_ITERATION_LIMIT = 4;\n+\n+    private static final Logger LOGGER = Loggers.getLogger(SignatureBinder.class);\n+\n+    private final Signature declaredSignature;\n+    private final boolean allowCoercion;\n+    private final Map<String, TypeVariableConstraint> typeVariableConstraints;\n+\n+    public SignatureBinder(Signature declaredSignature, boolean allowCoercion) {\n+        this.declaredSignature = declaredSignature;\n+        this.allowCoercion = allowCoercion;\n+        this.typeVariableConstraints = declaredSignature.getTypeVariableConstraints().stream()\n+            .collect(toMap(TypeVariableConstraint::getName, identity()));\n+    }\n+\n+    @Nullable\n+    public Signature bind(List<DataType> actualArgumentTypes) {\n+        BoundVariables boundVariables = bindVariables(Lists2.map(actualArgumentTypes, DataType::getTypeSignature));\n+        if (boundVariables == null) {\n+            return null;\n+        }\n+        return applyBoundVariables(declaredSignature, boundVariables, typeVariableConstraints, actualArgumentTypes.size());\n+    }\n+\n+    @Nullable\n+    BoundVariables bindVariables(List<TypeSignature> actualArgumentTypes) {\n+        ArrayList<TypeConstraintSolver> constraintSolvers = new ArrayList<>();\n+        if (!appendConstraintSolversForArguments(constraintSolvers, actualArgumentTypes)) {\n+            return null;\n+        }\n+\n+        return iterativeSolve(Collections.unmodifiableList(constraintSolvers));\n+    }\n+\n+    private static Signature applyBoundVariables(Signature signature,\n+                                                 BoundVariables boundVariables,\n+                                                 Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                                 int arity) {\n+        List<TypeSignature> argumentSignatures;\n+        if (signature.isVariableArity()) {\n+            argumentSignatures = expandVarargFormalTypeSignature(\n+                signature.getArgumentTypes(),\n+                signature.getVariableArityGroup(),\n+                typeVariableConstraints,\n+                arity);\n+            if (argumentSignatures == null) {\n+                throw new IllegalArgumentException(\n+                    \"Size of argument types does not match a multiple of the defined variable arguments\");\n+            }\n+        } else {\n+            if (signature.getArgumentTypes().size() != arity) {\n+                throw new IllegalArgumentException(\"Size of argument types does not match given arity\");\n+            }\n+            argumentSignatures = signature.getArgumentTypes();\n+        }\n+        List<TypeSignature> boundArgumentSignatures = applyBoundVariables(argumentSignatures, boundVariables);\n+        TypeSignature boundReturnTypeSignature = applyBoundVariables(signature.getReturnType(), boundVariables);\n+\n+        return Signature.builder()\n+            .name(signature.getName())\n+            .kind(signature.getKind())\n+            .argumentTypes(boundArgumentSignatures)\n+            .returnType(boundReturnTypeSignature)\n+            .setVariableArity(false)\n+            .build();\n+    }\n+\n+    private static List<TypeSignature> applyBoundVariables(List<TypeSignature> typeSignatures,\n+                                                           BoundVariables boundVariables) {\n+        ArrayList<TypeSignature> builder = new ArrayList<>();\n+        for (TypeSignature typeSignature : typeSignatures) {\n+            builder.add(applyBoundVariables(typeSignature, boundVariables));\n+        }\n+        return Collections.unmodifiableList(builder);\n+    }\n+\n+    private static TypeSignature applyBoundVariables(TypeSignature typeSignature, BoundVariables boundVariables) {\n+        String baseType = typeSignature.getBaseTypeName();\n+        if (boundVariables.containsTypeVariable(baseType)) {\n+            if (typeSignature.getParameters().isEmpty() == false) {\n+                throw new IllegalStateException(\"Type parameters cannot have parameters\");\n+            }\n+            return boundVariables.getTypeVariable(baseType).getTypeSignature();\n+        }\n+\n+        List<TypeSignature> parameters = Lists2.map(\n+            typeSignature.getParameters(),\n+            typeSignatureParameter -> applyBoundVariables(typeSignatureParameter, boundVariables));\n+\n+        return new TypeSignature(baseType, parameters);\n+    }\n+\n+    private boolean appendConstraintSolversForArguments(List<TypeConstraintSolver> resultBuilder,\n+                                                        List<TypeSignature> actualTypeSignatures) {\n+        boolean variableArity = declaredSignature.isVariableArity();\n+        List<TypeSignature> formalTypeSignatures = declaredSignature.getArgumentTypes();\n+        if (variableArity) {\n+            int variableGroupCount = declaredSignature.getVariableArityGroup().size();\n+            int variableArgumentCount = variableGroupCount > 0 ? variableGroupCount : 1;\n+            if (actualTypeSignatures.size() < formalTypeSignatures.size() - variableArgumentCount) {\n+                if (LOGGER.isTraceEnabled()) {\n+                    LOGGER.trace(\n+                        \"Given signature size {} is not smaller than minimum variableArity of formal signature size {}\",\n+                        actualTypeSignatures.size(),\n+                        formalTypeSignatures.size() - variableArgumentCount);\n+                }\n+                return false;\n+            }\n+            formalTypeSignatures = expandVarargFormalTypeSignature(\n+                formalTypeSignatures,\n+                declaredSignature.getVariableArityGroup(),\n+                typeVariableConstraints,\n+                actualTypeSignatures.size());\n+            if (formalTypeSignatures == null) {\n+                // var args expanding detected a no-match\n+                return false;\n+            }\n+        }\n+\n+        if (formalTypeSignatures.size() != actualTypeSignatures.size()) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Given signature size {} does not match formal signature size {}\",\n+                             actualTypeSignatures.size(), formalTypeSignatures.size());\n+            }\n+            return false;\n+        }\n+\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            appendTypeRelationshipConstraintSolver(resultBuilder,\n+                                                   formalTypeSignatures.get(i),\n+                                                   actualTypeSignatures.get(i),\n+                                                   allowCoercion);\n+        }\n+\n+        return appendConstraintSolvers(resultBuilder, formalTypeSignatures, actualTypeSignatures, allowCoercion);\n+    }\n+\n+    private boolean appendConstraintSolvers(List<TypeConstraintSolver> resultBuilder,\n+                                            List<? extends TypeSignature> formalTypeSignatures,\n+                                            List<TypeSignature> actualTypeSignatures,\n+                                            boolean allowCoercion) {\n+        if (formalTypeSignatures.size() != actualTypeSignatures.size()) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Given signature size {} does not match formal signature size {}\",\n+                             actualTypeSignatures.size(), formalTypeSignatures.size());\n+            }\n+            return false;\n+        }\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            if (!appendConstraintSolvers(resultBuilder,\n+                                         formalTypeSignatures.get(i),\n+                                         actualTypeSignatures.get(i),\n+                                         allowCoercion)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean appendConstraintSolvers(List<TypeConstraintSolver> resultBuilder,\n+                                            TypeSignature formalTypeSignature,\n+                                            TypeSignature actualTypeSignature,\n+                                            boolean allowCoercion) {\n+        if (formalTypeSignature.getParameters().isEmpty()) {\n+            TypeVariableConstraint typeVariableConstraint = typeVariableConstraints.get(formalTypeSignature.getBaseTypeName());\n+            if (typeVariableConstraint == null) {\n+                return true;\n+            }\n+            resultBuilder.add(new TypeParameterSolver(formalTypeSignature.getBaseTypeName(), actualTypeSignature.createType()));\n+            return true;\n+        }\n+\n+        DataType<?> actualType = actualTypeSignature.createType();\n+\n+        List<TypeSignature> actualTypeParametersTypeSignatureProvider;\n+        if (UndefinedType.ID == actualType.id()) {\n+            actualTypeParametersTypeSignatureProvider = Collections.nCopies(formalTypeSignature.getParameters().size(),\n+                                                                            UndefinedType.INSTANCE.getTypeSignature());\n+        } else {\n+            actualTypeParametersTypeSignatureProvider = Lists2.map(\n+                actualType.getTypeParameters(),\n+                DataType::getTypeSignature\n+            );\n+        }\n+\n+        return appendConstraintSolvers(\n+            resultBuilder,\n+            Collections.unmodifiableList(formalTypeSignature.getParameters()),\n+            actualTypeParametersTypeSignatureProvider,\n+            allowCoercion);\n+    }\n+\n+    private void appendTypeRelationshipConstraintSolver(List<TypeConstraintSolver> resultBuilder,\n+                                                        TypeSignature formalTypeSignature,\n+                                                        TypeSignature actualTypeSignature,\n+                                                        boolean allowCoercion) {\n+        Set<String> typeVariables = typeVariablesOf(formalTypeSignature);\n+        resultBuilder.add(new TypeRelationshipConstraintSolver(\n+            formalTypeSignature,\n+            typeVariables,\n+            actualTypeSignature.createType(),\n+            allowCoercion));\n+    }\n+\n+    private Set<String> typeVariablesOf(TypeSignature typeSignature) {\n+        if (typeVariableConstraints.containsKey(typeSignature.getBaseTypeName())) {\n+            return Set.of(typeSignature.getBaseTypeName());\n+        }\n+        HashSet<String> variables = new HashSet<>();\n+        for (TypeSignature parameter : typeSignature.getParameters()) {\n+            variables.addAll(typeVariablesOf(parameter));\n+        }\n+\n+        return variables;\n+    }\n+\n+    @Nullable\n+    private BoundVariables iterativeSolve(List<TypeConstraintSolver> constraints) {\n+        BoundVariables.Builder boundVariablesBuilder = BoundVariables.builder();\n+        for (int i = 0; true; i++) {\n+            if (i == SOLVE_ITERATION_LIMIT) {\n+                throw new IllegalStateException(format(\n+                    Locale.ENGLISH,\n+                    \"SignatureBinder.iterativeSolve does not converge after %d iterations.\",\n+                    SOLVE_ITERATION_LIMIT));\n+            }\n+            SolverReturnStatusMerger statusMerger = new SolverReturnStatusMerger();\n+            for (TypeConstraintSolver constraint : constraints) {\n+                var constraintStatus = constraint.update(boundVariablesBuilder);\n+                if (LOGGER.isTraceEnabled()) {\n+                    LOGGER.trace(\"Status after updating constraint={}: {}\", constraint, constraintStatus);\n+                }\n+                statusMerger.add(constraintStatus);\n+                if (statusMerger.getCurrent() == SolverReturnStatus.UNSOLVABLE) {\n+                    if (LOGGER.isTraceEnabled()) {\n+                        LOGGER.trace(\"Status merger resulted in UNSOLVABLE state\");\n+                    }\n+                    return null;\n+                }\n+            }\n+            switch (statusMerger.getCurrent()) {\n+                case UNCHANGED_SATISFIED:\n+                    break;\n+                case UNCHANGED_NOT_SATISFIED:\n+                    return null;\n+                case CHANGED:\n+                    continue;\n+                default:\n+                case UNSOLVABLE:\n+                    throw new UnsupportedOperationException(\"Signature binding unsolvable\");\n+            }\n+            break;\n+        }\n+\n+        BoundVariables boundVariables = boundVariablesBuilder.build();\n+        if (!allTypeVariablesBound(boundVariables)) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Not all variables are bound. Defined variables={}, bound={}\",\n+                             typeVariableConstraints,\n+                             boundVariables);\n+            }\n+            return null;\n+        }\n+        return boundVariables;\n+    }\n+\n+    private boolean allTypeVariablesBound(BoundVariables boundVariables) {\n+        return boundVariables.getTypeVariableNames().equals(typeVariableConstraints.keySet());\n+    }\n+\n+    @Nullable\n+    private static List<TypeSignature> expandVarargFormalTypeSignature(List<TypeSignature> formalTypeSignatures,\n+                                                                       List<TypeSignature> variableArityGroup,\n+                                                                       Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                                                       int actualArity) {\n+        int variableArityGroupCount = variableArityGroup.size();\n+        if (variableArityGroupCount > 0 && actualArity % variableArityGroupCount != 0) {\n+            // no match\n+            return null;\n+        }\n+        int arityCountIncludedInsideFormalSignature = variableArityGroupCount == 0 ? 1 : variableArityGroupCount;\n+        int variableArityArgumentsCount = actualArity - formalTypeSignatures.size() + arityCountIncludedInsideFormalSignature;\n+        if (variableArityArgumentsCount == 0) {\n+            return formalTypeSignatures.subList(0, formalTypeSignatures.size() - arityCountIncludedInsideFormalSignature);\n+        }\n+        if (variableArityArgumentsCount == arityCountIncludedInsideFormalSignature) {\n+            return formalTypeSignatures;\n+        }\n+        if (variableArityArgumentsCount > arityCountIncludedInsideFormalSignature && formalTypeSignatures.isEmpty()) {\n+            throw new IllegalArgumentException(\"Found variable argument(s) but list of formal type signatures is empty\");\n+        }\n+\n+        ArrayList<TypeSignature> builder = new ArrayList<>(formalTypeSignatures);\n+        if (variableArityGroup.isEmpty()) {\n+            TypeSignature lastTypeSignature = formalTypeSignatures.get(formalTypeSignatures.size() - 1);\n+            for (int i = 1; i < variableArityArgumentsCount; i++) {\n+                addVarArgTypeSignature(lastTypeSignature, typeVariableConstraints, builder, i);\n+            }\n+        } else {\n+            for (int i = 0; i < variableArityArgumentsCount - formalTypeSignatures.size(); ) {\n+                i += variableArityGroupCount;\n+                for (var typeSignature : variableArityGroup) {\n+                    addVarArgTypeSignature(typeSignature, typeVariableConstraints, builder, i);\n+                }\n+            }\n+        }\n+        return Collections.unmodifiableList(builder);\n+    }\n+\n+    private static void addVarArgTypeSignature(TypeSignature typeSignature,\n+                                               Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                               List<TypeSignature> builder,\n+                                               int actualArity) {\n+        TypeVariableConstraint typeVariableConstraint = typeVariableConstraints.get(typeSignature.getBaseTypeName());\n+        if (typeVariableConstraint != null && typeVariableConstraint.isAnyAllowed()) {\n+            // Type variables defaults to be bound to the same type.\n+            // To support independent variable type arguments, each vararg must be bound to a dedicated type variable.\n+            String constraintName = \"_generated_\" + typeSignature.getBaseTypeName() + actualArity;\n+            TypeSignature newTypeSignature = new TypeSignature(constraintName);\n+            typeVariableConstraints.put(constraintName, typeVariableOfAnyType(constraintName));\n+            builder.add(newTypeSignature);\n+        } else {\n+            builder.add(typeSignature);\n+        }\n+\n+    }\n+\n+    private static boolean satisfiesCoercion(boolean allowCoercion,\n+                                             DataType<?> fromType,\n+                                             TypeSignature toTypeSignature) {\n+        if (allowCoercion) {\n+            return fromType.isConvertableTo(toTypeSignature.createType());\n+        } else {\n+            return fromType.getTypeSignature().equals(toTypeSignature);\n+        }\n+    }\n+\n+    private interface TypeConstraintSolver {\n+        SolverReturnStatus update(BoundVariables.Builder bindings);\n+    }\n+\n+    private enum SolverReturnStatus {\n+        UNCHANGED_SATISFIED,\n+        UNCHANGED_NOT_SATISFIED,\n+        CHANGED,\n+        UNSOLVABLE,\n+    }\n+\n+    private static class SolverReturnStatusMerger {\n+        // This class gives the overall status when multiple status are seen from different parts.\n+        // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java b/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java\nindex ad80225ce4..e62d78b254 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java\n", "chunk": "@@ -404,7 +404,7 @@ public class SignatureBinder {\n \n     private static class SolverReturnStatusMerger {\n         // This class gives the overall status when multiple status are seen from different parts.\n-        // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:\n+        // The logic can be summarized as finding the right most item (based on the list below) seen so far:\n         //   UNCHANGED_SATISFIED, UNCHANGED_NOT_SATISFIED, CHANGED, UNSOLVABLE\n         // If no item was seen ever, it provides UNCHANGED_SATISFIED.\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java b/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java\nindex ad80225ce4..e62d78b254 100644\n--- a/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java\n+++ b/sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java\n", "chunk": "@@ -404,7 +404,7 @@ public class SignatureBinder {\n \n     private static class SolverReturnStatusMerger {\n         // This class gives the overall status when multiple status are seen from different parts.\n-        // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:\n+        // The logic can be summarized as finding the right most item (based on the list below) seen so far:\n         //   UNCHANGED_SATISFIED, UNCHANGED_NOT_SATISFIED, CHANGED, UNSOLVABLE\n         // If no item was seen ever, it provides UNCHANGED_SATISFIED.\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "30b5e4950ed4548b4c1039adc46255bcf4fe604f", "message": "Merge commit", "committedDate": null}, {"oid": "91795c06d68ae6b0289ccd383191aa6df12723ee", "committedDate": "2020-04-03 08:25:32 +0000", "message": "Add support for selecting most specific function"}, {"oid": "8f29abc16157d4421773704cb3c0adecf3036c4c", "committedDate": "2020-04-23 09:52:10 +0000", "message": "Add fast function lookup-by-signature support"}, {"oid": "d6a74bbff6df2cc810c789367407f56bf7237bac", "committedDate": "2020-04-29 12:53:20 +0200", "message": "Fix signature parameter binding for nested variables of any type."}, {"oid": "8120beec545b153566e01f22301ae31a4c4d39f3", "committedDate": "2020-05-07 11:24:27 +0000", "message": "Rename sql module to server"}]}, {"oid": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "url": "https://github.com/crate/crate/commit/4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-24T08:31:46Z", "type": "forcePushed"}, {"oid": "507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "url": "https://github.com/crate/crate/commit/507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "message": "Add new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-24T10:02:45Z", "type": "commit"}, {"oid": "507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "url": "https://github.com/crate/crate/commit/507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "message": "Add new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-24T10:02:45Z", "type": "forcePushed"}]}