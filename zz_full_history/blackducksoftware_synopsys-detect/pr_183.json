{"pr_number": 183, "pr_title": "Status json code locations", "pr_author": "crowleySynopsys", "pr_createdAt": "2020-06-04T16:53:42Z", "pr_url": "https://github.com/blackducksoftware/synopsys-detect/pull/183", "timeline": [{"oid": "73d77215e6404c86314b9dc86aee3d6d8eb993be", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/73d77215e6404c86314b9dc86aee3d6d8eb993be", "message": "feat: Incorporate code location data from all tools into status.json file (IDETECT-2035)", "committedDate": "2020-06-02T22:27:10Z", "type": "commit"}, {"oid": "bceb8e6212fed3082d20be6ad97643970517f875", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/bceb8e6212fed3082d20be6ad97643970517f875", "message": "fix: Revert BazelExtractor", "committedDate": "2020-06-04T16:38:45Z", "type": "commit"}, {"oid": "1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "message": "fix: Remove unnecessary comment", "committedDate": "2020-06-04T16:45:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTAwNA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435419004", "body": "I don't like that this is called \"collectCodeLocationNames\" when it really \"creates\" code location names. ", "bodyText": "I don't like that this is called \"collectCodeLocationNames\" when it really \"creates\" code location names.", "bodyHTML": "<p dir=\"auto\">I don't like that this is called \"collectCodeLocationNames\" when it really \"creates\" code location names.</p>", "author": "taikuukaits", "createdAt": "2020-06-04T17:15:22Z", "path": "src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java", "diffHunk": "@@ -409,4 +414,14 @@ private void runBlackDuckProduct(final ProductRunData productRunData, final Dete\n         }\n     }\n \n+    private Set<String> collectCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {", "originalCommit": "1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDk5Mw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435450993", "bodyText": "that seems like a reasonable renaming", "author": "crowleySynopsys", "createdAt": "2020-06-04T18:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTAwNA=="}], "type": "inlineReview", "revised_code": {"commit": "db429cd8d738f9d77a49d1940abc3aa45c33e27f", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 05e2ee37f..41a5200af 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -414,14 +409,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> collectCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "77f5bc128db3ea50db4eca2b4b70abec3af00b35", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 41a5200af..15bcda8b3 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -409,4 +414,14 @@ public class RunManager {\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "4ce0d86b56ba026bc4817429dff2165ec4c84501", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 15bcda8b3..18b57fcee 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -414,14 +413,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "16b2a37284b600bbc93fff3228fc82398e32b8c1", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 18b57fcee..d8d9d8daf 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -413,4 +418,14 @@ public class RunManager {\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "07dc7418d99917974facb437535917728c7533d2", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex d8d9d8daf..8a5861371 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -418,14 +465,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "4f2ba16d878930a66019d4584570a1ab4b962aeb", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 8a5861371..fbc7482d1 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -345,124 +347,128 @@ public class RunManager {\n         BdioResult bdioResult = bdioManager.createBdioFiles(bdioOptions, aggregateOptions, projectNameVersion, runResult.getDetectCodeLocations(), runOptions.shouldUseBdio2());\n         eventSystem.publishEvent(Event.DetectCodeLocationNamesCalculated, bdioResult.getCodeLocationNamesResult());\n \n-        CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n-        if (!bdioResult.getUploadTargets().isEmpty()) {\n-            logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n-            if (blackDuckRunData.isOnline()) {\n-                logger.debug(\"Uploading BDIO files.\");\n-                BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-                DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n-                CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory.createBdioUploadService(), blackDuckServicesFactory.createBdio2UploadService());\n-                codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n-            }\n+        if (runOptions.shouldPerformDeveloperModeScan()) {\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckDeveloperMode developerMode = new BlackDuckDeveloperMode(blackDuckRunData, blackDuckServicesFactory, detectConfigurationFactory);\n+            List<DeveloperScanComponentResultView> results = developerMode.run(bdioResult);\n+            BlackDuckDeveloperPostActions postActions = new BlackDuckDeveloperPostActions(gson, eventSystem, directoryManager);\n+            postActions.perform(projectNameVersion, results);\n         } else {\n-            logger.debug(\"Did not create any BDIO files.\");\n-        }\n-\n-        logger.debug(\"Completed Detect Code Location processing.\");\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-            logger.info(\"Will include the signature scanner tool.\");\n-            BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n-            BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n-            BlackDuckServerConfig blackDuckServerConfig = null;\n-            CodeLocationCreationService codeLocationCreationService = null;\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-                codeLocationCreationService = blackDuckServicesFactory.createCodeLocationCreationService();\n-                blackDuckServerConfig = onlineBlackDuckRunData.getBlackDuckServerConfig();\n+            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n+            if (!bdioResult.getUploadTargets().isEmpty()) {\n+                logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n+                if (null != blackDuckServicesFactory) {\n+                    logger.debug(\"Uploading BDIO files.\");\n+                    DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n+                    CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory);\n+                    codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n+                }\n+            } else {\n+                logger.debug(\"Did not create any BDIO files.\");\n             }\n-            SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(codeLocationCreationService, blackDuckServerConfig, projectNameVersion, runResult.getDockerTar());\n-            if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n-                codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n-            } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n-                eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n-                eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+\n+            logger.debug(\"Completed Detect Code Location processing.\");\n+\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+                logger.info(\"Will include the signature scanner tool.\");\n+                BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n+                BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n+                SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(blackDuckRunData, projectNameVersion, runResult.getDockerTar());\n+                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n+                    codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n+                } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n+                    eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n+                    eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+                }\n+                logger.info(\"Signature scanner actions finished.\");\n+            } else {\n+                logger.info(\"Signature scan tool will not be run.\");\n             }\n-            logger.info(\"Signature scanner actions finished.\");\n-        } else {\n-            logger.info(\"Signature scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-            logger.info(\"Will include the binary scanner tool.\");\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-                BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n-                BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory.createBinaryScanUploadService());\n-                if (blackDuckBinaryScanner.shouldRun()) {\n-                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n-                    if (result.isSuccessful()) {\n-                        codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+                logger.info(\"Will include the binary scanner tool.\");\n+                if (null != blackDuckServicesFactory) {\n+                    BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n+                    BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory);\n+                    if (blackDuckBinaryScanner.shouldRun()) {\n+                        BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n+                        if (result.isSuccessful()) {\n+                            codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+                        }\n                     }\n                 }\n+                logger.info(\"Binary scanner actions finished.\");\n+            } else {\n+                logger.info(\"Binary scan tool will not be run.\");\n             }\n-            logger.info(\"Binary scanner actions finished.\");\n-        } else {\n-            logger.info(\"Binary scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n-        if (blackDuckRunData.isOnline()) {\n-            BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-            ImpactAnalysisBatchRunner impactAnalysisBatchRunner = new ImpactAnalysisBatchRunner(blackDuckServicesFactory.getLogger(), blackDuckServicesFactory.getBlackDuckApiClient(), new NoThreadExecutorService(), blackDuckServicesFactory.getGson());\n-            ImpactAnalysisUploadService impactAnalysisUploadService = new ImpactAnalysisUploadService(impactAnalysisBatchRunner, blackDuckServicesFactory.createCodeLocationCreationService());\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory.getBlackDuckApiClient(), impactAnalysisUploadService, blackDuckServicesFactory.createCodeLocationService(), eventSystem);\n-        } else {\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n-        }\n-        if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-            ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n+            if (null != blackDuckServicesFactory) {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory, eventSystem);\n+            } else {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n+            }\n+            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+                ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+\n+                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n \n-            /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-            codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+                if (impactAnalysisToolResult.isSuccessful()) {\n+                    logger.info(\"Vulnerability Impact Analysis successful.\");\n+                } else {\n+                    logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                }\n \n-            if (impactAnalysisToolResult.isSuccessful()) {\n-                logger.info(\"Vulnerability Impact Analysis successful.\");\n+                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+            } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n             } else {\n-                logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n             }\n \n-            logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-        } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n-        } else {\n-            logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        //We have finished code locations.\n-        CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-        CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-        eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n-\n-        if (blackDuckRunData.isOnline()) {\n-            logger.info(\"Will perform Black Duck post actions.\");\n-            BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-            BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-            BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-            blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-            if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                      .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                      .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                      .map(HttpUrl::string);\n-\n-                if (componentsLink.isPresent()) {\n-                    DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                    eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            //We have finished code locations.\n+            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+\n+            if (null != blackDuckServicesFactory) {\n+                logger.info(\"Will perform Black Duck post actions.\");\n+                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory, eventSystem);\n+                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                          .map(HttpUrl::string);\n+\n+                    if (componentsLink.isPresent()) {\n+                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                    }\n                 }\n+                logger.info(\"Black Duck actions have finished.\");\n+            } else {\n+                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n-            logger.info(\"Black Duck actions have finished.\");\n-        } else {\n-            logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "b746ab8169a39089379db85a218c89398a097da8", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex fbc7482d1..814ed7c05 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -347,128 +339,124 @@ public class RunManager {\n         BdioResult bdioResult = bdioManager.createBdioFiles(bdioOptions, aggregateOptions, projectNameVersion, runResult.getDetectCodeLocations(), runOptions.shouldUseBdio2());\n         eventSystem.publishEvent(Event.DetectCodeLocationNamesCalculated, bdioResult.getCodeLocationNamesResult());\n \n-        if (runOptions.shouldPerformDeveloperModeScan()) {\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            BlackDuckDeveloperMode developerMode = new BlackDuckDeveloperMode(blackDuckRunData, blackDuckServicesFactory, detectConfigurationFactory);\n-            List<DeveloperScanComponentResultView> results = developerMode.run(bdioResult);\n-            BlackDuckDeveloperPostActions postActions = new BlackDuckDeveloperPostActions(gson, eventSystem, directoryManager);\n-            postActions.perform(projectNameVersion, results);\n-        } else {\n-            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n-            if (!bdioResult.getUploadTargets().isEmpty()) {\n-                logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n-                if (null != blackDuckServicesFactory) {\n-                    logger.debug(\"Uploading BDIO files.\");\n-                    DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n-                    CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory);\n-                    codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n-                }\n-            } else {\n-                logger.debug(\"Did not create any BDIO files.\");\n+        CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n+        if (!bdioResult.getUploadTargets().isEmpty()) {\n+            logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n+            if (blackDuckRunData.isOnline()) {\n+                logger.debug(\"Uploading BDIO files.\");\n+                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+                DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n+                CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory.createBdioUploadService(), blackDuckServicesFactory.createBdio2UploadService());\n+                codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n             }\n+        } else {\n+            logger.debug(\"Did not create any BDIO files.\");\n+        }\n \n-            logger.debug(\"Completed Detect Code Location processing.\");\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-                logger.info(\"Will include the signature scanner tool.\");\n-                BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n-                BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n-                SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(blackDuckRunData, projectNameVersion, runResult.getDockerTar());\n-                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n-                    codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n-                } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n-                    eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n-                    eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n-                }\n-                logger.info(\"Signature scanner actions finished.\");\n-            } else {\n-                logger.info(\"Signature scan tool will not be run.\");\n+        logger.debug(\"Completed Detect Code Location processing.\");\n+\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+            logger.info(\"Will include the signature scanner tool.\");\n+            BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n+            BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n+            BlackDuckServerConfig blackDuckServerConfig = null;\n+            CodeLocationCreationService codeLocationCreationService = null;\n+            if (blackDuckRunData.isOnline()) {\n+                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+                codeLocationCreationService = blackDuckServicesFactory.createCodeLocationCreationService();\n+                blackDuckServerConfig = blackDuckRunData.getBlackDuckServerConfig();\n             }\n+            SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(codeLocationCreationService, blackDuckServerConfig, projectNameVersion, runResult.getDockerTar());\n+            if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n+                codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n+            } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n+                eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n+                eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+            }\n+            logger.info(\"Signature scanner actions finished.\");\n+        } else {\n+            logger.info(\"Signature scan tool will not be run.\");\n+        }\n \n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-                logger.info(\"Will include the binary scanner tool.\");\n-                if (null != blackDuckServicesFactory) {\n-                    BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n-                    BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory);\n-                    if (blackDuckBinaryScanner.shouldRun()) {\n-                        BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n-                        if (result.isSuccessful()) {\n-                            codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n-                        }\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+            logger.info(\"Will include the binary scanner tool.\");\n+            if (blackDuckRunData.isOnline()) {\n+                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+                BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n+                BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory.createBinaryScanUploadService());\n+                if (blackDuckBinaryScanner.shouldRun()) {\n+                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n+                    if (result.isSuccessful()) {\n+                        codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n                     }\n                 }\n-                logger.info(\"Binary scanner actions finished.\");\n-            } else {\n-                logger.info(\"Binary scan tool will not be run.\");\n-            }\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n-            if (null != blackDuckServicesFactory) {\n-                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory, eventSystem);\n-            } else {\n-                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n             }\n-            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n-                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-                ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+            logger.info(\"Binary scanner actions finished.\");\n+        } else {\n+            logger.info(\"Binary scan tool will not be run.\");\n+        }\n \n-                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n+        if (blackDuckRunData.isOnline()) {\n+            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+            ImpactAnalysisBatchRunner impactAnalysisBatchRunner = new ImpactAnalysisBatchRunner(blackDuckServicesFactory.getLogger(), blackDuckServicesFactory.getBlackDuckApiClient(), new NoThreadExecutorService(), blackDuckServicesFactory.getGson());\n+            ImpactAnalysisUploadService impactAnalysisUploadService = new ImpactAnalysisUploadService(impactAnalysisBatchRunner, blackDuckServicesFactory.createCodeLocationCreationService());\n+            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory.getBlackDuckApiClient(), impactAnalysisUploadService, blackDuckServicesFactory.createCodeLocationService(), eventSystem);\n+        } else {\n+            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n+        }\n+        if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n+            logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+            ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n \n-                if (impactAnalysisToolResult.isSuccessful()) {\n-                    logger.info(\"Vulnerability Impact Analysis successful.\");\n-                } else {\n-                    logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n-                }\n+            /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+            codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n \n-                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-            } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n-                logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n+            if (impactAnalysisToolResult.isSuccessful()) {\n+                logger.info(\"Vulnerability Impact Analysis successful.\");\n             } else {\n-                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n+                logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n             }\n \n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            //We have finished code locations.\n-            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n-\n-            if (null != blackDuckServicesFactory) {\n-                logger.info(\"Will perform Black Duck post actions.\");\n-                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory, eventSystem);\n-                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                          .map(HttpUrl::string);\n-\n-                    if (componentsLink.isPresent()) {\n-                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n-                    }\n-                }\n-                logger.info(\"Black Duck actions have finished.\");\n-            } else {\n-                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n-            }\n+            logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+        } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n+            logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n+        } else {\n+            logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n         }\n-    }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        //We have finished code locations.\n+        CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+        CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+        eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+\n+        if (blackDuckRunData.isOnline()) {\n+            logger.info(\"Will perform Black Duck post actions.\");\n+            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+            BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+            BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n+                blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n+            blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+            if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                      .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                      .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                      .map(HttpUrl::string);\n+\n+                if (componentsLink.isPresent()) {\n+                    DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                    eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                }\n+            }\n+            logger.info(\"Black Duck actions have finished.\");\n+        } else {\n+            logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n         }\n-        return new HashSet<>();\n     }\n \n }\n", "next_change": {"commit": "8d5e738bae67fc7d53e266c08b1a551631efef04", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 814ed7c05..749ffade6 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -339,124 +347,128 @@ public class RunManager {\n         BdioResult bdioResult = bdioManager.createBdioFiles(bdioOptions, aggregateOptions, projectNameVersion, runResult.getDetectCodeLocations(), runOptions.shouldUseBdio2());\n         eventSystem.publishEvent(Event.DetectCodeLocationNamesCalculated, bdioResult.getCodeLocationNamesResult());\n \n-        CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n-        if (!bdioResult.getUploadTargets().isEmpty()) {\n-            logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n-            if (blackDuckRunData.isOnline()) {\n-                logger.debug(\"Uploading BDIO files.\");\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n-                CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory.createBdioUploadService(), blackDuckServicesFactory.createBdio2UploadService());\n-                codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n-            }\n+        if (runOptions.shouldPerformDeveloperModeScan()) {\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckDeveloperMode developerMode = new BlackDuckDeveloperMode(blackDuckRunData, blackDuckServicesFactory, detectConfigurationFactory);\n+            List<DeveloperScanComponentResultView> results = developerMode.run(bdioResult);\n+            BlackDuckDeveloperPostActions postActions = new BlackDuckDeveloperPostActions(gson, eventSystem, directoryManager);\n+            postActions.perform(projectNameVersion, results);\n         } else {\n-            logger.debug(\"Did not create any BDIO files.\");\n-        }\n-\n-        logger.debug(\"Completed Detect Code Location processing.\");\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-            logger.info(\"Will include the signature scanner tool.\");\n-            BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n-            BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n-            BlackDuckServerConfig blackDuckServerConfig = null;\n-            CodeLocationCreationService codeLocationCreationService = null;\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                codeLocationCreationService = blackDuckServicesFactory.createCodeLocationCreationService();\n-                blackDuckServerConfig = blackDuckRunData.getBlackDuckServerConfig();\n+            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n+            if (!bdioResult.getUploadTargets().isEmpty()) {\n+                logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n+                if (null != blackDuckServicesFactory) {\n+                    logger.debug(\"Uploading BDIO files.\");\n+                    DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n+                    CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory);\n+                    codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n+                }\n+            } else {\n+                logger.debug(\"Did not create any BDIO files.\");\n             }\n-            SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(codeLocationCreationService, blackDuckServerConfig, projectNameVersion, runResult.getDockerTar());\n-            if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n-                codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n-            } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n-                eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n-                eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+\n+            logger.debug(\"Completed Detect Code Location processing.\");\n+\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+                logger.info(\"Will include the signature scanner tool.\");\n+                BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n+                BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n+                SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(blackDuckRunData, projectNameVersion, runResult.getDockerTar());\n+                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n+                    codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n+                } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n+                    eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n+                    eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+                }\n+                logger.info(\"Signature scanner actions finished.\");\n+            } else {\n+                logger.info(\"Signature scan tool will not be run.\");\n             }\n-            logger.info(\"Signature scanner actions finished.\");\n-        } else {\n-            logger.info(\"Signature scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-            logger.info(\"Will include the binary scanner tool.\");\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n-                BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory.createBinaryScanUploadService());\n-                if (blackDuckBinaryScanner.shouldRun()) {\n-                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n-                    if (result.isSuccessful()) {\n-                        codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+                logger.info(\"Will include the binary scanner tool.\");\n+                if (null != blackDuckServicesFactory) {\n+                    BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n+                    BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory);\n+                    if (blackDuckBinaryScanner.shouldRun()) {\n+                        BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n+                        if (result.isSuccessful()) {\n+                            codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+                        }\n                     }\n                 }\n+                logger.info(\"Binary scanner actions finished.\");\n+            } else {\n+                logger.info(\"Binary scan tool will not be run.\");\n             }\n-            logger.info(\"Binary scanner actions finished.\");\n-        } else {\n-            logger.info(\"Binary scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n-        if (blackDuckRunData.isOnline()) {\n-            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-            ImpactAnalysisBatchRunner impactAnalysisBatchRunner = new ImpactAnalysisBatchRunner(blackDuckServicesFactory.getLogger(), blackDuckServicesFactory.getBlackDuckApiClient(), new NoThreadExecutorService(), blackDuckServicesFactory.getGson());\n-            ImpactAnalysisUploadService impactAnalysisUploadService = new ImpactAnalysisUploadService(impactAnalysisBatchRunner, blackDuckServicesFactory.createCodeLocationCreationService());\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory.getBlackDuckApiClient(), impactAnalysisUploadService, blackDuckServicesFactory.createCodeLocationService(), eventSystem);\n-        } else {\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n-        }\n-        if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-            ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n+            if (null != blackDuckServicesFactory) {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory, eventSystem);\n+            } else {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n+            }\n+            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+                ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+\n+                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n \n-            /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-            codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+                if (impactAnalysisToolResult.isSuccessful()) {\n+                    logger.info(\"Vulnerability Impact Analysis successful.\");\n+                } else {\n+                    logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                }\n \n-            if (impactAnalysisToolResult.isSuccessful()) {\n-                logger.info(\"Vulnerability Impact Analysis successful.\");\n+                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+            } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n             } else {\n-                logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n             }\n \n-            logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-        } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n-        } else {\n-            logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        //We have finished code locations.\n-        CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-        CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-        eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n-\n-        if (blackDuckRunData.isOnline()) {\n-            logger.info(\"Will perform Black Duck post actions.\");\n-            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-            BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-            BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-            blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-            if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                      .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                      .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                      .map(HttpUrl::string);\n-\n-                if (componentsLink.isPresent()) {\n-                    DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                    eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            //We have finished code locations.\n+            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+\n+            if (null != blackDuckServicesFactory) {\n+                logger.info(\"Will perform Black Duck post actions.\");\n+                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory, eventSystem);\n+                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                          .map(HttpUrl::string);\n+\n+                    if (componentsLink.isPresent()) {\n+                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                    }\n                 }\n+                logger.info(\"Black Duck actions have finished.\");\n+            } else {\n+                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n-            logger.info(\"Black Duck actions have finished.\");\n-        } else {\n-            logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "f5aa7a0c24828bc262bfea68219845cfb3adef28", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 749ffade6..5f925d87c 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -461,14 +484,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "796cec7992add8ce41bebd0c027cfdb7bce8a444", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 5f925d87c..6d7b8129b 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -454,34 +228,17 @@ public class RunManager {\n \n             logger.info(ReportConstants.RUN_SEPARATOR);\n             //We have finished code locations.\n-            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultOperation().execute(codeLocationAccumulator);\n \n             if (blackDuckRunData.isOnline()) {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                    blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                          .map(HttpUrl::string);\n-\n-                    if (componentsLink.isPresent()) {\n-                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n-                    }\n-                }\n+                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n+                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n         }\n     }\n-\n }\n", "next_change": {"commit": "f42aa793ea922b8a661aac13cb523640b469e5ba", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 6d7b8129b..ccb05fd5f 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -228,17 +454,34 @@ public class RunManager {\n \n             logger.info(ReportConstants.RUN_SEPARATOR);\n             //We have finished code locations.\n-            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultOperation().execute(codeLocationAccumulator);\n+            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n \n             if (blackDuckRunData.isOnline()) {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n+                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n+                    blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n+                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                          .map(HttpUrl::string);\n+\n+                    if (componentsLink.isPresent()) {\n+                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                    }\n+                }\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n         }\n     }\n+\n }\n", "next_change": {"commit": "620ed822ead4ec354f4f40285b749e3e48177c22", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex ccb05fd5f..7c198e5cb 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -454,34 +230,17 @@ public class RunManager {\n \n             logger.info(ReportConstants.RUN_SEPARATOR);\n             //We have finished code locations.\n-            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n \n             if (blackDuckRunData.isOnline()) {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                    blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                          .map(HttpUrl::string);\n-\n-                    if (componentsLink.isPresent()) {\n-                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n-                    }\n-                }\n+                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n+                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n         }\n     }\n-\n }\n", "next_change": {"commit": "79f1919fbf38dc4c90d82b7d2e629b581e631c94", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 7c198e5cb..d3aa6a860 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -236,7 +242,7 @@ public class RunManager {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n                 FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n+                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n", "next_change": {"commit": "6c880cc789b07b3b42c3de8b781bfd06683fe7d1", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex d3aa6a860..238db2227 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -1,252 +1,259 @@\n-/*\n- * synopsys-detect\n- *\n- * Copyright (c) 2021 Synopsys, Inc.\n- *\n- * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n- */\n-package com.synopsys.integration.detect.lifecycle.run;\n-\n-import java.util.Optional;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n-import com.synopsys.integration.blackduck.codelocation.bdioupload.UploadBatchOutput;\n-import com.synopsys.integration.blackduck.codelocation.binaryscanner.BinaryScanBatchOutput;\n-import com.synopsys.integration.blackduck.codelocation.signaturescanner.ScanBatchOutput;\n-import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;\n-import com.synopsys.integration.blackduck.service.model.ProjectVersionWrapper;\n-import com.synopsys.integration.detect.configuration.DetectUserFriendlyException;\n-import com.synopsys.integration.detect.configuration.enumeration.DetectTool;\n-import com.synopsys.integration.detect.lifecycle.run.data.BlackDuckRunData;\n-import com.synopsys.integration.detect.lifecycle.run.data.ProductRunData;\n-import com.synopsys.integration.detect.lifecycle.run.operation.OperationFactory;\n-import com.synopsys.integration.detect.lifecycle.run.operation.blackduck.ImpactAnalysisOperation;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.BdioInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.FullScanPostProcessingInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.ImpactAnalysisInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.RapidScanInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.SignatureScanInput;\n-import com.synopsys.integration.detect.lifecycle.shutdown.ExitCodeManager;\n-import com.synopsys.integration.detect.tool.DetectableToolResult;\n-import com.synopsys.integration.detect.tool.UniversalToolsResult;\n-import com.synopsys.integration.detect.tool.detector.DetectorToolResult;\n-import com.synopsys.integration.detect.tool.impactanalysis.ImpactAnalysisToolResult;\n-import com.synopsys.integration.detect.util.filter.DetectToolFilter;\n-import com.synopsys.integration.detect.workflow.bdio.AggregateDecision;\n-import com.synopsys.integration.detect.workflow.bdio.BdioResult;\n-import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationAccumulator;\n-import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationResults;\n-import com.synopsys.integration.detect.workflow.phonehome.PhoneHomeManager;\n-import com.synopsys.integration.detect.workflow.project.ProjectEventPublisher;\n-import com.synopsys.integration.detect.workflow.report.util.ReportConstants;\n-import com.synopsys.integration.detect.workflow.status.OperationSystem;\n-import com.synopsys.integration.exception.IntegrationException;\n-import com.synopsys.integration.util.NameVersion;\n-\n-public class RunManager {\n-    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n-    private ExitCodeManager exitCodeManager;\n-\n-    public RunManager(ExitCodeManager exitCodeManager) {\n-        this.exitCodeManager = exitCodeManager;\n-    }\n-\n-    public void run(RunContext runContext) {\n-        try {\n-            RunResult runResult = new RunResult();\n-            ProductRunData productRunData = runContext.getProductRunData();\n-            OperationFactory operationFactory = new OperationFactory(runContext);\n-            ProjectEventPublisher projectEventPublisher = runContext.getProjectEventPublisher();\n-            DetectToolFilter detectToolFilter = productRunData.getDetectToolFilter();\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (runContext.getProductRunData().shouldUsePolarisProduct()) {\n-                runPolarisProduct(operationFactory, detectToolFilter);\n-            } else {\n-                logger.info(\"Polaris tools will not be run.\");\n-            }\n-\n-            UniversalToolsResult universalToolsResult = runUniversalProjectTools(operationFactory, detectToolFilter, projectEventPublisher, runResult);\n-\n-            if (productRunData.shouldUseBlackDuckProduct()) {\n-                AggregateDecision aggregateDecision = operationFactory.createAggregateOptionsOperation().execute(universalToolsResult.anyFailed());\n-                runBlackDuckProduct(productRunData.getBlackDuckRunData(), operationFactory, detectToolFilter, runResult,\n-                    universalToolsResult.getNameVersion(), aggregateDecision);\n-            } else {\n-                logger.info(\"Black Duck tools will not be run.\");\n-            }\n-\n-            logger.info(\"All tools have finished.\");\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-        } catch (Exception e) {\n-            if (e.getMessage() != null) {\n-                logger.error(\"Detect run failed: {}\", e.getMessage());\n-            } else {\n-                logger.error(\"Detect run failed: {}\", e.getClass().getSimpleName());\n-            }\n-            logger.debug(\"An exception was thrown during the detect run.\", e);\n-            exitCodeManager.requestExitCode(e);\n-        } finally {\n-            OperationSystem operationSystem = runContext.getOperationSystem();\n-            operationSystem.publishOperations();\n-        }\n-    }\n-\n-    private UniversalToolsResult runUniversalProjectTools(\n-        OperationFactory operationFactory,\n-        DetectToolFilter detectToolFilter,\n-        ProjectEventPublisher projectEventPublisher,\n-        RunResult runResult\n-    ) throws DetectUserFriendlyException, IntegrationException {\n-        boolean anythingFailed = false;\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n-            logger.info(\"Will include the Docker tool.\");\n-            DetectableToolResult detectableToolResult = operationFactory.createDockerOperation().execute();\n-            runResult.addDetectableToolResult(detectableToolResult);\n-            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-            logger.info(\"Docker actions finished.\");\n-        } else {\n-            logger.info(\"Docker tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n-            logger.info(\"Will include the Bazel tool.\");\n-            DetectableToolResult detectableToolResult = operationFactory.createBazelOperation().execute();\n-            runResult.addDetectableToolResult(detectableToolResult);\n-            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-            logger.info(\"Bazel actions finished.\");\n-        } else {\n-            logger.info(\"Bazel tool will not be run.\");\n-        }\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n-            logger.info(\"Will include the detector tool.\");\n-            DetectorToolResult detectorToolResult = operationFactory.createDetectorOperation().execute();\n-            detectorToolResult.getBomToolProjectNameVersion().ifPresent(it -> runResult.addToolNameVersion(DetectTool.DETECTOR, new NameVersion(it.getName(), it.getVersion())));\n-            runResult.addDetectCodeLocations(detectorToolResult.getBomToolCodeLocations());\n-            anythingFailed = anythingFailed || detectorToolResult.anyDetectorsFailed();\n-            logger.info(\"Detector actions finished.\");\n-        } else {\n-            logger.info(\"Detector tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        logger.debug(\"Completed code location tools.\");\n-\n-        logger.debug(\"Determining project info.\");\n-\n-        NameVersion projectNameVersion = operationFactory.createProjectDecisionOperation().execute(runResult.getDetectToolProjectInfo());\n-\n-        logger.info(String.format(\"Project name: %s\", projectNameVersion.getName()));\n-        logger.info(String.format(\"Project version: %s\", projectNameVersion.getVersion()));\n-\n-        projectEventPublisher.publishProjectNameVersionChosen(projectNameVersion);\n-\n-        if (anythingFailed) {\n-            return UniversalToolsResult.failure(projectNameVersion);\n-        } else {\n-            return UniversalToolsResult.success(projectNameVersion);\n-        }\n-    }\n-\n-    private void runPolarisProduct(OperationFactory operationFactory, DetectToolFilter detectToolFilter) {\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.POLARIS)) {\n-            logger.info(\"Will include the Polaris tool.\");\n-            operationFactory.createPolarisOperation().execute();\n-            logger.info(\"Polaris actions finished.\");\n-        } else {\n-            logger.info(\"Polaris CLI tool will not be run.\");\n-        }\n-    }\n-\n-    private void runBlackDuckProduct(BlackDuckRunData blackDuckRunData, OperationFactory operationFactory, DetectToolFilter detectToolFilter, RunResult runResult, NameVersion projectNameVersion,\n-        AggregateDecision aggregateDecision)\n-        throws IntegrationException, DetectUserFriendlyException {\n-\n-        logger.debug(\"Black Duck tools will run.\");\n-\n-        ProjectVersionWrapper projectVersionWrapper = null;\n-\n-        BdioInput bdioInput = new BdioInput(aggregateDecision, projectNameVersion, runResult.getDetectCodeLocations());\n-        BdioResult bdioResult = operationFactory.createBdioFileGenerationOperation().execute(bdioInput);\n-        if (blackDuckRunData.isRapid()) {\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            RapidScanInput rapidScanInput = new RapidScanInput(projectNameVersion, bdioResult);\n-            operationFactory.createRapidScanOperation().execute(blackDuckRunData, blackDuckRunData.getBlackDuckServicesFactory(), rapidScanInput);\n-        } else {\n-            if (blackDuckRunData.isOnline()) {\n-                blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                logger.debug(\"Getting or creating project.\");\n-                projectVersionWrapper = operationFactory.createProjectCreationOperation().execute(blackDuckServicesFactory, projectNameVersion);\n-            } else {\n-                logger.debug(\"Detect is not online, and will not create the project.\");\n-            }\n-\n-            logger.debug(\"Completed project and version actions.\");\n-            logger.debug(\"Processing Detect Code Locations.\");\n-\n-            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator<>();\n-            Optional<CodeLocationCreationData<UploadBatchOutput>> uploadResult = operationFactory.createBdioUploadOperation().execute(blackDuckRunData, bdioResult);\n-            uploadResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-\n-            logger.debug(\"Completed Detect Code Location processing.\");\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-                logger.info(\"Will include the signature scanner tool.\");\n-                SignatureScanInput signatureScanInput = new SignatureScanInput(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-                Optional<CodeLocationCreationData<ScanBatchOutput>> signatureScanResult = operationFactory.createSignatureScanOperation().execute(signatureScanInput);\n-                signatureScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-                logger.info(\"Signature scanner actions finished.\");\n-            } else {\n-                logger.info(\"Signature scan tool will not be run.\");\n-            }\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-                logger.info(\"Will include the binary scanner tool.\");\n-                if (blackDuckRunData.isOnline()) {\n-                    Optional<CodeLocationCreationData<BinaryScanBatchOutput>> binaryScanResult = operationFactory.createBinaryScanOperation().execute(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-                    binaryScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-                }\n-                logger.info(\"Binary scanner actions finished.\");\n-            } else {\n-                logger.info(\"Binary scan tool will not be run.\");\n-            }\n-            ImpactAnalysisOperation impactAnalysisOperation = operationFactory.createImpactAnalysisOperation();\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS)) {\n-                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-                ImpactAnalysisInput impactAnalysisInput = new ImpactAnalysisInput(projectNameVersion, projectVersionWrapper);\n-                ImpactAnalysisToolResult impactAnalysisToolResult = impactAnalysisOperation.execute(impactAnalysisInput);\n-                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n-                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-            } else {\n-                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-            }\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            //We have finished code locations.\n-            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n-\n-            if (blackDuckRunData.isOnline()) {\n-                logger.info(\"Will perform Black Duck post actions.\");\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n-                logger.info(\"Black Duck actions have finished.\");\n-            } else {\n-                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n-            }\n-        }\n-    }\n-}\n+///*\n+// * synopsys-detect\n+// *\n+// * Copyright (c) 2021 Synopsys, Inc.\n+// *\n+// * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n+// */\n+//package com.synopsys.integration.detect.lifecycle.run;\n+//\n+//import java.util.Optional;\n+//\n+//import org.slf4j.Logger;\n+//import org.slf4j.LoggerFactory;\n+//\n+//import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n+//import com.synopsys.integration.blackduck.codelocation.binaryscanner.BinaryScanBatchOutput;\n+//import com.synopsys.integration.blackduck.codelocation.signaturescanner.ScanBatchOutput;\n+//import com.synopsys.integration.blackduck.codelocation.upload.UploadBatchOutput;\n+//import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;\n+//import com.synopsys.integration.blackduck.service.model.ProjectVersionWrapper;\n+//import com.synopsys.integration.detect.configuration.DetectUserFriendlyException;\n+//import com.synopsys.integration.detect.configuration.enumeration.DetectTool;\n+//import com.synopsys.integration.detect.lifecycle.run.data.BlackDuckRunData;\n+//import com.synopsys.integration.detect.lifecycle.run.data.ProductRunData;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.OperationFactory;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.blackduck.ImpactAnalysisOperation;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.BdioInput;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.FullScanPostProcessingInput;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.ImpactAnalysisInput;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.SignatureScanInput;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.BootSingletons;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.EventSingletons;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.SingletonFactory;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.UtilitySingletons;\n+//import com.synopsys.integration.detect.lifecycle.shutdown.ExitCodeManager;\n+//import com.synopsys.integration.detect.tool.DetectableToolResult;\n+//import com.synopsys.integration.detect.tool.UniversalToolsResult;\n+//import com.synopsys.integration.detect.tool.detector.DetectorToolResult;\n+//import com.synopsys.integration.detect.tool.detector.factory.DetectorFactory;\n+//import com.synopsys.integration.detect.tool.impactanalysis.ImpactAnalysisToolResult;\n+//import com.synopsys.integration.detect.util.filter.DetectToolFilter;\n+//import com.synopsys.integration.detect.workflow.bdio.AggregateDecision;\n+//import com.synopsys.integration.detect.workflow.bdio.BdioResult;\n+//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationAccumulator;\n+//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationResults;\n+//import com.synopsys.integration.detect.workflow.blackduck.developer.RapidScanDetectResult;\n+//import com.synopsys.integration.detect.workflow.phonehome.PhoneHomeManager;\n+//import com.synopsys.integration.detect.workflow.project.ProjectEventPublisher;\n+//import com.synopsys.integration.detect.workflow.report.util.ReportConstants;\n+//import com.synopsys.integration.detect.workflow.status.OperationSystem;\n+//import com.synopsys.integration.exception.IntegrationException;\n+//import com.synopsys.integration.util.NameVersion;\n+//\n+//public class RunManager {\n+//    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+//    private final ExitCodeManager exitCodeManager;\n+//\n+//    public RunManager(ExitCodeManager exitCodeManager) {\n+//        this.exitCodeManager = exitCodeManager;\n+//    }\n+//\n+//    public void run(BootSingletons bootSingletons) {\n+//        OperationSystem operationSystem = null;\n+//        try {\n+//            RunResult runResult = new RunResult();\n+//            ProductRunData productRunData = bootSingletons.getProductRunData();\n+//\n+//            SingletonFactory singletonFactory = new SingletonFactory(bootSingletons);\n+//            EventSingletons eventSingletons = singletonFactory.createEventSingletons();\n+//            UtilitySingletons utilitySingletons = singletonFactory.createUtilitySingletons(eventSingletons);\n+//            operationSystem = utilitySingletons.getOperationSystem();\n+//\n+//            DetectorFactory detectorFactory = new DetectorFactory(bootSingletons, utilitySingletons);\n+//            DetectFontLoaderFactory detectFontLoaderFactory = new DetectFontLoaderFactory(bootSingletons, utilitySingletons);\n+//            OperationFactory operationFactory = new OperationFactory(detectorFactory.detectDetectableFactory(), detectFontLoaderFactory, bootSingletons, utilitySingletons, eventSingletons);\n+//\n+//            // know singleton -\n+//            ProjectEventPublisher projectEventPublisher = eventSingletons.getProjectEventPublisher();\n+//            DetectToolFilter detectToolFilter = productRunData.getDetectToolFilter();\n+//\n+//            UniversalToolsResult universalToolsResult = runUniversalProjectTools(operationFactory, detectToolFilter, projectEventPublisher, runResult);\n+//\n+//            if (productRunData.shouldUseBlackDuckProduct()) {\n+//                AggregateDecision aggregateDecision = operationFactory.createAggregateOptionsOperation().execute(universalToolsResult.anyFailed());\n+//                runBlackDuckProduct(productRunData.getBlackDuckRunData(), operationFactory, detectToolFilter, runResult,\n+//                    universalToolsResult.getNameVersion(), aggregateDecision);\n+//            } else {\n+//                logger.info(\"Black Duck tools will not be run.\");\n+//            }\n+//\n+//            logger.info(\"All tools have finished.\");\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//        } catch (Exception e) {\n+//            if (e.getMessage() != null) {\n+//                logger.error(\"Detect run failed: {}\", e.getMessage());\n+//            } else {\n+//                logger.error(\"Detect run failed: {}\", e.getClass().getSimpleName());\n+//            }\n+//            logger.debug(\"An exception was thrown during the detect run.\", e);\n+//            exitCodeManager.requestExitCode(e);\n+//        } finally {\n+//            if (operationSystem != null) {\n+//                operationSystem.publishOperations();\n+//            }\n+//        }\n+//    }\n+//\n+//    private UniversalToolsResult runUniversalProjectTools(\n+//        OperationFactory operationFactory,\n+//        DetectToolFilter detectToolFilter,\n+//        ProjectEventPublisher projectEventPublisher,\n+//        RunResult runResult\n+//    ) throws DetectUserFriendlyException, IntegrationException {\n+//        boolean anythingFailed = false;\n+//\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n+//            logger.info(\"Will include the Docker tool.\");\n+//            DetectableToolResult detectableToolResult = operationFactory.createDockerOperation().execute();\n+//            runResult.addDetectableToolResult(detectableToolResult);\n+//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n+//            logger.info(\"Docker actions finished.\");\n+//        } else {\n+//            logger.info(\"Docker tool will not be run.\");\n+//        }\n+//\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n+//            logger.info(\"Will include the Bazel tool.\");\n+//            DetectableToolResult detectableToolResult = operationFactory.createBazelOperation().execute();\n+//            runResult.addDetectableToolResult(detectableToolResult);\n+//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n+//            logger.info(\"Bazel actions finished.\");\n+//        } else {\n+//            logger.info(\"Bazel tool will not be run.\");\n+//        }\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n+//            logger.info(\"Will include the detector tool.\");\n+//            DetectorToolResult detectorToolResult = operationFactory.createDetectorOperation().execute();\n+//            detectorToolResult.getBomToolProjectNameVersion().ifPresent(it -> runResult.addToolNameVersion(DetectTool.DETECTOR, new NameVersion(it.getName(), it.getVersion())));\n+//            runResult.addDetectCodeLocations(detectorToolResult.getBomToolCodeLocations());\n+//            anythingFailed = anythingFailed || detectorToolResult.anyDetectorsFailed();\n+//            logger.info(\"Detector actions finished.\");\n+//        } else {\n+//            logger.info(\"Detector tool will not be run.\");\n+//        }\n+//\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        logger.debug(\"Completed code location tools.\");\n+//\n+//        logger.debug(\"Determining project info.\");\n+//\n+//        NameVersion projectNameVersion = operationFactory.createProjectDecisionOperation().execute(runResult.getDetectToolProjectInfo());\n+//\n+//        logger.info(String.format(\"Project name: %s\", projectNameVersion.getName()));\n+//        logger.info(String.format(\"Project version: %s\", projectNameVersion.getVersion()));\n+//\n+//        projectEventPublisher.publishProjectNameVersionChosen(projectNameVersion);\n+//\n+//        if (anythingFailed) {\n+//            return UniversalToolsResult.failure(projectNameVersion);\n+//        } else {\n+//            return UniversalToolsResult.success(projectNameVersion);\n+//        }\n+//    }\n+//\n+//    private void runRapidScan(BlackDuckRunData blackDuckRunData, NameVersion projectNameVersion, BdioResult bdioResult) {\n+//        operationFactory.phoneHome();\n+//        File results = operationFactory.performRapidScan();\n+//        File jsonFile = operationFactory.generateRapidJsonFile(results);\n+//        File summary = operationFactory.logRapidReport(results);\n+//        statusEventPublisher.publishDetectResult(new RapidScanDetectResult(jsonFile.getCanonicalPath(), summary));\n+//    }\n+//\n+//    private void runBlackDuckProduct(BlackDuckRunData blackDuckRunData, OperationFactory operationFactory, DetectToolFilter detectToolFilter, RunResult runResult, NameVersion projectNameVersion,\n+//        AggregateDecision aggregateDecision)\n+//        throws IntegrationException, DetectUserFriendlyException {\n+//\n+//        logger.debug(\"Black Duck tools will run.\");\n+//\n+//        ProjectVersionWrapper projectVersionWrapper = null;\n+//\n+//        BdioInput bdioInput = new BdioInput(aggregateDecision, projectNameVersion, runResult.getDetectCodeLocations());\n+//        BdioResult bdioResult = operationFactory.createBdioFileGenerationOperation().execute(bdioInput);\n+//        if (blackDuckRunData.isRapid() && blackDuckRunData.isOnline()) {\n+//            blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            runRapidScan();\n+//        } else {\n+//            if (blackDuckRunData.isOnline()) {\n+//                blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n+//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+//                logger.debug(\"Getting or creating project.\");\n+//                projectVersionWrapper = operationFactory.createProjectCreationOperation().execute(blackDuckServicesFactory, projectNameVersion);\n+//            } else {\n+//                logger.debug(\"Detect is not online, and will not create the project.\");\n+//            }\n+//\n+//            logger.debug(\"Completed project and version actions.\");\n+//            logger.debug(\"Processing Detect Code Locations.\");\n+//\n+//            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator<>();\n+//            Optional<CodeLocationCreationData<UploadBatchOutput>> uploadResult = operationFactory.createBdioUploadOperation().execute(blackDuckRunData.getScanMode(), blackDuckRunData, bdioResult);\n+//            uploadResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n+//\n+//            logger.debug(\"Completed Detect Code Location processing.\");\n+//\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+//                logger.info(\"Will include the signature scanner tool.\");\n+//                SignatureScanInput signatureScanInput = new SignatureScanInput(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n+//                Optional<CodeLocationCreationData<ScanBatchOutput>> signatureScanResult = operationFactory.createSignatureScanOperation().execute(signatureScanInput);\n+//                signatureScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n+//                logger.info(\"Signature scanner actions finished.\");\n+//            } else {\n+//                logger.info(\"Signature scan tool will not be run.\");\n+//            }\n+//\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+//                logger.info(\"Will include the binary scanner tool.\");\n+//                if (blackDuckRunData.isOnline()) {\n+//                    Optional<CodeLocationCreationData<BinaryScanBatchOutput>> binaryScanResult = operationFactory.createBinaryScanOperation().execute(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n+//                    binaryScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n+//                }\n+//                logger.info(\"Binary scanner actions finished.\");\n+//            } else {\n+//                logger.info(\"Binary scan tool will not be run.\");\n+//            }\n+//            ImpactAnalysisOperation impactAnalysisOperation = operationFactory.createImpactAnalysisOperation();\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS)) {\n+//                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+//                ImpactAnalysisInput impactAnalysisInput = new ImpactAnalysisInput(projectNameVersion, projectVersionWrapper);\n+//                ImpactAnalysisToolResult impactAnalysisToolResult = impactAnalysisOperation.execute(impactAnalysisInput);\n+//                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+//                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+//                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+//            } else {\n+//                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n+//            }\n+//\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            //We have finished code locations.\n+//            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n+//\n+//            if (blackDuckRunData.isOnline()) {\n+//                logger.info(\"Will perform Black Duck post actions.\");\n+//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+//                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n+//                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n+//                logger.info(\"Black Duck actions have finished.\");\n+//            } else {\n+//                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n+//            }\n+//        }\n+//    }\n+//}\n", "next_change": {"commit": "678c90e318030a91013aab90358529e9ca9a746b", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\ndeleted file mode 100644\nindex 238db2227..000000000\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ /dev/null\n", "chunk": "@@ -1,259 +0,0 @@\n-///*\n-// * synopsys-detect\n-// *\n-// * Copyright (c) 2021 Synopsys, Inc.\n-// *\n-// * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n-// */\n-//package com.synopsys.integration.detect.lifecycle.run;\n-//\n-//import java.util.Optional;\n-//\n-//import org.slf4j.Logger;\n-//import org.slf4j.LoggerFactory;\n-//\n-//import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n-//import com.synopsys.integration.blackduck.codelocation.binaryscanner.BinaryScanBatchOutput;\n-//import com.synopsys.integration.blackduck.codelocation.signaturescanner.ScanBatchOutput;\n-//import com.synopsys.integration.blackduck.codelocation.upload.UploadBatchOutput;\n-//import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;\n-//import com.synopsys.integration.blackduck.service.model.ProjectVersionWrapper;\n-//import com.synopsys.integration.detect.configuration.DetectUserFriendlyException;\n-//import com.synopsys.integration.detect.configuration.enumeration.DetectTool;\n-//import com.synopsys.integration.detect.lifecycle.run.data.BlackDuckRunData;\n-//import com.synopsys.integration.detect.lifecycle.run.data.ProductRunData;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.OperationFactory;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.blackduck.ImpactAnalysisOperation;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.BdioInput;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.FullScanPostProcessingInput;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.ImpactAnalysisInput;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.SignatureScanInput;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.BootSingletons;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.EventSingletons;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.SingletonFactory;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.UtilitySingletons;\n-//import com.synopsys.integration.detect.lifecycle.shutdown.ExitCodeManager;\n-//import com.synopsys.integration.detect.tool.DetectableToolResult;\n-//import com.synopsys.integration.detect.tool.UniversalToolsResult;\n-//import com.synopsys.integration.detect.tool.detector.DetectorToolResult;\n-//import com.synopsys.integration.detect.tool.detector.factory.DetectorFactory;\n-//import com.synopsys.integration.detect.tool.impactanalysis.ImpactAnalysisToolResult;\n-//import com.synopsys.integration.detect.util.filter.DetectToolFilter;\n-//import com.synopsys.integration.detect.workflow.bdio.AggregateDecision;\n-//import com.synopsys.integration.detect.workflow.bdio.BdioResult;\n-//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationAccumulator;\n-//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationResults;\n-//import com.synopsys.integration.detect.workflow.blackduck.developer.RapidScanDetectResult;\n-//import com.synopsys.integration.detect.workflow.phonehome.PhoneHomeManager;\n-//import com.synopsys.integration.detect.workflow.project.ProjectEventPublisher;\n-//import com.synopsys.integration.detect.workflow.report.util.ReportConstants;\n-//import com.synopsys.integration.detect.workflow.status.OperationSystem;\n-//import com.synopsys.integration.exception.IntegrationException;\n-//import com.synopsys.integration.util.NameVersion;\n-//\n-//public class RunManager {\n-//    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n-//    private final ExitCodeManager exitCodeManager;\n-//\n-//    public RunManager(ExitCodeManager exitCodeManager) {\n-//        this.exitCodeManager = exitCodeManager;\n-//    }\n-//\n-//    public void run(BootSingletons bootSingletons) {\n-//        OperationSystem operationSystem = null;\n-//        try {\n-//            RunResult runResult = new RunResult();\n-//            ProductRunData productRunData = bootSingletons.getProductRunData();\n-//\n-//            SingletonFactory singletonFactory = new SingletonFactory(bootSingletons);\n-//            EventSingletons eventSingletons = singletonFactory.createEventSingletons();\n-//            UtilitySingletons utilitySingletons = singletonFactory.createUtilitySingletons(eventSingletons);\n-//            operationSystem = utilitySingletons.getOperationSystem();\n-//\n-//            DetectorFactory detectorFactory = new DetectorFactory(bootSingletons, utilitySingletons);\n-//            DetectFontLoaderFactory detectFontLoaderFactory = new DetectFontLoaderFactory(bootSingletons, utilitySingletons);\n-//            OperationFactory operationFactory = new OperationFactory(detectorFactory.detectDetectableFactory(), detectFontLoaderFactory, bootSingletons, utilitySingletons, eventSingletons);\n-//\n-//            // know singleton -\n-//            ProjectEventPublisher projectEventPublisher = eventSingletons.getProjectEventPublisher();\n-//            DetectToolFilter detectToolFilter = productRunData.getDetectToolFilter();\n-//\n-//            UniversalToolsResult universalToolsResult = runUniversalProjectTools(operationFactory, detectToolFilter, projectEventPublisher, runResult);\n-//\n-//            if (productRunData.shouldUseBlackDuckProduct()) {\n-//                AggregateDecision aggregateDecision = operationFactory.createAggregateOptionsOperation().execute(universalToolsResult.anyFailed());\n-//                runBlackDuckProduct(productRunData.getBlackDuckRunData(), operationFactory, detectToolFilter, runResult,\n-//                    universalToolsResult.getNameVersion(), aggregateDecision);\n-//            } else {\n-//                logger.info(\"Black Duck tools will not be run.\");\n-//            }\n-//\n-//            logger.info(\"All tools have finished.\");\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//        } catch (Exception e) {\n-//            if (e.getMessage() != null) {\n-//                logger.error(\"Detect run failed: {}\", e.getMessage());\n-//            } else {\n-//                logger.error(\"Detect run failed: {}\", e.getClass().getSimpleName());\n-//            }\n-//            logger.debug(\"An exception was thrown during the detect run.\", e);\n-//            exitCodeManager.requestExitCode(e);\n-//        } finally {\n-//            if (operationSystem != null) {\n-//                operationSystem.publishOperations();\n-//            }\n-//        }\n-//    }\n-//\n-//    private UniversalToolsResult runUniversalProjectTools(\n-//        OperationFactory operationFactory,\n-//        DetectToolFilter detectToolFilter,\n-//        ProjectEventPublisher projectEventPublisher,\n-//        RunResult runResult\n-//    ) throws DetectUserFriendlyException, IntegrationException {\n-//        boolean anythingFailed = false;\n-//\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n-//            logger.info(\"Will include the Docker tool.\");\n-//            DetectableToolResult detectableToolResult = operationFactory.createDockerOperation().execute();\n-//            runResult.addDetectableToolResult(detectableToolResult);\n-//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-//            logger.info(\"Docker actions finished.\");\n-//        } else {\n-//            logger.info(\"Docker tool will not be run.\");\n-//        }\n-//\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n-//            logger.info(\"Will include the Bazel tool.\");\n-//            DetectableToolResult detectableToolResult = operationFactory.createBazelOperation().execute();\n-//            runResult.addDetectableToolResult(detectableToolResult);\n-//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-//            logger.info(\"Bazel actions finished.\");\n-//        } else {\n-//            logger.info(\"Bazel tool will not be run.\");\n-//        }\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n-//            logger.info(\"Will include the detector tool.\");\n-//            DetectorToolResult detectorToolResult = operationFactory.createDetectorOperation().execute();\n-//            detectorToolResult.getBomToolProjectNameVersion().ifPresent(it -> runResult.addToolNameVersion(DetectTool.DETECTOR, new NameVersion(it.getName(), it.getVersion())));\n-//            runResult.addDetectCodeLocations(detectorToolResult.getBomToolCodeLocations());\n-//            anythingFailed = anythingFailed || detectorToolResult.anyDetectorsFailed();\n-//            logger.info(\"Detector actions finished.\");\n-//        } else {\n-//            logger.info(\"Detector tool will not be run.\");\n-//        }\n-//\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        logger.debug(\"Completed code location tools.\");\n-//\n-//        logger.debug(\"Determining project info.\");\n-//\n-//        NameVersion projectNameVersion = operationFactory.createProjectDecisionOperation().execute(runResult.getDetectToolProjectInfo());\n-//\n-//        logger.info(String.format(\"Project name: %s\", projectNameVersion.getName()));\n-//        logger.info(String.format(\"Project version: %s\", projectNameVersion.getVersion()));\n-//\n-//        projectEventPublisher.publishProjectNameVersionChosen(projectNameVersion);\n-//\n-//        if (anythingFailed) {\n-//            return UniversalToolsResult.failure(projectNameVersion);\n-//        } else {\n-//            return UniversalToolsResult.success(projectNameVersion);\n-//        }\n-//    }\n-//\n-//    private void runRapidScan(BlackDuckRunData blackDuckRunData, NameVersion projectNameVersion, BdioResult bdioResult) {\n-//        operationFactory.phoneHome();\n-//        File results = operationFactory.performRapidScan();\n-//        File jsonFile = operationFactory.generateRapidJsonFile(results);\n-//        File summary = operationFactory.logRapidReport(results);\n-//        statusEventPublisher.publishDetectResult(new RapidScanDetectResult(jsonFile.getCanonicalPath(), summary));\n-//    }\n-//\n-//    private void runBlackDuckProduct(BlackDuckRunData blackDuckRunData, OperationFactory operationFactory, DetectToolFilter detectToolFilter, RunResult runResult, NameVersion projectNameVersion,\n-//        AggregateDecision aggregateDecision)\n-//        throws IntegrationException, DetectUserFriendlyException {\n-//\n-//        logger.debug(\"Black Duck tools will run.\");\n-//\n-//        ProjectVersionWrapper projectVersionWrapper = null;\n-//\n-//        BdioInput bdioInput = new BdioInput(aggregateDecision, projectNameVersion, runResult.getDetectCodeLocations());\n-//        BdioResult bdioResult = operationFactory.createBdioFileGenerationOperation().execute(bdioInput);\n-//        if (blackDuckRunData.isRapid() && blackDuckRunData.isOnline()) {\n-//            blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            runRapidScan();\n-//        } else {\n-//            if (blackDuckRunData.isOnline()) {\n-//                blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n-//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-//                logger.debug(\"Getting or creating project.\");\n-//                projectVersionWrapper = operationFactory.createProjectCreationOperation().execute(blackDuckServicesFactory, projectNameVersion);\n-//            } else {\n-//                logger.debug(\"Detect is not online, and will not create the project.\");\n-//            }\n-//\n-//            logger.debug(\"Completed project and version actions.\");\n-//            logger.debug(\"Processing Detect Code Locations.\");\n-//\n-//            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator<>();\n-//            Optional<CodeLocationCreationData<UploadBatchOutput>> uploadResult = operationFactory.createBdioUploadOperation().execute(blackDuckRunData.getScanMode(), blackDuckRunData, bdioResult);\n-//            uploadResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-//\n-//            logger.debug(\"Completed Detect Code Location processing.\");\n-//\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-//                logger.info(\"Will include the signature scanner tool.\");\n-//                SignatureScanInput signatureScanInput = new SignatureScanInput(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-//                Optional<CodeLocationCreationData<ScanBatchOutput>> signatureScanResult = operationFactory.createSignatureScanOperation().execute(signatureScanInput);\n-//                signatureScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-//                logger.info(\"Signature scanner actions finished.\");\n-//            } else {\n-//                logger.info(\"Signature scan tool will not be run.\");\n-//            }\n-//\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-//                logger.info(\"Will include the binary scanner tool.\");\n-//                if (blackDuckRunData.isOnline()) {\n-//                    Optional<CodeLocationCreationData<BinaryScanBatchOutput>> binaryScanResult = operationFactory.createBinaryScanOperation().execute(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-//                    binaryScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-//                }\n-//                logger.info(\"Binary scanner actions finished.\");\n-//            } else {\n-//                logger.info(\"Binary scan tool will not be run.\");\n-//            }\n-//            ImpactAnalysisOperation impactAnalysisOperation = operationFactory.createImpactAnalysisOperation();\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS)) {\n-//                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-//                ImpactAnalysisInput impactAnalysisInput = new ImpactAnalysisInput(projectNameVersion, projectVersionWrapper);\n-//                ImpactAnalysisToolResult impactAnalysisToolResult = impactAnalysisOperation.execute(impactAnalysisInput);\n-//                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-//                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n-//                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-//            } else {\n-//                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-//            }\n-//\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            //We have finished code locations.\n-//            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n-//\n-//            if (blackDuckRunData.isOnline()) {\n-//                logger.info(\"Will perform Black Duck post actions.\");\n-//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-//                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-//                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n-//                logger.info(\"Black Duck actions have finished.\");\n-//            } else {\n-//                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n-//            }\n-//        }\n-//    }\n-//}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435419535", "body": "This isn't after calculation though, this is after we add it to wait data. Doesn't seem like the event matches up.", "bodyText": "This isn't after calculation though, this is after we add it to wait data. Doesn't seem like the event matches up.", "bodyHTML": "<p dir=\"auto\">This isn't after calculation though, this is after we add it to wait data. Doesn't seem like the event matches up.</p>", "author": "taikuukaits", "createdAt": "2020-06-04T17:16:16Z", "path": "src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java", "diffHunk": "@@ -24,19 +24,26 @@\n \n import java.util.Date;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n import com.synopsys.integration.blackduck.service.model.NotificationTaskRange;\n+import com.synopsys.integration.detect.workflow.event.Event;\n+import com.synopsys.integration.detect.workflow.event.EventSystem;\n \n public class CodeLocationWaitData {\n     private NotificationTaskRange notificationRange;\n     private Set<String> codeLocationNames = new HashSet<>();\n     private int expectedNotificationCount = 0;\n \n-    public void addWaitForCreationData(CodeLocationCreationData codeLocationCreationData) {\n+    public void addWaitForCreationData(CodeLocationCreationData codeLocationCreationData, EventSystem eventSystem) {\n         expectedNotificationCount += codeLocationCreationData.getOutput().getExpectedNotificationCount();\n-        codeLocationNames.addAll(codeLocationCreationData.getOutput().getSuccessfulCodeLocationNames());\n+\n+        Set<String> codeLocationNames = codeLocationCreationData.getOutput().getSuccessfulCodeLocationNames();\n+        this.codeLocationNames.addAll(codeLocationNames);\n+        eventSystem.publishEvent(Event.CodeLocationNamesCalculated, codeLocationNames);", "originalCommit": "1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1Mjk3NA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435452974", "bodyText": "is the name of the event what you have an issue with?", "author": "crowleySynopsys", "createdAt": "2020-06-04T18:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNDE4MA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436004180", "bodyText": "I'm concerned that publishing the events is not the responsibility of the WaitData, because as a consumer of that class I would assume I could call \"addWaitForCreationData\" multiple times but those events imply that it is called once. Did you consider having the caller send the event? My interpretation is that WaitData is like a DateRange where I can extend the range (extendToIncludeDays is to addWaitForCreationData) so I wouldn't expect it to have any logic (such as publishing events) and would put that on the caller.", "author": "taikuukaits", "createdAt": "2020-06-05T15:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxOTIzNA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436019234", "bodyText": "I see.  Yeah I just figured I'd publish within the method since it was already extracting the names I wanted sent to the event system, and otherwise I'd be doing so every time the method was called.  The event would be more appropriately named CodeLocationNamesAdded, as it is a mechanism to update the code location names found by all the different tools on a rolling basis.  If you think that publishing an event is confusing the role of the class, though, I'd be fine delegating to the caller", "author": "crowleySynopsys", "createdAt": "2020-06-05T16:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNzkxMw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436037913", "bodyText": "Ah I see, then it is the event name and the class name that I am reacting to. If it was CodeLocationNamesAdded and CodeLocationWaitController (to me data means that it doesn't have the logic) then I think I would be OK with it.", "author": "taikuukaits", "createdAt": "2020-06-05T16:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MzMyMw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436053323", "bodyText": "Okay cool, those name changes seem reasonable to me.", "author": "crowleySynopsys", "createdAt": "2020-06-05T17:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java b/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitController.java\nsimilarity index 95%\nrename from src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java\nrename to src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitController.java\nindex 4c509f4a6..65cd4b001 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitController.java\n", "chunk": "@@ -42,7 +41,7 @@ public class CodeLocationWaitData {\n \n         Set<String> codeLocationNames = codeLocationCreationData.getOutput().getSuccessfulCodeLocationNames();\n         this.codeLocationNames.addAll(codeLocationNames);\n-        eventSystem.publishEvent(Event.CodeLocationNamesCalculated, codeLocationNames);\n+        eventSystem.publishEvent(Event.CodeLocationNamesAdded, codeLocationNames);\n \n         if (null == notificationRange) {\n             notificationRange = codeLocationCreationData.getNotificationTaskRange();\n", "next_change": null}]}}, {"oid": "77f5bc128db3ea50db4eca2b4b70abec3af00b35", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/77f5bc128db3ea50db4eca2b4b70abec3af00b35", "message": "fix: Renamed collectCodeLocationNames to createCodeLocationNames", "committedDate": "2020-06-05T14:29:01Z", "type": "commit"}, {"oid": "a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "message": "style: renamed Event.CodeLocationNamesCalculated Event.CodeLocationNamesAdded -> , CodeLocationWaitData -> CodeLocationWaitController", "committedDate": "2020-06-05T17:19:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU2Mjc0MQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r437562741", "body": "Shouldn't this be renamed to `codeLocationsAdded`?", "bodyText": "Shouldn't this be renamed to codeLocationsAdded?", "bodyHTML": "<p dir=\"auto\">Shouldn't this be renamed to <code>codeLocationsAdded</code>?</p>", "author": "JakeMathews", "createdAt": "2020-06-09T16:27:59Z", "path": "src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java", "diffHunk": "@@ -130,8 +130,8 @@ private void detectorsComplete(final DetectorToolResult detectorToolResult) {\n         this.detectorToolResult = detectorToolResult;\n     }\n \n-    private void codeLocationsCalculated(final BdioCodeLocationResult bdioCodeLocationResult) {\n-        this.bdioCodeLocationResult = bdioCodeLocationResult;\n+    private void codeLocationsCalculated(final Collection<String> codeLocations) {", "originalCommit": "a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "963e1ce63ff80c6fbffd8f00f9547e66d48b35a1", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex c55e80a48..da603f88b 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -130,14 +125,6 @@ public class FormattedOutputManager {\n         this.detectorToolResult = detectorToolResult;\n     }\n \n-    private void codeLocationsCalculated(final Collection<String> codeLocations) {\n-        this.codeLocations.addAll(codeLocations);\n-    }\n-\n-    private void projectNameVersionChosen(final NameVersion nameVersion) {\n-        this.projectNameVersion = nameVersion;\n-    }\n-\n     public void addStatusSummary(final Status status) {\n         statusSummaries.add(status);\n     }\n", "next_change": {"commit": "4890855a6e9347d990e8c98c4574b22c61dac38c", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex da603f88b..fcc885e9b 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -125,6 +141,14 @@ public class FormattedOutputManager {\n         this.detectorToolResult = detectorToolResult;\n     }\n \n+    private void codeLocationsCalculated(final BdioCodeLocationResult bdioCodeLocationResult) {\n+        this.bdioCodeLocationResult = bdioCodeLocationResult;\n+    }\n+\n+    private void projectNameVersionChosen(final NameVersion nameVersion) {\n+        this.projectNameVersion = nameVersion;\n+    }\n+\n     public void addStatusSummary(final Status status) {\n         statusSummaries.add(status);\n     }\n", "next_change": {"commit": "37b4e8d686c42481da28e0f37abfd70da461a71b", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex fcc885e9b..b051ae1e5 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -137,19 +134,19 @@ public class FormattedOutputManager {\n         return detectorOutput;\n     }\n \n-    private void detectorsComplete(final DetectorToolResult detectorToolResult) {\n+    private void detectorsComplete(DetectorToolResult detectorToolResult) {\n         this.detectorToolResult = detectorToolResult;\n     }\n \n-    private void codeLocationsCalculated(final BdioCodeLocationResult bdioCodeLocationResult) {\n-        this.bdioCodeLocationResult = bdioCodeLocationResult;\n+    private void codeLocationsCompleted(Collection<String> codeLocations) {\n+        this.codeLocations.addAll(codeLocations);\n     }\n \n-    private void projectNameVersionChosen(final NameVersion nameVersion) {\n+    private void projectNameVersionChosen(NameVersion nameVersion) {\n         this.projectNameVersion = nameVersion;\n     }\n \n-    public void addStatusSummary(final Status status) {\n+    public void addStatusSummary(Status status) {\n         statusSummaries.add(status);\n     }\n \n", "next_change": {"commit": "0de5745eb8c0a1c164e89b3d567049706c322ef3", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex b051ae1e5..f108e74a1 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -134,34 +148,11 @@ public class FormattedOutputManager {\n         return detectorOutput;\n     }\n \n-    private void detectorsComplete(DetectorToolResult detectorToolResult) {\n-        this.detectorToolResult = detectorToolResult;\n-    }\n-\n-    private void codeLocationsCompleted(Collection<String> codeLocations) {\n-        this.codeLocations.addAll(codeLocations);\n-    }\n-\n-    private void projectNameVersionChosen(NameVersion nameVersion) {\n-        this.projectNameVersion = nameVersion;\n-    }\n-\n-    public void addStatusSummary(Status status) {\n-        statusSummaries.add(status);\n-    }\n-\n-    public void addIssue(DetectIssue issue) {\n-        detectIssues.add(issue);\n-    }\n-\n-    public void addDetectResult(DetectResult detectResult) {\n-        detectResults.add(detectResult);\n-    }\n-\n-    public void addUnrecognizedPaths(UnrecognizedPaths unrecognizedPaths) {\n+    private void addUnrecognizedPaths(UnrecognizedPaths unrecognizedPaths) {\n         if (!this.unrecognizedPaths.containsKey(unrecognizedPaths.getGroup())) {\n             this.unrecognizedPaths.put(unrecognizedPaths.getGroup(), new ArrayList<>());\n         }\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n+\n }\n", "next_change": null}]}}, {"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex fcc885e9b..b051ae1e5 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -157,11 +154,11 @@ public class FormattedOutputManager {\n         detectIssues.add(issue);\n     }\n \n-    public void addDetectResult(final DetectResult detectResult) {\n+    public void addDetectResult(DetectResult detectResult) {\n         detectResults.add(detectResult);\n     }\n \n-    public void addUnrecognizedPaths(final UnrecognizedPaths unrecognizedPaths) {\n+    public void addUnrecognizedPaths(UnrecognizedPaths unrecognizedPaths) {\n         if (!this.unrecognizedPaths.containsKey(unrecognizedPaths.getGroup())) {\n             this.unrecognizedPaths.put(unrecognizedPaths.getGroup(), new ArrayList<>());\n         }\n", "next_change": {"commit": "cc85284999a1c28508b0ffbf9dd4c035ce1243aa", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex b051ae1e5..e330a84fc 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -164,4 +166,8 @@ public class FormattedOutputManager {\n         }\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n+\n+    private void propertyValuesCollected(Map<String, String> propertyValues) {\n+        this.propertyValues.putAll(propertyValues);\n+    }\n }\n", "next_change": {"commit": "13f6abd50464ff21b8a52cf876591a1a6937433c", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex e330a84fc..78b82413b 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -167,7 +167,7 @@ public class FormattedOutputManager {\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n-    private void propertyValuesCollected(Map<String, String> propertyValues) {\n-        this.propertyValues.putAll(propertyValues);\n+    private void propertyValuesCollected(PropertyValues propertyValues) {\n+        this.propertyValues = propertyValues;\n     }\n }\n", "next_change": {"commit": "7f36074246b6ff6ea467ea772f1d8d070c2eff99", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex 78b82413b..fff6dc392 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -167,7 +170,7 @@ public class FormattedOutputManager {\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n-    private void propertyValuesCollected(PropertyValues propertyValues) {\n-        this.propertyValues = propertyValues;\n+    private void propertyValuesCollected(PropertyMap propertyMap) {\n+        this.propertyMap = propertyMap;\n     }\n }\n", "next_change": {"commit": "65364bc3ec9787605d9cd484d012ced0886d6cec", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex fff6dc392..3c17a1699 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -170,7 +170,7 @@ public class FormattedOutputManager {\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n-    private void propertyValuesCollected(PropertyMap propertyMap) {\n-        this.propertyMap = propertyMap;\n+    private void propertyValuesCollected(KeyValueMap keyValueMap) {\n+        this.keyValueMap = keyValueMap;\n     }\n }\n", "next_change": {"commit": "7ba2ad1f2946d25617067b8914f6a5fef4385a8b", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex 3c17a1699..773544846 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -171,6 +189,6 @@ public class FormattedOutputManager {\n     }\n \n     private void propertyValuesCollected(KeyValueMap keyValueMap) {\n-        this.keyValueMap = keyValueMap;\n+        this.rawMaskedPropertyValues = keyValueMap;\n     }\n }\n", "next_change": {"commit": "1ebfc2f781475c03715c7da690491181546f6efe", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex 773544846..f132addf2 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -188,7 +168,7 @@ public class FormattedOutputManager {\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n-    private void propertyValuesCollected(KeyValueMap keyValueMap) {\n+    private void rawMaskedPropertyValuesCollected(SortedMap<String, String> keyValueMap) {\n         this.rawMaskedPropertyValues = keyValueMap;\n     }\n }\n", "next_change": {"commit": "b7c676d0789650d0eaf8d6051bd5b611f06985a5", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex f132addf2..ee4b0511c 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -167,8 +164,4 @@ public class FormattedOutputManager {\n         }\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n-\n-    private void rawMaskedPropertyValuesCollected(SortedMap<String, String> keyValueMap) {\n-        this.rawMaskedPropertyValues = keyValueMap;\n-    }\n }\n", "next_change": {"commit": "b18fdf091ffb25e04dcc682bee7e5581f68f2544", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex ee4b0511c..e520cbe6d 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -164,4 +169,8 @@ public class FormattedOutputManager {\n         }\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n+\n+    private void rawMaskedPropertyValuesCollected(SortedMap<String, String> keyValueMap) {\n+        this.rawMaskedPropertyValues = keyValueMap;\n+    }\n }\n", "next_change": {"commit": "e6ce99bf553b79ddc912d4ef3366c1393de11d7b", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex e520cbe6d..7fb864d0c 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -170,6 +162,10 @@ public class FormattedOutputManager {\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n+    public void addOperation(Operation detectOperation) {\n+        this.detectOperations.add(detectOperation);\n+    }\n+\n     private void rawMaskedPropertyValuesCollected(SortedMap<String, String> keyValueMap) {\n         this.rawMaskedPropertyValues = keyValueMap;\n     }\n", "next_change": {"commit": "f87a3615d5d919aefc441b1161984716fe7e840a", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex 7fb864d0c..437a716a4 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -162,10 +180,6 @@ public class FormattedOutputManager {\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n-    public void addOperation(Operation detectOperation) {\n-        this.detectOperations.add(detectOperation);\n-    }\n-\n     private void rawMaskedPropertyValuesCollected(SortedMap<String, String> keyValueMap) {\n         this.rawMaskedPropertyValues = keyValueMap;\n     }\n", "next_change": {"commit": "0de5745eb8c0a1c164e89b3d567049706c322ef3", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex 437a716a4..f108e74a1 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -149,38 +148,11 @@ public class FormattedOutputManager {\n         return detectorOutput;\n     }\n \n-    private void detectorsComplete(DetectorToolResult detectorToolResult) {\n-        this.detectorToolResult = detectorToolResult;\n-    }\n-\n-    private void codeLocationsCompleted(Collection<String> codeLocations) {\n-        this.codeLocations.addAll(codeLocations);\n-    }\n-\n-    private void projectNameVersionChosen(NameVersion nameVersion) {\n-        this.projectNameVersion = nameVersion;\n-    }\n-\n-    public void addStatusSummary(Status status) {\n-        statusSummaries.add(status);\n-    }\n-\n-    public void addIssue(DetectIssue issue) {\n-        detectIssues.add(issue);\n-    }\n-\n-    public void addDetectResult(DetectResult detectResult) {\n-        detectResults.add(detectResult);\n-    }\n-\n-    public void addUnrecognizedPaths(UnrecognizedPaths unrecognizedPaths) {\n+    private void addUnrecognizedPaths(UnrecognizedPaths unrecognizedPaths) {\n         if (!this.unrecognizedPaths.containsKey(unrecognizedPaths.getGroup())) {\n             this.unrecognizedPaths.put(unrecognizedPaths.getGroup(), new ArrayList<>());\n         }\n         this.unrecognizedPaths.get(unrecognizedPaths.getGroup()).addAll(unrecognizedPaths.getPaths());\n     }\n \n-    private void rawMaskedPropertyValuesCollected(SortedMap<String, String> keyValueMap) {\n-        this.rawMaskedPropertyValues = keyValueMap;\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "c1c95687a4c3d578ed9cb626bbf816d5bd6cb657", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/c1c95687a4c3d578ed9cb626bbf816d5bd6cb657", "message": "refactor: Renamed FormattedOutputManager.codeLocationsCalculated to FormattedOutputManager.codeLocationsAdded", "committedDate": "2020-06-09T17:12:39Z", "type": "commit"}, {"oid": "8f431ae1bcb91f141782eda213a2479dd2ef3852", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/8f431ae1bcb91f141782eda213a2479dd2ef3852", "message": "Merge branch 'master' into statusJsonCodeLocations", "committedDate": "2020-06-09T17:24:18Z", "type": "commit"}, {"oid": "7780d24c03b20eaac655bdb33450d4c79ca7dfb5", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7780d24c03b20eaac655bdb33450d4c79ca7dfb5", "message": "fix: Resolving errors from merge conflict resolutions", "committedDate": "2020-06-09T17:28:23Z", "type": "commit"}]}