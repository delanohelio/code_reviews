{"pr_number": 939, "pr_title": "GG-26598 Expose per query memory usage", "pr_author": "korlov42", "pr_createdAt": "2020-02-19T16:05:55Z", "pr_url": "https://github.com/gridgain/gridgain/pull/939", "merge_commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "timeline": [{"oid": "1d97ccf67649703a38c232b227c1f645fadfbb0b", "url": "https://github.com/gridgain/gridgain/commit/1d97ccf67649703a38c232b227c1f645fadfbb0b", "message": "fix docs and style", "committedDate": "2020-02-20T09:26:14Z", "type": "forcePushed"}, {"oid": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "url": "https://github.com/gridgain/gridgain/commit/8afb926f4b39deadf6d769ee3d28b48f0c32191d", "message": "fix NPE when quota not set", "committedDate": "2020-02-20T12:54:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4NjE2MQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r381986161", "body": "Can we encapsulate the tracking-related fields and logic into a dedicated object? Like `IgniteTrace` in gg-27202? I think we need to separate statistics gathering from the actual free memory tracking.", "bodyText": "Can we encapsulate the tracking-related fields and logic into a dedicated object? Like IgniteTrace in gg-27202? I think we need to separate statistics gathering from the actual free memory tracking.", "bodyHTML": "<p dir=\"auto\">Can we encapsulate the tracking-related fields and logic into a dedicated object? Like <code>IgniteTrace</code> in gg-27202? I think we need to separate statistics gathering from the actual free memory tracking.</p>", "author": "rkondakov", "createdAt": "2020-02-20T13:07:00Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -50,6 +51,18 @@\n     /** Memory reserved by query. */\n     private long reserved;\n \n+    /** Maximum number of bytes reserved by query. */", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE0MDI5Mg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r386140292", "bodyText": "yes, it's already incapsulated within TrackableFileIO", "author": "korlov42", "createdAt": "2020-03-01T21:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4NjE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "befcf5000dc94af7e9952b036738a512a1939529", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 21cbf0a024e..a4664c7ad6d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -49,38 +53,55 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryTrack\n     private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private long reserved;\n+    private volatile long reserved;\n \n     /** Maximum number of bytes reserved by query. */\n-    private long maxReserved;\n+    private volatile long maxReserved;\n \n-    /** Total number of bytes written on disk tracked by current tracker. */\n-    private long totalWrittenOnDisk;\n+    /** Number of bytes written on disk at the current moment. */\n+    private volatile long writtenOnDisk;\n \n     /** Maximum number of bytes written on disk at the same time. */\n-    private long maxWrittenOnDisk;\n+    private volatile long maxWrittenOnDisk;\n \n-    /** Number of bytes written on disk at the current moment. */\n-    private long writtenOnDisk;\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n \n     /** Close flag to prevent tracker reuse. */\n     private Boolean closed = Boolean.FALSE;\n \n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n+\n+    /** Query descriptor (for logging). */\n+    private final String qryDesc;\n+\n     /**\n      * Constructor.\n      *\n+     * @param log Logger.\n      * @param parent Parent memory tracker.\n      * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n      * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n+     * @param qryDesc Descriptor of the racked query.\n      */\n-    public QueryMemoryTracker(H2MemoryTracker parent, long quota, long blockSize, boolean offloadingEnabled) {\n+    public QueryMemoryTracker(\n+        IgniteLogger log,\n+        H2MemoryTracker parent,\n+        long quota,\n+        long blockSize,\n+        boolean offloadingEnabled,\n+        String qryDesc\n+    ) {\n         assert quota >= 0;\n \n+        this.log = log;\n         this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n         this.quota = quota;\n         this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n+        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "071af2afe1ee9ab728f45ee0a09afab7150e6783", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex a4664c7ad6d..710e6d41e48 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -84,24 +81,20 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryTrack\n      * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n      * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n-     * @param qryDesc Descriptor of the racked query.\n      */\n     public QueryMemoryTracker(\n-        IgniteLogger log,\n         H2MemoryTracker parent,\n         long quota,\n         long blockSize,\n-        boolean offloadingEnabled,\n-        String qryDesc\n+        boolean offloadingEnabled\n     ) {\n         assert quota >= 0;\n \n-        this.log = log;\n+        this.log = null;\n         this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n         this.quota = quota;\n         this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n-        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "8dae651f667727d4c1497f24def5ebe7fd56844d", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 710e6d41e48..a29fcea4f9c 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -90,7 +90,6 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryTrack\n     ) {\n         assert quota >= 0;\n \n-        this.log = null;\n         this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n         this.quota = quota;\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 21cbf0a024e..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -49,22 +64,31 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryTrack\n     private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private long reserved;\n+    private volatile long reserved;\n \n     /** Maximum number of bytes reserved by query. */\n-    private long maxReserved;\n+    private volatile long maxReserved;\n \n-    /** Total number of bytes written on disk tracked by current tracker. */\n-    private long totalWrittenOnDisk;\n+    /** Number of bytes written on disk at the current moment. */\n+    private volatile long writtenOnDisk;\n \n     /** Maximum number of bytes written on disk at the same time. */\n-    private long maxWrittenOnDisk;\n+    private volatile long maxWrittenOnDisk;\n \n-    /** Number of bytes written on disk at the current moment. */\n-    private long writtenOnDisk;\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n \n     /** Close flag to prevent tracker reuse. */\n-    private Boolean closed = Boolean.FALSE;\n+    private volatile boolean closed;\n+\n+    /** State of the tracker. Can be equal {@link #STATE_INITIAL} or {@link #STATE_CLOSED}*/\n+    private volatile int state;\n+\n+    /** Children. */\n+    private final List<H2MemoryTracker> children = new ArrayList<>();\n+\n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n \n     /**\n      * Constructor.\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -30,247 +27,124 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetricProvider {\n-    /** State updater. */\n-    private static final AtomicIntegerFieldUpdater<QueryMemoryTracker> STATE_UPDATER\n-        = AtomicIntegerFieldUpdater.newUpdater(QueryMemoryTracker.class, \"state\");\n+public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n+    /** Resered field updater. */\n+    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n+        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n \n-    /** Tracker is not closed and not in the middle of the closing process. */\n-    private static final int STATE_INITIAL = 0;\n-\n-    /** Tracker is closed or in the middle of the closing process. */\n-    private static final int STATE_CLOSED = 1;\n+    /** Closed flag updater. */\n+    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n+        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n \n     /** Parent tracker. */\n-    @GridToStringExclude\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long quota;\n-\n-    /**\n-     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n-     * <ul>\n-     * <li>{@code false} - exception will be thrown.</li>\n-     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n-     * </ul>\n-     */\n-    private final boolean offloadingEnabled;\n+    private final long maxMem;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private long reservedFromParent;\n+    private volatile long reservedFromParent;\n \n     /** Memory reserved by query. */\n     private volatile long reserved;\n \n-    /** Maximum number of bytes reserved by query. */\n-    private volatile long maxReserved;\n-\n-    /** Number of bytes written on disk at the current moment. */\n-    private volatile long writtenOnDisk;\n-\n-    /** Maximum number of bytes written on disk at the same time. */\n-    private volatile long maxWrittenOnDisk;\n-\n-    /** Total number of bytes written on disk tracked by current tracker. */\n-    private volatile long totalWrittenOnDisk;\n-\n     /** Close flag to prevent tracker reuse. */\n-    private volatile boolean closed;\n-\n-    /** State of the tracker. Can be equal {@link #STATE_INITIAL} or {@link #STATE_CLOSED}*/\n-    private volatile int state;\n-\n-    /** Children. */\n-    private final List<H2MemoryTracker> children = new ArrayList<>();\n-\n-    /** The number of files created by the query. */\n-    private volatile int filesCreated;\n+    private volatile Boolean closed = Boolean.FALSE;\n \n     /**\n      * Constructor.\n      *\n      * @param parent Parent memory tracker.\n-     * @param quota Query memory limit in bytes.\n+     * @param maxMem Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n-     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n-     */\n-    public QueryMemoryTracker(\n-        H2MemoryTracker parent,\n-        long quota,\n-        long blockSize,\n-        boolean offloadingEnabled\n-    ) {\n-        assert quota >= 0;\n-\n-        this.offloadingEnabled = offloadingEnabled;\n-        this.parent = parent;\n-        this.quota = quota;\n-        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized boolean reserve(long size) {\n-        assert size >= 0;\n-\n-        checkClosed();\n-\n-        reserved += size;\n-        maxReserved = Math.max(maxReserved, reserved);\n-\n-        if (parent != null && reserved > reservedFromParent) {\n-            if (!reserveFromParent())\n-                return false; // Offloading.\n-        }\n-\n-        if (quota > 0 && reserved >= quota)\n-            return onQuotaExceeded();\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Checks whether tracker was closed.\n-     */\n-    private void checkClosed() {\n-        if (closed)\n-            throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-    }\n-\n-    /**\n-     * Reserves memory from parent tracker.\n-     * @return {@code false} if offloading is needed.\n      */\n-    private boolean reserveFromParent() {\n-        // If single block size is too small.\n-        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n-\n-        // If we are too close to limit.\n-        if (quota > 0)\n-            blockSize = Math.min(blockSize, quota - reservedFromParent);\n-\n-        if (parent.reserve(blockSize))\n-            reservedFromParent += blockSize;\n-        else\n-            return false;\n+    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n+        assert maxMem > 0;\n \n-        return true;\n-    }\n-\n-    /**\n-     * Action on quota exceeded.\n-     * @return {@code false} if offloading is needed.\n-     */\n-    private boolean onQuotaExceeded() {\n-        if (offloadingEnabled)\n-            return false;\n-        else\n-            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+        this.parent = parent;\n+        this.maxMem = maxMem;\n+        this.blockSize = blockSize;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void release(long size) {\n-        assert size >= 0;\n+    @Override public void reserve(long size) {\n+        assert !closed && size >= 0;\n \n         if (size == 0)\n             return;\n \n-        checkClosed();\n-\n-        reserved -= size;\n-\n-        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + size) +\n-            \", toFree=\" + size + ']';\n-\n-        if (parent != null && reservedFromParent - reserved > blockSize)\n-            releaseFromParent();\n-    }\n-\n-    /**\n-     * Releases memory from parent.\n-     */\n-    private void releaseFromParent() {\n-        long toReleaseFromParent = reservedFromParent - reserved;\n-\n-        parent.release(toReleaseFromParent);\n+        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n+            if (prev + x > maxMem) {\n+                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            }\n \n-        reservedFromParent -= toReleaseFromParent;\n+            return prev + x;\n+        });\n \n-        assert reservedFromParent >= 0 : reservedFromParent;\n-    }\n+        if (parent != null && reserved0 > reservedFromParent) {\n+            synchronized (this) {\n+                assert !closed;\n \n-    /** {@inheritDoc} */\n-    @Override public long reserved() {\n-        return reserved;\n-    }\n+                if (reserved0 <= reservedFromParent)\n+                    return;\n \n-    /** {@inheritDoc} */\n-    @Override public long maxReserved() {\n-        return maxReserved;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public long writtenOnDisk() {\n-        return writtenOnDisk;\n-    }\n+                // If single block size is too small.\n+                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n+                // If we are too close to limit.\n+                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n \n-    /** {@inheritDoc} */\n-    @Override public long maxWrittenOnDisk() {\n-        return maxWrittenOnDisk;\n-    }\n+                try {\n+                    parent.reserve(blockSize);\n \n-    /** {@inheritDoc} */\n-    @Override public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n-    }\n+                    reservedFromParent += blockSize;\n+                }\n+                catch (Throwable e) {\n+                    // Fallback if failed to reserve.\n+                    RESERVED_UPD.addAndGet(this, -size);\n \n-    /**\n-     * @return Offloading enabled flag.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n+                    throw e;\n+                }\n+            }\n+        }\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void spill(long size) {\n+    @Override public void release(long size) {\n         assert size >= 0;\n \n         if (size == 0)\n             return;\n \n-        checkClosed();\n+        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n+                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n \n-        if (parent != null)\n-            parent.spill(size);\n+            return prev + x;\n+        });\n \n-        writtenOnDisk += size;\n-        totalWrittenOnDisk += size;\n-        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n-    }\n+        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void unspill(long size) {\n-        assert size >= 0;\n+        // For now, won'tQ release memory to parent until tracker closed.\n+       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n+            synchronized (this) {\n+                if (preAllocated - reserved >= 2 * blockSize) {\n+                    parent.release(blockSize);\n \n-        if (size == 0)\n-            return;\n-\n-        checkClosed();\n-\n-        if (parent != null)\n-            parent.unspill(size);\n-\n-        writtenOnDisk -= size;\n+                    preAllocated -= blockSize;\n+                }\n+            }\n+        }*/\n     }\n \n     /**\n-     * @return {@code true} if closed, {@code false} otherwise.\n+     * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    @Override public boolean closed() {\n+    public boolean closed() {\n         return closed;\n     }\n \n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..ea3193007a5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -152,8 +152,13 @@ public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        synchronized (this) {\n+            if (closed)\n+                return;\n+\n+            closed = true;\n+\n+            release0(reserved);\n \n             if (parent != null)\n                 parent.release(reservedFromParent);\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ea3193007a5..557040604bd 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -158,10 +168,10 @@ public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable\n \n             closed = true;\n \n-            release0(reserved);\n+            reserved = 0;\n \n             if (parent != null)\n-                parent.release(reservedFromParent);\n+                parent.released(reservedFromParent);\n         }\n     }\n \n", "next_change": {"commit": "ed30d3c44e4c1d6461f1973432e15ae383179398", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 557040604bd..6c365d5b9ad 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -159,20 +178,18 @@ public class QueryMemoryTracker extends H2MemoryTracker {\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        synchronized (this) {\n-            if (closed)\n-                return;\n+        if (closed)\n+            return;\n \n-            closed = true;\n+        closed = true;\n \n-            reserved = 0;\n+        reserved = 0;\n \n-            if (parent != null)\n-                parent.released(reservedFromParent);\n-        }\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 6c365d5b9ad..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -190,6 +223,50 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n \n         if (parent != null)\n             parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n+        }\n+    }\n+\n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5MTkyMQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r381991921", "body": "Should we track memory usage for statistics purposes even when the actual memory tracking (OOM prevention) is turned off?", "bodyText": "Should we track memory usage for statistics purposes even when the actual memory tracking (OOM prevention) is turned off?", "bodyHTML": "<p dir=\"auto\">Should we track memory usage for statistics purposes even when the actual memory tracking (OOM prevention) is turned off?</p>", "author": "rkondakov", "createdAt": "2020-02-20T13:18:53Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java", "diffHunk": "@@ -125,7 +148,8 @@ public Long register(String qry, GridCacheQueryType qryType, String schemaName,\n             schemaName,\n             System.currentTimeMillis(),\n             cancel,\n-            loc\n+            loc,\n+            memTracker == null ? DUMMY_TRACKER : memTracker", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzODE0Mg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r386138142", "bodyText": "yes, we should. And we actually track it. But there are two kind of queries that has not yet tracked by current tracker: text queries and streaming queries. So for now dummy tracker will be used in system views.", "author": "korlov42", "createdAt": "2020-03-01T20:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5MTkyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "40d79418306f334e74a4901a2890e4dc887a0620", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 90fc7c0fa6c..a048246715f 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -142,7 +154,7 @@ public class RunningQueryManager {\n \n         GridRunningQueryInfo run = new GridRunningQueryInfo(\n             qryId,\n-            localNodeId,\n+            locNodeId,\n             qry,\n             qryType,\n             schemaName,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 90fc7c0fa6c..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -137,12 +146,12 @@ public class RunningQueryManager {\n      * @return Id of registered query.\n      */\n     public Long register(String qry, GridCacheQueryType qryType, String schemaName, boolean loc,\n-        @Nullable GridQueryMemoryTracker memTracker, @Nullable GridQueryCancel cancel) {\n+        @Nullable GridQueryMemoryMetricProvider memTracker, @Nullable GridQueryCancel cancel) {\n         Long qryId = qryIdGen.incrementAndGet();\n \n         GridRunningQueryInfo run = new GridRunningQueryInfo(\n             qryId,\n-            localNodeId,\n+            locNodeId,\n             qry,\n             qryType,\n             schemaName,\n", "next_change": {"commit": "67910a86c5418715d0399a1cb039d265da5a1aaa", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 257e8282af4..a40205d65e3 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -146,30 +114,24 @@ public class RunningQueryManager {\n      * @return Id of registered query.\n      */\n     public Long register(String qry, GridCacheQueryType qryType, String schemaName, boolean loc,\n-        @Nullable GridQueryMemoryMetricProvider memTracker, @Nullable GridQueryCancel cancel) {\n+        @Nullable GridQueryCancel cancel) {\n         Long qryId = qryIdGen.incrementAndGet();\n \n         GridRunningQueryInfo run = new GridRunningQueryInfo(\n             qryId,\n-            locNodeId,\n+            localNodeId,\n             qry,\n             qryType,\n             schemaName,\n             System.currentTimeMillis(),\n             cancel,\n-            loc,\n-            memTracker == null ? DUMMY_TRACKER : memTracker\n+            loc\n         );\n \n         GridRunningQueryInfo preRun = runs.putIfAbsent(qryId, run);\n \n         assert preRun == null : \"Running query already registered [prev_qry=\" + preRun + \", newQry=\" + run + ']';\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"User's query started [id=\" + qryId + \", type=\" + qryType + \", local=\" + loc +\n-                \", qry=\" + qry + ']');\n-        }\n-\n         return qryId;\n     }\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex a40205d65e3..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -114,24 +146,30 @@ public class RunningQueryManager {\n      * @return Id of registered query.\n      */\n     public Long register(String qry, GridCacheQueryType qryType, String schemaName, boolean loc,\n-        @Nullable GridQueryCancel cancel) {\n+        @Nullable GridQueryMemoryMetricProvider memTracker, @Nullable GridQueryCancel cancel) {\n         Long qryId = qryIdGen.incrementAndGet();\n \n         GridRunningQueryInfo run = new GridRunningQueryInfo(\n             qryId,\n-            localNodeId,\n+            locNodeId,\n             qry,\n             qryType,\n             schemaName,\n             System.currentTimeMillis(),\n             cancel,\n-            loc\n+            loc,\n+            memTracker == null ? DUMMY_TRACKER : memTracker\n         );\n \n         GridRunningQueryInfo preRun = runs.putIfAbsent(qryId, run);\n \n         assert preRun == null : \"Running query already registered [prev_qry=\" + preRun + \", newQry=\" + run + ']';\n \n+        if (log.isDebugEnabled()) {\n+            log.debug(\"User's query started [id=\" + qryId + \", type=\" + qryType + \", local=\" + loc +\n+                \", qry=\" + qry + ']');\n+        }\n+\n         return qryId;\n     }\n \n", "next_change": {"commit": "d9bd32fbdd40bdb7b47bbec692e714bd5bc55414", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 257e8282af4..b1be563a294 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -170,6 +193,37 @@ public class RunningQueryManager {\n                 \", qry=\" + qry + ']');\n         }\n \n+        if (!qryStartedListeners.isEmpty()) {\n+            GridQueryStartedInfo info = new GridQueryStartedInfo(\n+                run.id(),\n+                locNodeId,\n+                run.query(),\n+                run.queryType(),\n+                run.schemaName(),\n+                run.startTime(),\n+                run.local(),\n+                run.queryInitiatorId()\n+            );\n+\n+            try {\n+                closure.runLocal(\n+                    () -> qryStartedListeners.forEach(lsnr -> {\n+                        try {\n+                            lsnr.accept(info);\n+                        }\n+                        catch (Exception ex) {\n+                            log.error(\"Listener fails during handling query started\" +\n+                                \" event [qryId=\" + qryId + \"]\", ex);\n+                        }\n+                    }),\n+                    GridIoPolicy.PUBLIC_POOL\n+                );\n+            }\n+            catch (IgniteCheckedException ex) {\n+                throw new IgniteException(ex.getMessage(), ex);\n+            }\n+        }\n+\n         return qryId;\n     }\n \n", "next_change": {"commit": "f77cc1efda1485e6ad2ee2fb097d89e7f45de995", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex b1be563a294..a4e5b6655fe 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -224,6 +260,8 @@ public class RunningQueryManager {\n             }\n         }\n \n+        run.span().addTag(SQL_QRY_ID, run::globalQueryId);\n+\n         return qryId;\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "67910a86c5418715d0399a1cb039d265da5a1aaa", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20983: SQL: metrics of executions of user queries"}, {"oid": "04362e5d82d3a69abc7c13ffe6562a2382935b94", "committedDate": "2019-08-13 20:34:37 +0300", "message": "GG-22426 [IGNITE-11961] JMX metrics for PME timings (#6701)"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a35edeec5778d6053e2f63fe220e6683b259b0a7", "committedDate": "2020-04-06 12:48:32 +0300", "message": "GG-26421 track query initiator"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "d9bd32fbdd40bdb7b47bbec692e714bd5bc55414", "committedDate": "2020-04-27 17:48:28 +0300", "message": "GG-26430 Provide ability to register listeners for query start/finish events"}, {"oid": "79c235d9530a174e1a6259125e8b7668de5362e3", "committedDate": "2020-06-07 19:52:05 +0300", "message": "GG-29134 [IGNITE-12939] Add WhitespacesAround support for the checkstyle (#7726)"}, {"oid": "f6a78e48d972087ac5375206505bad89b1989730", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29057 [IGNITE-12224] SQL query & SQL query history system views. (#7059)"}, {"oid": "21517d8eab815dd81a611a75329742a0187ca732", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29115 [IGNITE-12441] Refactor SystemViewRowAttributeWalker registration for system views (#7136)"}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "9ff25c8a5bde71f38e984b67781fe072697983d6", "committedDate": "2021-01-04 01:09:07 +0300", "message": "GG-32024 Add query attributes to QueryHistoryTracker#qryHist and QueryHistory (enforceJoinOrder, distributedJoins, local, lazy)"}, {"oid": "f77cc1efda1485e6ad2ee2fb097d89e7f45de995", "committedDate": "2021-03-05 15:51:07 +0300", "message": "GG-32450 [IGNITE-14008] SQL tracing: add tag sql.query.id"}, {"oid": "e5ef51022e00b387287d3c0c0a55b0da6e4bd361", "committedDate": "2022-08-25 10:01:08 +0700", "message": "GG-35591 Extend GridQueryStartedInfo, GridQueryFinishedInfo. (#2514)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5Mzk3Mg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r381993972", "body": "Typo: \r\n\r\n> ofloaded", "bodyText": "Typo:\n\nofloaded", "bodyHTML": "<p dir=\"auto\">Typo:</p>\n<blockquote>\n<p dir=\"auto\">ofloaded</p>\n</blockquote>", "author": "rkondakov", "createdAt": "2020-02-20T13:22:57Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.oom;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.GridQueryMemoryTracker;\n+import org.apache.ignite.internal.processors.query.h2.QueryMemoryManager;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases to ensure that ofloaded data properly tracked by memory tracker.", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d97f90f2eae8de2ae547543cd97b827cc70ff6d", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\nindex faec7ee6820..96ca2be6c86 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\n", "chunk": "@@ -18,7 +18,7 @@ package org.apache.ignite.internal.processors.query.oom;\n import java.util.ArrayList;\n import java.util.List;\n import org.apache.ignite.internal.IgniteEx;\n-import org.apache.ignite.internal.processors.query.GridQueryMemoryTracker;\n+import org.apache.ignite.internal.processors.query.GridQueryMemoryMetricProvider;\n import org.apache.ignite.internal.processors.query.h2.QueryMemoryManager;\n import org.apache.ignite.testframework.GridTestUtils;\n import org.junit.Test;\n", "next_change": {"commit": "317c5592198e02352234a8f71c1bbb2681b0040b", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\nindex 96ca2be6c86..ef88fd78ba8 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\n", "chunk": "@@ -24,7 +24,7 @@ import org.apache.ignite.testframework.GridTestUtils;\n import org.junit.Test;\n \n /**\n- * Test cases to ensure that ofloaded data properly tracked by memory tracker.\n+ * Test cases to ensure that offloaded data properly tracked by memory tracker.\n  */\n public class DiskSpillingMemoryTrackerTest extends DiskSpillingAbstractTest {\n     /** */\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\nindex faec7ee6820..ef88fd78ba8 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/DiskSpillingMemoryTrackerTest.java\n", "chunk": "@@ -18,13 +18,13 @@ package org.apache.ignite.internal.processors.query.oom;\n import java.util.ArrayList;\n import java.util.List;\n import org.apache.ignite.internal.IgniteEx;\n-import org.apache.ignite.internal.processors.query.GridQueryMemoryTracker;\n+import org.apache.ignite.internal.processors.query.GridQueryMemoryMetricProvider;\n import org.apache.ignite.internal.processors.query.h2.QueryMemoryManager;\n import org.apache.ignite.testframework.GridTestUtils;\n import org.junit.Test;\n \n /**\n- * Test cases to ensure that ofloaded data properly tracked by memory tracker.\n+ * Test cases to ensure that offloaded data properly tracked by memory tracker.\n  */\n public class DiskSpillingMemoryTrackerTest extends DiskSpillingAbstractTest {\n     /** */\n", "next_change": null}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTA3MQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r382005071", "body": "Redundant initialization", "bodyText": "Redundant initialization", "bodyHTML": "<p dir=\"auto\">Redundant initialization</p>", "author": "rkondakov", "createdAt": "2020-02-20T13:43:05Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java", "diffHunk": "@@ -25,23 +25,25 @@\n /**\n  * Basic class for external result.\n  */\n-@SuppressWarnings({\"MissortedModifiers\", \"WeakerAccess\", \"ForLoopReplaceableByForEach\"})\n+@SuppressWarnings({\"WeakerAccess\", \"ForLoopReplaceableByForEach\"})\n public abstract class AbstractExternalResult<T> implements AutoCloseable {\n-\n     /** Logger. */\n     protected final IgniteLogger log;\n \n     /** Current size in rows. */\n     protected int size;\n \n+    /** */\n+    protected long swapped = 0;", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40d79418306f334e74a4901a2890e4dc887a0620", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\nindex ebb9d24d8d4..18d16e2abc3 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n", "chunk": "@@ -33,9 +33,6 @@ public abstract class AbstractExternalResult<T> implements AutoCloseable {\n     /** Current size in rows. */\n     protected int size;\n \n-    /** */\n-    protected long swapped = 0;\n-\n     /** Memory tracker. */\n     protected final H2MemoryTracker memTracker;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\nindex ebb9d24d8d4..bec56a1577a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n", "chunk": "@@ -33,9 +33,6 @@ public abstract class AbstractExternalResult<T> implements AutoCloseable {\n     /** Current size in rows. */\n     protected int size;\n \n-    /** */\n-    protected long swapped = 0;\n-\n     /** Memory tracker. */\n     protected final H2MemoryTracker memTracker;\n \n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\nindex bec56a1577a..4e66b9ef0e0 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n", "chunk": "@@ -36,9 +38,6 @@ public abstract class AbstractExternalResult<T> implements AutoCloseable {\n     /** Memory tracker. */\n     protected final H2MemoryTracker memTracker;\n \n-    /** Memory manager. */\n-    protected final QueryMemoryManager memMgr;\n-\n     /** Parent result. */\n     protected final AbstractExternalResult parent;\n \n", "next_change": {"commit": "3c6a5cb36df055ae623a37e59044c99b862b1938", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\nindex 4e66b9ef0e0..56c61cc5d5b 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/AbstractExternalResult.java\n", "chunk": "@@ -38,6 +37,9 @@ public abstract class AbstractExternalResult<T> implements AutoCloseable {\n     /** Memory tracker. */\n     protected final H2MemoryTracker memTracker;\n \n+    /** Memory manager. */\n+    protected final QueryMemoryManager memMgr;\n+\n     /** Parent result. */\n     protected final AbstractExternalResult parent;\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxNjE0MA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r382016140", "body": "In my opinion it is not the best way to track data amount that spilled to disk. I can see two drawbacks here:\r\n- Code in external results became more complicated because of the tracking part\r\n- It is easy very easy to make a mistake and forget to count some disk offloads with this approach. Like it happened for `ExternalResultHashIndex`\r\n\r\nI think that using specialized `FileIoFactory` for tracking spilled files is more solid solution here. See example `TrackableFileIoFactory` in gg-27202 branch.", "bodyText": "In my opinion it is not the best way to track data amount that spilled to disk. I can see two drawbacks here:\n\nCode in external results became more complicated because of the tracking part\nIt is easy very easy to make a mistake and forget to count some disk offloads with this approach. Like it happened for ExternalResultHashIndex\n\nI think that using specialized FileIoFactory for tracking spilled files is more solid solution here. See example TrackableFileIoFactory in gg-27202 branch.", "bodyHTML": "<p dir=\"auto\">In my opinion it is not the best way to track data amount that spilled to disk. I can see two drawbacks here:</p>\n<ul dir=\"auto\">\n<li>Code in external results became more complicated because of the tracking part</li>\n<li>It is easy very easy to make a mistake and forget to count some disk offloads with this approach. Like it happened for <code>ExternalResultHashIndex</code></li>\n</ul>\n<p dir=\"auto\">I think that using specialized <code>FileIoFactory</code> for tracking spilled files is more solid solution here. See example <code>TrackableFileIoFactory</code> in gg-27202 branch.</p>", "author": "rkondakov", "createdAt": "2020-02-20T14:01:59Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java", "diffHunk": "@@ -115,16 +115,19 @@ private void spillRows() {\n         if (F.isEmpty(rowBuff))\n             return;\n \n-        data.store(rowBuff);\n+        long swapped = data.store(rowBuff);\n+\n+        memTracker.swap(swapped);\n+        this.swapped += swapped;", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40d79418306f334e74a4901a2890e4dc887a0620", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\nindex d3e86d9c624..a41521a5e50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n", "chunk": "@@ -115,19 +115,16 @@ public class PlainExternalResult extends AbstractExternalResult<Value> implement\n         if (F.isEmpty(rowBuff))\n             return;\n \n-        long swapped = data.store(rowBuff);\n-\n-        memTracker.swap(swapped);\n-        this.swapped += swapped;\n+        data.store(rowBuff);\n \n         long delta = 0;\n \n         for (Map.Entry<ValueRow, Value[]> row : rowBuff)\n-            delta += H2Utils.calculateMemoryDelta(null, null, row.getValue());\n+            delta += H2Utils.calculateMemoryDelta(null, row.getValue(), null);\n \n-        rowBuff.clear();\n+        memTracker.release(-delta);\n \n-        memTracker.release(delta);\n+        rowBuff.clear();\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\nindex d3e86d9c624..0fed03076ad 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n", "chunk": "@@ -115,19 +112,16 @@ public class PlainExternalResult extends AbstractExternalResult<Value> implement\n         if (F.isEmpty(rowBuff))\n             return;\n \n-        long swapped = data.store(rowBuff);\n-\n-        memTracker.swap(swapped);\n-        this.swapped += swapped;\n+        data.store(rowBuff);\n \n         long delta = 0;\n \n         for (Map.Entry<ValueRow, Value[]> row : rowBuff)\n-            delta += H2Utils.calculateMemoryDelta(null, null, row.getValue());\n+            delta += H2Utils.calculateMemoryDelta(null, row.getValue(), null);\n \n-        rowBuff.clear();\n+        memTracker.release(-delta);\n \n-        memTracker.release(delta);\n+        rowBuff.clear();\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\nindex 0fed03076ad..ef516c67bdd 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n", "chunk": "@@ -119,7 +125,7 @@ public class PlainExternalResult extends AbstractExternalResult<Value> implement\n         for (Map.Entry<ValueRow, Value[]> row : rowBuff)\n             delta += H2Utils.calculateMemoryDelta(null, row.getValue(), null);\n \n-        memTracker.release(-delta);\n+        memTracker.released(-delta);\n \n         rowBuff.clear();\n     }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\nindex ef516c67bdd..0fed03076ad 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/PlainExternalResult.java\n", "chunk": "@@ -125,7 +119,7 @@ public class PlainExternalResult extends AbstractExternalResult<Value> implement\n         for (Map.Entry<ValueRow, Value[]> row : rowBuff)\n             delta += H2Utils.calculateMemoryDelta(null, row.getValue(), null);\n \n-        memTracker.released(-delta);\n+        memTracker.release(-delta);\n \n         rowBuff.clear();\n     }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxNzAzMQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r382017031", "body": "Seems like this field is not used here", "bodyText": "Seems like this field is not used here", "bodyHTML": "<p dir=\"auto\">Seems like this field is not used here</p>", "author": "rkondakov", "createdAt": "2020-02-20T14:03:24Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java", "diffHunk": "@@ -126,7 +127,10 @@\n     private IgniteLogger log;\n \n     /** */\n-    private final AtomicLong qryIdGen = new AtomicLong();\n+    private final RunningQueryManager runningQryMgr;", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40d79418306f334e74a4901a2890e4dc887a0620", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\nindex 7f2907765da..a4bf2606f04 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n", "chunk": "@@ -126,9 +125,6 @@ public class GridReduceQueryExecutor {\n     /** */\n     private IgniteLogger log;\n \n-    /** */\n-    private final RunningQueryManager runningQryMgr;\n-\n     /** Generator of ids for query requests. */\n     private final AtomicLong qryReqIdGen = new AtomicLong();\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\nindex 7f2907765da..b4c5eb5c948 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n", "chunk": "@@ -126,9 +125,6 @@ public class GridReduceQueryExecutor {\n     /** */\n     private IgniteLogger log;\n \n-    /** */\n-    private final RunningQueryManager runningQryMgr;\n-\n     /** Generator of ids for query requests. */\n     private final AtomicLong qryReqIdGen = new AtomicLong();\n \n", "next_change": {"commit": "2049cae7f678a9a0f29b1ffda74cd7e9351b1f9f", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\nindex b4c5eb5c948..84d9d9bc3ae 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n", "chunk": "@@ -125,8 +127,8 @@ public class GridReduceQueryExecutor {\n     /** */\n     private IgniteLogger log;\n \n-    /** Generator of ids for query requests. */\n-    private final AtomicLong qryReqIdGen = new AtomicLong();\n+    /** */\n+    private final AtomicLong qryIdGen = new AtomicLong();\n \n     /** */\n     private final ConcurrentMap<Long, ReduceQueryRun> runs = new ConcurrentHashMap<>();\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\nindex 84d9d9bc3ae..b4c5eb5c948 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridReduceQueryExecutor.java\n", "chunk": "@@ -127,8 +125,8 @@ public class GridReduceQueryExecutor {\n     /** */\n     private IgniteLogger log;\n \n-    /** */\n-    private final AtomicLong qryIdGen = new AtomicLong();\n+    /** Generator of ids for query requests. */\n+    private final AtomicLong qryReqIdGen = new AtomicLong();\n \n     /** */\n     private final ConcurrentMap<Long, ReduceQueryRun> runs = new ConcurrentHashMap<>();\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "2049cae7f678a9a0f29b1ffda74cd7e9351b1f9f", "committedDate": "2019-06-17 15:53:36 +0300", "message": "GG-18873: Kill query tests (#61) (#152)"}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "67910a86c5418715d0399a1cb039d265da5a1aaa", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20983: SQL: metrics of executions of user queries"}, {"oid": "f3d5e5b81fa448e1602a1929367726281a6091c6", "committedDate": "2019-10-25 15:28:05 +0300", "message": "GG-24808 SQL: print warning log message when query's result is big"}, {"oid": "71b775cdf86a15ed0b8da7e65bed60f175e19a55", "committedDate": "2019-10-30 16:09:15 +0300", "message": "GG-19120 ConnectionManager refactoring"}, {"oid": "320e1e775c4532770828541fb9c194bb4af56bf2", "committedDate": "2019-12-09 12:19:40 +0300", "message": "GG-25908: Client node stopped with AssertionError in GridReduceQueryExecutor."}, {"oid": "362558c658b512e561eb9208cd1178c90d0431f7", "committedDate": "2019-12-25 12:38:44 +0300", "message": "GG-21236 fix H2ResultSetIterator and QueryCursors for local queries in lazy mode"}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "73cd10ce7ec527f44ff940d109a63e5ffcaf7808", "committedDate": "2020-01-30 16:16:00 +0300", "message": "GG-26176: SQL: GridReduceQueryExecutor refactoring."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "b92b1f3f1bf974e8df14f78eccab681aafe10229", "committedDate": "2020-03-03 14:29:14 +0300", "message": "GG-27582: always use query flags to create H2CachedStatementKey"}, {"oid": "aa446c0e1b157c95a3db268c2b5662270fb57976", "committedDate": "2020-03-06 18:47:20 +0300", "message": "GG-27538 Fix for KILL QUERY command hanging."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "9502a24df45ba7a97e2efa7d21476926e8250c66", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29130 [IGNITE-12953] Add support for SingleSpaceSeparator to the checkstyle (#7734)"}, {"oid": "dd30be50d5c60b36b490221a9007fd3891083f39", "committedDate": "2020-08-19 10:43:43 +0300", "message": "GG-25278 add default query timeout for SQL queries"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "f424682d81184f8a558791048b7139e4f9e3338a", "committedDate": "2020-12-03 00:29:51 +0300", "message": "GG-28316: Partial LEFT JOIN support from REPLICATED to PARTITIONED (#1482)"}, {"oid": "05fb0a8dd03ba8b85b973df2d2b0ca6d6f191745", "committedDate": "2020-12-24 17:33:06 +0300", "message": "GG-31382 don't use rows buffers for simple one-way reducer, use mem tracker for reducer's rows buffers"}, {"oid": "4eec982f41c441c92ced615836280bf6a7cc7118", "committedDate": "2021-06-17 18:42:24 +0300", "message": "GG-33275 fix multiple results bug when query parallelism is enabled (#1966)"}, {"oid": "669e2f99c8b80365443a1f2352f4cbafb5df5392", "committedDate": "2021-12-10 16:37:36 +0300", "message": "GG-34370: Logging globalQueryId for long running queries. (#2220)"}, {"oid": "77e64187ad2d602843e37893b2383366c8e6e9cd", "committedDate": "2021-12-21 18:30:48 +0300", "message": "GG-34372: Possible extra warning - Query run was already removed (#2253)"}, {"oid": "c7ab25eb8f57efb036378951f0874337f52956fe", "committedDate": "2021-12-22 13:36:09 +0300", "message": "GG-34372 Fix styles."}, {"oid": "d3a69cfa27a905a4af48bf5ee3cc3b46e7207f49", "committedDate": "2022-02-08 17:17:41 +0300", "message": "GG-34696 Wrong calculation of replies count for queries with partition pruning and enabled parallelism"}, {"oid": "3ace5557cdf95794a2a51472686287c80b0994cd", "committedDate": "2022-11-09 17:13:15 +0300", "message": "GG-35878 Changing default QueryParallelism leads to crush ordered queries"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxNzY3NQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r382017675", "body": "Redundant initialization", "bodyText": "Redundant initialization", "bodyHTML": "<p dir=\"auto\">Redundant initialization</p>", "author": "rkondakov", "createdAt": "2020-02-20T14:04:20Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java", "diffHunk": "@@ -57,6 +57,9 @@\n     /** */\n     private int size;\n \n+    /** */\n+    private long swapped = 0;", "originalCommit": "8afb926f4b39deadf6d769ee3d28b48f0c32191d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "befcf5000dc94af7e9952b036738a512a1939529", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\nindex e1e99bd78e6..6eed5dfadde 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\n", "chunk": "@@ -58,7 +58,7 @@ public class H2ManagedGroupByData extends GroupByData {\n     private int size;\n \n     /** */\n-    private long swapped = 0;\n+    private long swapped;\n \n     /**\n      * @param ses Session.\n", "next_change": {"commit": "40d79418306f334e74a4901a2890e4dc887a0620", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\nindex 6eed5dfadde..685cc4a0f0e 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\n", "chunk": "@@ -57,9 +57,6 @@ public class H2ManagedGroupByData extends GroupByData {\n     /** */\n     private int size;\n \n-    /** */\n-    private long swapped;\n-\n     /**\n      * @param ses Session.\n      * @param grpIdx Indexes of group-by columns.\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\nindex e1e99bd78e6..25f86cde85e 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedGroupByData.java\n", "chunk": "@@ -57,9 +57,6 @@ public class H2ManagedGroupByData extends GroupByData {\n     /** */\n     private int size;\n \n-    /** */\n-    private long swapped = 0;\n-\n     /**\n      * @param ses Session.\n      * @param grpIdx Indexes of group-by columns.\n", "next_change": null}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"oid": "befcf5000dc94af7e9952b036738a512a1939529", "url": "https://github.com/gridgain/gridgain/commit/befcf5000dc94af7e9952b036738a512a1939529", "message": "DRAFT: mem metrics for system view", "committedDate": "2020-02-28T08:07:46Z", "type": "commit"}, {"oid": "071af2afe1ee9ab728f45ee0a09afab7150e6783", "url": "https://github.com/gridgain/gridgain/commit/071af2afe1ee9ab728f45ee0a09afab7150e6783", "message": "fix compilation", "committedDate": "2020-02-28T09:07:12Z", "type": "commit"}, {"oid": "8dae651f667727d4c1497f24def5ebe7fd56844d", "url": "https://github.com/gridgain/gridgain/commit/8dae651f667727d4c1497f24def5ebe7fd56844d", "message": "another wip commit", "committedDate": "2020-03-01T18:20:04Z", "type": "commit"}, {"oid": "8dae651f667727d4c1497f24def5ebe7fd56844d", "url": "https://github.com/gridgain/gridgain/commit/8dae651f667727d4c1497f24def5ebe7fd56844d", "message": "another wip commit", "committedDate": "2020-03-01T18:20:04Z", "type": "forcePushed"}, {"oid": "40d79418306f334e74a4901a2890e4dc887a0620", "url": "https://github.com/gridgain/gridgain/commit/40d79418306f334e74a4901a2890e4dc887a0620", "message": "refactoring", "committedDate": "2020-03-01T20:26:57Z", "type": "commit"}, {"oid": "0cb6b879462cf944b6f3e041eec8cd30f3bacc60", "url": "https://github.com/gridgain/gridgain/commit/0cb6b879462cf944b6f3e041eec8cd30f3bacc60", "message": "minors", "committedDate": "2020-03-01T21:03:20Z", "type": "commit"}, {"oid": "e8f075e675b8764f1f7b686d27bfa9251692fe70", "url": "https://github.com/gridgain/gridgain/commit/e8f075e675b8764f1f7b686d27bfa9251692fe70", "message": "fix compilation", "committedDate": "2020-03-01T21:16:13Z", "type": "commit"}, {"oid": "ae76c3e616933cbef7a7a912082106a2db955eee", "url": "https://github.com/gridgain/gridgain/commit/ae76c3e616933cbef7a7a912082106a2db955eee", "message": "fix tests", "committedDate": "2020-03-02T10:17:34Z", "type": "commit"}, {"oid": "9708e6beabd3cc7b48295fd604f4e940608f5385", "url": "https://github.com/gridgain/gridgain/commit/9708e6beabd3cc7b48295fd604f4e940608f5385", "message": "fix npe", "committedDate": "2020-03-02T11:10:11Z", "type": "commit"}, {"oid": "5f19b17dce07321fc387912b787271a23858d65b", "url": "https://github.com/gridgain/gridgain/commit/5f19b17dce07321fc387912b787271a23858d65b", "message": "fix JDBC quota test", "committedDate": "2020-03-02T11:42:28Z", "type": "commit"}, {"oid": "9d97f90f2eae8de2ae547543cd97b827cc70ff6d", "url": "https://github.com/gridgain/gridgain/commit/9d97f90f2eae8de2ae547543cd97b827cc70ff6d", "message": "rename interface", "committedDate": "2020-03-02T11:51:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MDc0NA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r386370744", "body": "non-atomic update\r\nRace is possible while updating  globalQuota and globalQuotaStr from different threads.", "bodyText": "non-atomic update\nRace is possible while updating  globalQuota and globalQuotaStr from different threads.", "bodyHTML": "<p dir=\"auto\">non-atomic update<br>\nRace is possible while updating  globalQuota and globalQuotaStr from different threads.</p>", "author": "AMashenkov", "createdAt": "2020-03-02T12:44:53Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java", "diffHunk": "@@ -244,9 +228,20 @@ public boolean onQuotaExceeded(long size) {\n      *\n      * @param newGlobalQuota New global query quota.\n      */\n-    public synchronized void setGlobalQuota(String newGlobalQuota) {\n-        this.globalQuota = U.parseBytes(newGlobalQuota);\n-        this.globalQuotaStr = newGlobalQuota;\n+    public void setGlobalQuota(String newGlobalQuota) {\n+        long globalQuota0 = U.parseBytes(newGlobalQuota);\n+        long heapSize = Runtime.getRuntime().maxMemory();\n+\n+        A.ensure(\n+            heapSize > globalQuota0,\n+            \"Sql global memory quota can't be more than heap size: heapSize=\"\n+                + heapSize + \", quotaSize=\" + globalQuota0\n+        );\n+\n+        A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n+\n+        globalQuota = globalQuota0;\n+        globalQuotaStr = newGlobalQuota;", "originalCommit": "9708e6beabd3cc7b48295fd604f4e940608f5385", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3c4fba49e2362adb932629617b02b9952bd4285a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 4107ade0fd7..bed35e8a8bf 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -241,7 +235,6 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n         A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n \n         globalQuota = globalQuota0;\n-        globalQuotaStr = newGlobalQuota;\n \n         if (log.isInfoEnabled()) {\n             log.info(\"SQL query global quota was set to \" + globalQuota +  \". Current memory tracking parameters: \" +\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 4107ade0fd7..65892c13b4a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -241,7 +235,6 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n         A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n \n         globalQuota = globalQuota0;\n-        globalQuotaStr = newGlobalQuota;\n \n         if (log.isInfoEnabled()) {\n             log.info(\"SQL query global quota was set to \" + globalQuota +  \". Current memory tracking parameters: \" +\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 65892c13b4a..58ae9e20f92 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -163,168 +109,62 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n         if (size == 0)\n             return; // Nothing to do.\n \n-        assert size > 0;\n+        reserved.accumulateAndGet(-size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to free more memory that ever be reserved: [\" +\n+                    \"reserved=\" + prev + \", toFree=\" + x + ']');\n \n-        reserved.accumulateAndGet(size, RELEASE_OP);\n+            return prev + x;\n+        });\n     }\n \n     /**\n      * Query memory tracker factory method.\n      *\n-     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota} will be used.\n+     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#dfltSqlQryMemoryLimit}  will be used.\n+     * Note: Negative values are reserved for disable memory tracking.\n      *\n-     * @param maxQryMemory Query memory limit in bytes.\n+     * @param maxQueryMemory Query memory limit in bytes.\n      * @return Query memory tracker.\n      */\n-    public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n-        long globalQuota0 = globalQuota;\n-\n-        if (globalQuota0 > 0 && globalQuota0 < maxQryMemory) {\n-            if (log.isInfoEnabled()) {\n-                LT.info(log, \"Query memory quota cannot exceed global memory quota.\" +\n-                    \" It will be reduced to the size of global quota: \" + globalQuota0);\n-            }\n-\n-            maxQryMemory = globalQuota0;\n-        }\n-\n-        if (maxQryMemory == 0)\n-            maxQryMemory = globalQuota0 > 0 ? Math.min(qryQuota, globalQuota0) : qryQuota;\n-\n-        if (maxQryMemory < 0)\n-            maxQryMemory = 0;\n+    public QueryMemoryTracker createQueryMemoryTracker(long maxQueryMemory) {\n+        assert maxQueryMemory >= 0;\n \n-        QueryMemoryTracker tracker = new QueryMemoryTracker(this, maxQryMemory, blockSize, offloadingEnabled);\n+        if (maxQueryMemory == 0)\n+            maxQueryMemory = dfltSqlQryMemoryLimit;\n \n-        if (log.isDebugEnabled())\n-            log.debug(\"Memory tracker created: \" + tracker);\n+        if (dfltSqlQryMemoryLimit < 0)\n+            return null;\n \n-        return tracker;\n-    }\n+        if (globalQuota > 0 && globalQuota < maxQueryMemory) {\n+            U.warn(log, \"Max query memory can't exceeds SQL memory pool size. Will be reduced down to: \" + globalQuota);\n \n-    /**\n-     * Action when quota is exceeded.\n-     * @return {@code false} if it is needed to offload data.\n-     */\n-    public boolean onQuotaExceeded(long size) {\n-        reserved.addAndGet(-size);\n-\n-        if (offloadingEnabled)\n-            return false;\n-        else {\n-            throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            maxQueryMemory = globalQuota;\n         }\n-    }\n-\n-    /**\n-     * Sets new global query quota.\n-     *\n-     * @param newGlobalQuota New global query quota.\n-     */\n-    public synchronized void setGlobalQuota(String newGlobalQuota) {\n-        long globalQuota0 = U.parseBytes(newGlobalQuota);\n-        long heapSize = Runtime.getRuntime().maxMemory();\n-\n-        A.ensure(\n-            heapSize > globalQuota0,\n-            \"Sql global memory quota can't be more than heap size: heapSize=\"\n-                + heapSize + \", quotaSize=\" + globalQuota0\n-        );\n \n-        A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n+        assert maxQueryMemory >= blockSize;\n \n-        globalQuota = globalQuota0;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query global quota was set to \" + globalQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n+        return new QueryMemoryTracker(globalQuota < 0 ? null : this, maxQueryMemory, blockSize);\n     }\n \n     /**\n-     * @return Current global query quota.\n-     */\n-    public String getGlobalQuota() {\n-        return String.valueOf(globalQuota);\n-    }\n-\n-    /**\n-     * Sets new per-query quota.\n+     * Gets memory reserved by running queries.\n      *\n-     * @param newQryQuota New per-query quota.\n+     * @return Reserved memory in bytes.\n      */\n-    public synchronized void setQueryQuota(String newQryQuota) {\n-        long qryQuota0 = U.parseBytes(newQryQuota);\n-\n-        A.ensure(qryQuota0 >= 0, \"Sql query memory quota must be >= 0: quotaSize=\" + qryQuota0);\n-\n-        qryQuota = U.parseBytes(newQryQuota);\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query memory quota was set to \" + qryQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n-\n-        if (qryQuota > globalQuota) {\n-            log.warning(\"The local quota was set higher than global. The new value will be truncated \" +\n-                \"to the size of the global quota [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota);\n-        }\n-    }\n-\n-    /**\n-     * @return Current query quota.\n-     */\n-    public String getQueryQuotaString() {\n-        return String.valueOf(qryQuota);\n+    public long memoryReserved() {\n+        return reserved.get();\n     }\n \n     /**\n-     * Sets offloading enabled flag.\n+     * Gets global memory limit for queries.\n      *\n-     * @param offloadingEnabled Offloading enabled flag.\n-     */\n-    public synchronized void setOffloadingEnabled(boolean offloadingEnabled) {\n-        this.offloadingEnabled = offloadingEnabled;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query query offloading enabled flag was set to \" + offloadingEnabled +\n-                \". Current memory tracking parameters: [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + this.offloadingEnabled + ']');\n-        }\n-    }\n-\n-    /**\n-     * @return Flag whether offloading is enabled.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n-    }\n-\n-    /**\n-     * @return Bytes reserved by all queries.\n+     * @return Max memory in bytes.\n      */\n-    @Override public long reserved() {\n-        return reserved.get();\n-    }\n-\n-    /** */\n-    public long memoryLimit() {\n+    public long maxMemory() {\n         return globalQuota;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public void spill(long size) {\n-        // NO-OP\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void unspill(long size) {\n-        // NO-OP\n-    }\n-\n     /** {@inheritDoc} */\n     @Override public void close() {\n         // Cursors are not tracked and can't be forcibly closed to release resources.\n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 58ae9e20f92..727ed359f06 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -172,4 +179,29 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    private static class ReservationOp implements LongBinaryOperator {\n+        /** Operation result high bound.*/\n+        private final long limit;\n+\n+        /**\n+         * Constructor.\n+         * @param limit Operation result high bound.\n+         */\n+        ReservationOp(long limit) {\n+            this.limit = limit;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long applyAsLong(long prev, long x) {\n+            long res = prev + x;\n+\n+            if (res > limit)\n+                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+\n+            return res;\n+        }\n+    }\n }\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 727ed359f06..788602adfa6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -179,29 +196,4 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n-\n-    /** */\n-    private static class ReservationOp implements LongBinaryOperator {\n-        /** Operation result high bound.*/\n-        private final long limit;\n-\n-        /**\n-         * Constructor.\n-         * @param limit Operation result high bound.\n-         */\n-        ReservationOp(long limit) {\n-            this.limit = limit;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long applyAsLong(long prev, long x) {\n-            long res = prev + x;\n-\n-            if (res > limit)\n-                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-\n-            return res;\n-        }\n-    }\n }\n", "next_change": {"commit": "3c6a5cb36df055ae623a37e59044c99b862b1938", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 788602adfa6..750b2e3b12d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -196,4 +297,196 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    public IgniteLogger log() {\n+        return log;\n+    }\n+\n+    /**\n+     * Cleans spill directory. Spill directory is used for disk\n+     * offloading of the intermediate results of heavy queries.\n+     */\n+    public void cleanSpillDirectory() {\n+        try {\n+            File spillDir = U.resolveWorkDirectory(\n+                ctx.config().getWorkDirectory(),\n+                DISK_SPILL_DIR,\n+                false);\n+\n+            File[] spillFiles = spillDir.listFiles();\n+\n+            if (spillFiles.length == 0)\n+                return;\n+\n+            for (int i = 0; i < spillFiles.length; i++) {\n+                try {\n+                    File spillFile = spillFiles[i];\n+\n+                    String nodeId = spillFile.getName().split(\"_\")[1]; // Spill name pattern: spill_nodeId_fileId.\n+\n+                    UUID nodeUuid = UUID.fromString(nodeId);\n+\n+                    if (!ctx.discovery().alive(nodeUuid) || ctx.localNodeId().equals(nodeUuid))\n+                        spillFile.delete();\n+                }\n+                catch (Exception e) {\n+                    log.debug(\"Error on cleaning spill directory. \" + X.getFullStackTrace(e));\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.warning(\"Failed to cleanup the temporary directory for intermediate \" +\n+                \"SQL query results from the previous node run.\", e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public GroupByData newManagedGroupByData(Session ses, ArrayList<Expression> expressions,\n+        boolean isGrpQry, int[] grpIdx) {\n+\n+        boolean spillingEnabled = ctx.config().isSqlOffloadingEnabled();\n+\n+        if (!spillingEnabled)\n+            return null;\n+\n+        assert isGrpQry; // isGrpQry == false allowed only for window queries which are not supported yet.\n+\n+        return new H2ManagedGroupByData(ses, grpIdx);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @return Plain external result.\n+     */\n+    public ResultExternal createPlainExternalResult(Session ses) {\n+        return new PlainExternalResult(ses);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param distinct Distinct flag.\n+     * @param distinctIndexes Distinct indexes.\n+     * @param visibleColCnt Visible columns count.\n+     * @param sort Sort order.\n+     * @param rowCnt Row count.\n+     * @return Sorted external result.\n+     */\n+    public ResultExternal createSortedExternalResult(Session ses, boolean distinct, int[] distinctIndexes,\n+        int visibleColCnt, SortOrder sort, int rowCnt) {\n+        return new SortedExternalResult(ses, distinct, distinctIndexes, visibleColCnt, sort, rowCnt);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param size Size;\n+     * @return Grouped result;\n+     */\n+    public GroupedExternalResult createGroupedExternalResult(Session ses, int size) {\n+        return new GroupedExternalResult(ses, size);\n+    }\n+\n+    /**\n+     * Creates external data (offload file wrapper).\n+     * @param ses Session.\n+     * @param useHashIdx Flag whether to use hash index.\n+     * @param initSize Initial size.\n+     * @param cls Class of stored values.\n+     * @param <T> Type of stored values.\n+     * @return Created external data (offload file wrapper).\n+     */\n+    public <T> ExternalResultData<T> createExternalData(Session ses, boolean useHashIdx, long initSize, Class<T> cls) {\n+        if (!ses.isOffloadedToDisk()) {\n+            ses.setOffloadedToDisk(true);\n+\n+            metrics.trackQueryOffloaded();\n+        }\n+\n+        return new ExternalResultData<>(log,\n+            ctx.config().getWorkDirectory(),\n+            fileIOFactory,\n+            ctx.localNodeId(),\n+            useHashIdx,\n+            initSize,\n+            cls,\n+            ses.getDatabase().getCompareMode(),\n+            ses.getDatabase());\n+    }\n+\n+    /**\n+     * FileIO decorator for stats collecting.\n+     */\n+    private static class TrackableFileIO extends FileIODecorator {\n+        /** */\n+        private final SqlMemoryStatisticsHolder metrics;\n+\n+        /**\n+         * @param delegate File I/O delegate\n+         */\n+        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n+            super(delegate);\n+\n+            this.metrics = metrics;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf) throws IOException {\n+            int bytesRead = delegate.read(destBuf);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n+            int bytesRead = delegate.read(destBuf, position);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(byte[] buf, int off, int len) throws IOException {\n+            int bytesRead = delegate.read(buf, off, len);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf, position);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(byte[] buf, int off, int len) throws IOException {\n+            int bytesWritten = delegate.write(buf, off, len);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+    }\n }\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 750b2e3b12d..3768f833c89 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -410,83 +456,7 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n             initSize,\n             cls,\n             ses.getDatabase().getCompareMode(),\n-            ses.getDatabase());\n-    }\n-\n-    /**\n-     * FileIO decorator for stats collecting.\n-     */\n-    private static class TrackableFileIO extends FileIODecorator {\n-        /** */\n-        private final SqlMemoryStatisticsHolder metrics;\n-\n-        /**\n-         * @param delegate File I/O delegate\n-         */\n-        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n-            super(delegate);\n-\n-            this.metrics = metrics;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf) throws IOException {\n-            int bytesRead = delegate.read(destBuf);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n-            int bytesRead = delegate.read(destBuf, position);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(byte[] buf, int off, int len) throws IOException {\n-            int bytesRead = delegate.read(buf, off, len);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf, position);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(byte[] buf, int off, int len) throws IOException {\n-            int bytesWritten = delegate.write(buf, off, len);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n+            ses.getDatabase(),\n+            ses.memoryTracker());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "5c7104415d67a2d06fa12b058c6ea8c5410c3393", "committedDate": "2019-07-24 20:42:20 +0300", "message": "GG-21813: SQL: Fix assert in MemoryManager.createMemoryTracker."}, {"oid": "e6adea02b6463c268d3c67bb973e9dbf754a8ff1", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20995: SQL: Metrics of using memory quotas."}, {"oid": "ee923b0183a2f8dc02b9e408f949c48be9c7366d", "committedDate": "2019-10-22 15:09:39 +0300", "message": "GG-24667: SQL: Disable memory quotas by default. This closes #604."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "cb6c1b2a9be6ce52cdbb5cfbfb3c7b5e34fe53cd", "committedDate": "2020-03-05 12:27:31 +0300", "message": "GG-27922 Expose SQL memory quota in bytes for JMX"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "9502a24df45ba7a97e2efa7d21476926e8250c66", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29130 [IGNITE-12953] Add support for SingleSpaceSeparator to the checkstyle (#7734)"}, {"oid": "f4f9676e82ec87f0977f387ad233f993e5c4cb28", "committedDate": "2020-08-18 18:12:18 -0400", "message": "GG-29772 (#1247)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "a8de46705cf54e56edefa158338a3a8ce3bc96e2", "committedDate": "2021-03-10 13:53:17 -0500", "message": "GG-32298 Create a JMX metric to show realtime sql engine memory utililization (#1726)"}, {"oid": "342366623db8d66053fb090ea2bee50826137670", "committedDate": "2021-05-28 10:18:58 -0400", "message": "GG-33258 correct log reporting of sqlOffloadingEnabled (#1943)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3NDM2MQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r386374361", "body": "It looks like there is no need to mark method with 'synchronized' just to read volatile field", "bodyText": "It looks like there is no need to mark method with 'synchronized' just to read volatile field", "bodyHTML": "<p dir=\"auto\">It looks like there is no need to mark method with 'synchronized' just to read volatile field</p>", "author": "AMashenkov", "createdAt": "2020-03-02T12:52:47Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -179,21 +182,36 @@ private boolean onQuotaExceeded() {\n     private void releaseFromParent() {\n         long toReleaseFromParent = reservedFromParent - reserved;\n \n-        parent.released(toReleaseFromParent);\n+        parent.release(toReleaseFromParent);\n \n         reservedFromParent -= toReleaseFromParent;\n \n         assert reservedFromParent >= 0 : reservedFromParent;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long memoryReserved() {\n+    @Override public synchronized long reserved() {", "originalCommit": "9708e6beabd3cc7b48295fd604f4e940608f5385", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc3575f1dcde70d7b1f6840050fd91bd365038d7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex b9754fc4405..006c4a89b8e 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -190,27 +193,27 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryTrack\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long reserved() {\n+    @Override public long reserved() {\n         return reserved;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long maxReserved() {\n+    @Override public long maxReserved() {\n         return maxReserved;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long writtenOnDisk() {\n+    @Override public long writtenOnDisk() {\n         return writtenOnDisk;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long maxWrittenOnDisk() {\n+    @Override public long maxWrittenOnDisk() {\n         return maxWrittenOnDisk;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long totalWrittenOnDisk() {\n+    @Override public long totalWrittenOnDisk() {\n         return totalWrittenOnDisk;\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex b9754fc4405..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -190,27 +204,27 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryTrack\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long reserved() {\n+    @Override public long reserved() {\n         return reserved;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long maxReserved() {\n+    @Override public long maxReserved() {\n         return maxReserved;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long writtenOnDisk() {\n+    @Override public long writtenOnDisk() {\n         return writtenOnDisk;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long maxWrittenOnDisk() {\n+    @Override public long maxWrittenOnDisk() {\n         return maxWrittenOnDisk;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized long totalWrittenOnDisk() {\n+    @Override public long totalWrittenOnDisk() {\n         return totalWrittenOnDisk;\n     }\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -30,247 +27,124 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetricProvider {\n-    /** State updater. */\n-    private static final AtomicIntegerFieldUpdater<QueryMemoryTracker> STATE_UPDATER\n-        = AtomicIntegerFieldUpdater.newUpdater(QueryMemoryTracker.class, \"state\");\n+public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n+    /** Resered field updater. */\n+    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n+        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n \n-    /** Tracker is not closed and not in the middle of the closing process. */\n-    private static final int STATE_INITIAL = 0;\n-\n-    /** Tracker is closed or in the middle of the closing process. */\n-    private static final int STATE_CLOSED = 1;\n+    /** Closed flag updater. */\n+    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n+        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n \n     /** Parent tracker. */\n-    @GridToStringExclude\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long quota;\n-\n-    /**\n-     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n-     * <ul>\n-     * <li>{@code false} - exception will be thrown.</li>\n-     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n-     * </ul>\n-     */\n-    private final boolean offloadingEnabled;\n+    private final long maxMem;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private long reservedFromParent;\n+    private volatile long reservedFromParent;\n \n     /** Memory reserved by query. */\n     private volatile long reserved;\n \n-    /** Maximum number of bytes reserved by query. */\n-    private volatile long maxReserved;\n-\n-    /** Number of bytes written on disk at the current moment. */\n-    private volatile long writtenOnDisk;\n-\n-    /** Maximum number of bytes written on disk at the same time. */\n-    private volatile long maxWrittenOnDisk;\n-\n-    /** Total number of bytes written on disk tracked by current tracker. */\n-    private volatile long totalWrittenOnDisk;\n-\n     /** Close flag to prevent tracker reuse. */\n-    private volatile boolean closed;\n-\n-    /** State of the tracker. Can be equal {@link #STATE_INITIAL} or {@link #STATE_CLOSED}*/\n-    private volatile int state;\n-\n-    /** Children. */\n-    private final List<H2MemoryTracker> children = new ArrayList<>();\n-\n-    /** The number of files created by the query. */\n-    private volatile int filesCreated;\n+    private volatile Boolean closed = Boolean.FALSE;\n \n     /**\n      * Constructor.\n      *\n      * @param parent Parent memory tracker.\n-     * @param quota Query memory limit in bytes.\n+     * @param maxMem Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n-     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n-     */\n-    public QueryMemoryTracker(\n-        H2MemoryTracker parent,\n-        long quota,\n-        long blockSize,\n-        boolean offloadingEnabled\n-    ) {\n-        assert quota >= 0;\n-\n-        this.offloadingEnabled = offloadingEnabled;\n-        this.parent = parent;\n-        this.quota = quota;\n-        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized boolean reserve(long size) {\n-        assert size >= 0;\n-\n-        checkClosed();\n-\n-        reserved += size;\n-        maxReserved = Math.max(maxReserved, reserved);\n-\n-        if (parent != null && reserved > reservedFromParent) {\n-            if (!reserveFromParent())\n-                return false; // Offloading.\n-        }\n-\n-        if (quota > 0 && reserved >= quota)\n-            return onQuotaExceeded();\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Checks whether tracker was closed.\n-     */\n-    private void checkClosed() {\n-        if (closed)\n-            throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-    }\n-\n-    /**\n-     * Reserves memory from parent tracker.\n-     * @return {@code false} if offloading is needed.\n      */\n-    private boolean reserveFromParent() {\n-        // If single block size is too small.\n-        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n-\n-        // If we are too close to limit.\n-        if (quota > 0)\n-            blockSize = Math.min(blockSize, quota - reservedFromParent);\n-\n-        if (parent.reserve(blockSize))\n-            reservedFromParent += blockSize;\n-        else\n-            return false;\n+    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n+        assert maxMem > 0;\n \n-        return true;\n-    }\n-\n-    /**\n-     * Action on quota exceeded.\n-     * @return {@code false} if offloading is needed.\n-     */\n-    private boolean onQuotaExceeded() {\n-        if (offloadingEnabled)\n-            return false;\n-        else\n-            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+        this.parent = parent;\n+        this.maxMem = maxMem;\n+        this.blockSize = blockSize;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void release(long size) {\n-        assert size >= 0;\n+    @Override public void reserve(long size) {\n+        assert !closed && size >= 0;\n \n         if (size == 0)\n             return;\n \n-        checkClosed();\n-\n-        reserved -= size;\n-\n-        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + size) +\n-            \", toFree=\" + size + ']';\n-\n-        if (parent != null && reservedFromParent - reserved > blockSize)\n-            releaseFromParent();\n-    }\n-\n-    /**\n-     * Releases memory from parent.\n-     */\n-    private void releaseFromParent() {\n-        long toReleaseFromParent = reservedFromParent - reserved;\n-\n-        parent.release(toReleaseFromParent);\n+        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n+            if (prev + x > maxMem) {\n+                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            }\n \n-        reservedFromParent -= toReleaseFromParent;\n+            return prev + x;\n+        });\n \n-        assert reservedFromParent >= 0 : reservedFromParent;\n-    }\n+        if (parent != null && reserved0 > reservedFromParent) {\n+            synchronized (this) {\n+                assert !closed;\n \n-    /** {@inheritDoc} */\n-    @Override public long reserved() {\n-        return reserved;\n-    }\n+                if (reserved0 <= reservedFromParent)\n+                    return;\n \n-    /** {@inheritDoc} */\n-    @Override public long maxReserved() {\n-        return maxReserved;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public long writtenOnDisk() {\n-        return writtenOnDisk;\n-    }\n+                // If single block size is too small.\n+                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n+                // If we are too close to limit.\n+                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n \n-    /** {@inheritDoc} */\n-    @Override public long maxWrittenOnDisk() {\n-        return maxWrittenOnDisk;\n-    }\n+                try {\n+                    parent.reserve(blockSize);\n \n-    /** {@inheritDoc} */\n-    @Override public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n-    }\n+                    reservedFromParent += blockSize;\n+                }\n+                catch (Throwable e) {\n+                    // Fallback if failed to reserve.\n+                    RESERVED_UPD.addAndGet(this, -size);\n \n-    /**\n-     * @return Offloading enabled flag.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n+                    throw e;\n+                }\n+            }\n+        }\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void spill(long size) {\n+    @Override public void release(long size) {\n         assert size >= 0;\n \n         if (size == 0)\n             return;\n \n-        checkClosed();\n+        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n+                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n \n-        if (parent != null)\n-            parent.spill(size);\n+            return prev + x;\n+        });\n \n-        writtenOnDisk += size;\n-        totalWrittenOnDisk += size;\n-        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n-    }\n+        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void unspill(long size) {\n-        assert size >= 0;\n+        // For now, won'tQ release memory to parent until tracker closed.\n+       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n+            synchronized (this) {\n+                if (preAllocated - reserved >= 2 * blockSize) {\n+                    parent.release(blockSize);\n \n-        if (size == 0)\n-            return;\n-\n-        checkClosed();\n-\n-        if (parent != null)\n-            parent.unspill(size);\n-\n-        writtenOnDisk -= size;\n+                    preAllocated -= blockSize;\n+                }\n+            }\n+        }*/\n     }\n \n     /**\n-     * @return {@code true} if closed, {@code false} otherwise.\n+     * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    @Override public boolean closed() {\n+    public boolean closed() {\n         return closed;\n     }\n \n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..ea3193007a5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -152,8 +152,13 @@ public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        synchronized (this) {\n+            if (closed)\n+                return;\n+\n+            closed = true;\n+\n+            release0(reserved);\n \n             if (parent != null)\n                 parent.release(reservedFromParent);\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ea3193007a5..557040604bd 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -158,10 +168,10 @@ public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable\n \n             closed = true;\n \n-            release0(reserved);\n+            reserved = 0;\n \n             if (parent != null)\n-                parent.release(reservedFromParent);\n+                parent.released(reservedFromParent);\n         }\n     }\n \n", "next_change": {"commit": "ed30d3c44e4c1d6461f1973432e15ae383179398", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 557040604bd..6c365d5b9ad 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -159,20 +178,18 @@ public class QueryMemoryTracker extends H2MemoryTracker {\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        synchronized (this) {\n-            if (closed)\n-                return;\n+        if (closed)\n+            return;\n \n-            closed = true;\n+        closed = true;\n \n-            reserved = 0;\n+        reserved = 0;\n \n-            if (parent != null)\n-                parent.released(reservedFromParent);\n-        }\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 6c365d5b9ad..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -190,6 +223,50 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n \n         if (parent != null)\n             parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n+        }\n+    }\n+\n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"oid": "ca1d2aa85a4838610adaf423450b61a7b8fc90e8", "url": "https://github.com/gridgain/gridgain/commit/ca1d2aa85a4838610adaf423450b61a7b8fc90e8", "message": "another attempt to get green visa", "committedDate": "2020-03-03T06:05:41Z", "type": "commit"}, {"oid": "48cd37e2dc468afc04afc82fa9ae2a97726a9609", "url": "https://github.com/gridgain/gridgain/commit/48cd37e2dc468afc04afc82fa9ae2a97726a9609", "message": "save the progress", "committedDate": "2020-03-03T10:05:57Z", "type": "commit"}, {"oid": "cb4b5c82c97cafa5c74fd6f7c482b1aa63f308de", "url": "https://github.com/gridgain/gridgain/commit/cb4b5c82c97cafa5c74fd6f7c482b1aa63f308de", "message": "fix tests", "committedDate": "2020-03-03T11:16:06Z", "type": "commit"}, {"oid": "dc3575f1dcde70d7b1f6840050fd91bd365038d7", "url": "https://github.com/gridgain/gridgain/commit/dc3575f1dcde70d7b1f6840050fd91bd365038d7", "message": "save the progress", "committedDate": "2020-03-03T13:01:34Z", "type": "commit"}, {"oid": "317c5592198e02352234a8f71c1bbb2681b0040b", "url": "https://github.com/gridgain/gridgain/commit/317c5592198e02352234a8f71c1bbb2681b0040b", "message": "minors", "committedDate": "2020-03-03T13:35:21Z", "type": "commit"}, {"oid": "2262f9886257de14eb765f703bbe903619dd11a1", "url": "https://github.com/gridgain/gridgain/commit/2262f9886257de14eb765f703bbe903619dd11a1", "message": "fix failed tests", "committedDate": "2020-03-04T07:21:30Z", "type": "commit"}, {"oid": "fbb183f415294196ec3288504d848e3175be5eaa", "url": "https://github.com/gridgain/gridgain/commit/fbb183f415294196ec3288504d848e3175be5eaa", "message": "minors", "committedDate": "2020-03-04T09:39:11Z", "type": "commit"}, {"oid": "68df8071e510416aaa076f46244be540f406fd13", "url": "https://github.com/gridgain/gridgain/commit/68df8071e510416aaa076f46244be540f406fd13", "message": "save the progress", "committedDate": "2020-03-04T13:15:45Z", "type": "commit"}, {"oid": "12d75e939a64115b366a9c88b0f06c2d62f84109", "url": "https://github.com/gridgain/gridgain/commit/12d75e939a64115b366a9c88b0f06c2d62f84109", "message": "save the progress", "committedDate": "2020-03-04T13:45:34Z", "type": "commit"}, {"oid": "a8260e09a51a92322876a84d59a41358019bb79d", "url": "https://github.com/gridgain/gridgain/commit/a8260e09a51a92322876a84d59a41358019bb79d", "message": "minors", "committedDate": "2020-03-04T14:40:34Z", "type": "commit"}, {"oid": "de3dd2ae3f106045b4340273542ef81211931b6a", "url": "https://github.com/gridgain/gridgain/commit/de3dd2ae3f106045b4340273542ef81211931b6a", "message": "minors", "committedDate": "2020-03-04T16:24:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE3OTMzMQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388179331", "body": "H2 has function to close Autoclosables: IOUtils.closeSilently()", "bodyText": "H2 has function to close Autoclosables: IOUtils.closeSilently()", "bodyHTML": "<p dir=\"auto\">H2 has function to close Autoclosables: IOUtils.closeSilently()</p>", "author": "AMashenkov", "createdAt": "2020-03-05T09:43:26Z", "path": "modules/h2/src/main/java/org/h2/index/HashJoinIndex.java", "diffHunk": "@@ -508,12 +507,15 @@ private boolean checkConditions(Session ses, Row r) {\n     public void clearHashTable(Session session) {\n         hashTbl = null;\n \n-        if (memoryReserved > 0) {\n-            assert session.memoryTracker() != null;\n-\n-            session.memoryTracker().released(memoryReserved);\n+        if (tracker != null) {\n+            try {", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex 7fbeacc5ce8..2ed3f5d4ef9 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -507,16 +508,9 @@ public class HashJoinIndex extends BaseIndex {\n     public void clearHashTable(Session session) {\n         hashTbl = null;\n \n-        if (tracker != null) {\n-            try {\n-                tracker.close();\n-            }\n-            catch (Exception ignored) {\n-                // no-op\n-            }\n+        IOUtils.closeSilently(tracker);\n \n-            tracker = null;\n-        }\n+        tracker = null;\n     }\n \n     /**\n", "next_change": {"commit": "4539bc347c43488f0594ec532f6247300fd5d6c0", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex 2ed3f5d4ef9..d3514dbb7b2 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -508,7 +507,8 @@ public class HashJoinIndex extends BaseIndex {\n     public void clearHashTable(Session session) {\n         hashTbl = null;\n \n-        IOUtils.closeSilently(tracker);\n+        if (tracker != null)\n+            tracker.close();\n \n         tracker = null;\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex 7fbeacc5ce8..d3514dbb7b2 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -507,16 +507,10 @@ public class HashJoinIndex extends BaseIndex {\n     public void clearHashTable(Session session) {\n         hashTbl = null;\n \n-        if (tracker != null) {\n-            try {\n-                tracker.close();\n-            }\n-            catch (Exception ignored) {\n-                // no-op\n-            }\n+        if (tracker != null)\n+            tracker.close();\n \n-            tracker = null;\n-        }\n+        tracker = null;\n     }\n \n     /**\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex d3514dbb7b2..1b0bffa3b57 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -507,10 +530,13 @@ public class HashJoinIndex extends BaseIndex {\n     public void clearHashTable(Session session) {\n         hashTbl = null;\n \n-        if (tracker != null)\n-            tracker.close();\n+        if (memoryReserved > 0) {\n+            assert session.queryMemoryTracker() != null;\n+\n+            session.queryMemoryTracker().release(memoryReserved);\n \n-        tracker = null;\n+            memoryReserved = 0;\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex 1b0bffa3b57..4cbbf6c9bed 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -533,7 +511,7 @@ public class HashJoinIndex extends BaseIndex {\n         if (memoryReserved > 0) {\n             assert session.queryMemoryTracker() != null;\n \n-            session.queryMemoryTracker().release(memoryReserved);\n+            session.queryMemoryTracker().released(memoryReserved);\n \n             memoryReserved = 0;\n         }\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex 4cbbf6c9bed..74c7c097df9 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -509,9 +509,9 @@ public class HashJoinIndex extends BaseIndex {\n         hashTbl = null;\n \n         if (memoryReserved > 0) {\n-            assert session.queryMemoryTracker() != null;\n+            assert session.memoryTracker() != null;\n \n-            session.queryMemoryTracker().released(memoryReserved);\n+            session.memoryTracker().released(memoryReserved);\n \n             memoryReserved = 0;\n         }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\nindex 74c7c097df9..d3514dbb7b2 100644\n--- a/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n+++ b/modules/h2/src/main/java/org/h2/index/HashJoinIndex.java\n", "chunk": "@@ -508,13 +507,10 @@ public class HashJoinIndex extends BaseIndex {\n     public void clearHashTable(Session session) {\n         hashTbl = null;\n \n-        if (memoryReserved > 0) {\n-            assert session.memoryTracker() != null;\n+        if (tracker != null)\n+            tracker.close();\n \n-            session.memoryTracker().released(memoryReserved);\n-\n-            memoryReserved = 0;\n-        }\n+        tracker = null;\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "a30306eb0b4ea1d376c1b6a4052c407d5b4a5525", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-21157 fix hash join on different types"}, {"oid": "709592f80a8c631459655117ab293917d2b6fce9", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-21157: Fix imports."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE3OTk3NQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388179975", "body": "Let's help GC in anyway\r\n\r\nif (values != null)\r\n   values = null;\r\nif (tracker != null)\r\n   tracker.release ....\r\n", "bodyText": "Let's help GC in anyway\nif (values != null)\nvalues = null;\nif (tracker != null)\ntracker.release ....", "bodyHTML": "<p dir=\"auto\">Let's help GC in anyway</p>\n<p dir=\"auto\">if (values != null)<br>\nvalues = null;<br>\nif (tracker != null)<br>\ntracker.release ....</p>", "author": "AMashenkov", "createdAt": "2020-03-05T09:44:40Z", "path": "modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java", "diffHunk": "@@ -153,17 +155,16 @@ public Value getSharedArgument() {\n \n     /** {@inheritDoc} */\n     @Override public void cleanup(Session ses) {\n-        H2MemoryTracker memTracker;\n-        if (values != null && (memTracker = ses.memoryTracker()) != null) {\n+        if (values != null && tracker != null) {", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\nindex b8ac9483da2..3d10dadca78 100644\n--- a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n+++ b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n", "chunk": "@@ -155,11 +155,11 @@ public class AggregateDataCollecting extends AggregateData implements Iterable<V\n \n     /** {@inheritDoc} */\n     @Override public void cleanup(Session ses) {\n-        if (values != null && tracker != null) {\n+        if (values != null)\n             values = null;\n \n+        if (tracker != null)\n             tracker.release(tracker.reserved());\n-        }\n     }\n \n     /** */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\nindex b8ac9483da2..3d10dadca78 100644\n--- a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n+++ b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n", "chunk": "@@ -155,11 +155,11 @@ public class AggregateDataCollecting extends AggregateData implements Iterable<V\n \n     /** {@inheritDoc} */\n     @Override public void cleanup(Session ses) {\n-        if (values != null && tracker != null) {\n+        if (values != null)\n             values = null;\n \n+        if (tracker != null)\n             tracker.release(tracker.reserved());\n-        }\n     }\n \n     /** */\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\nindex 3d10dadca78..cdb3524fb8f 100644\n--- a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n+++ b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n", "chunk": "@@ -149,36 +121,17 @@ public class AggregateDataCollecting extends AggregateData implements Iterable<V\n      *\n      * @return value of a shared argument\n      */\n-    public Value getSharedArgument() {\n+    Value getSharedArgument() {\n         return shared;\n     }\n \n     /** {@inheritDoc} */\n     @Override public void cleanup(Session ses) {\n-        if (values != null)\n+        H2MemoryTracker memTracker;\n+        if (values != null && (memTracker = ses.queryMemoryTracker()) != null) {\n             values = null;\n \n-        if (tracker != null)\n-            tracker.release(tracker.reserved());\n-    }\n-\n-    /** */\n-    @Override public long getMemory() {\n-        return tracker.reserved();\n-    }\n-\n-    /** */\n-    public boolean isDistinct() {\n-        return distinct;\n-    }\n-\n-    /** */\n-    public Collection<Value> values() {\n-        return values;\n-    }\n-\n-    /** */\n-    public static AggregateDataCollecting from(boolean distinct, Collection<Value> values, Value shared) {\n-        return new AggregateDataCollecting(distinct, values, shared);\n+            memTracker.release(memReserved);\n+        }\n     }\n }\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\nindex cdb3524fb8f..90d85570434 100644\n--- a/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n+++ b/modules/h2/src/main/java/org/h2/expression/aggregate/AggregateDataCollecting.java\n", "chunk": "@@ -131,7 +157,27 @@ class AggregateDataCollecting extends AggregateData implements Iterable<Value> {\n         if (values != null && (memTracker = ses.queryMemoryTracker()) != null) {\n             values = null;\n \n-            memTracker.release(memReserved);\n+            memTracker.released(memReserved);\n         }\n     }\n+\n+    /** */\n+    @Override public long getMemory() {\n+        return memReserved;\n+    }\n+\n+    /** */\n+    public boolean isDistinct() {\n+        return distinct;\n+    }\n+\n+    /** */\n+    public Collection<Value> values() {\n+        return values;\n+    }\n+\n+    /** */\n+    public static AggregateDataCollecting from(boolean distinct, Collection<Value> values, Value shared) {\n+        return new AggregateDataCollecting(distinct, values, shared);\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE4NDU4NA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388184584", "body": "This looks non optimal.\r\nLet's make stacktrace analyse as a second condition.\r\nif (canceled && X.hasCause...)\r\n\r\nAlso this conditions can be checked after 'errorCode' check.", "bodyText": "This looks non optimal.\nLet's make stacktrace analyse as a second condition.\nif (canceled && X.hasCause...)\nAlso this conditions can be checked after 'errorCode' check.", "bodyHTML": "<p dir=\"auto\">This looks non optimal.<br>\nLet's make stacktrace analyse as a second condition.<br>\nif (canceled &amp;&amp; X.hasCause...)</p>\n<p dir=\"auto\">Also this conditions can be checked after 'errorCode' check.</p>", "author": "AMashenkov", "createdAt": "2020-03-05T09:52:42Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java", "diffHunk": "@@ -162,6 +163,9 @@ private boolean fetchPage() throws IgniteCheckedException {\n                     return false;\n             }\n             catch (SQLException e) {\n+                if (X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class) && canceled)", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex fc2fff40232..9d338e079e6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -163,10 +163,10 @@ public abstract class H2ResultSetIterator<T> extends GridIteratorAdapter<T> impl\n                     return false;\n             }\n             catch (SQLException e) {\n-                if (X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class) && canceled)\n+                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n                     throw new QueryCancelledException();\n \n-                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n+                if (canceled && X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class))\n                     throw new QueryCancelledException();\n \n                 throw new IgniteSQLException(e);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex fc2fff40232..9d338e079e6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -163,10 +163,10 @@ public abstract class H2ResultSetIterator<T> extends GridIteratorAdapter<T> impl\n                     return false;\n             }\n             catch (SQLException e) {\n-                if (X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class) && canceled)\n+                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n                     throw new QueryCancelledException();\n \n-                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n+                if (canceled && X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class))\n                     throw new QueryCancelledException();\n \n                 throw new IgniteSQLException(e);\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex 9d338e079e6..0662a8f4a4a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -122,167 +81,73 @@ public abstract class H2ResultSetIterator<T> extends GridIteratorAdapter<T> impl\n \n         if (data != null) {\n             try {\n-                colCnt = data.getMetaData().getColumnCount();\n-\n-                ses = H2Utils.session(data.getStatement().getConnection());\n-\n-                page = new ArrayList<>(pageSize);\n+                row = new Object[data.getMetaData().getColumnCount()];\n             }\n             catch (SQLException e) {\n                 throw new IgniteCheckedException(e);\n             }\n         }\n-        else {\n-            colCnt = 0;\n-            page = null;\n+        else\n             row = null;\n-            ses = null;\n-        }\n-\n-        assert log != null;\n-        assert h2 != null;\n-        assert qryInfo != null;\n-\n-        fetchSizeInterceptor = new H2QueryFetchSizeInterceptor(h2, qryInfo, log);\n     }\n \n     /**\n-     * @return {@code true} if the next page is available.\n-     * @throws IgniteCheckedException On cancel.\n+     * @return {@code true} If next row was fetched successfully.\n      */\n-    private boolean fetchPage() throws IgniteCheckedException {\n-        lockTables();\n+    private boolean fetchNext() throws IgniteCheckedException {\n+        if (data == null)\n+            return false;\n \n         try {\n-            GridH2Table.checkTablesVersions(ses);\n-\n-            page.clear();\n-\n-            try {\n-                if (data.isClosed())\n-                    return false;\n-            }\n-            catch (SQLException e) {\n-                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n-                    throw new QueryCancelledException();\n-\n-                if (canceled && X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class))\n-                    throw new QueryCancelledException();\n+            if (!data.next()) {\n+                close();\n \n-                throw new IgniteSQLException(e);\n+                return false;\n             }\n \n-            for (int i = 0; i < pageSize; ++i) {\n-                try {\n-                    if (!data.next())\n-                        break;\n+            if (res != null) {\n+                Value[] values = res.currentRow();\n \n-                    row = new Object[colCnt];\n+                for (int c = 0; c < row.length; c++) {\n+                    Value val = values[c];\n \n-                    readRow();\n+                    if (val instanceof GridH2ValueCacheObject) {\n+                        GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n \n-                    page.add(row);\n-                }\n-                catch (SQLException e) {\n-                    close();\n-\n-                    if (e.getCause() instanceof IgniteSQLException)\n-                        throw (IgniteSQLException)e.getCause();\n-\n-                    if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n-                        throw new QueryCancelledException();\n-\n-                    if (canceled && X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class))\n-                        throw new QueryCancelledException();\n-\n-                    throw new IgniteSQLException(e);\n+                        row[c] = valCacheObj.getObject(true);\n+                    }\n+                    else\n+                        row[c] = val.getObject();\n                 }\n             }\n-\n-            if (F.isEmpty(page)) {\n-                rowIter = null;\n-\n-                return false;\n-            }\n             else {\n-                rowIter = page.iterator();\n-\n-                return true;\n+                for (int c = 0; c < row.length; c++)\n+                    row[c] = data.getObject(c + 1);\n             }\n-        }\n-        finally {\n-            unlockTables();\n-        }\n-    }\n \n-    /**\n-     * @throws SQLException On error.\n-     */\n-    private void readRow() throws SQLException {\n-        if (res != null) {\n-            Value[] values = res.currentRow();\n-\n-            for (int c = 0; c < row.length; c++) {\n-                Value val = values[c];\n-\n-                if (val instanceof GridH2ValueCacheObject) {\n-                    GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n-\n-                    row[c] = valCacheObj.getObject(true);\n-                }\n-                else\n-                    row[c] = val.getObject();\n-            }\n-        }\n-        else {\n-            for (int c = 0; c < row.length; c++)\n-                row[c] = data.getObject(c + 1);\n+            return true;\n         }\n-    }\n+        catch (SQLException e) {\n+            if (e.getCause() instanceof IgniteSQLException)\n+                throw (IgniteSQLException)e.getCause();\n \n-    /** */\n-    public void lockTables() {\n-        if (ses.isLazyQueryExecution() && !isClosed())\n-            GridH2Table.readLockTables(ses);\n+            throw new IgniteSQLException(e);\n+        }\n     }\n \n-    /** */\n-    public void unlockTables() {\n-        if (ses.isLazyQueryExecution())\n-            GridH2Table.unlockTables(ses);\n+    /** {@inheritDoc} */\n+    @Override public boolean onHasNext() throws IgniteCheckedException {\n+        return hasRow || (hasRow = fetchNext());\n     }\n \n-    /**\n-     * @return {@code true} If next row was fetched successfully.\n-     * @throws IgniteCheckedException On error.\n-     */\n-    private synchronized boolean fetchNext() throws IgniteCheckedException {\n-        if (canceled)\n-            throw new QueryCancelledException();\n-\n-        if (rowIter != null && rowIter.hasNext()) {\n-            row = rowIter.next();\n-\n-            fetchSizeInterceptor.checkOnFetchNext();\n-\n-            return true;\n-        }\n-\n-        if (!fetchPage()) {\n-            closeInternal();\n-\n-            return false;\n-        }\n-\n-        if (rowIter != null && rowIter.hasNext()) {\n-            row = rowIter.next();\n+    /** {@inheritDoc} */\n+    @Override public T onNext() {\n+        if (!hasNext())\n+            throw new NoSuchElementException();\n \n-            fetchSizeInterceptor.checkOnFetchNext();\n+        hasRow = false;\n \n-            return true;\n-        }\n-        else\n-            return false;\n+        return createRow();\n     }\n \n     /**\n", "next_change": {"commit": "362558c658b512e561eb9208cd1178c90d0431f7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex 0662a8f4a4a..e7953cc74f5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -81,73 +121,161 @@ public abstract class H2ResultSetIterator<T> extends GridCloseableIteratorAdapte\n \n         if (data != null) {\n             try {\n-                row = new Object[data.getMetaData().getColumnCount()];\n+                colCnt = data.getMetaData().getColumnCount();\n+\n+                ses = H2Utils.session(data.getStatement().getConnection());\n+\n+                page = new ArrayList<>(pageSize);\n             }\n             catch (SQLException e) {\n                 throw new IgniteCheckedException(e);\n             }\n         }\n-        else\n+        else {\n+            colCnt = 0;\n+            page = null;\n             row = null;\n+            ses = null;\n+        }\n+\n+        assert log != null;\n+        assert h2 != null;\n+        assert qryInfo != null;\n+\n+        fetchSizeInterceptor = new H2QueryFetchSizeInterceptor(h2, qryInfo, log);\n     }\n \n     /**\n-     * @return {@code true} If next row was fetched successfully.\n+     * @return {@code true} if the next page is available.\n+     * @throws IgniteCheckedException On cancel.\n      */\n-    private boolean fetchNext() throws IgniteCheckedException {\n-        if (data == null)\n-            return false;\n+    private boolean fetchPage() throws IgniteCheckedException {\n+        lockTables();\n \n         try {\n-            if (!data.next()) {\n-                close();\n+            GridH2Table.checkTablesVersions(ses);\n \n-                return false;\n+            page.clear();\n+\n+            try {\n+                if (data.isClosed())\n+                    return false;\n             }\n+            catch (SQLException e) {\n+                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n+                    throw new QueryCancelledException();\n \n-            if (res != null) {\n-                Value[] values = res.currentRow();\n+                throw new IgniteSQLException(e);\n+            }\n \n-                for (int c = 0; c < row.length; c++) {\n-                    Value val = values[c];\n+            for (int i = 0; i < pageSize; ++i) {\n+                try {\n+                    if (!data.next())\n+                        break;\n \n-                    if (val instanceof GridH2ValueCacheObject) {\n-                        GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n+                    row = new Object[colCnt];\n \n-                        row[c] = valCacheObj.getObject(true);\n-                    }\n-                    else\n-                        row[c] = val.getObject();\n+                    readRow();\n+\n+                    page.add(row);\n+                }\n+                catch (SQLException e) {\n+                    close();\n+\n+                    if (e.getCause() instanceof IgniteSQLException)\n+                        throw (IgniteSQLException)e.getCause();\n+\n+                    if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n+                        throw new QueryCancelledException();\n+\n+                    throw new IgniteSQLException(e);\n                 }\n             }\n-            else {\n-                for (int c = 0; c < row.length; c++)\n-                    row[c] = data.getObject(c + 1);\n+\n+            if (F.isEmpty(page)) {\n+                rowIter = null;\n+\n+                return false;\n             }\n+            else {\n+                rowIter = page.iterator();\n \n-            return true;\n+                return true;\n+            }\n         }\n-        catch (SQLException e) {\n-            if (e.getCause() instanceof IgniteSQLException)\n-                throw (IgniteSQLException)e.getCause();\n+        finally {\n+            unlockTables();\n+        }\n+    }\n \n-            throw new IgniteSQLException(e);\n+    /**\n+     * @throws SQLException On error.\n+     */\n+    private void readRow() throws SQLException {\n+        if (res != null) {\n+            Value[] values = res.currentRow();\n+\n+            for (int c = 0; c < row.length; c++) {\n+                Value val = values[c];\n+\n+                if (val instanceof GridH2ValueCacheObject) {\n+                    GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n+\n+                    row[c] = valCacheObj.getObject(true);\n+                }\n+                else\n+                    row[c] = val.getObject();\n+            }\n+        }\n+        else {\n+            for (int c = 0; c < row.length; c++)\n+                row[c] = data.getObject(c + 1);\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public boolean onHasNext() throws IgniteCheckedException {\n-        return hasRow || (hasRow = fetchNext());\n+    /** */\n+    public void lockTables() {\n+        if (ses.isLazyQueryExecution() && !isClosed())\n+            GridH2Table.readLockTables(ses);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public T onNext() {\n-        if (!hasNext())\n-            throw new NoSuchElementException();\n+    /** */\n+    public void unlockTables() {\n+        if (ses.isLazyQueryExecution())\n+            GridH2Table.unlockTables(ses);\n+    }\n \n-        hasRow = false;\n+    /**\n+     * @return {@code true} If next row was fetched successfully.\n+     * @throws IgniteCheckedException On error.\n+     */\n+    private synchronized boolean fetchNext() throws IgniteCheckedException {\n+        if (canceled)\n+            throw new QueryCancelledException();\n \n-        return createRow();\n+        if (rowIter != null && rowIter.hasNext()) {\n+            row = rowIter.next();\n+\n+            fetchSizeInterceptor.checkOnFetchNext();\n+\n+            return true;\n+        }\n+\n+        if (!fetchPage()) {\n+            closeInternal();\n+\n+            return false;\n+        }\n+\n+        if (rowIter != null && rowIter.hasNext()) {\n+            row = rowIter.next();\n+\n+            fetchSizeInterceptor.checkOnFetchNext();\n+\n+            return true;\n+        }\n+        else\n+            return false;\n     }\n \n     /**\n", "next_change": null}, {"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex 0662a8f4a4a..e7953cc74f5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -155,18 +283,19 @@ public abstract class H2ResultSetIterator<T> extends GridCloseableIteratorAdapte\n      */\n     protected abstract T createRow();\n \n-    /** {@inheritDoc} */\n-    @Override public void onRemove() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void onClose() throws IgniteCheckedException {\n+    /**\n+     * @throws IgniteCheckedException On error.\n+     */\n+    public void onClose() throws IgniteCheckedException {\n         if (data == null)\n             // Nothing to close.\n             return;\n \n+        lockTables();\n+\n         try {\n+            fetchSizeInterceptor.checkOnClose();\n+\n             data.close();\n         }\n         catch (SQLException e) {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "f3d5e5b81fa448e1602a1929367726281a6091c6", "committedDate": "2019-10-25 15:28:05 +0300", "message": "GG-24808 SQL: print warning log message when query's result is big"}, {"oid": "71b775cdf86a15ed0b8da7e65bed60f175e19a55", "committedDate": "2019-10-30 16:09:15 +0300", "message": "GG-19120 ConnectionManager refactoring"}, {"oid": "362558c658b512e561eb9208cd1178c90d0431f7", "committedDate": "2019-12-25 12:38:44 +0300", "message": "GG-21236 fix H2ResultSetIterator and QueryCursors for local queries in lazy mode"}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "1df7bb1673bdd845166dbfe0fd435cfdad066359", "committedDate": "2020-11-06 12:23:18 +0300", "message": "GG-31352 fix SYSDATE type and convert INTERVAL to long"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE4NTIwNA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388185204", "body": "Is it safe to skip Iterator close() call?", "bodyText": "Is it safe to skip Iterator close() call?", "bodyHTML": "<p dir=\"auto\">Is it safe to skip Iterator close() call?</p>", "author": "AMashenkov", "createdAt": "2020-03-05T09:53:48Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java", "diffHunk": "@@ -180,6 +184,9 @@ private boolean fetchPage() throws IgniteCheckedException {\n                     page.add(row);\n                 }\n                 catch (SQLException e) {\n+                    if (X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class) && canceled)", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NTA3MA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388255070", "bodyText": "No it isn't. I've move this check after close() invoking.", "author": "korlov42", "createdAt": "2020-03-05T12:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE4NTIwNA=="}], "type": "inlineReview", "revised_code": {"commit": "8eb17e884a8872215837da42eb32293bfb3021c1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex fc2fff40232..806580f2019 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -184,9 +184,6 @@ public abstract class H2ResultSetIterator<T> extends GridIteratorAdapter<T> impl\n                     page.add(row);\n                 }\n                 catch (SQLException e) {\n-                    if (X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class) && canceled)\n-                        throw new QueryCancelledException();\n-\n                     close();\n \n                     if (e.getCause() instanceof IgniteSQLException)\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex fc2fff40232..9d338e079e6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -184,9 +184,6 @@ public abstract class H2ResultSetIterator<T> extends GridIteratorAdapter<T> impl\n                     page.add(row);\n                 }\n                 catch (SQLException e) {\n-                    if (X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class) && canceled)\n-                        throw new QueryCancelledException();\n-\n                     close();\n \n                     if (e.getCause() instanceof IgniteSQLException)\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex 9d338e079e6..0662a8f4a4a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -122,167 +81,73 @@ public abstract class H2ResultSetIterator<T> extends GridIteratorAdapter<T> impl\n \n         if (data != null) {\n             try {\n-                colCnt = data.getMetaData().getColumnCount();\n-\n-                ses = H2Utils.session(data.getStatement().getConnection());\n-\n-                page = new ArrayList<>(pageSize);\n+                row = new Object[data.getMetaData().getColumnCount()];\n             }\n             catch (SQLException e) {\n                 throw new IgniteCheckedException(e);\n             }\n         }\n-        else {\n-            colCnt = 0;\n-            page = null;\n+        else\n             row = null;\n-            ses = null;\n-        }\n-\n-        assert log != null;\n-        assert h2 != null;\n-        assert qryInfo != null;\n-\n-        fetchSizeInterceptor = new H2QueryFetchSizeInterceptor(h2, qryInfo, log);\n     }\n \n     /**\n-     * @return {@code true} if the next page is available.\n-     * @throws IgniteCheckedException On cancel.\n+     * @return {@code true} If next row was fetched successfully.\n      */\n-    private boolean fetchPage() throws IgniteCheckedException {\n-        lockTables();\n+    private boolean fetchNext() throws IgniteCheckedException {\n+        if (data == null)\n+            return false;\n \n         try {\n-            GridH2Table.checkTablesVersions(ses);\n-\n-            page.clear();\n-\n-            try {\n-                if (data.isClosed())\n-                    return false;\n-            }\n-            catch (SQLException e) {\n-                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n-                    throw new QueryCancelledException();\n-\n-                if (canceled && X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class))\n-                    throw new QueryCancelledException();\n+            if (!data.next()) {\n+                close();\n \n-                throw new IgniteSQLException(e);\n+                return false;\n             }\n \n-            for (int i = 0; i < pageSize; ++i) {\n-                try {\n-                    if (!data.next())\n-                        break;\n+            if (res != null) {\n+                Value[] values = res.currentRow();\n \n-                    row = new Object[colCnt];\n+                for (int c = 0; c < row.length; c++) {\n+                    Value val = values[c];\n \n-                    readRow();\n+                    if (val instanceof GridH2ValueCacheObject) {\n+                        GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n \n-                    page.add(row);\n-                }\n-                catch (SQLException e) {\n-                    close();\n-\n-                    if (e.getCause() instanceof IgniteSQLException)\n-                        throw (IgniteSQLException)e.getCause();\n-\n-                    if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n-                        throw new QueryCancelledException();\n-\n-                    if (canceled && X.hasCause(e, QueryMemoryTracker.TrackerWasClosedException.class))\n-                        throw new QueryCancelledException();\n-\n-                    throw new IgniteSQLException(e);\n+                        row[c] = valCacheObj.getObject(true);\n+                    }\n+                    else\n+                        row[c] = val.getObject();\n                 }\n             }\n-\n-            if (F.isEmpty(page)) {\n-                rowIter = null;\n-\n-                return false;\n-            }\n             else {\n-                rowIter = page.iterator();\n-\n-                return true;\n+                for (int c = 0; c < row.length; c++)\n+                    row[c] = data.getObject(c + 1);\n             }\n-        }\n-        finally {\n-            unlockTables();\n-        }\n-    }\n \n-    /**\n-     * @throws SQLException On error.\n-     */\n-    private void readRow() throws SQLException {\n-        if (res != null) {\n-            Value[] values = res.currentRow();\n-\n-            for (int c = 0; c < row.length; c++) {\n-                Value val = values[c];\n-\n-                if (val instanceof GridH2ValueCacheObject) {\n-                    GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n-\n-                    row[c] = valCacheObj.getObject(true);\n-                }\n-                else\n-                    row[c] = val.getObject();\n-            }\n-        }\n-        else {\n-            for (int c = 0; c < row.length; c++)\n-                row[c] = data.getObject(c + 1);\n+            return true;\n         }\n-    }\n+        catch (SQLException e) {\n+            if (e.getCause() instanceof IgniteSQLException)\n+                throw (IgniteSQLException)e.getCause();\n \n-    /** */\n-    public void lockTables() {\n-        if (ses.isLazyQueryExecution() && !isClosed())\n-            GridH2Table.readLockTables(ses);\n+            throw new IgniteSQLException(e);\n+        }\n     }\n \n-    /** */\n-    public void unlockTables() {\n-        if (ses.isLazyQueryExecution())\n-            GridH2Table.unlockTables(ses);\n+    /** {@inheritDoc} */\n+    @Override public boolean onHasNext() throws IgniteCheckedException {\n+        return hasRow || (hasRow = fetchNext());\n     }\n \n-    /**\n-     * @return {@code true} If next row was fetched successfully.\n-     * @throws IgniteCheckedException On error.\n-     */\n-    private synchronized boolean fetchNext() throws IgniteCheckedException {\n-        if (canceled)\n-            throw new QueryCancelledException();\n-\n-        if (rowIter != null && rowIter.hasNext()) {\n-            row = rowIter.next();\n-\n-            fetchSizeInterceptor.checkOnFetchNext();\n-\n-            return true;\n-        }\n-\n-        if (!fetchPage()) {\n-            closeInternal();\n-\n-            return false;\n-        }\n-\n-        if (rowIter != null && rowIter.hasNext()) {\n-            row = rowIter.next();\n+    /** {@inheritDoc} */\n+    @Override public T onNext() {\n+        if (!hasNext())\n+            throw new NoSuchElementException();\n \n-            fetchSizeInterceptor.checkOnFetchNext();\n+        hasRow = false;\n \n-            return true;\n-        }\n-        else\n-            return false;\n+        return createRow();\n     }\n \n     /**\n", "next_change": {"commit": "362558c658b512e561eb9208cd1178c90d0431f7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex 0662a8f4a4a..e7953cc74f5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -81,73 +121,161 @@ public abstract class H2ResultSetIterator<T> extends GridCloseableIteratorAdapte\n \n         if (data != null) {\n             try {\n-                row = new Object[data.getMetaData().getColumnCount()];\n+                colCnt = data.getMetaData().getColumnCount();\n+\n+                ses = H2Utils.session(data.getStatement().getConnection());\n+\n+                page = new ArrayList<>(pageSize);\n             }\n             catch (SQLException e) {\n                 throw new IgniteCheckedException(e);\n             }\n         }\n-        else\n+        else {\n+            colCnt = 0;\n+            page = null;\n             row = null;\n+            ses = null;\n+        }\n+\n+        assert log != null;\n+        assert h2 != null;\n+        assert qryInfo != null;\n+\n+        fetchSizeInterceptor = new H2QueryFetchSizeInterceptor(h2, qryInfo, log);\n     }\n \n     /**\n-     * @return {@code true} If next row was fetched successfully.\n+     * @return {@code true} if the next page is available.\n+     * @throws IgniteCheckedException On cancel.\n      */\n-    private boolean fetchNext() throws IgniteCheckedException {\n-        if (data == null)\n-            return false;\n+    private boolean fetchPage() throws IgniteCheckedException {\n+        lockTables();\n \n         try {\n-            if (!data.next()) {\n-                close();\n+            GridH2Table.checkTablesVersions(ses);\n \n-                return false;\n+            page.clear();\n+\n+            try {\n+                if (data.isClosed())\n+                    return false;\n             }\n+            catch (SQLException e) {\n+                if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n+                    throw new QueryCancelledException();\n \n-            if (res != null) {\n-                Value[] values = res.currentRow();\n+                throw new IgniteSQLException(e);\n+            }\n \n-                for (int c = 0; c < row.length; c++) {\n-                    Value val = values[c];\n+            for (int i = 0; i < pageSize; ++i) {\n+                try {\n+                    if (!data.next())\n+                        break;\n \n-                    if (val instanceof GridH2ValueCacheObject) {\n-                        GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n+                    row = new Object[colCnt];\n \n-                        row[c] = valCacheObj.getObject(true);\n-                    }\n-                    else\n-                        row[c] = val.getObject();\n+                    readRow();\n+\n+                    page.add(row);\n+                }\n+                catch (SQLException e) {\n+                    close();\n+\n+                    if (e.getCause() instanceof IgniteSQLException)\n+                        throw (IgniteSQLException)e.getCause();\n+\n+                    if (e.getErrorCode() == ErrorCode.STATEMENT_WAS_CANCELED)\n+                        throw new QueryCancelledException();\n+\n+                    throw new IgniteSQLException(e);\n                 }\n             }\n-            else {\n-                for (int c = 0; c < row.length; c++)\n-                    row[c] = data.getObject(c + 1);\n+\n+            if (F.isEmpty(page)) {\n+                rowIter = null;\n+\n+                return false;\n             }\n+            else {\n+                rowIter = page.iterator();\n \n-            return true;\n+                return true;\n+            }\n         }\n-        catch (SQLException e) {\n-            if (e.getCause() instanceof IgniteSQLException)\n-                throw (IgniteSQLException)e.getCause();\n+        finally {\n+            unlockTables();\n+        }\n+    }\n \n-            throw new IgniteSQLException(e);\n+    /**\n+     * @throws SQLException On error.\n+     */\n+    private void readRow() throws SQLException {\n+        if (res != null) {\n+            Value[] values = res.currentRow();\n+\n+            for (int c = 0; c < row.length; c++) {\n+                Value val = values[c];\n+\n+                if (val instanceof GridH2ValueCacheObject) {\n+                    GridH2ValueCacheObject valCacheObj = (GridH2ValueCacheObject)values[c];\n+\n+                    row[c] = valCacheObj.getObject(true);\n+                }\n+                else\n+                    row[c] = val.getObject();\n+            }\n+        }\n+        else {\n+            for (int c = 0; c < row.length; c++)\n+                row[c] = data.getObject(c + 1);\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public boolean onHasNext() throws IgniteCheckedException {\n-        return hasRow || (hasRow = fetchNext());\n+    /** */\n+    public void lockTables() {\n+        if (ses.isLazyQueryExecution() && !isClosed())\n+            GridH2Table.readLockTables(ses);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public T onNext() {\n-        if (!hasNext())\n-            throw new NoSuchElementException();\n+    /** */\n+    public void unlockTables() {\n+        if (ses.isLazyQueryExecution())\n+            GridH2Table.unlockTables(ses);\n+    }\n \n-        hasRow = false;\n+    /**\n+     * @return {@code true} If next row was fetched successfully.\n+     * @throws IgniteCheckedException On error.\n+     */\n+    private synchronized boolean fetchNext() throws IgniteCheckedException {\n+        if (canceled)\n+            throw new QueryCancelledException();\n \n-        return createRow();\n+        if (rowIter != null && rowIter.hasNext()) {\n+            row = rowIter.next();\n+\n+            fetchSizeInterceptor.checkOnFetchNext();\n+\n+            return true;\n+        }\n+\n+        if (!fetchPage()) {\n+            closeInternal();\n+\n+            return false;\n+        }\n+\n+        if (rowIter != null && rowIter.hasNext()) {\n+            row = rowIter.next();\n+\n+            fetchSizeInterceptor.checkOnFetchNext();\n+\n+            return true;\n+        }\n+        else\n+            return false;\n     }\n \n     /**\n", "next_change": null}, {"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\nindex 0662a8f4a4a..e7953cc74f5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ResultSetIterator.java\n", "chunk": "@@ -155,18 +283,19 @@ public abstract class H2ResultSetIterator<T> extends GridCloseableIteratorAdapte\n      */\n     protected abstract T createRow();\n \n-    /** {@inheritDoc} */\n-    @Override public void onRemove() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void onClose() throws IgniteCheckedException {\n+    /**\n+     * @throws IgniteCheckedException On error.\n+     */\n+    public void onClose() throws IgniteCheckedException {\n         if (data == null)\n             // Nothing to close.\n             return;\n \n+        lockTables();\n+\n         try {\n+            fetchSizeInterceptor.checkOnClose();\n+\n             data.close();\n         }\n         catch (SQLException e) {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "f3d5e5b81fa448e1602a1929367726281a6091c6", "committedDate": "2019-10-25 15:28:05 +0300", "message": "GG-24808 SQL: print warning log message when query's result is big"}, {"oid": "71b775cdf86a15ed0b8da7e65bed60f175e19a55", "committedDate": "2019-10-30 16:09:15 +0300", "message": "GG-19120 ConnectionManager refactoring"}, {"oid": "362558c658b512e561eb9208cd1178c90d0431f7", "committedDate": "2019-12-25 12:38:44 +0300", "message": "GG-21236 fix H2ResultSetIterator and QueryCursors for local queries in lazy mode"}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "1df7bb1673bdd845166dbfe0fd435cfdad066359", "committedDate": "2020-11-06 12:23:18 +0300", "message": "GG-31352 fix SYSDATE type and convert INTERVAL to long"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwMTgxOA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388201818", "body": "Actually, there is no need to have reference to AtomicBoolean object.\r\nIt can be replaced with primitive and CAS can be replaced with Unsafe field update operation.", "bodyText": "Actually, there is no need to have reference to AtomicBoolean object.\nIt can be replaced with primitive and CAS can be replaced with Unsafe field update operation.", "bodyHTML": "<p dir=\"auto\">Actually, there is no need to have reference to AtomicBoolean object.<br>\nIt can be replaced with primitive and CAS can be replaced with Unsafe field update operation.</p>", "author": "AMashenkov", "createdAt": "2020-03-05T10:23:52Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -203,74 +224,223 @@ public boolean isOffloadingEnabled() {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void swap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.swap(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unswap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unswap(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!closing.compareAndSet(false, true))", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c338d0c298b..133f140486a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -267,11 +279,15 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!closing.compareAndSet(false, true))\n+        if (!CLOSING_UPDATER.compareAndSet(this, NORMALLY_OPERATING_STATE, CLOSING_OR_CLOSED_STATE))\n             return;\n \n-        for (H2MemoryTracker child : children)\n-            child.close();\n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n \n         closed = true;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c338d0c298b..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -267,11 +278,15 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!closing.compareAndSet(false, true))\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n-        for (H2MemoryTracker child : children)\n-            child.close();\n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n \n         closed = true;\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -278,192 +152,16 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-            return;\n-\n-        synchronized (this) {\n-            for (H2MemoryTracker child : children)\n-                child.close();\n+        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n+            release(RESERVED_UPD.get(this));\n \n-            children.clear();\n+            if (parent != null)\n+                parent.release(reservedFromParent);\n         }\n-\n-        closed = true;\n-\n-        reserved = 0;\n-\n-        if (parent != null)\n-            parent.release(reservedFromParent);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        if (parent != null)\n-            parent.incrementFilesCreated();\n-\n-        filesCreated++;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized H2MemoryTracker createChildTracker() {\n-        checkClosed();\n-\n-        H2MemoryTracker child = new ChildMemoryTracker(this);\n-\n-        children.add(child);\n-\n-        return child;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n-        if (state != STATE_CLOSED)\n-            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-\n-    /** */\n-    private static class ChildMemoryTracker implements H2MemoryTracker {\n-        /** State updater. */\n-        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n-            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n-\n-        /** */\n-        private final H2MemoryTracker parent;\n-\n-        /** */\n-        private long reserved;\n-\n-        /** */\n-        private long writtenOnDisk;\n-\n-        /** */\n-        private long totalWrittenOnDisk;\n-\n-        /** */\n-        private volatile int state;\n-\n-        /**\n-         * @param parent Parent.\n-         */\n-        public ChildMemoryTracker(H2MemoryTracker parent) {\n-            this.parent = parent;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean reserve(long size) {\n-            checkClosed();\n-\n-            boolean res;\n-            try {\n-                res = parent.reserve(size);\n-            }\n-            finally {\n-                reserved += size;\n-            }\n-\n-            return res;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void release(long size) {\n-            checkClosed();\n-\n-            reserved -= size;\n-\n-            parent.release(size);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long writtenOnDisk() {\n-            return writtenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long totalWrittenOnDisk() {\n-            return totalWrittenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long reserved() {\n-            return reserved;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void spill(long size) {\n-            checkClosed();\n-\n-            parent.spill(size);\n-\n-            writtenOnDisk += size;\n-            totalWrittenOnDisk += size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void unspill(long size) {\n-            checkClosed();\n-\n-            parent.unspill(size);\n-\n-            writtenOnDisk -= size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void incrementFilesCreated() {\n-            checkClosed();\n-\n-            parent.incrementFilesCreated();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public H2MemoryTracker createChildTracker() {\n-            checkClosed();\n-\n-            return parent.createChildTracker();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void onChildClosed(H2MemoryTracker child) {\n-            parent.onChildClosed(child);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean closed() {\n-            return state == STATE_CLOSED;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() {\n-            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-                return;\n-\n-            parent.release(reserved);\n-            parent.unspill(writtenOnDisk);\n-\n-            reserved = 0;\n-            writtenOnDisk = 0;\n-\n-            parent.onChildClosed(this);\n-        }\n-\n-        /** */\n-        private void checkClosed() {\n-            if (state == STATE_CLOSED)\n-                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-        }\n-    }\n-\n-    /** Exception thrown when try to track memory with closed tracker. */\n-    public static class TrackerWasClosedException extends RuntimeException {\n-        /**\n-         * @param msg Message.\n-         */\n-        public TrackerWasClosedException(String msg) {\n-            super(msg);\n-        }\n-    }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -27,139 +26,249 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n-    /** Resered field updater. */\n-    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n-        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n-\n-    /** Closed flag updater. */\n-    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n-        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n+public class QueryMemoryTracker implements H2MemoryTracker {\n+    /** Logger. */\n+    private final IgniteLogger log;\n \n     /** Parent tracker. */\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long maxMem;\n+    private final long quota;\n+\n+    /**\n+     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n+     * <ul>\n+     * <li>{@code false} - exception will be thrown.</li>\n+     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n+     * </ul>\n+     */\n+    private final boolean offloadingEnabled;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private volatile long reservedFromParent;\n+    private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private volatile long reserved;\n+    private long reserved;\n \n     /** Close flag to prevent tracker reuse. */\n-    private volatile Boolean closed = Boolean.FALSE;\n+    private Boolean closed = Boolean.FALSE;\n+\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n+\n+    /** Total number of bytes tracked by current tracker. */\n+    private volatile long totalReserved;\n+\n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n+\n+    /** Query descriptor (for logging). */\n+    private final String qryDesc;\n \n     /**\n      * Constructor.\n      *\n+     * @param log Logger.\n      * @param parent Parent memory tracker.\n-     * @param maxMem Query memory limit in bytes.\n+     * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n+     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n      */\n-    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n-        assert maxMem > 0;\n-\n+    QueryMemoryTracker(\n+        IgniteLogger log,\n+        H2MemoryTracker parent,\n+        long quota,\n+        long blockSize,\n+        boolean offloadingEnabled,\n+        String qryDesc) {\n+        assert quota >= 0;\n+\n+        this.log = log;\n+        this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n-        this.maxMem = maxMem;\n-        this.blockSize = blockSize;\n+        this.quota = quota;\n+        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n+        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void reserve(long size) {\n-        assert !closed && size >= 0;\n+    @Override public synchronized boolean reserved(long toReserve) {\n+        assert toReserve >= 0;\n \n-        if (size == 0)\n-            return;\n+        checkClosed();\n \n-        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n-            if (prev + x > maxMem) {\n-                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-            }\n+        reserved += toReserve;\n+        totalReserved += toReserve;\n \n-            return prev + x;\n-        });\n+        if (parent != null && reserved > reservedFromParent) {\n+            if (!reserveFromParent())\n+                return false; // Offloading.\n+        }\n \n-        if (parent != null && reserved0 > reservedFromParent) {\n-            synchronized (this) {\n-                assert !closed;\n+        if (quota > 0 && reserved >= quota)\n+            return onQuotaExceeded();\n \n-                if (reserved0 <= reservedFromParent)\n-                    return;\n+        return true;\n+    }\n \n-                // If single block size is too small.\n-                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n-                // If we are too close to limit.\n-                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n+    /**\n+     * Checks whether tracker was closed.\n+     */\n+    private void checkClosed() {\n+        if (closed)\n+            throw new IllegalStateException(\"Memory tracker has been closed concurrently.\");\n+    }\n \n-                try {\n-                    parent.reserve(blockSize);\n+    /**\n+     * Reserves memory from parent tracker.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean reserveFromParent() {\n+        // If single block size is too small.\n+        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n \n-                    reservedFromParent += blockSize;\n-                }\n-                catch (Throwable e) {\n-                    // Fallback if failed to reserve.\n-                    RESERVED_UPD.addAndGet(this, -size);\n+        // If we are too close to limit.\n+        if (quota > 0)\n+            blockSize = Math.min(blockSize, quota - reservedFromParent);\n \n-                    throw e;\n-                }\n-            }\n-        }\n+        if (parent.reserved(blockSize))\n+            reservedFromParent += blockSize;\n+        else\n+            return false;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Action on quota exceeded.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean onQuotaExceeded() {\n+        if (offloadingEnabled)\n+            return false;\n+        else\n+            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void release(long size) {\n-        assert size >= 0;\n+    @Override public synchronized void released(long toRelease) {\n+        assert toRelease >= 0;\n \n-        if (size == 0)\n+        if (toRelease == 0)\n             return;\n \n-        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n-            if (prev + x < 0)\n-                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n-                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n+        checkClosed();\n+\n+        reserved -= toRelease;\n+\n+        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + toRelease) +\n+            \", toFree=\" + toRelease + ']';\n \n-            return prev + x;\n-        });\n+        if (parent != null && reservedFromParent - reserved > blockSize)\n+            releaseFromParent();\n+    }\n+\n+    /**\n+     * Releases memory from parent.\n+     */\n+    private void releaseFromParent() {\n+        long toReleaseFromParent = reservedFromParent - reserved;\n \n-        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n+        parent.released(toReleaseFromParent);\n \n-        // For now, won'tQ release memory to parent until tracker closed.\n-       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n-            synchronized (this) {\n-                if (preAllocated - reserved >= 2 * blockSize) {\n-                    parent.release(blockSize);\n+        reservedFromParent -= toReleaseFromParent;\n \n-                    preAllocated -= blockSize;\n-                }\n-            }\n-        }*/\n+        assert reservedFromParent >= 0 : reservedFromParent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized long memoryReserved() {\n+        return reserved;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long memoryLimit() {\n+        return quota;\n+    }\n+\n+    /**\n+     * @return Offloading enabled flag.\n+     */\n+    public boolean isOffloadingEnabled() {\n+        return offloadingEnabled;\n     }\n \n     /**\n      * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    public boolean closed() {\n+    public synchronized boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        if (closed)\n+            return;\n+\n+        closed = true;\n \n-            if (parent != null)\n-                parent.release(reservedFromParent);\n+        reserved = 0;\n+\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n         }\n     }\n \n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n+    }\n+\n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwMjUzNg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388202536", "body": "There is no need to have heavy concurrent structure as collection is used mostly in single thread.\r\nWe can wrap it into synchronized", "bodyText": "There is no need to have heavy concurrent structure as collection is used mostly in single thread.\nWe can wrap it into synchronized", "bodyHTML": "<p dir=\"auto\">There is no need to have heavy concurrent structure as collection is used mostly in single thread.<br>\nWe can wrap it into synchronized</p>", "author": "AMashenkov", "createdAt": "2020-03-05T10:25:09Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -203,74 +224,223 @@ public boolean isOffloadingEnabled() {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void swap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.swap(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unswap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unswap(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!closing.compareAndSet(false, true))\n             return;\n \n+        for (H2MemoryTracker child : children)", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c338d0c298b..133f140486a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -267,11 +279,15 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!closing.compareAndSet(false, true))\n+        if (!CLOSING_UPDATER.compareAndSet(this, NORMALLY_OPERATING_STATE, CLOSING_OR_CLOSED_STATE))\n             return;\n \n-        for (H2MemoryTracker child : children)\n-            child.close();\n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n \n         closed = true;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c338d0c298b..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -267,11 +278,15 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!closing.compareAndSet(false, true))\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n-        for (H2MemoryTracker child : children)\n-            child.close();\n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n \n         closed = true;\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -278,192 +152,16 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-            return;\n-\n-        synchronized (this) {\n-            for (H2MemoryTracker child : children)\n-                child.close();\n+        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n+            release(RESERVED_UPD.get(this));\n \n-            children.clear();\n+            if (parent != null)\n+                parent.release(reservedFromParent);\n         }\n-\n-        closed = true;\n-\n-        reserved = 0;\n-\n-        if (parent != null)\n-            parent.release(reservedFromParent);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        if (parent != null)\n-            parent.incrementFilesCreated();\n-\n-        filesCreated++;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized H2MemoryTracker createChildTracker() {\n-        checkClosed();\n-\n-        H2MemoryTracker child = new ChildMemoryTracker(this);\n-\n-        children.add(child);\n-\n-        return child;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n-        if (state != STATE_CLOSED)\n-            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-\n-    /** */\n-    private static class ChildMemoryTracker implements H2MemoryTracker {\n-        /** State updater. */\n-        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n-            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n-\n-        /** */\n-        private final H2MemoryTracker parent;\n-\n-        /** */\n-        private long reserved;\n-\n-        /** */\n-        private long writtenOnDisk;\n-\n-        /** */\n-        private long totalWrittenOnDisk;\n-\n-        /** */\n-        private volatile int state;\n-\n-        /**\n-         * @param parent Parent.\n-         */\n-        public ChildMemoryTracker(H2MemoryTracker parent) {\n-            this.parent = parent;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean reserve(long size) {\n-            checkClosed();\n-\n-            boolean res;\n-            try {\n-                res = parent.reserve(size);\n-            }\n-            finally {\n-                reserved += size;\n-            }\n-\n-            return res;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void release(long size) {\n-            checkClosed();\n-\n-            reserved -= size;\n-\n-            parent.release(size);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long writtenOnDisk() {\n-            return writtenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long totalWrittenOnDisk() {\n-            return totalWrittenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long reserved() {\n-            return reserved;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void spill(long size) {\n-            checkClosed();\n-\n-            parent.spill(size);\n-\n-            writtenOnDisk += size;\n-            totalWrittenOnDisk += size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void unspill(long size) {\n-            checkClosed();\n-\n-            parent.unspill(size);\n-\n-            writtenOnDisk -= size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void incrementFilesCreated() {\n-            checkClosed();\n-\n-            parent.incrementFilesCreated();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public H2MemoryTracker createChildTracker() {\n-            checkClosed();\n-\n-            return parent.createChildTracker();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void onChildClosed(H2MemoryTracker child) {\n-            parent.onChildClosed(child);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean closed() {\n-            return state == STATE_CLOSED;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() {\n-            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-                return;\n-\n-            parent.release(reserved);\n-            parent.unspill(writtenOnDisk);\n-\n-            reserved = 0;\n-            writtenOnDisk = 0;\n-\n-            parent.onChildClosed(this);\n-        }\n-\n-        /** */\n-        private void checkClosed() {\n-            if (state == STATE_CLOSED)\n-                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-        }\n-    }\n-\n-    /** Exception thrown when try to track memory with closed tracker. */\n-    public static class TrackerWasClosedException extends RuntimeException {\n-        /**\n-         * @param msg Message.\n-         */\n-        public TrackerWasClosedException(String msg) {\n-            super(msg);\n-        }\n-    }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -27,139 +26,249 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n-    /** Resered field updater. */\n-    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n-        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n-\n-    /** Closed flag updater. */\n-    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n-        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n+public class QueryMemoryTracker implements H2MemoryTracker {\n+    /** Logger. */\n+    private final IgniteLogger log;\n \n     /** Parent tracker. */\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long maxMem;\n+    private final long quota;\n+\n+    /**\n+     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n+     * <ul>\n+     * <li>{@code false} - exception will be thrown.</li>\n+     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n+     * </ul>\n+     */\n+    private final boolean offloadingEnabled;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private volatile long reservedFromParent;\n+    private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private volatile long reserved;\n+    private long reserved;\n \n     /** Close flag to prevent tracker reuse. */\n-    private volatile Boolean closed = Boolean.FALSE;\n+    private Boolean closed = Boolean.FALSE;\n+\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n+\n+    /** Total number of bytes tracked by current tracker. */\n+    private volatile long totalReserved;\n+\n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n+\n+    /** Query descriptor (for logging). */\n+    private final String qryDesc;\n \n     /**\n      * Constructor.\n      *\n+     * @param log Logger.\n      * @param parent Parent memory tracker.\n-     * @param maxMem Query memory limit in bytes.\n+     * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n+     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n      */\n-    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n-        assert maxMem > 0;\n-\n+    QueryMemoryTracker(\n+        IgniteLogger log,\n+        H2MemoryTracker parent,\n+        long quota,\n+        long blockSize,\n+        boolean offloadingEnabled,\n+        String qryDesc) {\n+        assert quota >= 0;\n+\n+        this.log = log;\n+        this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n-        this.maxMem = maxMem;\n-        this.blockSize = blockSize;\n+        this.quota = quota;\n+        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n+        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void reserve(long size) {\n-        assert !closed && size >= 0;\n+    @Override public synchronized boolean reserved(long toReserve) {\n+        assert toReserve >= 0;\n \n-        if (size == 0)\n-            return;\n+        checkClosed();\n \n-        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n-            if (prev + x > maxMem) {\n-                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-            }\n+        reserved += toReserve;\n+        totalReserved += toReserve;\n \n-            return prev + x;\n-        });\n+        if (parent != null && reserved > reservedFromParent) {\n+            if (!reserveFromParent())\n+                return false; // Offloading.\n+        }\n \n-        if (parent != null && reserved0 > reservedFromParent) {\n-            synchronized (this) {\n-                assert !closed;\n+        if (quota > 0 && reserved >= quota)\n+            return onQuotaExceeded();\n \n-                if (reserved0 <= reservedFromParent)\n-                    return;\n+        return true;\n+    }\n \n-                // If single block size is too small.\n-                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n-                // If we are too close to limit.\n-                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n+    /**\n+     * Checks whether tracker was closed.\n+     */\n+    private void checkClosed() {\n+        if (closed)\n+            throw new IllegalStateException(\"Memory tracker has been closed concurrently.\");\n+    }\n \n-                try {\n-                    parent.reserve(blockSize);\n+    /**\n+     * Reserves memory from parent tracker.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean reserveFromParent() {\n+        // If single block size is too small.\n+        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n \n-                    reservedFromParent += blockSize;\n-                }\n-                catch (Throwable e) {\n-                    // Fallback if failed to reserve.\n-                    RESERVED_UPD.addAndGet(this, -size);\n+        // If we are too close to limit.\n+        if (quota > 0)\n+            blockSize = Math.min(blockSize, quota - reservedFromParent);\n \n-                    throw e;\n-                }\n-            }\n-        }\n+        if (parent.reserved(blockSize))\n+            reservedFromParent += blockSize;\n+        else\n+            return false;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Action on quota exceeded.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean onQuotaExceeded() {\n+        if (offloadingEnabled)\n+            return false;\n+        else\n+            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void release(long size) {\n-        assert size >= 0;\n+    @Override public synchronized void released(long toRelease) {\n+        assert toRelease >= 0;\n \n-        if (size == 0)\n+        if (toRelease == 0)\n             return;\n \n-        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n-            if (prev + x < 0)\n-                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n-                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n+        checkClosed();\n+\n+        reserved -= toRelease;\n+\n+        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + toRelease) +\n+            \", toFree=\" + toRelease + ']';\n \n-            return prev + x;\n-        });\n+        if (parent != null && reservedFromParent - reserved > blockSize)\n+            releaseFromParent();\n+    }\n+\n+    /**\n+     * Releases memory from parent.\n+     */\n+    private void releaseFromParent() {\n+        long toReleaseFromParent = reservedFromParent - reserved;\n \n-        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n+        parent.released(toReleaseFromParent);\n \n-        // For now, won'tQ release memory to parent until tracker closed.\n-       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n-            synchronized (this) {\n-                if (preAllocated - reserved >= 2 * blockSize) {\n-                    parent.release(blockSize);\n+        reservedFromParent -= toReleaseFromParent;\n \n-                    preAllocated -= blockSize;\n-                }\n-            }\n-        }*/\n+        assert reservedFromParent >= 0 : reservedFromParent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized long memoryReserved() {\n+        return reserved;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long memoryLimit() {\n+        return quota;\n+    }\n+\n+    /**\n+     * @return Offloading enabled flag.\n+     */\n+    public boolean isOffloadingEnabled() {\n+        return offloadingEnabled;\n     }\n \n     /**\n      * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    public boolean closed() {\n+    public synchronized boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        if (closed)\n+            return;\n+\n+        closed = true;\n \n-            if (parent != null)\n-                parent.release(reservedFromParent);\n+        reserved = 0;\n+\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n         }\n     }\n \n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n+    }\n+\n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwMzcxOA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r388203718", "body": "synchronized", "bodyText": "synchronized", "bodyHTML": "<p dir=\"auto\">synchronized</p>", "author": "AMashenkov", "createdAt": "2020-03-05T10:27:18Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -203,74 +224,223 @@ public boolean isOffloadingEnabled() {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void swap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.swap(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unswap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unswap(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!closing.compareAndSet(false, true))\n             return;\n \n+        for (H2MemoryTracker child : children)\n+            child.close();\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n+            parent.release(reservedFromParent);\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+        onChildClosed(this);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public H2MemoryTracker createChildTracker() {", "originalCommit": "de3dd2ae3f106045b4340273542ef81211931b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c338d0c298b..133f140486a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -292,7 +306,7 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     }\n \n     /** {@inheritDoc} */\n-    @Override public H2MemoryTracker createChildTracker() {\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n         checkClosed();\n \n         H2MemoryTracker child = new ChildMemoryTracker();\n", "next_change": {"commit": "c895c69cc62f0f1f159d41d0339c458ff8fec293", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 133f140486a..c443b687658 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -309,7 +308,7 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public synchronized H2MemoryTracker createChildTracker() {\n         checkClosed();\n \n-        H2MemoryTracker child = new ChildMemoryTracker();\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n         children.add(child);\n \n", "next_change": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c443b687658..ff2d0f694bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -317,7 +317,7 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n \n     /** {@inheritDoc} */\n     @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n-        if (state != CLOSING_OR_CLOSED_STATE)\n+        if (state != STATE_CLOSED)\n             children.remove(child);\n     }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex c338d0c298b..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -292,10 +305,10 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     }\n \n     /** {@inheritDoc} */\n-    @Override public H2MemoryTracker createChildTracker() {\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n         checkClosed();\n \n-        H2MemoryTracker child = new ChildMemoryTracker();\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n         children.add(child);\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -278,192 +152,16 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-            return;\n-\n-        synchronized (this) {\n-            for (H2MemoryTracker child : children)\n-                child.close();\n+        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n+            release(RESERVED_UPD.get(this));\n \n-            children.clear();\n+            if (parent != null)\n+                parent.release(reservedFromParent);\n         }\n-\n-        closed = true;\n-\n-        reserved = 0;\n-\n-        if (parent != null)\n-            parent.release(reservedFromParent);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        if (parent != null)\n-            parent.incrementFilesCreated();\n-\n-        filesCreated++;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized H2MemoryTracker createChildTracker() {\n-        checkClosed();\n-\n-        H2MemoryTracker child = new ChildMemoryTracker(this);\n-\n-        children.add(child);\n-\n-        return child;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n-        if (state != STATE_CLOSED)\n-            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-\n-    /** */\n-    private static class ChildMemoryTracker implements H2MemoryTracker {\n-        /** State updater. */\n-        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n-            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n-\n-        /** */\n-        private final H2MemoryTracker parent;\n-\n-        /** */\n-        private long reserved;\n-\n-        /** */\n-        private long writtenOnDisk;\n-\n-        /** */\n-        private long totalWrittenOnDisk;\n-\n-        /** */\n-        private volatile int state;\n-\n-        /**\n-         * @param parent Parent.\n-         */\n-        public ChildMemoryTracker(H2MemoryTracker parent) {\n-            this.parent = parent;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean reserve(long size) {\n-            checkClosed();\n-\n-            boolean res;\n-            try {\n-                res = parent.reserve(size);\n-            }\n-            finally {\n-                reserved += size;\n-            }\n-\n-            return res;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void release(long size) {\n-            checkClosed();\n-\n-            reserved -= size;\n-\n-            parent.release(size);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long writtenOnDisk() {\n-            return writtenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long totalWrittenOnDisk() {\n-            return totalWrittenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long reserved() {\n-            return reserved;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void spill(long size) {\n-            checkClosed();\n-\n-            parent.spill(size);\n-\n-            writtenOnDisk += size;\n-            totalWrittenOnDisk += size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void unspill(long size) {\n-            checkClosed();\n-\n-            parent.unspill(size);\n-\n-            writtenOnDisk -= size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void incrementFilesCreated() {\n-            checkClosed();\n-\n-            parent.incrementFilesCreated();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public H2MemoryTracker createChildTracker() {\n-            checkClosed();\n-\n-            return parent.createChildTracker();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void onChildClosed(H2MemoryTracker child) {\n-            parent.onChildClosed(child);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean closed() {\n-            return state == STATE_CLOSED;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() {\n-            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-                return;\n-\n-            parent.release(reserved);\n-            parent.unspill(writtenOnDisk);\n-\n-            reserved = 0;\n-            writtenOnDisk = 0;\n-\n-            parent.onChildClosed(this);\n-        }\n-\n-        /** */\n-        private void checkClosed() {\n-            if (state == STATE_CLOSED)\n-                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-        }\n-    }\n-\n-    /** Exception thrown when try to track memory with closed tracker. */\n-    public static class TrackerWasClosedException extends RuntimeException {\n-        /**\n-         * @param msg Message.\n-         */\n-        public TrackerWasClosedException(String msg) {\n-            super(msg);\n-        }\n-    }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -27,139 +26,249 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n-    /** Resered field updater. */\n-    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n-        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n-\n-    /** Closed flag updater. */\n-    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n-        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n+public class QueryMemoryTracker implements H2MemoryTracker {\n+    /** Logger. */\n+    private final IgniteLogger log;\n \n     /** Parent tracker. */\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long maxMem;\n+    private final long quota;\n+\n+    /**\n+     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n+     * <ul>\n+     * <li>{@code false} - exception will be thrown.</li>\n+     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n+     * </ul>\n+     */\n+    private final boolean offloadingEnabled;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private volatile long reservedFromParent;\n+    private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private volatile long reserved;\n+    private long reserved;\n \n     /** Close flag to prevent tracker reuse. */\n-    private volatile Boolean closed = Boolean.FALSE;\n+    private Boolean closed = Boolean.FALSE;\n+\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n+\n+    /** Total number of bytes tracked by current tracker. */\n+    private volatile long totalReserved;\n+\n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n+\n+    /** Query descriptor (for logging). */\n+    private final String qryDesc;\n \n     /**\n      * Constructor.\n      *\n+     * @param log Logger.\n      * @param parent Parent memory tracker.\n-     * @param maxMem Query memory limit in bytes.\n+     * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n+     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n      */\n-    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n-        assert maxMem > 0;\n-\n+    QueryMemoryTracker(\n+        IgniteLogger log,\n+        H2MemoryTracker parent,\n+        long quota,\n+        long blockSize,\n+        boolean offloadingEnabled,\n+        String qryDesc) {\n+        assert quota >= 0;\n+\n+        this.log = log;\n+        this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n-        this.maxMem = maxMem;\n-        this.blockSize = blockSize;\n+        this.quota = quota;\n+        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n+        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void reserve(long size) {\n-        assert !closed && size >= 0;\n+    @Override public synchronized boolean reserved(long toReserve) {\n+        assert toReserve >= 0;\n \n-        if (size == 0)\n-            return;\n+        checkClosed();\n \n-        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n-            if (prev + x > maxMem) {\n-                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-            }\n+        reserved += toReserve;\n+        totalReserved += toReserve;\n \n-            return prev + x;\n-        });\n+        if (parent != null && reserved > reservedFromParent) {\n+            if (!reserveFromParent())\n+                return false; // Offloading.\n+        }\n \n-        if (parent != null && reserved0 > reservedFromParent) {\n-            synchronized (this) {\n-                assert !closed;\n+        if (quota > 0 && reserved >= quota)\n+            return onQuotaExceeded();\n \n-                if (reserved0 <= reservedFromParent)\n-                    return;\n+        return true;\n+    }\n \n-                // If single block size is too small.\n-                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n-                // If we are too close to limit.\n-                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n+    /**\n+     * Checks whether tracker was closed.\n+     */\n+    private void checkClosed() {\n+        if (closed)\n+            throw new IllegalStateException(\"Memory tracker has been closed concurrently.\");\n+    }\n \n-                try {\n-                    parent.reserve(blockSize);\n+    /**\n+     * Reserves memory from parent tracker.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean reserveFromParent() {\n+        // If single block size is too small.\n+        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n \n-                    reservedFromParent += blockSize;\n-                }\n-                catch (Throwable e) {\n-                    // Fallback if failed to reserve.\n-                    RESERVED_UPD.addAndGet(this, -size);\n+        // If we are too close to limit.\n+        if (quota > 0)\n+            blockSize = Math.min(blockSize, quota - reservedFromParent);\n \n-                    throw e;\n-                }\n-            }\n-        }\n+        if (parent.reserved(blockSize))\n+            reservedFromParent += blockSize;\n+        else\n+            return false;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Action on quota exceeded.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean onQuotaExceeded() {\n+        if (offloadingEnabled)\n+            return false;\n+        else\n+            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void release(long size) {\n-        assert size >= 0;\n+    @Override public synchronized void released(long toRelease) {\n+        assert toRelease >= 0;\n \n-        if (size == 0)\n+        if (toRelease == 0)\n             return;\n \n-        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n-            if (prev + x < 0)\n-                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n-                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n+        checkClosed();\n+\n+        reserved -= toRelease;\n+\n+        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + toRelease) +\n+            \", toFree=\" + toRelease + ']';\n \n-            return prev + x;\n-        });\n+        if (parent != null && reservedFromParent - reserved > blockSize)\n+            releaseFromParent();\n+    }\n+\n+    /**\n+     * Releases memory from parent.\n+     */\n+    private void releaseFromParent() {\n+        long toReleaseFromParent = reservedFromParent - reserved;\n \n-        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n+        parent.released(toReleaseFromParent);\n \n-        // For now, won'tQ release memory to parent until tracker closed.\n-       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n-            synchronized (this) {\n-                if (preAllocated - reserved >= 2 * blockSize) {\n-                    parent.release(blockSize);\n+        reservedFromParent -= toReleaseFromParent;\n \n-                    preAllocated -= blockSize;\n-                }\n-            }\n-        }*/\n+        assert reservedFromParent >= 0 : reservedFromParent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized long memoryReserved() {\n+        return reserved;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long memoryLimit() {\n+        return quota;\n+    }\n+\n+    /**\n+     * @return Offloading enabled flag.\n+     */\n+    public boolean isOffloadingEnabled() {\n+        return offloadingEnabled;\n     }\n \n     /**\n      * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    public boolean closed() {\n+    public synchronized boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        if (closed)\n+            return;\n+\n+        closed = true;\n \n-            if (parent != null)\n-                parent.release(reservedFromParent);\n+        reserved = 0;\n+\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n         }\n     }\n \n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n+    }\n+\n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"oid": "8eb17e884a8872215837da42eb32293bfb3021c1", "url": "https://github.com/gridgain/gridgain/commit/8eb17e884a8872215837da42eb32293bfb3021c1", "message": "fix resource cleanup", "committedDate": "2020-03-05T11:48:33Z", "type": "commit"}, {"oid": "3c4fba49e2362adb932629617b02b9952bd4285a", "url": "https://github.com/gridgain/gridgain/commit/3c4fba49e2362adb932629617b02b9952bd4285a", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-26598", "committedDate": "2020-03-05T11:51:43Z", "type": "commit"}, {"oid": "a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "url": "https://github.com/gridgain/gridgain/commit/a2b7a0101fb972146fffd2f5894eeec6fa9a25c3", "message": "review", "committedDate": "2020-03-05T13:20:37Z", "type": "commit"}, {"oid": "c895c69cc62f0f1f159d41d0339c458ff8fec293", "url": "https://github.com/gridgain/gridgain/commit/c895c69cc62f0f1f159d41d0339c458ff8fec293", "message": "review", "committedDate": "2020-03-05T13:55:11Z", "type": "commit"}, {"oid": "17fc88ca4dd35091808a956ca72ff61e1d9da123", "url": "https://github.com/gridgain/gridgain/commit/17fc88ca4dd35091808a956ca72ff61e1d9da123", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-26598", "committedDate": "2020-03-05T16:58:01Z", "type": "commit"}, {"oid": "0aa4ef682beba600a34586ea51af1abecc84958c", "url": "https://github.com/gridgain/gridgain/commit/0aa4ef682beba600a34586ea51af1abecc84958c", "message": "fix jdbc2 query quota test", "committedDate": "2020-03-06T07:10:45Z", "type": "commit"}, {"oid": "2d3332e27d2457d4515522769a53ee739e0dd25a", "url": "https://github.com/gridgain/gridgain/commit/2d3332e27d2457d4515522769a53ee739e0dd25a", "message": "add test for child tracker verification", "committedDate": "2020-03-06T08:17:27Z", "type": "commit"}, {"oid": "4539bc347c43488f0594ec532f6247300fd5d6c0", "url": "https://github.com/gridgain/gridgain/commit/4539bc347c43488f0594ec532f6247300fd5d6c0", "message": "review", "committedDate": "2020-03-06T18:12:10Z", "type": "commit"}, {"oid": "68a17877ef420e749a5ca770ad29e58333ab4b25", "url": "https://github.com/gridgain/gridgain/commit/68a17877ef420e749a5ca770ad29e58333ab4b25", "message": "fix failed tests after review", "committedDate": "2020-03-10T09:18:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5MTE2NA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390191164", "body": "may be rename to `memTrackerProvider`, in order to not confuse with `QueryMemoryTracker` instances? ", "bodyText": "may be rename to memTrackerProvider, in order to not confuse with QueryMemoryTracker instances?", "bodyHTML": "<p dir=\"auto\">may be rename to <code>memTrackerProvider</code>, in order to not confuse with <code>QueryMemoryTracker</code> instances?</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:37:47Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java", "diffHunk": "@@ -47,6 +47,9 @@\n     /** */\n     private final boolean loc;\n \n+    /** */\n+    private final GridQueryMemoryMetricProvider memTracker;", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwNjE1NQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390906155", "bodyText": "done", "author": "korlov42", "createdAt": "2020-03-11T11:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5MTE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "a92bfb05d14cf079f18fdd7f8befed605ada743a", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 10e07ed4538..5db6937de3c 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -48,7 +48,7 @@ public class GridRunningQueryInfo {\n     private final boolean loc;\n \n     /** */\n-    private final GridQueryMemoryMetricProvider memTracker;\n+    private final GridQueryMemoryMetricProvider memMetricProvider;\n \n     /** */\n     private final QueryRunningFuture fut = new QueryRunningFuture();\n", "next_change": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 5db6937de3c..6e31a335f37 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -51,6 +54,7 @@ public class GridRunningQueryInfo {\n     private final GridQueryMemoryMetricProvider memMetricProvider;\n \n     /** */\n+    @GridToStringExclude\n     private final QueryRunningFuture fut = new QueryRunningFuture();\n \n     /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 10e07ed4538..6e31a335f37 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -42,15 +44,17 @@ public class GridRunningQueryInfo {\n     private final long startTime;\n \n     /** */\n+    @GridToStringExclude\n     private final GridQueryCancel cancel;\n \n     /** */\n     private final boolean loc;\n \n     /** */\n-    private final GridQueryMemoryMetricProvider memTracker;\n+    private final GridQueryMemoryMetricProvider memMetricProvider;\n \n     /** */\n+    @GridToStringExclude\n     private final QueryRunningFuture fut = new QueryRunningFuture();\n \n     /**\n", "next_change": {"commit": "52d71755e2aad4158fbfb936b22d17fdc2fbd477", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 6e31a335f37..20bf821bad2 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -50,9 +50,6 @@ public class GridRunningQueryInfo {\n     /** */\n     private final boolean loc;\n \n-    /** */\n-    private final GridQueryMemoryMetricProvider memMetricProvider;\n-\n     /** */\n     @GridToStringExclude\n     private final QueryRunningFuture fut = new QueryRunningFuture();\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 20bf821bad2..6e31a335f37 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -50,6 +50,9 @@ public class GridRunningQueryInfo {\n     /** */\n     private final boolean loc;\n \n+    /** */\n+    private final GridQueryMemoryMetricProvider memMetricProvider;\n+\n     /** */\n     @GridToStringExclude\n     private final QueryRunningFuture fut = new QueryRunningFuture();\n", "next_change": {"commit": "a35edeec5778d6053e2f63fe220e6683b259b0a7", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 6e31a335f37..d806f754e54 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -57,6 +57,9 @@ public class GridRunningQueryInfo {\n     @GridToStringExclude\n     private final QueryRunningFuture fut = new QueryRunningFuture();\n \n+    /** Originator. */\n+    private final String qryInitiatorId;\n+\n     /**\n      * Constructor.\n      *\n", "next_change": {"commit": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex d806f754e54..83045fd366c 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -60,6 +62,9 @@ public class GridRunningQueryInfo {\n     /** Originator. */\n     private final String qryInitiatorId;\n \n+    /** Span of the running query. */\n+    private final Span span;\n+\n     /**\n      * Constructor.\n      *\n", "next_change": {"commit": "9ff25c8a5bde71f38e984b67781fe072697983d6", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\nindex 83045fd366c..b46bfac178c 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n", "chunk": "@@ -65,6 +65,15 @@ public class GridRunningQueryInfo {\n     /** Span of the running query. */\n     private final Span span;\n \n+    /** Enforce join order flag. */\n+    private final boolean enforceJoinOrder;\n+\n+    /** Lazy flag. */\n+    private final boolean lazy;\n+\n+    /** Distributed joins flag. */\n+    private final boolean distributedJoins;\n+\n     /**\n      * Constructor.\n      *\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "52d71755e2aad4158fbfb936b22d17fdc2fbd477", "committedDate": "2020-03-16 13:49:21 +0300", "message": "GG-27994 Fix KillQueryTest.testCancelLocalQueryNative test in the nightly suite."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a35edeec5778d6053e2f63fe220e6683b259b0a7", "committedDate": "2020-04-06 12:48:32 +0300", "message": "GG-26421 track query initiator"}, {"oid": "79c235d9530a174e1a6259125e8b7668de5362e3", "committedDate": "2020-06-07 19:52:05 +0300", "message": "GG-29134 [IGNITE-12939] Add WhitespacesAround support for the checkstyle (#7726)"}, {"oid": "f6a78e48d972087ac5375206505bad89b1989730", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29057 [IGNITE-12224] SQL query & SQL query history system views. (#7059)"}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "9ff25c8a5bde71f38e984b67781fe072697983d6", "committedDate": "2021-01-04 01:09:07 +0300", "message": "GG-32024 Add query attributes to QueryHistoryTracker#qryHist and QueryHistory (enforceJoinOrder, distributedJoins, local, lazy)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5Mjk5Ng==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390192996", "body": "Could you provide example of `text queries` ?", "bodyText": "Could you provide example of text queries ?", "bodyHTML": "<p dir=\"auto\">Could you provide example of <code>text queries</code> ?</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:41:05Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java", "diffHunk": "@@ -44,14 +46,44 @@\n     /** Name of the MetricRegistry which metrics measure stats of queries initiated by user. */\n     public static final String SQL_USER_QUERIES_REG_NAME = \"sql.queries.user\";\n \n+    /** Dummy memory metric provider that returns only -1's. */\n+    // This provider used to highlight that query has no tracker at all.\n+    // It could be intentionally in case of streaming or text queries", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MDEwMA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390250100", "bodyText": "Any query running via GridQueryProcessor#executeQuery with qryType==TEXT", "author": "korlov42", "createdAt": "2020-03-10T11:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5Mjk5Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "67910a86c5418715d0399a1cb039d265da5a1aaa", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 57599e49dc5..a40205d65e3 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -46,36 +44,6 @@ public class RunningQueryManager {\n     /** Name of the MetricRegistry which metrics measure stats of queries initiated by user. */\n     public static final String SQL_USER_QUERIES_REG_NAME = \"sql.queries.user\";\n \n-    /** Dummy memory metric provider that returns only -1's. */\n-    // This provider used to highlight that query has no tracker at all.\n-    // It could be intentionally in case of streaming or text queries\n-    // and occasionally in case of uncounted circumstances\n-    // that requires followed investigation\n-    private static final GridQueryMemoryMetricProvider DUMMY_TRACKER = new GridQueryMemoryMetricProvider() {\n-        @Override public long reserved() {\n-            return -1;\n-        }\n-\n-        @Override public long maxReserved() {\n-            return -1;\n-        }\n-\n-        @Override public long writtenOnDisk() {\n-            return -1;\n-        }\n-\n-        @Override public long maxWrittenOnDisk() {\n-            return -1;\n-        }\n-\n-        @Override public long totalWrittenOnDisk() {\n-            return -1;\n-        }\n-    };\n-\n-    /** */\n-    private final IgniteLogger log;\n-\n     /** Keep registered user queries. */\n     private final ConcurrentMap<Long, GridRunningQueryInfo> runs = new ConcurrentHashMap<>();\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex a40205d65e3..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -44,6 +46,36 @@ public class RunningQueryManager {\n     /** Name of the MetricRegistry which metrics measure stats of queries initiated by user. */\n     public static final String SQL_USER_QUERIES_REG_NAME = \"sql.queries.user\";\n \n+    /** Dummy memory metric provider that returns only -1's. */\n+    // This provider used to highlight that query has no tracker at all.\n+    // It could be intentionally in case of streaming or text queries\n+    // and occasionally in case of uncounted circumstances\n+    // that requires followed investigation\n+    private static final GridQueryMemoryMetricProvider DUMMY_TRACKER = new GridQueryMemoryMetricProvider() {\n+        @Override public long reserved() {\n+            return -1;\n+        }\n+\n+        @Override public long maxReserved() {\n+            return -1;\n+        }\n+\n+        @Override public long writtenOnDisk() {\n+            return -1;\n+        }\n+\n+        @Override public long maxWrittenOnDisk() {\n+            return -1;\n+        }\n+\n+        @Override public long totalWrittenOnDisk() {\n+            return -1;\n+        }\n+    };\n+\n+    /** */\n+    private final IgniteLogger log;\n+\n     /** Keep registered user queries. */\n     private final ConcurrentMap<Long, GridRunningQueryInfo> runs = new ConcurrentHashMap<>();\n \n", "next_change": {"commit": "d9bd32fbdd40bdb7b47bbec692e714bd5bc55414", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 257e8282af4..b1be563a294 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -76,6 +84,9 @@ public class RunningQueryManager {\n     /** */\n     private final IgniteLogger log;\n \n+    /** */\n+    private final GridClosureProcessor closure;\n+\n     /** Keep registered user queries. */\n     private final ConcurrentMap<Long, GridRunningQueryInfo> runs = new ConcurrentHashMap<>();\n \n", "next_change": null}]}}, {"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex a40205d65e3..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -51,7 +83,7 @@ public class RunningQueryManager {\n     private final AtomicLong qryIdGen = new AtomicLong();\n \n     /** Local node ID. */\n-    private final UUID localNodeId;\n+    private final UUID locNodeId;\n \n     /** History size. */\n     private final int histSz;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "67910a86c5418715d0399a1cb039d265da5a1aaa", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20983: SQL: metrics of executions of user queries"}, {"oid": "04362e5d82d3a69abc7c13ffe6562a2382935b94", "committedDate": "2019-08-13 20:34:37 +0300", "message": "GG-22426 [IGNITE-11961] JMX metrics for PME timings (#6701)"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a35edeec5778d6053e2f63fe220e6683b259b0a7", "committedDate": "2020-04-06 12:48:32 +0300", "message": "GG-26421 track query initiator"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "d9bd32fbdd40bdb7b47bbec692e714bd5bc55414", "committedDate": "2020-04-27 17:48:28 +0300", "message": "GG-26430 Provide ability to register listeners for query start/finish events"}, {"oid": "79c235d9530a174e1a6259125e8b7668de5362e3", "committedDate": "2020-06-07 19:52:05 +0300", "message": "GG-29134 [IGNITE-12939] Add WhitespacesAround support for the checkstyle (#7726)"}, {"oid": "f6a78e48d972087ac5375206505bad89b1989730", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29057 [IGNITE-12224] SQL query & SQL query history system views. (#7059)"}, {"oid": "21517d8eab815dd81a611a75329742a0187ca732", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29115 [IGNITE-12441] Refactor SystemViewRowAttributeWalker registration for system views (#7136)"}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "9ff25c8a5bde71f38e984b67781fe072697983d6", "committedDate": "2021-01-04 01:09:07 +0300", "message": "GG-32024 Add query attributes to QueryHistoryTracker#qryHist and QueryHistory (enforceJoinOrder, distributedJoins, local, lazy)"}, {"oid": "f77cc1efda1485e6ad2ee2fb097d89e7f45de995", "committedDate": "2021-03-05 15:51:07 +0300", "message": "GG-32450 [IGNITE-14008] SQL tracing: add tag sql.query.id"}, {"oid": "e5ef51022e00b387287d3c0c0a55b0da6e4bd361", "committedDate": "2022-08-25 10:01:08 +0700", "message": "GG-35591 Extend GridQueryStartedInfo, GridQueryFinishedInfo. (#2514)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NDA2OQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390194069", "body": "Do we have any kind of protection against resource leak in case queries are only registered and never unregistered?", "bodyText": "Do we have any kind of protection against resource leak in case queries are only registered and never unregistered?", "bodyHTML": "<p dir=\"auto\">Do we have any kind of protection against resource leak in case queries are only registered and never unregistered?</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:43:04Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java", "diffHunk": "@@ -153,6 +191,15 @@ public void unregister(Long qryId, @Nullable Throwable failReason) {\n         if (qry == null)\n             return;\n \n+        if (qry.memoryTracker() instanceof AutoCloseable)\n+            U.close((AutoCloseable)qry.memoryTracker(), log);", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MTIxMQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390251211", "bodyText": "What protection do you mean?", "author": "korlov42", "createdAt": "2020-03-10T11:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwNDgxMA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390304810", "bodyText": "if we have some (periodic/triggered) check that all registered queries were unregistered once they are closed/completed", "author": "mshonichev", "createdAt": "2020-03-10T13:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwNTkzMg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390305932", "bodyText": "no, we have not such check", "author": "korlov42", "createdAt": "2020-03-10T13:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NDA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a92bfb05d14cf079f18fdd7f8befed605ada743a", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 57599e49dc5..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -191,12 +191,12 @@ public class RunningQueryManager {\n         if (qry == null)\n             return;\n \n-        if (qry.memoryTracker() instanceof AutoCloseable)\n-            U.close((AutoCloseable)qry.memoryTracker(), log);\n+        if (qry.memoryMetricProvider() instanceof AutoCloseable)\n+            U.close((AutoCloseable)qry.memoryMetricProvider(), log);\n \n         if (log.isDebugEnabled()) {\n             log.debug(\"User's query \" + (failReason == null ? \"completed \" : \"failed \") +\n-                \"[id=\" + qryId + \", tracker=\" + qry.memoryTracker() +\n+                \"[id=\" + qryId + \", tracker=\" + qry.memoryMetricProvider() +\n                 \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n         }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 57599e49dc5..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -191,12 +191,12 @@ public class RunningQueryManager {\n         if (qry == null)\n             return;\n \n-        if (qry.memoryTracker() instanceof AutoCloseable)\n-            U.close((AutoCloseable)qry.memoryTracker(), log);\n+        if (qry.memoryMetricProvider() instanceof AutoCloseable)\n+            U.close((AutoCloseable)qry.memoryMetricProvider(), log);\n \n         if (log.isDebugEnabled()) {\n             log.debug(\"User's query \" + (failReason == null ? \"completed \" : \"failed \") +\n-                \"[id=\" + qryId + \", tracker=\" + qry.memoryTracker() +\n+                \"[id=\" + qryId + \", tracker=\" + qry.memoryMetricProvider() +\n                 \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n         }\n \n", "next_change": {"commit": "67910a86c5418715d0399a1cb039d265da5a1aaa", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 257e8282af4..a40205d65e3 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -191,15 +153,6 @@ public class RunningQueryManager {\n         if (qry == null)\n             return;\n \n-        if (qry.memoryMetricProvider() instanceof AutoCloseable)\n-            U.close((AutoCloseable)qry.memoryMetricProvider(), log);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"User's query \" + (failReason == null ? \"completed \" : \"failed \") +\n-                \"[id=\" + qryId + \", tracker=\" + qry.memoryMetricProvider() +\n-                \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n-        }\n-\n         //We need to collect query history and metrics only for SQL queries.\n         if (isSqlQuery(qry)) {\n             qry.runningFuture().onDone();\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex a40205d65e3..257e8282af4 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -153,6 +191,15 @@ public class RunningQueryManager {\n         if (qry == null)\n             return;\n \n+        if (qry.memoryMetricProvider() instanceof AutoCloseable)\n+            U.close((AutoCloseable)qry.memoryMetricProvider(), log);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"User's query \" + (failReason == null ? \"completed \" : \"failed \") +\n+                \"[id=\" + qryId + \", tracker=\" + qry.memoryMetricProvider() +\n+                \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n+        }\n+\n         //We need to collect query history and metrics only for SQL queries.\n         if (isSqlQuery(qry)) {\n             qry.runningFuture().onDone();\n", "next_change": {"commit": "d9bd32fbdd40bdb7b47bbec692e714bd5bc55414", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 257e8282af4..b1be563a294 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -200,6 +254,39 @@ public class RunningQueryManager {\n                 \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n         }\n \n+        if (!qryFinishedListeners.isEmpty()) {\n+            GridQueryFinishedInfo info = new GridQueryFinishedInfo(\n+                qry.id(),\n+                locNodeId,\n+                qry.query(),\n+                qry.queryType(),\n+                qry.schemaName(),\n+                qry.startTime(),\n+                System.currentTimeMillis(),\n+                qry.local(),\n+                failed,\n+                qry.queryInitiatorId()\n+            );\n+\n+            try {\n+                closure.runLocal(\n+                    () -> qryFinishedListeners.forEach(lsnr -> {\n+                        try {\n+                            lsnr.accept(info);\n+                        }\n+                        catch (Exception ex) {\n+                            log.error(\"Listener fails during handling query finished\" +\n+                                    \" event [qryId=\" + qryId + \"]\", ex);\n+                        }\n+                    }),\n+                    GridIoPolicy.PUBLIC_POOL\n+                );\n+            }\n+            catch (IgniteCheckedException ex) {\n+                throw new IgniteException(ex.getMessage(), ex);\n+            }\n+        }\n+\n         //We need to collect query history and metrics only for SQL queries.\n         if (isSqlQuery(qry)) {\n             qry.runningFuture().onDone();\n", "next_change": {"commit": "f6a78e48d972087ac5375206505bad89b1989730", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex b1be563a294..541e895c2a1 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -291,7 +316,7 @@ public class RunningQueryManager {\n         if (isSqlQuery(qry)) {\n             qry.runningFuture().onDone();\n \n-            qryHistTracker.collectMetrics(qry, failed);\n+            qryHistTracker.collectHistory(qry, failed);\n \n             if (!failed)\n                 successQrsCnt.increment();\n", "next_change": {"commit": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\nindex 541e895c2a1..2f55160f922 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java\n", "chunk": "@@ -270,58 +274,64 @@ public class RunningQueryManager {\n         if (qry == null)\n             return;\n \n-        if (qry.memoryMetricProvider() instanceof AutoCloseable)\n-            U.close((AutoCloseable)qry.memoryMetricProvider(), log);\n+        Span qrySpan = qry.span();\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"User's query \" + (failReason == null ? \"completed \" : \"failed \") +\n-                \"[id=\" + qryId + \", tracker=\" + qry.memoryMetricProvider() +\n-                \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n-        }\n+        try {\n+            if (failed)\n+                qrySpan.addTag(ERROR, failReason::getMessage);\n \n-        if (!qryFinishedListeners.isEmpty()) {\n-            GridQueryFinishedInfo info = new GridQueryFinishedInfo(\n-                qry.id(),\n-                locNodeId,\n-                qry.query(),\n-                qry.queryType(),\n-                qry.schemaName(),\n-                qry.startTime(),\n-                System.currentTimeMillis(),\n-                qry.local(),\n-                failed,\n-                qry.queryInitiatorId()\n-            );\n+            if (qry.memoryMetricProvider() instanceof AutoCloseable)\n+                U.close((AutoCloseable)qry.memoryMetricProvider(), log);\n \n-            try {\n-                closure.runLocal(\n-                    () -> qryFinishedListeners.forEach(lsnr -> {\n-                        try {\n-                            lsnr.accept(info);\n-                        }\n-                        catch (Exception ex) {\n-                            log.error(\"Listener fails during handling query finished\" +\n-                                    \" event [qryId=\" + qryId + \"]\", ex);\n-                        }\n-                    }),\n-                    GridIoPolicy.PUBLIC_POOL\n-                );\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"User's query \" + (failReason == null ? \"completed \" : \"failed \") +\n+                    \"[id=\" + qryId + \", tracker=\" + qry.memoryMetricProvider() +\n+                    \", failReason=\" + (failReason != null ? failReason.getMessage() : \"null\") + ']');\n             }\n-            catch (IgniteCheckedException ex) {\n-                throw new IgniteException(ex.getMessage(), ex);\n+\n+            if (!qryFinishedListeners.isEmpty()) {\n+                GridQueryFinishedInfo info = new GridQueryFinishedInfo(\n+                    qry.id(),\n+                    locNodeId,\n+                    qry.query(),\n+                    qry.queryType(),\n+                    qry.schemaName(),\n+                    qry.startTime(),\n+                    System.currentTimeMillis(),\n+                    qry.local(),\n+                    failed,\n+                    qry.queryInitiatorId()\n+                );\n+\n+                try {\n+                    closure.runLocal(\n+                        () -> qryFinishedListeners.forEach(lsnr -> {\n+                            try {\n+                                lsnr.accept(info);\n+                            }\n+                            catch (Exception ex) {\n+                                log.error(\"Listener fails during handling query finished\" +\n+                                    \" event [qryId=\" + qryId + \"]\", ex);\n+                            }\n+                        }),\n+                        GridIoPolicy.PUBLIC_POOL\n+                    );\n+                }\n+                catch (IgniteCheckedException ex) {\n+                    throw new IgniteException(ex.getMessage(), ex);\n+                }\n             }\n-        }\n \n-        //We need to collect query history and metrics only for SQL queries.\n-        if (isSqlQuery(qry)) {\n-            qry.runningFuture().onDone();\n+            //We need to collect query history and metrics only for SQL queries.\n+            if (isSqlQuery(qry)) {\n+                qry.runningFuture().onDone();\n \n-            qryHistTracker.collectHistory(qry, failed);\n+                qryHistTracker.collectHistory(qry, failed);\n \n-            if (!failed)\n-                successQrsCnt.increment();\n-            else {\n-                failedQrsCnt.increment();\n+                if (!failed)\n+                    successQrsCnt.increment();\n+                else {\n+                    failedQrsCnt.increment();\n \n                 // We measure cancel metric as \"number of times user's queries ended up with query cancelled exception\",\n                 // not \"how many user's KILL QUERY command succeeded\". These may be not the same if cancel was issued\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "67910a86c5418715d0399a1cb039d265da5a1aaa", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20983: SQL: metrics of executions of user queries"}, {"oid": "04362e5d82d3a69abc7c13ffe6562a2382935b94", "committedDate": "2019-08-13 20:34:37 +0300", "message": "GG-22426 [IGNITE-11961] JMX metrics for PME timings (#6701)"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a35edeec5778d6053e2f63fe220e6683b259b0a7", "committedDate": "2020-04-06 12:48:32 +0300", "message": "GG-26421 track query initiator"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "d9bd32fbdd40bdb7b47bbec692e714bd5bc55414", "committedDate": "2020-04-27 17:48:28 +0300", "message": "GG-26430 Provide ability to register listeners for query start/finish events"}, {"oid": "79c235d9530a174e1a6259125e8b7668de5362e3", "committedDate": "2020-06-07 19:52:05 +0300", "message": "GG-29134 [IGNITE-12939] Add WhitespacesAround support for the checkstyle (#7726)"}, {"oid": "f6a78e48d972087ac5375206505bad89b1989730", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29057 [IGNITE-12224] SQL query & SQL query history system views. (#7059)"}, {"oid": "21517d8eab815dd81a611a75329742a0187ca732", "committedDate": "2020-09-25 16:53:45 +0300", "message": "GG-29115 [IGNITE-12441] Refactor SystemViewRowAttributeWalker registration for system views (#7136)"}, {"oid": "0d0ec31b20c6061a540b1b274e1aad6ba44b2108", "committedDate": "2020-10-16 16:27:06 +0300", "message": "GG-31099 Add tracing of SQL queries."}, {"oid": "9ff25c8a5bde71f38e984b67781fe072697983d6", "committedDate": "2021-01-04 01:09:07 +0300", "message": "GG-32024 Add query attributes to QueryHistoryTracker#qryHist and QueryHistory (enforceJoinOrder, distributedJoins, local, lazy)"}, {"oid": "f77cc1efda1485e6ad2ee2fb097d89e7f45de995", "committedDate": "2021-03-05 15:51:07 +0300", "message": "GG-32450 [IGNITE-14008] SQL tracing: add tag sql.query.id"}, {"oid": "e5ef51022e00b387287d3c0c0a55b0da6e4bd361", "committedDate": "2022-08-25 10:01:08 +0700", "message": "GG-35591 Extend GridQueryStartedInfo, GridQueryFinishedInfo. (#2514)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NzAyNg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390197026", "body": "As far as I know, query can continue executing after connection close, am I right? \r\nWouldn't `.close()` break OOM protection for that case?", "bodyText": "As far as I know, query can continue executing after connection close, am I right?\nWouldn't .close() break OOM protection for that case?", "bodyHTML": "<p dir=\"auto\">As far as I know, query can continue executing after connection close, am I right?<br>\nWouldn't <code>.close()</code> break OOM protection for that case?</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:47:59Z", "path": "modules/h2/src/main/java/org/h2/engine/Session.java", "diffHunk": "@@ -960,6 +975,11 @@ public void close() {\n             try {\n                 database.checkPowerOff();\n \n+                H2MemoryTracker tracker = memoryTracker;\n+                if (tracker != null) {\n+                    tracker.close();", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2ODY5NA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390268694", "bodyText": "I know about only one case - when query was cancelled. And this case is handled properly.", "author": "korlov42", "createdAt": "2020-03-10T12:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NzAyNg=="}], "type": "inlineReview", "revised_code": {"commit": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 31f688f665f..87bdaad3500 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -976,9 +978,8 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n                 database.checkPowerOff();\n \n                 H2MemoryTracker tracker = memoryTracker;\n-                if (tracker != null) {\n+                if (tracker != null)\n                     tracker.close();\n-                }\n \n                 // release any open table locks\n                 rollback();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 31f688f665f..87bdaad3500 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -976,9 +978,8 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n                 database.checkPowerOff();\n \n                 H2MemoryTracker tracker = memoryTracker;\n-                if (tracker != null) {\n+                if (tracker != null)\n                     tracker.close();\n-                }\n \n                 // release any open table locks\n                 rollback();\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 87bdaad3500..922209fce8e 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -977,10 +938,6 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n             try {\n                 database.checkPowerOff();\n \n-                H2MemoryTracker tracker = memoryTracker;\n-                if (tracker != null)\n-                    tracker.close();\n-\n                 // release any open table locks\n                 rollback();\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 922209fce8e..87bdaad3500 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -938,6 +977,10 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n             try {\n                 database.checkPowerOff();\n \n+                H2MemoryTracker tracker = memoryTracker;\n+                if (tracker != null)\n+                    tracker.close();\n+\n                 // release any open table locks\n                 rollback();\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTA5Mg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390201092", "body": "need add `inResult = null` here too?", "bodyText": "need add inResult = null here too?", "bodyHTML": "<p dir=\"auto\">need add <code>inResult = null</code> here too?</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:54:47Z", "path": "modules/h2/src/main/java/org/h2/index/IndexCursor.java", "diffHunk": "@@ -296,6 +300,9 @@ public boolean previous() {\n \n     @Override\n     public void close() throws Exception {\n+        if (inResult != null)\n+            inResult.close();", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2NzgxOA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390267818", "bodyText": "not sure. It could help GC, but currently there are more resources that is not cleared here", "author": "korlov42", "createdAt": "2020-03-10T12:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwNTIxMw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390305213", "bodyText": "and what about double call to close?", "author": "mshonichev", "createdAt": "2020-03-10T13:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwOTExNw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390309117", "bodyText": "close should be idempotent", "author": "korlov42", "createdAt": "2020-03-10T13:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTA5Mg=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "ae976a5e026af98297e6d7d35ed117cd000969f0", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/IndexCursor.java b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\nindex 191c82d247f..6d3d4fa4001 100644\n--- a/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n+++ b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n", "chunk": "@@ -300,9 +296,6 @@ public class IndexCursor implements Cursor, AutoCloseable {\n \n     @Override\n     public void close() throws Exception {\n-        if (inResult != null)\n-            inResult.close();\n-\n         if (cursor instanceof AutoCloseable)\n             ((AutoCloseable)cursor).close();\n     }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/IndexCursor.java b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\nindex 6d3d4fa4001..00ee3cfc248 100644\n--- a/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n+++ b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n", "chunk": "@@ -296,6 +299,9 @@ public class IndexCursor implements Cursor, AutoCloseable {\n \n     @Override\n     public void close() throws Exception {\n+        if (inResult != null)\n+            inResult.close();\n+\n         if (cursor instanceof AutoCloseable)\n             ((AutoCloseable)cursor).close();\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ae976a5e026af98297e6d7d35ed117cd000969f0", "committedDate": "2019-11-18 17:17:39 +0300", "message": "GG-22138 OOM Fix. Added close() method for BPlusTree.ForwardCursor."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTc3Mw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390201773", "body": "(y)", "bodyText": "(y)", "bodyHTML": "<p dir=\"auto\">(y)</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:55:49Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java", "diffHunk": "@@ -53,19 +59,22 @@\n     private final boolean lazy;\n \n     /** Prepared statement. */\n+    @GridToStringExclude", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "004d0aeddd1ba85e2c7ed9319ef037fb4c4552f7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 4640bd9e64f..aee8549dd27 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -59,7 +57,6 @@ public class H2QueryInfo {\n     private final boolean lazy;\n \n     /** Prepared statement. */\n-    @GridToStringExclude\n     private final Prepared stmt;\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 4640bd9e64f..3323822cc96 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -59,7 +57,6 @@ public class H2QueryInfo {\n     private final boolean lazy;\n \n     /** Prepared statement. */\n-    @GridToStringExclude\n     private final Prepared stmt;\n \n     /**\n", "next_change": {"commit": "f3d5e5b81fa448e1602a1929367726281a6091c6", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 3323822cc96..1e60bf82b19 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -63,15 +59,13 @@ public class H2QueryInfo {\n      * @param type Query type.\n      * @param stmt Query statement.\n      * @param sql Query statement.\n-     * @param runningQryId Query id assigned by {@link RunningQueryManager}.\n      */\n-    public H2QueryInfo(QueryType type, PreparedStatement stmt, String sql, Long runningQryId) {\n+    public H2QueryInfo(QueryType type, PreparedStatement stmt, String sql) {\n         try {\n             assert stmt != null;\n \n             this.type = type;\n             this.sql = sql;\n-            this.runningQryId = runningQryId;\n \n             beginTs = U.currentTimeMillis();\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 1e60bf82b19..3323822cc96 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -59,13 +63,15 @@ public class H2QueryInfo {\n      * @param type Query type.\n      * @param stmt Query statement.\n      * @param sql Query statement.\n+     * @param runningQryId Query id assigned by {@link RunningQueryManager}.\n      */\n-    public H2QueryInfo(QueryType type, PreparedStatement stmt, String sql) {\n+    public H2QueryInfo(QueryType type, PreparedStatement stmt, String sql, Long runningQryId) {\n         try {\n             assert stmt != null;\n \n             this.type = type;\n             this.sql = sql;\n+            this.runningQryId = runningQryId;\n \n             beginTs = U.currentTimeMillis();\n \n", "next_change": {"commit": "669e2f99c8b80365443a1f2352f4cbafb5df5392", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 3323822cc96..807e3a7a23a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -59,18 +62,23 @@ public class H2QueryInfo {\n     /** Prepared statement. */\n     private final Prepared stmt;\n \n+    /** Originator node uid. */\n+    private final UUID node;\n+\n     /**\n      * @param type Query type.\n      * @param stmt Query statement.\n      * @param sql Query statement.\n+     * @param node Originator node.\n      * @param runningQryId Query id assigned by {@link RunningQueryManager}.\n      */\n-    public H2QueryInfo(QueryType type, PreparedStatement stmt, String sql, Long runningQryId) {\n+    public H2QueryInfo(QueryType type, PreparedStatement stmt, String sql, ClusterNode node,\n+        Long runningQryId) {\n         try {\n             assert stmt != null;\n-\n             this.type = type;\n             this.sql = sql;\n+            this.node = node.id();\n             this.runningQryId = runningQryId;\n \n             beginTs = U.currentTimeMillis();\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "f3d5e5b81fa448e1602a1929367726281a6091c6", "committedDate": "2019-10-25 15:28:05 +0300", "message": "GG-24808 SQL: print warning log message when query's result is big"}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "70c768ce24aee355008841e12766be2b470bb07e", "committedDate": "2021-03-29 18:19:22 +0300", "message": "GG-27961 hide sensitive data on log messages for long running query and huge results query according with the property IGNITE_TO_STRING_INCLUDE_SENSITIVE"}, {"oid": "17d61305c2c1652790dd34670a67bd5509c8c8f7", "committedDate": "2021-04-21 10:22:46 +0300", "message": "GG-33093 Revert \"GG-27961 hide sensitive data on log messages for long running query and huge results query according with the property IGNITE_TO_STRING_INCLUDE_SENSITIVE\""}, {"oid": "f3e3f4dbebb5aa65410e0d26c97bfaa8f25079e1", "committedDate": "2021-07-22 15:27:56 +0300", "message": "GG-33442 Throttle long running query warnings with queryParallelism > 1 (#2015)"}, {"oid": "669e2f99c8b80365443a1f2352f4cbafb5df5392", "committedDate": "2021-12-10 16:37:36 +0300", "message": "GG-34370: Logging globalQueryId for long running queries. (#2220)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMzYzMA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390203630", "body": "Did we change conventions about _negative values are reserved for disable memory tracking_ again ?\r\nIf yes, documentation ticket must be created with currently actual behavior description.", "bodyText": "Did we change conventions about negative values are reserved for disable memory tracking again ?\nIf yes, documentation ticket must be created with currently actual behavior description.", "bodyHTML": "<p dir=\"auto\">Did we change conventions about <em>negative values are reserved for disable memory tracking</em> again ?<br>\nIf yes, documentation ticket must be created with currently actual behavior description.</p>", "author": "mshonichev", "createdAt": "2020-03-10T09:58:56Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java", "diffHunk": "@@ -174,48 +171,35 @@ public QueryMemoryManager(GridKernalContext ctx) {\n     /**\n      * Query memory tracker factory method.\n      *\n-     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota}  will be used.\n-     * Note: Negative values are reserved for disable memory tracking.\n+     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota} will be used.", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2NjQyMQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390266421", "bodyText": "No, convention is not changed. Just for now memory tracking is always enabled.", "author": "korlov42", "createdAt": "2020-03-10T12:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMzYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwNTUxMA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390305510", "bodyText": "need to benchmark this", "author": "mshonichev", "createdAt": "2020-03-10T13:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMzYzMA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex bed35e8a8bf..58ae9e20f92 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -163,168 +109,62 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n         if (size == 0)\n             return; // Nothing to do.\n \n-        assert size > 0;\n+        reserved.accumulateAndGet(-size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to free more memory that ever be reserved: [\" +\n+                    \"reserved=\" + prev + \", toFree=\" + x + ']');\n \n-        reserved.accumulateAndGet(size, RELEASE_OP);\n+            return prev + x;\n+        });\n     }\n \n     /**\n      * Query memory tracker factory method.\n      *\n-     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota} will be used.\n+     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#dfltSqlQryMemoryLimit}  will be used.\n+     * Note: Negative values are reserved for disable memory tracking.\n      *\n-     * @param maxQryMemory Query memory limit in bytes.\n+     * @param maxQueryMemory Query memory limit in bytes.\n      * @return Query memory tracker.\n      */\n-    public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n-        long globalQuota0 = globalQuota;\n-\n-        if (globalQuota0 > 0 && globalQuota0 < maxQryMemory) {\n-            if (log.isInfoEnabled()) {\n-                LT.info(log, \"Query memory quota cannot exceed global memory quota.\" +\n-                    \" It will be reduced to the size of global quota: \" + globalQuota0);\n-            }\n-\n-            maxQryMemory = globalQuota0;\n-        }\n-\n-        if (maxQryMemory == 0)\n-            maxQryMemory = globalQuota0 > 0 ? Math.min(qryQuota, globalQuota0) : qryQuota;\n-\n-        if (maxQryMemory < 0)\n-            maxQryMemory = 0;\n+    public QueryMemoryTracker createQueryMemoryTracker(long maxQueryMemory) {\n+        assert maxQueryMemory >= 0;\n \n-        QueryMemoryTracker tracker = new QueryMemoryTracker(this, maxQryMemory, blockSize, offloadingEnabled);\n+        if (maxQueryMemory == 0)\n+            maxQueryMemory = dfltSqlQryMemoryLimit;\n \n-        if (log.isDebugEnabled())\n-            log.debug(\"Memory tracker created: \" + tracker);\n+        if (dfltSqlQryMemoryLimit < 0)\n+            return null;\n \n-        return tracker;\n-    }\n+        if (globalQuota > 0 && globalQuota < maxQueryMemory) {\n+            U.warn(log, \"Max query memory can't exceeds SQL memory pool size. Will be reduced down to: \" + globalQuota);\n \n-    /**\n-     * Action when quota is exceeded.\n-     * @return {@code false} if it is needed to offload data.\n-     */\n-    public boolean onQuotaExceeded(long size) {\n-        reserved.addAndGet(-size);\n-\n-        if (offloadingEnabled)\n-            return false;\n-        else {\n-            throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            maxQueryMemory = globalQuota;\n         }\n-    }\n-\n-    /**\n-     * Sets new global query quota.\n-     *\n-     * @param newGlobalQuota New global query quota.\n-     */\n-    public synchronized void setGlobalQuota(String newGlobalQuota) {\n-        long globalQuota0 = U.parseBytes(newGlobalQuota);\n-        long heapSize = Runtime.getRuntime().maxMemory();\n-\n-        A.ensure(\n-            heapSize > globalQuota0,\n-            \"Sql global memory quota can't be more than heap size: heapSize=\"\n-                + heapSize + \", quotaSize=\" + globalQuota0\n-        );\n \n-        A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n+        assert maxQueryMemory >= blockSize;\n \n-        globalQuota = globalQuota0;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query global quota was set to \" + globalQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n+        return new QueryMemoryTracker(globalQuota < 0 ? null : this, maxQueryMemory, blockSize);\n     }\n \n     /**\n-     * @return Current global query quota.\n-     */\n-    public String getGlobalQuota() {\n-        return String.valueOf(globalQuota);\n-    }\n-\n-    /**\n-     * Sets new per-query quota.\n+     * Gets memory reserved by running queries.\n      *\n-     * @param newQryQuota New per-query quota.\n+     * @return Reserved memory in bytes.\n      */\n-    public synchronized void setQueryQuota(String newQryQuota) {\n-        long qryQuota0 = U.parseBytes(newQryQuota);\n-\n-        A.ensure(qryQuota0 >= 0, \"Sql query memory quota must be >= 0: quotaSize=\" + qryQuota0);\n-\n-        qryQuota = U.parseBytes(newQryQuota);\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query memory quota was set to \" + qryQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n-\n-        if (qryQuota > globalQuota) {\n-            log.warning(\"The local quota was set higher than global. The new value will be truncated \" +\n-                \"to the size of the global quota [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota);\n-        }\n-    }\n-\n-    /**\n-     * @return Current query quota.\n-     */\n-    public String getQueryQuotaString() {\n-        return String.valueOf(qryQuota);\n+    public long memoryReserved() {\n+        return reserved.get();\n     }\n \n     /**\n-     * Sets offloading enabled flag.\n+     * Gets global memory limit for queries.\n      *\n-     * @param offloadingEnabled Offloading enabled flag.\n-     */\n-    public synchronized void setOffloadingEnabled(boolean offloadingEnabled) {\n-        this.offloadingEnabled = offloadingEnabled;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query query offloading enabled flag was set to \" + offloadingEnabled +\n-                \". Current memory tracking parameters: [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + this.offloadingEnabled + ']');\n-        }\n-    }\n-\n-    /**\n-     * @return Flag whether offloading is enabled.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n-    }\n-\n-    /**\n-     * @return Bytes reserved by all queries.\n+     * @return Max memory in bytes.\n      */\n-    @Override public long reserved() {\n-        return reserved.get();\n-    }\n-\n-    /** */\n-    public long memoryLimit() {\n+    public long maxMemory() {\n         return globalQuota;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public void swap(long size) {\n-        // NO-OP\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void unswap(long size) {\n-        // NO-OP\n-    }\n-\n     /** {@inheritDoc} */\n     @Override public void close() {\n         // Cursors are not tracked and can't be forcibly closed to release resources.\n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 58ae9e20f92..727ed359f06 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -172,4 +179,29 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    private static class ReservationOp implements LongBinaryOperator {\n+        /** Operation result high bound.*/\n+        private final long limit;\n+\n+        /**\n+         * Constructor.\n+         * @param limit Operation result high bound.\n+         */\n+        ReservationOp(long limit) {\n+            this.limit = limit;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long applyAsLong(long prev, long x) {\n+            long res = prev + x;\n+\n+            if (res > limit)\n+                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+\n+            return res;\n+        }\n+    }\n }\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 727ed359f06..788602adfa6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -179,29 +196,4 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n-\n-    /** */\n-    private static class ReservationOp implements LongBinaryOperator {\n-        /** Operation result high bound.*/\n-        private final long limit;\n-\n-        /**\n-         * Constructor.\n-         * @param limit Operation result high bound.\n-         */\n-        ReservationOp(long limit) {\n-            this.limit = limit;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long applyAsLong(long prev, long x) {\n-            long res = prev + x;\n-\n-            if (res > limit)\n-                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-\n-            return res;\n-        }\n-    }\n }\n", "next_change": {"commit": "3c6a5cb36df055ae623a37e59044c99b862b1938", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 788602adfa6..750b2e3b12d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -196,4 +297,196 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    public IgniteLogger log() {\n+        return log;\n+    }\n+\n+    /**\n+     * Cleans spill directory. Spill directory is used for disk\n+     * offloading of the intermediate results of heavy queries.\n+     */\n+    public void cleanSpillDirectory() {\n+        try {\n+            File spillDir = U.resolveWorkDirectory(\n+                ctx.config().getWorkDirectory(),\n+                DISK_SPILL_DIR,\n+                false);\n+\n+            File[] spillFiles = spillDir.listFiles();\n+\n+            if (spillFiles.length == 0)\n+                return;\n+\n+            for (int i = 0; i < spillFiles.length; i++) {\n+                try {\n+                    File spillFile = spillFiles[i];\n+\n+                    String nodeId = spillFile.getName().split(\"_\")[1]; // Spill name pattern: spill_nodeId_fileId.\n+\n+                    UUID nodeUuid = UUID.fromString(nodeId);\n+\n+                    if (!ctx.discovery().alive(nodeUuid) || ctx.localNodeId().equals(nodeUuid))\n+                        spillFile.delete();\n+                }\n+                catch (Exception e) {\n+                    log.debug(\"Error on cleaning spill directory. \" + X.getFullStackTrace(e));\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.warning(\"Failed to cleanup the temporary directory for intermediate \" +\n+                \"SQL query results from the previous node run.\", e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public GroupByData newManagedGroupByData(Session ses, ArrayList<Expression> expressions,\n+        boolean isGrpQry, int[] grpIdx) {\n+\n+        boolean spillingEnabled = ctx.config().isSqlOffloadingEnabled();\n+\n+        if (!spillingEnabled)\n+            return null;\n+\n+        assert isGrpQry; // isGrpQry == false allowed only for window queries which are not supported yet.\n+\n+        return new H2ManagedGroupByData(ses, grpIdx);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @return Plain external result.\n+     */\n+    public ResultExternal createPlainExternalResult(Session ses) {\n+        return new PlainExternalResult(ses);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param distinct Distinct flag.\n+     * @param distinctIndexes Distinct indexes.\n+     * @param visibleColCnt Visible columns count.\n+     * @param sort Sort order.\n+     * @param rowCnt Row count.\n+     * @return Sorted external result.\n+     */\n+    public ResultExternal createSortedExternalResult(Session ses, boolean distinct, int[] distinctIndexes,\n+        int visibleColCnt, SortOrder sort, int rowCnt) {\n+        return new SortedExternalResult(ses, distinct, distinctIndexes, visibleColCnt, sort, rowCnt);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param size Size;\n+     * @return Grouped result;\n+     */\n+    public GroupedExternalResult createGroupedExternalResult(Session ses, int size) {\n+        return new GroupedExternalResult(ses, size);\n+    }\n+\n+    /**\n+     * Creates external data (offload file wrapper).\n+     * @param ses Session.\n+     * @param useHashIdx Flag whether to use hash index.\n+     * @param initSize Initial size.\n+     * @param cls Class of stored values.\n+     * @param <T> Type of stored values.\n+     * @return Created external data (offload file wrapper).\n+     */\n+    public <T> ExternalResultData<T> createExternalData(Session ses, boolean useHashIdx, long initSize, Class<T> cls) {\n+        if (!ses.isOffloadedToDisk()) {\n+            ses.setOffloadedToDisk(true);\n+\n+            metrics.trackQueryOffloaded();\n+        }\n+\n+        return new ExternalResultData<>(log,\n+            ctx.config().getWorkDirectory(),\n+            fileIOFactory,\n+            ctx.localNodeId(),\n+            useHashIdx,\n+            initSize,\n+            cls,\n+            ses.getDatabase().getCompareMode(),\n+            ses.getDatabase());\n+    }\n+\n+    /**\n+     * FileIO decorator for stats collecting.\n+     */\n+    private static class TrackableFileIO extends FileIODecorator {\n+        /** */\n+        private final SqlMemoryStatisticsHolder metrics;\n+\n+        /**\n+         * @param delegate File I/O delegate\n+         */\n+        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n+            super(delegate);\n+\n+            this.metrics = metrics;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf) throws IOException {\n+            int bytesRead = delegate.read(destBuf);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n+            int bytesRead = delegate.read(destBuf, position);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(byte[] buf, int off, int len) throws IOException {\n+            int bytesRead = delegate.read(buf, off, len);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf, position);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(byte[] buf, int off, int len) throws IOException {\n+            int bytesWritten = delegate.write(buf, off, len);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+    }\n }\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 750b2e3b12d..3768f833c89 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -410,83 +456,7 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n             initSize,\n             cls,\n             ses.getDatabase().getCompareMode(),\n-            ses.getDatabase());\n-    }\n-\n-    /**\n-     * FileIO decorator for stats collecting.\n-     */\n-    private static class TrackableFileIO extends FileIODecorator {\n-        /** */\n-        private final SqlMemoryStatisticsHolder metrics;\n-\n-        /**\n-         * @param delegate File I/O delegate\n-         */\n-        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n-            super(delegate);\n-\n-            this.metrics = metrics;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf) throws IOException {\n-            int bytesRead = delegate.read(destBuf);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n-            int bytesRead = delegate.read(destBuf, position);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(byte[] buf, int off, int len) throws IOException {\n-            int bytesRead = delegate.read(buf, off, len);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf, position);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(byte[] buf, int off, int len) throws IOException {\n-            int bytesWritten = delegate.write(buf, off, len);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n+            ses.getDatabase(),\n+            ses.memoryTracker());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "5c7104415d67a2d06fa12b058c6ea8c5410c3393", "committedDate": "2019-07-24 20:42:20 +0300", "message": "GG-21813: SQL: Fix assert in MemoryManager.createMemoryTracker."}, {"oid": "e6adea02b6463c268d3c67bb973e9dbf754a8ff1", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20995: SQL: Metrics of using memory quotas."}, {"oid": "ee923b0183a2f8dc02b9e408f949c48be9c7366d", "committedDate": "2019-10-22 15:09:39 +0300", "message": "GG-24667: SQL: Disable memory quotas by default. This closes #604."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "cb6c1b2a9be6ce52cdbb5cfbfb3c7b5e34fe53cd", "committedDate": "2020-03-05 12:27:31 +0300", "message": "GG-27922 Expose SQL memory quota in bytes for JMX"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "9502a24df45ba7a97e2efa7d21476926e8250c66", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29130 [IGNITE-12953] Add support for SingleSpaceSeparator to the checkstyle (#7734)"}, {"oid": "f4f9676e82ec87f0977f387ad233f993e5c4cb28", "committedDate": "2020-08-18 18:12:18 -0400", "message": "GG-29772 (#1247)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "a8de46705cf54e56edefa158338a3a8ce3bc96e2", "committedDate": "2021-03-10 13:53:17 -0500", "message": "GG-32298 Create a JMX metric to show realtime sql engine memory utililization (#1726)"}, {"oid": "342366623db8d66053fb090ea2bee50826137670", "committedDate": "2021-05-28 10:18:58 -0400", "message": "GG-33258 correct log reporting of sqlOffloadingEnabled (#1943)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwNTY3NQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390205675", "body": "I don't understand that logic _reserve anyway even if parent reservation fails_. \r\nWhy don't use `finally` here?", "bodyText": "I don't understand that logic reserve anyway even if parent reservation fails.\nWhy don't use finally here?", "bodyHTML": "<p dir=\"auto\">I don't understand that logic <em>reserve anyway even if parent reservation fails</em>.<br>\nWhy don't use <code>finally</code> here?</p>", "author": "mshonichev", "createdAt": "2020-03-10T10:02:31Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -203,74 +235,239 @@ public boolean isOffloadingEnabled() {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void swap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.swap(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unswap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unswap(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, NORMALLY_OPERATING_STATE, CLOSING_OR_CLOSED_STATE))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != CLOSING_OR_CLOSED_STATE)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            catch (IgniteSQLException ex) {\n+                reserved += size;", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2NTIwOA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390265208", "bodyText": "Yes, finally is fit better, thanks!\nWe should count memory here to match tracked memory on parent (parent reserves memory, but then could throw exception and doesn't release memory)", "author": "korlov42", "createdAt": "2020-03-10T12:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwNTY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a92bfb05d14cf079f18fdd7f8befed605ada743a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ca2188c44ad..459c4a15213 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -362,14 +362,10 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n             try {\n                 res = parent.reserve(size);\n             }\n-            catch (IgniteSQLException ex) {\n+            finally {\n                 reserved += size;\n-\n-                throw ex;\n             }\n \n-            reserved += size;\n-\n             return res;\n         }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ca2188c44ad..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -362,14 +362,10 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n             try {\n                 res = parent.reserve(size);\n             }\n-            catch (IgniteSQLException ex) {\n+            finally {\n                 reserved += size;\n-\n-                throw ex;\n             }\n \n-            reserved += size;\n-\n             return res;\n         }\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -278,192 +152,16 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-            return;\n-\n-        synchronized (this) {\n-            for (H2MemoryTracker child : children)\n-                child.close();\n+        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n+            release(RESERVED_UPD.get(this));\n \n-            children.clear();\n+            if (parent != null)\n+                parent.release(reservedFromParent);\n         }\n-\n-        closed = true;\n-\n-        reserved = 0;\n-\n-        if (parent != null)\n-            parent.release(reservedFromParent);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        if (parent != null)\n-            parent.incrementFilesCreated();\n-\n-        filesCreated++;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized H2MemoryTracker createChildTracker() {\n-        checkClosed();\n-\n-        H2MemoryTracker child = new ChildMemoryTracker(this);\n-\n-        children.add(child);\n-\n-        return child;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n-        if (state != STATE_CLOSED)\n-            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-\n-    /** */\n-    private static class ChildMemoryTracker implements H2MemoryTracker {\n-        /** State updater. */\n-        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n-            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n-\n-        /** */\n-        private final H2MemoryTracker parent;\n-\n-        /** */\n-        private long reserved;\n-\n-        /** */\n-        private long writtenOnDisk;\n-\n-        /** */\n-        private long totalWrittenOnDisk;\n-\n-        /** */\n-        private volatile int state;\n-\n-        /**\n-         * @param parent Parent.\n-         */\n-        public ChildMemoryTracker(H2MemoryTracker parent) {\n-            this.parent = parent;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean reserve(long size) {\n-            checkClosed();\n-\n-            boolean res;\n-            try {\n-                res = parent.reserve(size);\n-            }\n-            finally {\n-                reserved += size;\n-            }\n-\n-            return res;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void release(long size) {\n-            checkClosed();\n-\n-            reserved -= size;\n-\n-            parent.release(size);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long writtenOnDisk() {\n-            return writtenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long totalWrittenOnDisk() {\n-            return totalWrittenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long reserved() {\n-            return reserved;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void spill(long size) {\n-            checkClosed();\n-\n-            parent.spill(size);\n-\n-            writtenOnDisk += size;\n-            totalWrittenOnDisk += size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void unspill(long size) {\n-            checkClosed();\n-\n-            parent.unspill(size);\n-\n-            writtenOnDisk -= size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void incrementFilesCreated() {\n-            checkClosed();\n-\n-            parent.incrementFilesCreated();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public H2MemoryTracker createChildTracker() {\n-            checkClosed();\n-\n-            return parent.createChildTracker();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void onChildClosed(H2MemoryTracker child) {\n-            parent.onChildClosed(child);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean closed() {\n-            return state == STATE_CLOSED;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() {\n-            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-                return;\n-\n-            parent.release(reserved);\n-            parent.unspill(writtenOnDisk);\n-\n-            reserved = 0;\n-            writtenOnDisk = 0;\n-\n-            parent.onChildClosed(this);\n-        }\n-\n-        /** */\n-        private void checkClosed() {\n-            if (state == STATE_CLOSED)\n-                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-        }\n-    }\n-\n-    /** Exception thrown when try to track memory with closed tracker. */\n-    public static class TrackerWasClosedException extends RuntimeException {\n-        /**\n-         * @param msg Message.\n-         */\n-        public TrackerWasClosedException(String msg) {\n-            super(msg);\n-        }\n-    }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -27,139 +26,249 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n-    /** Resered field updater. */\n-    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n-        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n-\n-    /** Closed flag updater. */\n-    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n-        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n+public class QueryMemoryTracker implements H2MemoryTracker {\n+    /** Logger. */\n+    private final IgniteLogger log;\n \n     /** Parent tracker. */\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long maxMem;\n+    private final long quota;\n+\n+    /**\n+     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n+     * <ul>\n+     * <li>{@code false} - exception will be thrown.</li>\n+     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n+     * </ul>\n+     */\n+    private final boolean offloadingEnabled;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private volatile long reservedFromParent;\n+    private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private volatile long reserved;\n+    private long reserved;\n \n     /** Close flag to prevent tracker reuse. */\n-    private volatile Boolean closed = Boolean.FALSE;\n+    private Boolean closed = Boolean.FALSE;\n+\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n+\n+    /** Total number of bytes tracked by current tracker. */\n+    private volatile long totalReserved;\n+\n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n+\n+    /** Query descriptor (for logging). */\n+    private final String qryDesc;\n \n     /**\n      * Constructor.\n      *\n+     * @param log Logger.\n      * @param parent Parent memory tracker.\n-     * @param maxMem Query memory limit in bytes.\n+     * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n+     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n      */\n-    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n-        assert maxMem > 0;\n-\n+    QueryMemoryTracker(\n+        IgniteLogger log,\n+        H2MemoryTracker parent,\n+        long quota,\n+        long blockSize,\n+        boolean offloadingEnabled,\n+        String qryDesc) {\n+        assert quota >= 0;\n+\n+        this.log = log;\n+        this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n-        this.maxMem = maxMem;\n-        this.blockSize = blockSize;\n+        this.quota = quota;\n+        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n+        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void reserve(long size) {\n-        assert !closed && size >= 0;\n+    @Override public synchronized boolean reserved(long toReserve) {\n+        assert toReserve >= 0;\n \n-        if (size == 0)\n-            return;\n+        checkClosed();\n \n-        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n-            if (prev + x > maxMem) {\n-                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-            }\n+        reserved += toReserve;\n+        totalReserved += toReserve;\n \n-            return prev + x;\n-        });\n+        if (parent != null && reserved > reservedFromParent) {\n+            if (!reserveFromParent())\n+                return false; // Offloading.\n+        }\n \n-        if (parent != null && reserved0 > reservedFromParent) {\n-            synchronized (this) {\n-                assert !closed;\n+        if (quota > 0 && reserved >= quota)\n+            return onQuotaExceeded();\n \n-                if (reserved0 <= reservedFromParent)\n-                    return;\n+        return true;\n+    }\n \n-                // If single block size is too small.\n-                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n-                // If we are too close to limit.\n-                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n+    /**\n+     * Checks whether tracker was closed.\n+     */\n+    private void checkClosed() {\n+        if (closed)\n+            throw new IllegalStateException(\"Memory tracker has been closed concurrently.\");\n+    }\n \n-                try {\n-                    parent.reserve(blockSize);\n+    /**\n+     * Reserves memory from parent tracker.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean reserveFromParent() {\n+        // If single block size is too small.\n+        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n \n-                    reservedFromParent += blockSize;\n-                }\n-                catch (Throwable e) {\n-                    // Fallback if failed to reserve.\n-                    RESERVED_UPD.addAndGet(this, -size);\n+        // If we are too close to limit.\n+        if (quota > 0)\n+            blockSize = Math.min(blockSize, quota - reservedFromParent);\n \n-                    throw e;\n-                }\n-            }\n-        }\n+        if (parent.reserved(blockSize))\n+            reservedFromParent += blockSize;\n+        else\n+            return false;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Action on quota exceeded.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean onQuotaExceeded() {\n+        if (offloadingEnabled)\n+            return false;\n+        else\n+            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void release(long size) {\n-        assert size >= 0;\n+    @Override public synchronized void released(long toRelease) {\n+        assert toRelease >= 0;\n \n-        if (size == 0)\n+        if (toRelease == 0)\n             return;\n \n-        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n-            if (prev + x < 0)\n-                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n-                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n+        checkClosed();\n+\n+        reserved -= toRelease;\n+\n+        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + toRelease) +\n+            \", toFree=\" + toRelease + ']';\n \n-            return prev + x;\n-        });\n+        if (parent != null && reservedFromParent - reserved > blockSize)\n+            releaseFromParent();\n+    }\n+\n+    /**\n+     * Releases memory from parent.\n+     */\n+    private void releaseFromParent() {\n+        long toReleaseFromParent = reservedFromParent - reserved;\n \n-        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n+        parent.released(toReleaseFromParent);\n \n-        // For now, won'tQ release memory to parent until tracker closed.\n-       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n-            synchronized (this) {\n-                if (preAllocated - reserved >= 2 * blockSize) {\n-                    parent.release(blockSize);\n+        reservedFromParent -= toReleaseFromParent;\n \n-                    preAllocated -= blockSize;\n-                }\n-            }\n-        }*/\n+        assert reservedFromParent >= 0 : reservedFromParent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized long memoryReserved() {\n+        return reserved;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long memoryLimit() {\n+        return quota;\n+    }\n+\n+    /**\n+     * @return Offloading enabled flag.\n+     */\n+    public boolean isOffloadingEnabled() {\n+        return offloadingEnabled;\n     }\n \n     /**\n      * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    public boolean closed() {\n+    public synchronized boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        if (closed)\n+            return;\n+\n+        closed = true;\n \n-            if (parent != null)\n-                parent.release(reservedFromParent);\n+        reserved = 0;\n+\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n         }\n     }\n \n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n+    }\n+\n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwNjQxNg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390206416", "body": "shouldn't `try .. catch` be added here too?", "bodyText": "shouldn't try .. catch be added here too?", "bodyHTML": "<p dir=\"auto\">shouldn't <code>try .. catch</code> be added here too?</p>", "author": "mshonichev", "createdAt": "2020-03-10T10:03:46Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -203,74 +235,239 @@ public boolean isOffloadingEnabled() {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void swap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.swap(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unswap(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unswap(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, NORMALLY_OPERATING_STATE, CLOSING_OR_CLOSED_STATE))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != CLOSING_OR_CLOSED_STATE)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            catch (IgniteSQLException ex) {\n+                reserved += size;\n+\n+                throw ex;\n+            }\n+\n+            reserved += size;\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void swap(long size) {\n+            checkClosed();\n+\n+            parent.swap(size);", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2MjM2Ng==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390262366", "bodyText": "no, because we expect exceptions only when you try to reserve memory and quota exceeded and  offloading is disabled", "author": "korlov42", "createdAt": "2020-03-10T11:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwNjQxNg=="}], "type": "inlineReview", "revised_code": {"commit": "a92bfb05d14cf079f18fdd7f8befed605ada743a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ca2188c44ad..459c4a15213 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -398,20 +394,20 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n         }\n \n         /** {@inheritDoc} */\n-        @Override public void swap(long size) {\n+        @Override public void spill(long size) {\n             checkClosed();\n \n-            parent.swap(size);\n+            parent.spill(size);\n \n             writtenOnDisk += size;\n             totalWrittenOnDisk += size;\n         }\n \n         /** {@inheritDoc} */\n-        @Override public void unswap(long size) {\n+        @Override public void unspill(long size) {\n             checkClosed();\n \n-            parent.unswap(size);\n+            parent.unspill(size);\n \n             writtenOnDisk -= size;\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ca2188c44ad..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -398,20 +394,20 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n         }\n \n         /** {@inheritDoc} */\n-        @Override public void swap(long size) {\n+        @Override public void spill(long size) {\n             checkClosed();\n \n-            parent.swap(size);\n+            parent.spill(size);\n \n             writtenOnDisk += size;\n             totalWrittenOnDisk += size;\n         }\n \n         /** {@inheritDoc} */\n-        @Override public void unswap(long size) {\n+        @Override public void unspill(long size) {\n             checkClosed();\n \n-            parent.unswap(size);\n+            parent.unspill(size);\n \n             writtenOnDisk -= size;\n         }\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -278,192 +152,16 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-            return;\n-\n-        synchronized (this) {\n-            for (H2MemoryTracker child : children)\n-                child.close();\n+        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n+            release(RESERVED_UPD.get(this));\n \n-            children.clear();\n+            if (parent != null)\n+                parent.release(reservedFromParent);\n         }\n-\n-        closed = true;\n-\n-        reserved = 0;\n-\n-        if (parent != null)\n-            parent.release(reservedFromParent);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        if (parent != null)\n-            parent.incrementFilesCreated();\n-\n-        filesCreated++;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized H2MemoryTracker createChildTracker() {\n-        checkClosed();\n-\n-        H2MemoryTracker child = new ChildMemoryTracker(this);\n-\n-        children.add(child);\n-\n-        return child;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n-        if (state != STATE_CLOSED)\n-            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-\n-    /** */\n-    private static class ChildMemoryTracker implements H2MemoryTracker {\n-        /** State updater. */\n-        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n-            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n-\n-        /** */\n-        private final H2MemoryTracker parent;\n-\n-        /** */\n-        private long reserved;\n-\n-        /** */\n-        private long writtenOnDisk;\n-\n-        /** */\n-        private long totalWrittenOnDisk;\n-\n-        /** */\n-        private volatile int state;\n-\n-        /**\n-         * @param parent Parent.\n-         */\n-        public ChildMemoryTracker(H2MemoryTracker parent) {\n-            this.parent = parent;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean reserve(long size) {\n-            checkClosed();\n-\n-            boolean res;\n-            try {\n-                res = parent.reserve(size);\n-            }\n-            finally {\n-                reserved += size;\n-            }\n-\n-            return res;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void release(long size) {\n-            checkClosed();\n-\n-            reserved -= size;\n-\n-            parent.release(size);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long writtenOnDisk() {\n-            return writtenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long totalWrittenOnDisk() {\n-            return totalWrittenOnDisk;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long reserved() {\n-            return reserved;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void spill(long size) {\n-            checkClosed();\n-\n-            parent.spill(size);\n-\n-            writtenOnDisk += size;\n-            totalWrittenOnDisk += size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void unspill(long size) {\n-            checkClosed();\n-\n-            parent.unspill(size);\n-\n-            writtenOnDisk -= size;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void incrementFilesCreated() {\n-            checkClosed();\n-\n-            parent.incrementFilesCreated();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public H2MemoryTracker createChildTracker() {\n-            checkClosed();\n-\n-            return parent.createChildTracker();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void onChildClosed(H2MemoryTracker child) {\n-            parent.onChildClosed(child);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public boolean closed() {\n-            return state == STATE_CLOSED;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() {\n-            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n-                return;\n-\n-            parent.release(reserved);\n-            parent.unspill(writtenOnDisk);\n-\n-            reserved = 0;\n-            writtenOnDisk = 0;\n-\n-            parent.onChildClosed(this);\n-        }\n-\n-        /** */\n-        private void checkClosed() {\n-            if (state == STATE_CLOSED)\n-                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-        }\n-    }\n-\n-    /** Exception thrown when try to track memory with closed tracker. */\n-    public static class TrackerWasClosedException extends RuntimeException {\n-        /**\n-         * @param msg Message.\n-         */\n-        public TrackerWasClosedException(String msg) {\n-            super(msg);\n-        }\n-    }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -27,139 +26,249 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n-    /** Resered field updater. */\n-    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n-        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n-\n-    /** Closed flag updater. */\n-    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n-        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n+public class QueryMemoryTracker implements H2MemoryTracker {\n+    /** Logger. */\n+    private final IgniteLogger log;\n \n     /** Parent tracker. */\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long maxMem;\n+    private final long quota;\n+\n+    /**\n+     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n+     * <ul>\n+     * <li>{@code false} - exception will be thrown.</li>\n+     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n+     * </ul>\n+     */\n+    private final boolean offloadingEnabled;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private volatile long reservedFromParent;\n+    private long reservedFromParent;\n \n     /** Memory reserved by query. */\n-    private volatile long reserved;\n+    private long reserved;\n \n     /** Close flag to prevent tracker reuse. */\n-    private volatile Boolean closed = Boolean.FALSE;\n+    private Boolean closed = Boolean.FALSE;\n+\n+    /** Total number of bytes written on disk tracked by current tracker. */\n+    private volatile long totalWrittenOnDisk;\n+\n+    /** Total number of bytes tracked by current tracker. */\n+    private volatile long totalReserved;\n+\n+    /** The number of files created by the query. */\n+    private volatile int filesCreated;\n+\n+    /** Query descriptor (for logging). */\n+    private final String qryDesc;\n \n     /**\n      * Constructor.\n      *\n+     * @param log Logger.\n      * @param parent Parent memory tracker.\n-     * @param maxMem Query memory limit in bytes.\n+     * @param quota Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n+     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n      */\n-    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n-        assert maxMem > 0;\n-\n+    QueryMemoryTracker(\n+        IgniteLogger log,\n+        H2MemoryTracker parent,\n+        long quota,\n+        long blockSize,\n+        boolean offloadingEnabled,\n+        String qryDesc) {\n+        assert quota >= 0;\n+\n+        this.log = log;\n+        this.offloadingEnabled = offloadingEnabled;\n         this.parent = parent;\n-        this.maxMem = maxMem;\n-        this.blockSize = blockSize;\n+        this.quota = quota;\n+        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n+        this.qryDesc = qryDesc;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void reserve(long size) {\n-        assert !closed && size >= 0;\n+    @Override public synchronized boolean reserved(long toReserve) {\n+        assert toReserve >= 0;\n \n-        if (size == 0)\n-            return;\n+        checkClosed();\n \n-        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n-            if (prev + x > maxMem) {\n-                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-            }\n+        reserved += toReserve;\n+        totalReserved += toReserve;\n \n-            return prev + x;\n-        });\n+        if (parent != null && reserved > reservedFromParent) {\n+            if (!reserveFromParent())\n+                return false; // Offloading.\n+        }\n \n-        if (parent != null && reserved0 > reservedFromParent) {\n-            synchronized (this) {\n-                assert !closed;\n+        if (quota > 0 && reserved >= quota)\n+            return onQuotaExceeded();\n \n-                if (reserved0 <= reservedFromParent)\n-                    return;\n+        return true;\n+    }\n \n-                // If single block size is too small.\n-                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n-                // If we are too close to limit.\n-                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n+    /**\n+     * Checks whether tracker was closed.\n+     */\n+    private void checkClosed() {\n+        if (closed)\n+            throw new IllegalStateException(\"Memory tracker has been closed concurrently.\");\n+    }\n \n-                try {\n-                    parent.reserve(blockSize);\n+    /**\n+     * Reserves memory from parent tracker.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean reserveFromParent() {\n+        // If single block size is too small.\n+        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n \n-                    reservedFromParent += blockSize;\n-                }\n-                catch (Throwable e) {\n-                    // Fallback if failed to reserve.\n-                    RESERVED_UPD.addAndGet(this, -size);\n+        // If we are too close to limit.\n+        if (quota > 0)\n+            blockSize = Math.min(blockSize, quota - reservedFromParent);\n \n-                    throw e;\n-                }\n-            }\n-        }\n+        if (parent.reserved(blockSize))\n+            reservedFromParent += blockSize;\n+        else\n+            return false;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Action on quota exceeded.\n+     * @return {@code false} if offloading is needed.\n+     */\n+    private boolean onQuotaExceeded() {\n+        if (offloadingEnabled)\n+            return false;\n+        else\n+            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void release(long size) {\n-        assert size >= 0;\n+    @Override public synchronized void released(long toRelease) {\n+        assert toRelease >= 0;\n \n-        if (size == 0)\n+        if (toRelease == 0)\n             return;\n \n-        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n-            if (prev + x < 0)\n-                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n-                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n+        checkClosed();\n+\n+        reserved -= toRelease;\n+\n+        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + toRelease) +\n+            \", toFree=\" + toRelease + ']';\n \n-            return prev + x;\n-        });\n+        if (parent != null && reservedFromParent - reserved > blockSize)\n+            releaseFromParent();\n+    }\n+\n+    /**\n+     * Releases memory from parent.\n+     */\n+    private void releaseFromParent() {\n+        long toReleaseFromParent = reservedFromParent - reserved;\n \n-        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n+        parent.released(toReleaseFromParent);\n \n-        // For now, won'tQ release memory to parent until tracker closed.\n-       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n-            synchronized (this) {\n-                if (preAllocated - reserved >= 2 * blockSize) {\n-                    parent.release(blockSize);\n+        reservedFromParent -= toReleaseFromParent;\n \n-                    preAllocated -= blockSize;\n-                }\n-            }\n-        }*/\n+        assert reservedFromParent >= 0 : reservedFromParent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized long memoryReserved() {\n+        return reserved;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long memoryLimit() {\n+        return quota;\n+    }\n+\n+    /**\n+     * @return Offloading enabled flag.\n+     */\n+    public boolean isOffloadingEnabled() {\n+        return offloadingEnabled;\n     }\n \n     /**\n      * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    public boolean closed() {\n+    public synchronized boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        if (closed)\n+            return;\n+\n+        closed = true;\n \n-            if (parent != null)\n-                parent.release(reservedFromParent);\n+        reserved = 0;\n+\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n         }\n     }\n \n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n+    }\n+\n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxMDE4NQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390210185", "body": "why was test expectation changed ?", "bodyText": "why was test expectation changed ?", "bodyHTML": "<p dir=\"auto\">why was test expectation changed ?</p>", "author": "mshonichev", "createdAt": "2020-03-10T10:10:46Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java", "diffHunk": "@@ -80,7 +80,7 @@ public void testOffloadStats() {\n         // Ensure that metrics increased.\n         Metrics m1 = withdrawMetrics();\n \n-        Metrics expected = m0.add(Metrics.of(6249, 6249, 1, 16878, 16878, 1)); // Expected numbers of written bytes.\n+        Metrics expected = m0.add(Metrics.of(6249, 6249, 1, 16878, 16878, 2)); // Expected numbers of written bytes.", "originalCommit": "68a17877ef420e749a5ca770ad29e58333ab4b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxMDYxNw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390210617", "bodyText": "same question about JdbcQueryQuotaTest, btw, why was memory quota doubled there ?", "author": "mshonichev", "createdAt": "2020-03-10T10:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxMDE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2MTc4OQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r390261789", "bodyText": "because now all local map queries and reduce shares the common tracker, so they shares common quota", "author": "korlov42", "createdAt": "2020-03-10T11:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxMDE4NQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "3c6a5cb36df055ae623a37e59044c99b862b1938", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java\nindex 6d47e6d724a..d3e3d6cf4bf 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java\n", "chunk": "@@ -80,7 +80,7 @@ public class SqlStatisticOffloadingTest extends DiskSpillingAbstractTest {\n         // Ensure that metrics increased.\n         Metrics m1 = withdrawMetrics();\n \n-        Metrics expected = m0.add(Metrics.of(6249, 6249, 1, 16878, 16878, 2)); // Expected numbers of written bytes.\n+        Metrics expected = m0.add(Metrics.of(6249, 6249, 1, 16878, 16878, 1)); // Expected numbers of written bytes.\n \n         assertEquals(expected, m1);\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java\nindex d3e3d6cf4bf..6d47e6d724a 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/metric/SqlStatisticOffloadingTest.java\n", "chunk": "@@ -80,7 +80,7 @@ public class SqlStatisticOffloadingTest extends DiskSpillingAbstractTest {\n         // Ensure that metrics increased.\n         Metrics m1 = withdrawMetrics();\n \n-        Metrics expected = m0.add(Metrics.of(6249, 6249, 1, 16878, 16878, 1)); // Expected numbers of written bytes.\n+        Metrics expected = m0.add(Metrics.of(6249, 6249, 1, 16878, 16878, 2)); // Expected numbers of written bytes.\n \n         assertEquals(expected, m1);\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "9502a24df45ba7a97e2efa7d21476926e8250c66", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29130 [IGNITE-12953] Add support for SingleSpaceSeparator to the checkstyle (#7734)"}, {"oid": "79c235d9530a174e1a6259125e8b7668de5362e3", "committedDate": "2020-06-07 19:52:05 +0300", "message": "GG-29134 [IGNITE-12939] Add WhitespacesAround support for the checkstyle (#7726)"}]}, {"oid": "a92bfb05d14cf079f18fdd7f8befed605ada743a", "url": "https://github.com/gridgain/gridgain/commit/a92bfb05d14cf079f18fdd7f8befed605ada743a", "message": "review", "committedDate": "2020-03-10T12:41:37Z", "type": "commit"}, {"oid": "29eaaab19f8e082296dbb3d947d1deea5ebe2b60", "url": "https://github.com/gridgain/gridgain/commit/29eaaab19f8e082296dbb3d947d1deea5ebe2b60", "message": "tests for testplan", "committedDate": "2020-03-11T12:41:51Z", "type": "commit"}, {"oid": "df1454f5690a86fc1f28d728f60ab667b7510a65", "url": "https://github.com/gridgain/gridgain/commit/df1454f5690a86fc1f28d728f60ab667b7510a65", "message": "add new test to suit", "committedDate": "2020-03-11T12:43:14Z", "type": "commit"}, {"oid": "acde264d8790ad4c163b28cee541edc793d6fe04", "url": "https://github.com/gridgain/gridgain/commit/acde264d8790ad4c163b28cee541edc793d6fe04", "message": "minors", "committedDate": "2020-03-12T09:22:53Z", "type": "commit"}, {"oid": "c36f5f7b60389640dcf21a90edf0cc5094bfe660", "url": "https://github.com/gridgain/gridgain/commit/c36f5f7b60389640dcf21a90edf0cc5094bfe660", "message": "disable memory tracking", "committedDate": "2020-03-13T07:09:39Z", "type": "commit"}, {"oid": "59886b58e2c0efd007b2974da811001742c0d9c6", "url": "https://github.com/gridgain/gridgain/commit/59886b58e2c0efd007b2974da811001742c0d9c6", "message": "mock qry info", "committedDate": "2020-03-13T11:33:50Z", "type": "commit"}, {"oid": "004d0aeddd1ba85e2c7ed9319ef037fb4c4552f7", "url": "https://github.com/gridgain/gridgain/commit/004d0aeddd1ba85e2c7ed9319ef037fb4c4552f7", "message": "change H2QueryInfo description building", "committedDate": "2020-03-13T14:24:29Z", "type": "commit"}, {"oid": "761726bfb587bfef82e4c1599bf1997979e593c9", "url": "https://github.com/gridgain/gridgain/commit/761726bfb587bfef82e4c1599bf1997979e593c9", "message": "supplier for description", "committedDate": "2020-03-13T16:09:21Z", "type": "commit"}, {"oid": "9f6f1d7012ddfa9777fe71459ca85899ebb617e5", "url": "https://github.com/gridgain/gridgain/commit/9f6f1d7012ddfa9777fe71459ca85899ebb617e5", "message": "one more try", "committedDate": "2020-03-15T09:07:28Z", "type": "commit"}, {"oid": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "url": "https://github.com/gridgain/gridgain/commit/f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "message": "minor", "committedDate": "2020-03-15T14:57:33Z", "type": "commit"}, {"oid": "7642ca020ce0f80e6edabcdd6556c18f540f5ff8", "url": "https://github.com/gridgain/gridgain/commit/7642ca020ce0f80e6edabcdd6556c18f540f5ff8", "message": "minors", "committedDate": "2020-03-16T08:03:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NjAyMw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392846023", "body": "Braces", "bodyText": "Braces", "bodyHTML": "<p dir=\"auto\">Braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:16:54Z", "path": "modules/h2/src/main/java/org/h2/engine/Session.java", "diffHunk": "@@ -960,6 +977,11 @@ public void close() {\n             try {\n                 database.checkPowerOff();\n \n+                H2MemoryTracker tracker = memoryTracker;\n+                if (tracker != null) {\n+                    tracker.close();", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5OTk2OA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392899968", "bodyText": "do we apply our code style rules to h2 module too?", "author": "korlov42", "createdAt": "2020-03-16T09:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NjAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 95880dac68d..87bdaad3500 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -978,9 +978,8 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n                 database.checkPowerOff();\n \n                 H2MemoryTracker tracker = memoryTracker;\n-                if (tracker != null) {\n+                if (tracker != null)\n                     tracker.close();\n-                }\n \n                 // release any open table locks\n                 rollback();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 95880dac68d..87bdaad3500 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -978,9 +978,8 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n                 database.checkPowerOff();\n \n                 H2MemoryTracker tracker = memoryTracker;\n-                if (tracker != null) {\n+                if (tracker != null)\n                     tracker.close();\n-                }\n \n                 // release any open table locks\n                 rollback();\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 87bdaad3500..922209fce8e 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -977,10 +938,6 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n             try {\n                 database.checkPowerOff();\n \n-                H2MemoryTracker tracker = memoryTracker;\n-                if (tracker != null)\n-                    tracker.close();\n-\n                 // release any open table locks\n                 rollback();\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/engine/Session.java b/modules/h2/src/main/java/org/h2/engine/Session.java\nindex 922209fce8e..87bdaad3500 100644\n--- a/modules/h2/src/main/java/org/h2/engine/Session.java\n+++ b/modules/h2/src/main/java/org/h2/engine/Session.java\n", "chunk": "@@ -938,6 +977,10 @@ public class Session extends SessionWithState implements TransactionStore.Rollba\n             try {\n                 database.checkPowerOff();\n \n+                H2MemoryTracker tracker = memoryTracker;\n+                if (tracker != null)\n+                    tracker.close();\n+\n                 // release any open table locks\n                 rollback();\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NjQyMA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392846420", "body": "Braces", "bodyText": "Braces", "bodyHTML": "<p dir=\"auto\">Braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:17:52Z", "path": "modules/h2/src/main/java/org/h2/index/IndexCursor.java", "diffHunk": "@@ -135,6 +134,11 @@ public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n                 if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n                     inColumn = null;\n                     inList = null;\n+\n+                    if (inResult != null) {\n+                        inResult.close();", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/IndexCursor.java b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\nindex 191c82d247f..00ee3cfc248 100644\n--- a/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n+++ b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n", "chunk": "@@ -135,9 +135,8 @@ public class IndexCursor implements Cursor, AutoCloseable {\n                     inColumn = null;\n                     inList = null;\n \n-                    if (inResult != null) {\n+                    if (inResult != null)\n                         inResult.close();\n-                    }\n \n                     inResult = null;\n                 }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/IndexCursor.java b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\nindex 191c82d247f..00ee3cfc248 100644\n--- a/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n+++ b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n", "chunk": "@@ -135,9 +135,8 @@ public class IndexCursor implements Cursor, AutoCloseable {\n                     inColumn = null;\n                     inList = null;\n \n-                    if (inResult != null) {\n+                    if (inResult != null)\n                         inResult.close();\n-                    }\n \n                     inResult = null;\n                 }\n", "next_change": {"commit": "ae976a5e026af98297e6d7d35ed117cd000969f0", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/IndexCursor.java b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\nindex 00ee3cfc248..6d3d4fa4001 100644\n--- a/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n+++ b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n", "chunk": "@@ -134,10 +135,6 @@ public class IndexCursor implements Cursor, AutoCloseable {\n                 if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n                     inColumn = null;\n                     inList = null;\n-\n-                    if (inResult != null)\n-                        inResult.close();\n-\n                     inResult = null;\n                 }\n             }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/h2/src/main/java/org/h2/index/IndexCursor.java b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\nindex 6d3d4fa4001..00ee3cfc248 100644\n--- a/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n+++ b/modules/h2/src/main/java/org/h2/index/IndexCursor.java\n", "chunk": "@@ -135,6 +134,10 @@ public class IndexCursor implements Cursor, AutoCloseable {\n                 if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n                     inColumn = null;\n                     inList = null;\n+\n+                    if (inResult != null)\n+                        inResult.close();\n+\n                     inResult = null;\n                 }\n             }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ae976a5e026af98297e6d7d35ed117cd000969f0", "committedDate": "2019-11-18 17:17:39 +0300", "message": "GG-22138 OOM Fix. Added close() method for BPlusTree.ForwardCursor."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NzEwNw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392847107", "body": "Braces", "bodyText": "Braces", "bodyHTML": "<p dir=\"auto\">Braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:19:29Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java", "diffHunk": "@@ -391,6 +396,7 @@ private void addRowsToDisk(boolean forcePlainResult) {\n \n     /** {@inheritDoc} */\n     @Override public void done() {\n+        initMemTracker();\n         if (external != null) {\n             addRowsToDisk(false);", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 1243591f59f..6b8d19774bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -397,21 +397,20 @@ public class H2ManagedLocalResult implements LocalResult {\n     /** {@inheritDoc} */\n     @Override public void done() {\n         initMemTracker();\n-        if (external != null) {\n+        if (external != null)\n             addRowsToDisk(false);\n-        }\n+\n         else {\n-            if (isAnyDistinct()) {\n+            if (isAnyDistinct())\n                 rows = new ArrayList<>(distinctRows.values());\n-            }\n+\n             if (sort != null && limit != 0 && !limitsWereApplied) {\n                 boolean withLimit = limit > 0 && withTiesSortOrder == null;\n-                if (offset > 0 || withLimit) {\n+\n+                if (offset > 0 || withLimit)\n                     sort.sort(rows, offset, withLimit ? limit : rows.size());\n-                }\n-                else {\n+                else\n                     sort.sort(rows);\n-                }\n             }\n         }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 1243591f59f..6b8d19774bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -397,21 +397,20 @@ public class H2ManagedLocalResult implements LocalResult {\n     /** {@inheritDoc} */\n     @Override public void done() {\n         initMemTracker();\n-        if (external != null) {\n+        if (external != null)\n             addRowsToDisk(false);\n-        }\n+\n         else {\n-            if (isAnyDistinct()) {\n+            if (isAnyDistinct())\n                 rows = new ArrayList<>(distinctRows.values());\n-            }\n+\n             if (sort != null && limit != 0 && !limitsWereApplied) {\n                 boolean withLimit = limit > 0 && withTiesSortOrder == null;\n-                if (offset > 0 || withLimit) {\n+\n+                if (offset > 0 || withLimit)\n                     sort.sort(rows, offset, withLimit ? limit : rows.size());\n-                }\n-                else {\n+                else\n                     sort.sort(rows);\n-                }\n             }\n         }\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 6b8d19774bc..e45937a060d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -16,538 +16,69 @@\n \n package org.apache.ignite.internal.processors.query.h2;\n \n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.TreeMap;\n+import org.h2.engine.Constants;\n import org.h2.engine.Session;\n-import org.h2.engine.SessionInterface;\n import org.h2.expression.Expression;\n-import org.h2.message.DbException;\n-import org.h2.result.LocalResult;\n-import org.h2.result.ResultExternal;\n-import org.h2.result.SortOrder;\n-import org.h2.util.Utils;\n-import org.h2.value.TypeInfo;\n+import org.h2.result.H2BaseLocalResult;\n import org.h2.value.Value;\n import org.h2.value.ValueRow;\n \n-import static org.apache.ignite.internal.processors.query.h2.H2Utils.calculateMemoryDelta;\n-\n-/** */\n-public class H2ManagedLocalResult implements LocalResult {\n-    private Session session;\n-    private int visibleColumnCount;\n-    private Expression[] expressions;\n-    private int rowId, rowCount;\n-    private ArrayList<Value[]> rows;\n-    private SortOrder sort;\n-    private TreeMap<Value, Value[]> distinctRows;\n-    private Value[] currentRow;\n-    private int offset;\n-    private int limit = -1;\n-    private boolean fetchPercent;\n-    private SortOrder withTiesSortOrder;\n-    private boolean limitsWereApplied;\n-    private boolean distinct;\n-    private int[] distinctIndexes;\n-    private boolean closed;\n-    private boolean containsLobs;\n-    private Boolean containsNull;\n-\n-    /** Disk spilling (offloading) manager. */\n-    private ResultExternal external;\n-\n+/**\n+ * H2 local result with memory tracker.\n+ */\n+public class H2ManagedLocalResult extends H2BaseLocalResult {\n     /** Query memory tracker. */\n-    private H2MemoryTracker memTracker;\n+    private H2MemoryTracker mem;\n \n     /** Reserved memory. */\n     private long memReserved;\n \n-    /**\n-     * Construct a local result object.\n-     */\n-    public H2ManagedLocalResult() {\n-        // nothing to do\n-    }\n-\n     /**\n      * Constructor.\n      *\n      * @param ses the session\n+     * @param memTracker Query memory tracker.\n      * @param expressions the expression array\n      * @param visibleColCnt the number of visible columns\n      */\n-    public H2ManagedLocalResult(Session ses, Expression[] expressions,\n+    public H2ManagedLocalResult(Session ses, H2MemoryTracker memTracker, Expression[] expressions,\n         int visibleColCnt) {\n-        this.session = ses;\n-        rows = Utils.newSmallArrayList();\n-        this.visibleColumnCount = visibleColCnt;\n-        rowId = -1;\n-        this.expressions = expressions;\n-    }\n-\n-    private void initMemTracker() {\n-        if (memTracker == null)\n-            memTracker = session.memoryTracker() != null ? session.memoryTracker().createChildTracker() : null;\n-    }\n-\n-    /**\n-     * Checks available memory.\n-     *\n-     * @param distinctRowKey Row key.\n-     * @param oldRow Old row.\n-     * @param row New row.\n-     * @return {@code True} if we have available memory.\n-     */\n-    private boolean hasAvailableMemory(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n-        assert !isClosed();\n-\n-        if (memTracker == null)\n-            return true; // No memory management set.\n+        super(ses, expressions, visibleColCnt);\n \n-        long memory = calculateMemoryDelta(distinctRowKey, oldRow, row);\n-\n-        boolean hasMemory = true;\n-\n-        if (memory < 0)\n-            memTracker.release(-memory);\n-        else\n-            hasMemory = memTracker.reserve(memory);\n-\n-        memReserved += memory;\n-\n-        return hasMemory;\n+        this.mem = memTracker;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public boolean isLazy() {\n-        return false;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setMaxMemoryRows(int maxValue) {\n-        // No-op. We do not use rowCount-based memory tracking in this class. {@link memTracker} is used instead.\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public H2ManagedLocalResult createShallowCopy(SessionInterface targetSession) {\n-        if (containsLobs) {\n-            return null;\n-        }\n-\n-        ResultExternal e2 = null;\n-\n-        if (external != null) {\n-            e2 = external.createShallowCopy();\n-\n-            if (e2 == null)\n-                return null;\n-        }\n-\n-        H2ManagedLocalResult cp = new H2ManagedLocalResult();\n-\n-        cp.session = (Session)targetSession;\n-        cp.visibleColumnCount = this.visibleColumnCount;\n-        cp.expressions = this.expressions;\n-        cp.rowId = -1;\n-        cp.rowCount = this.rowCount;\n-        cp.rows = this.rows;\n-        cp.sort = this.sort;\n-        cp.distinctRows = this.distinctRows;\n-        cp.distinct = distinct;\n-        cp.distinctIndexes = distinctIndexes;\n-        cp.currentRow = null;\n-        cp.offset = 0;\n-        cp.limit = -1;\n-        cp.containsNull = containsNull;\n-        cp.external = e2;\n-\n-        return cp;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setSortOrder(SortOrder sort) {\n-        this.sort = sort;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setDistinct() {\n-        assert distinctIndexes == null;\n-        distinct = true;\n-        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n-    }\n+    @Override protected void onUpdate(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n+        assert !isClosed();\n+        assert row != null;\n \n-    /** {@inheritDoc} */\n-    @Override public void setDistinct(int[] distinctIndexes) {\n-        assert !distinct;\n-        this.distinctIndexes = distinctIndexes;\n-        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n-    }\n+        long memory;\n \n-    /**\n-     * @return whether this result is a distinct result\n-     */\n-    private boolean isAnyDistinct() {\n-        return distinct || distinctIndexes != null;\n-    }\n+        // Replace old row.\n+        if (oldRow != null) {\n+            memory = (row.length - oldRow.length) * Constants.MEMORY_POINTER;\n \n-    /** {@inheritDoc} */\n-    @Override public void removeDistinct(Value[] values) {\n-        if (!distinct) {\n-            DbException.throwInternalError();\n-        }\n-        assert values.length == visibleColumnCount;\n-        if (distinctRows != null) {\n-            ValueRow array = ValueRow.get(values);\n-            distinctRows.remove(array);\n-            rowCount = distinctRows.size();\n+            for (int i = 0; i < oldRow.length; i++)\n+                memory -= oldRow[i].getMemory();\n         }\n         // Add new row.\n         else {\n-            rowCount = external.removeRow(values);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean containsDistinct(Value[] values) {\n-        assert values.length == visibleColumnCount;\n-        if (external != null) {\n-            return external.contains(values);\n-        }\n-        if (distinctRows == null) {\n-            distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n-            for (Value[] row : rows) {\n-                ValueRow array = getDistinctRow(row);\n-                distinctRows.put(array, array.getList());\n-            }\n-        }\n-        ValueRow array = ValueRow.get(values);\n-        return distinctRows.get(array) != null;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean containsNull() {\n-        Boolean r = containsNull;\n-        if (r == null) {\n-            r = false;\n-            reset();\n-            loop:\n-            while (next()) {\n-                Value[] row = currentRow;\n-                for (int i = 0; i < visibleColumnCount; i++) {\n-                    if (row[i].containsNull()) {\n-                        r = true;\n-                        break loop;\n-                    }\n-                }\n-            }\n-            reset();\n-            containsNull = r;\n-        }\n-        return r;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void reset() {\n-        rowId = -1;\n-        currentRow = null;\n-        if (external != null)\n-            external.reset();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public Value[] currentRow() {\n-        return currentRow;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean next() {\n-        if (!closed && rowId < rowCount) {\n-            rowId++;\n-            if (rowId < rowCount) {\n-                if (external != null) {\n-                    currentRow = external.next();\n-                } else {\n-                    currentRow = rows.get(rowId);\n-                }\n-                return true;\n-            }\n-            currentRow = null;\n-        }\n-        return false;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public int getRowId() {\n-        return rowId;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean isAfterLast() {\n-        return rowId >= rowCount;\n-    }\n-\n-    /**\n-     * @param values Values.\n-     */\n-    private void cloneLobs(Value[] values) {\n-        for (int i = 0; i < values.length; i++) {\n-            Value v = values[i];\n-            Value v2 = v.copyToResult();\n-            if (v2 != v) {\n-                containsLobs = true;\n-                session.addTemporaryLob(v2);\n-                values[i] = v2;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param values row.\n-     * @return Row,\n-     */\n-    private ValueRow getDistinctRow(Value[] values) {\n-        if (distinctIndexes != null) {\n-            int cnt = distinctIndexes.length;\n-            Value[] newValues = new Value[cnt];\n-            for (int i = 0; i < cnt; i++) {\n-                newValues[i] = values[distinctIndexes[i]];\n-            }\n-            values = newValues;\n-        }\n-        else if (values.length > visibleColumnCount) {\n-            values = Arrays.copyOf(values, visibleColumnCount);\n-        }\n-        return ValueRow.get(values);\n-    }\n-\n-    private void createExternalResult(boolean forcePlainResult) {\n-        QueryMemoryManager memMgr = (QueryMemoryManager)session.groupByDataFactory();\n-        if (forcePlainResult)\n-            external = memMgr.createPlainExternalResult(session);\n-        else {\n-            external = distinct || distinctIndexes != null || sort != null ?\n-                memMgr.createSortedExternalResult(session, distinct, distinctIndexes, visibleColumnCount, sort, rowCount)\n-                : memMgr.createPlainExternalResult(session);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void addRow(Value[] values) {\n-        cloneLobs(values);\n-        initMemTracker();\n-        if (isAnyDistinct()) {\n-            if (distinctRows != null) {\n-                ValueRow array = getDistinctRow(values);\n-                Value[] previous = distinctRows.get(array);\n-                if (previous == null || sort != null && sort.compare(previous, values) > 0) {\n-                    distinctRows.put(array, values);\n-                }\n-                rowCount = distinctRows.size();\n-                if (!hasAvailableMemory(array, previous, values)) {\n-                    addRowsToDisk(false);\n-\n-                    distinctRows = null;\n-                }\n-            } else {\n-                rowCount = external.addRow(values);\n-            }\n-        } else {\n-            rowCount++;\n-            if (external == null) {\n-                rows.add(values);\n-                if (!hasAvailableMemory(null, null, values)) {\n-                    addRowsToDisk(false);\n-                }\n-            }\n-            else\n-                external.addRow(values);\n-        }\n-    }\n-\n-    /**\n-     * Adds rows to disk.\n-     * @param forcePlainResult Whether to force creation of not sorted result.\n-     */\n-    private void addRowsToDisk(boolean forcePlainResult) {\n-        if (external == null) {\n-            createExternalResult(forcePlainResult);\n-        }\n-\n-        if (distinctRows == null) {\n-            rowCount = external.addRows(rows);\n-            rows.clear();\n-        }\n-        else {\n-            rowCount = external.addRows(distinctRows.values());\n-            distinctRows.clear();\n-        }\n-\n-        memTracker.release(memTracker.reserved());\n-\n-        memReserved = 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public int getVisibleColumnCount() {\n-        return visibleColumnCount;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void done() {\n-        initMemTracker();\n-        if (external != null)\n-            addRowsToDisk(false);\n-\n-        else {\n-            if (isAnyDistinct())\n-                rows = new ArrayList<>(distinctRows.values());\n-\n-            if (sort != null && limit != 0 && !limitsWereApplied) {\n-                boolean withLimit = limit > 0 && withTiesSortOrder == null;\n+            memory = Constants.MEMORY_ARRAY + row.length * Constants.MEMORY_POINTER;\n \n-                if (offset > 0 || withLimit)\n-                    sort.sort(rows, offset, withLimit ? limit : rows.size());\n-                else\n-                    sort.sort(rows);\n-            }\n-        }\n-\n-        applyOffsetAndLimit();\n-        reset();\n-    }\n-\n-    private void applyOffsetAndLimit() {\n-        if (limitsWereApplied) {\n-            return;\n-        }\n-        int offset = Math.max(this.offset, 0);\n-        int limit = this.limit;\n-        if (offset == 0 && limit < 0 && !fetchPercent || rowCount == 0) {\n-            return;\n-        }\n-        if (fetchPercent) {\n-            if (limit < 0 || limit > 100) {\n-                throw DbException.getInvalidValueException(\"FETCH PERCENT\", limit);\n-            }\n-            // Oracle rounds percent up, do the same for now\n-            limit = (int) (((long) limit * rowCount + 99) / 100);\n-        }\n-        boolean clearAll = offset >= rowCount || limit == 0;\n-        if (!clearAll) {\n-            int remaining = rowCount - offset;\n-            limit = limit < 0 ? remaining : Math.min(remaining, limit);\n-            if (offset == 0 && remaining <= limit) {\n-                return;\n-            }\n-        } else {\n-            limit = 0;\n-        }\n-        distinctRows = null;\n-        rowCount = limit;\n-        if (external == null) {\n-            if (clearAll) {\n-                rows.clear();\n-                return;\n-            }\n-            int to = offset + limit;\n-            if (withTiesSortOrder != null) {\n-                Value[] expected = rows.get(to - 1);\n-                while (to < rows.size() && withTiesSortOrder.compare(expected, rows.get(to)) == 0) {\n-                    to++;\n-                    rowCount++;\n-                }\n-            }\n-            if (offset != 0 || to != rows.size()) {\n-                // avoid copying the whole array for each row\n-                rows = new ArrayList<>(rows.subList(offset, to));\n-            }\n-        } else {\n-            if (clearAll) {\n-                external.close();\n-                external = null;\n-                return;\n-            }\n-            trimExternal(offset, limit);\n+            if (distinctRowKey != null)\n+                memory += distinctRowKey.getMemory();\n         }\n-    }\n-\n-    /**\n-     * @param offset Offset.\n-     * @param limit Limit.\n-     */\n-    private void trimExternal(int offset, int limit) {\n-        ResultExternal temp = external;\n-        external = null;\n-\n-        temp.reset();\n-        initMemTracker();\n-\n-        while (--offset >= 0)\n-            temp.next();\n-\n-        Value[] row = null;\n-\n-        while (--limit >= 0) {\n-            row = temp.next();\n-            rows.add(row);\n-\n-            if (!hasAvailableMemory(null,null, row))\n-                addRowsToDisk(true);\n-        }\n-        if (withTiesSortOrder != null && row != null) {\n-            Value[] expected = row;\n-\n-            while ((row = temp.next()) != null && withTiesSortOrder.compare(expected, row) == 0) {\n-                rows.add(row);\n-                rowCount++;\n-\n-                if (!hasAvailableMemory(null,null, row))\n-                    addRowsToDisk(true);\n-            }\n-        }\n-\n-        if (external != null)\n-            addRowsToDisk(true);\n-\n-        temp.close();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public int getRowCount() {\n-        return rowCount;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void limitsWereApplied() {\n-        this.limitsWereApplied = true;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean hasNext() {\n-        return !closed && rowId < rowCount - 1;\n-    }\n \n-    /** {@inheritDoc} */\n-    @Override public void setLimit(int limit) {\n-        this.limit = limit;\n-    }\n+        for (int i = 0; i < row.length; i++)\n+            memory += row[i].getMemory();\n \n-    /** {@inheritDoc} */\n-    @Override public void setFetchPercent(boolean fetchPercent) {\n-        this.fetchPercent = fetchPercent;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setWithTies(SortOrder withTiesSortOrder) {\n-        assert sort == null || sort == withTiesSortOrder;\n-        this.withTiesSortOrder = withTiesSortOrder;\n-    }\n+        if (memory < 0)\n+            mem.release(memory);\n+        else\n+            mem.reserve(memory);\n \n-    /** {@inheritDoc} */\n-    @Override public boolean needToClose() {\n-        return !closed;\n+        memReserved += memory;\n     }\n \n     /** */\n", "next_change": {"commit": "2db025677cc4fb675a1a161fe813c5c06da63bca", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex e45937a060d..b6caf3a685a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -74,7 +74,7 @@ public class H2ManagedLocalResult extends H2BaseLocalResult {\n             memory += row[i].getMemory();\n \n         if (memory < 0)\n-            mem.release(memory);\n+            mem.release(-memory);\n         else\n             mem.reserve(memory);\n \n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex b6caf3a685a..63ef0d9aaf5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -43,42 +86,465 @@ public class H2ManagedLocalResult extends H2BaseLocalResult {\n      */\n     public H2ManagedLocalResult(Session ses, H2MemoryTracker memTracker, Expression[] expressions,\n         int visibleColCnt) {\n-        super(ses, expressions, visibleColCnt);\n+        this.session = ses;\n+        rows = Utils.newSmallArrayList();\n+        this.visibleColumnCount = visibleColCnt;\n+        rowId = -1;\n+        this.expressions = expressions;\n+        this.memTracker = memTracker;\n+\n+        if (ses != null && ses.getQueryContext() != null) {\n+            QueryContext qctx = (QueryContext)ses.getQueryContext();\n \n-        this.mem = memTracker;\n+            ctx = qctx.context();\n+\n+            assert memTracker == null || ctx != null; // Context should be set when we track memory.\n+        }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override protected void onUpdate(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n+    /**\n+     * Checks available memory.\n+     *\n+     * @param distinctRowKey Row key.\n+     * @param oldRow Old row.\n+     * @param row New row.\n+     * @return {@code True} if we have available memory.\n+     */\n+    private boolean hasAvailableMemory(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n         assert !isClosed();\n-        assert row != null;\n \n-        long memory;\n+        if (memTracker == null)\n+            return true; // No memory management set.\n+\n+        long memory = calculateMemoryDelta(distinctRowKey, oldRow, row);\n+\n+        boolean hasMemory = true;\n+\n+        if (memory < 0)\n+            memTracker.released(-memory);\n+        else\n+            hasMemory = memTracker.reserved(memory);\n+\n+        memReserved += memory;\n+\n+        return hasMemory;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isLazy() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setMaxMemoryRows(int maxValue) {\n+        // No-op. We do not use rowCount-based memory tracking in this class. {@link memTracker} is used instead.\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public H2ManagedLocalResult createShallowCopy(SessionInterface targetSession) {\n+        if (containsLobs) {\n+            return null;\n+        }\n+\n+        ResultExternal e2 = null;\n+\n+        if (external != null) {\n+            e2 = external.createShallowCopy();\n+\n+            if (e2 == null)\n+                return null;\n+        }\n+\n+        H2ManagedLocalResult cp = new H2ManagedLocalResult();\n+\n+        cp.session = (Session)targetSession;\n+        cp.visibleColumnCount = this.visibleColumnCount;\n+        cp.expressions = this.expressions;\n+        cp.rowId = -1;\n+        cp.rowCount = this.rowCount;\n+        cp.rows = this.rows;\n+        cp.sort = this.sort;\n+        cp.distinctRows = this.distinctRows;\n+        cp.distinct = distinct;\n+        cp.distinctIndexes = distinctIndexes;\n+        cp.currentRow = null;\n+        cp.offset = 0;\n+        cp.limit = -1;\n+        cp.containsNull = containsNull;\n+        cp.external = e2;\n+\n+        return cp;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setSortOrder(SortOrder sort) {\n+        this.sort = sort;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setDistinct() {\n+        assert distinctIndexes == null;\n+        distinct = true;\n+        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setDistinct(int[] distinctIndexes) {\n+        assert !distinct;\n+        this.distinctIndexes = distinctIndexes;\n+        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n+    }\n \n-        // Replace old row.\n-        if (oldRow != null) {\n-            memory = (row.length - oldRow.length) * Constants.MEMORY_POINTER;\n+    /**\n+     * @return whether this result is a distinct result\n+     */\n+    private boolean isAnyDistinct() {\n+        return distinct || distinctIndexes != null;\n+    }\n \n-            for (int i = 0; i < oldRow.length; i++)\n-                memory -= oldRow[i].getMemory();\n+    /** {@inheritDoc} */\n+    @Override public void removeDistinct(Value[] values) {\n+        if (!distinct) {\n+            DbException.throwInternalError();\n+        }\n+        assert values.length == visibleColumnCount;\n+        if (distinctRows != null) {\n+            ValueRow array = ValueRow.get(values);\n+            distinctRows.remove(array);\n+            rowCount = distinctRows.size();\n         }\n         // Add new row.\n         else {\n-            memory = Constants.MEMORY_ARRAY + row.length * Constants.MEMORY_POINTER;\n+            rowCount = external.removeRow(values);\n+        }\n+    }\n \n-            if (distinctRowKey != null)\n-                memory += distinctRowKey.getMemory();\n+    /** {@inheritDoc} */\n+    @Override public boolean containsDistinct(Value[] values) {\n+        assert values.length == visibleColumnCount;\n+        if (external != null) {\n+            return external.contains(values);\n+        }\n+        if (distinctRows == null) {\n+            distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n+            for (Value[] row : rows) {\n+                ValueRow array = getDistinctRow(row);\n+                distinctRows.put(array, array.getList());\n+            }\n         }\n+        ValueRow array = ValueRow.get(values);\n+        return distinctRows.get(array) != null;\n+    }\n \n-        for (int i = 0; i < row.length; i++)\n-            memory += row[i].getMemory();\n+    /** {@inheritDoc} */\n+    @Override public boolean containsNull() {\n+        Boolean r = containsNull;\n+        if (r == null) {\n+            r = false;\n+            reset();\n+            loop:\n+            while (next()) {\n+                Value[] row = currentRow;\n+                for (int i = 0; i < visibleColumnCount; i++) {\n+                    if (row[i].containsNull()) {\n+                        r = true;\n+                        break loop;\n+                    }\n+                }\n+            }\n+            reset();\n+            containsNull = r;\n+        }\n+        return r;\n+    }\n \n-        if (memory < 0)\n-            mem.release(-memory);\n+    /** {@inheritDoc} */\n+    @Override\n+    public void reset() {\n+        rowId = -1;\n+        currentRow = null;\n+        if (external != null) {\n+            external.reset();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Value[] currentRow() {\n+        return currentRow;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean next() {\n+        if (!closed && rowId < rowCount) {\n+            rowId++;\n+            if (rowId < rowCount) {\n+                if (external != null) {\n+                    currentRow = external.next();\n+                } else {\n+                    currentRow = rows.get(rowId);\n+                }\n+                return true;\n+            }\n+            currentRow = null;\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public int getRowId() {\n+        return rowId;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isAfterLast() {\n+        return rowId >= rowCount;\n+    }\n+\n+    /**\n+     * @param values Values.\n+     */\n+    private void cloneLobs(Value[] values) {\n+        for (int i = 0; i < values.length; i++) {\n+            Value v = values[i];\n+            Value v2 = v.copyToResult();\n+            if (v2 != v) {\n+                containsLobs = true;\n+                session.addTemporaryLob(v2);\n+                values[i] = v2;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param values row.\n+     * @return Row,\n+     */\n+    private ValueRow getDistinctRow(Value[] values) {\n+        if (distinctIndexes != null) {\n+            int cnt = distinctIndexes.length;\n+            Value[] newValues = new Value[cnt];\n+            for (int i = 0; i < cnt; i++) {\n+                newValues[i] = values[distinctIndexes[i]];\n+            }\n+            values = newValues;\n+        }\n+        else if (values.length > visibleColumnCount) {\n+            values = Arrays.copyOf(values, visibleColumnCount);\n+        }\n+        return ValueRow.get(values);\n+    }\n+\n+    private void createExternalResult(boolean forcePlainResult) {\n+        assert ctx != null;\n+\n+        if (forcePlainResult)\n+            external = new PlainExternalResult(ctx, memTracker, session);\n         else\n-            mem.reserve(memory);\n+            external = distinct || distinctIndexes != null || sort != null ?\n+                new SortedExternalResult(ctx, session, distinct, distinctIndexes, visibleColumnCount, sort, memTracker,\n+                    rowCount) : new PlainExternalResult(ctx, memTracker, session);\n+    }\n \n-        memReserved += memory;\n+    /** {@inheritDoc} */\n+    @Override public void addRow(Value[] values) {\n+        cloneLobs(values);\n+        if (isAnyDistinct()) {\n+            if (distinctRows != null) {\n+                ValueRow array = getDistinctRow(values);\n+                Value[] previous = distinctRows.get(array);\n+                if (previous == null || sort != null && sort.compare(previous, values) > 0) {\n+                    distinctRows.put(array, values);\n+                }\n+                rowCount = distinctRows.size();\n+                if (!hasAvailableMemory(array, previous, values)) {\n+                    addRowsToDisk(false);\n+\n+                    distinctRows = null;\n+                }\n+            } else {\n+                rowCount = external.addRow(values);\n+            }\n+        } else {\n+            rowCount++;\n+            if (external == null) {\n+                rows.add(values);\n+                if (!hasAvailableMemory(null, null, values)) {\n+                    addRowsToDisk(false);\n+                }\n+            }\n+            else\n+                external.addRow(values);\n+        }\n+    }\n+\n+    /**\n+     * Adds rows to disk.\n+     * @param forcePlainResult Whether to force creation of not sorted result.\n+     */\n+    private void addRowsToDisk(boolean forcePlainResult) {\n+        if (external == null) {\n+            createExternalResult(forcePlainResult);\n+        }\n+\n+        if (distinctRows == null) {\n+            rowCount = external.addRows(rows);\n+            rows.clear();\n+        }\n+        else {\n+            rowCount = external.addRows(distinctRows.values());\n+            distinctRows.clear();\n+        }\n+\n+        memReserved = 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public int getVisibleColumnCount() {\n+        return visibleColumnCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void done() {\n+        if (external != null) {\n+            addRowsToDisk(false);\n+        }\n+        else {\n+            if (isAnyDistinct()) {\n+                rows = new ArrayList<>(distinctRows.values());\n+            }\n+            if (sort != null && limit != 0 && !limitsWereApplied) {\n+                boolean withLimit = limit > 0 && withTiesSortOrder == null;\n+                if (offset > 0 || withLimit) {\n+                    sort.sort(rows, offset, withLimit ? limit : rows.size());\n+                }\n+                else {\n+                    sort.sort(rows);\n+                }\n+            }\n+        }\n+\n+        applyOffsetAndLimit();\n+        reset();\n+    }\n+\n+    private void applyOffsetAndLimit() {\n+        if (limitsWereApplied) {\n+            return;\n+        }\n+        int offset = Math.max(this.offset, 0);\n+        int limit = this.limit;\n+        if (offset == 0 && limit < 0 && !fetchPercent || rowCount == 0) {\n+            return;\n+        }\n+        if (fetchPercent) {\n+            if (limit < 0 || limit > 100) {\n+                throw DbException.getInvalidValueException(\"FETCH PERCENT\", limit);\n+            }\n+            // Oracle rounds percent up, do the same for now\n+            limit = (int) (((long) limit * rowCount + 99) / 100);\n+        }\n+        boolean clearAll = offset >= rowCount || limit == 0;\n+        if (!clearAll) {\n+            int remaining = rowCount - offset;\n+            limit = limit < 0 ? remaining : Math.min(remaining, limit);\n+            if (offset == 0 && remaining <= limit) {\n+                return;\n+            }\n+        } else {\n+            limit = 0;\n+        }\n+        distinctRows = null;\n+        rowCount = limit;\n+        if (external == null) {\n+            if (clearAll) {\n+                rows.clear();\n+                return;\n+            }\n+            int to = offset + limit;\n+            if (withTiesSortOrder != null) {\n+                Value[] expected = rows.get(to - 1);\n+                while (to < rows.size() && withTiesSortOrder.compare(expected, rows.get(to)) == 0) {\n+                    to++;\n+                    rowCount++;\n+                }\n+            }\n+            if (offset != 0 || to != rows.size()) {\n+                // avoid copying the whole array for each row\n+                rows = new ArrayList<>(rows.subList(offset, to));\n+            }\n+        } else {\n+            if (clearAll) {\n+                external.close();\n+                external = null;\n+                return;\n+            }\n+            trimExternal(offset, limit);\n+        }\n+    }\n+\n+    private void trimExternal(int offset, int limit) {\n+        ResultExternal temp = external;\n+        external = null;\n+        temp.reset();\n+        while (--offset >= 0) {\n+            temp.next();\n+        }\n+        Value[] row = null;\n+        while (--limit >= 0) {\n+            row = temp.next();\n+            rows.add(row);\n+            if (!hasAvailableMemory(null,null, row))\n+                addRowsToDisk(true);\n+        }\n+        if (withTiesSortOrder != null && row != null) {\n+            Value[] expected = row;\n+            while ((row = temp.next()) != null && withTiesSortOrder.compare(expected, row) == 0) {\n+                rows.add(row);\n+                rowCount++;\n+                if (!hasAvailableMemory(null,null, row))\n+                    addRowsToDisk(true);\n+            }\n+        }\n+        if (external != null) {\n+            addRowsToDisk(true);\n+        }\n+        temp.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public int getRowCount() {\n+        return rowCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void limitsWereApplied() {\n+        this.limitsWereApplied = true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean hasNext() {\n+        return !closed && rowId < rowCount - 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setLimit(int limit) {\n+        this.limit = limit;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setFetchPercent(boolean fetchPercent) {\n+        this.fetchPercent = fetchPercent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setWithTies(SortOrder withTiesSortOrder) {\n+        assert sort == null || sort == withTiesSortOrder;\n+        this.withTiesSortOrder = withTiesSortOrder;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean needToClose() {\n+        return !closed;\n     }\n \n     /** */\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 63ef0d9aaf5..6b8d19774bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -552,7 +555,6 @@ public class H2ManagedLocalResult implements LocalResult {\n         return memReserved;\n     }\n \n-\n     /** {@inheritDoc} */\n     @Override public void close() {\n         if (!closed) {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "2db025677cc4fb675a1a161fe813c5c06da63bca", "committedDate": "2019-07-24 13:25:10 +0300", "message": "GG-21748: SQL: Fix unexpected assertion failure in MemoryTracker.release()."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "4bdd95f670e3b37e41d5d4efdfffe4226c884623", "committedDate": "2020-06-04 16:49:35 +0300", "message": "GG-28564 Performance drop 8.7.15 vs 8.7.13"}, {"oid": "e59250634580750798b04f632b6795cf56863519", "committedDate": "2020-06-07 19:52:03 +0300", "message": "GG-22441 [IGNITE-11872] EmptyLineSeparator check added"}, {"oid": "4a0e2d3d72047117d6a0835cbde5864352591bc9", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29128 [IGNITE-12959] Add support for GenericWhitespace to checkstyle rules (#7749)"}, {"oid": "69705564d6572f3ff8b15a9a5531815462933b47", "committedDate": "2020-06-07 20:06:33 +0300", "message": "GG-28973 [IGNITE-12841] @Override must be on the same line as a method (#7578)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "734869bf4cfe20f7fd79bbfbfbc372e8339aa401", "committedDate": "2021-05-26 12:21:25 +0300", "message": "GG-33232 Fix the performance issue with SQL DISTINCT (use HashMap instead of TreeMap when possible) (#1939)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NzE5OA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392847198", "body": "Braces", "bodyText": "Braces", "bodyHTML": "<p dir=\"auto\">Braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:19:43Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java", "diffHunk": "@@ -472,6 +478,7 @@ private void trimExternal(int offset, int limit) {\n         ResultExternal temp = external;\n         external = null;\n         temp.reset();\n+        initMemTracker();\n         while (--offset >= 0) {", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 1243591f59f..6b8d19774bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -474,33 +473,44 @@ public class H2ManagedLocalResult implements LocalResult {\n         }\n     }\n \n+    /**\n+     * @param offset Offset.\n+     * @param limit Limit.\n+     */\n     private void trimExternal(int offset, int limit) {\n         ResultExternal temp = external;\n         external = null;\n+\n         temp.reset();\n         initMemTracker();\n-        while (--offset >= 0) {\n+\n+        while (--offset >= 0)\n             temp.next();\n-        }\n+\n         Value[] row = null;\n+\n         while (--limit >= 0) {\n             row = temp.next();\n             rows.add(row);\n+\n             if (!hasAvailableMemory(null,null, row))\n                 addRowsToDisk(true);\n         }\n         if (withTiesSortOrder != null && row != null) {\n             Value[] expected = row;\n+\n             while ((row = temp.next()) != null && withTiesSortOrder.compare(expected, row) == 0) {\n                 rows.add(row);\n                 rowCount++;\n+\n                 if (!hasAvailableMemory(null,null, row))\n                     addRowsToDisk(true);\n             }\n         }\n-        if (external != null) {\n+\n+        if (external != null)\n             addRowsToDisk(true);\n-        }\n+\n         temp.close();\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 1243591f59f..6b8d19774bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -474,33 +473,44 @@ public class H2ManagedLocalResult implements LocalResult {\n         }\n     }\n \n+    /**\n+     * @param offset Offset.\n+     * @param limit Limit.\n+     */\n     private void trimExternal(int offset, int limit) {\n         ResultExternal temp = external;\n         external = null;\n+\n         temp.reset();\n         initMemTracker();\n-        while (--offset >= 0) {\n+\n+        while (--offset >= 0)\n             temp.next();\n-        }\n+\n         Value[] row = null;\n+\n         while (--limit >= 0) {\n             row = temp.next();\n             rows.add(row);\n+\n             if (!hasAvailableMemory(null,null, row))\n                 addRowsToDisk(true);\n         }\n         if (withTiesSortOrder != null && row != null) {\n             Value[] expected = row;\n+\n             while ((row = temp.next()) != null && withTiesSortOrder.compare(expected, row) == 0) {\n                 rows.add(row);\n                 rowCount++;\n+\n                 if (!hasAvailableMemory(null,null, row))\n                     addRowsToDisk(true);\n             }\n         }\n-        if (external != null) {\n+\n+        if (external != null)\n             addRowsToDisk(true);\n-        }\n+\n         temp.close();\n     }\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 6b8d19774bc..e45937a060d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -16,538 +16,69 @@\n \n package org.apache.ignite.internal.processors.query.h2;\n \n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.TreeMap;\n+import org.h2.engine.Constants;\n import org.h2.engine.Session;\n-import org.h2.engine.SessionInterface;\n import org.h2.expression.Expression;\n-import org.h2.message.DbException;\n-import org.h2.result.LocalResult;\n-import org.h2.result.ResultExternal;\n-import org.h2.result.SortOrder;\n-import org.h2.util.Utils;\n-import org.h2.value.TypeInfo;\n+import org.h2.result.H2BaseLocalResult;\n import org.h2.value.Value;\n import org.h2.value.ValueRow;\n \n-import static org.apache.ignite.internal.processors.query.h2.H2Utils.calculateMemoryDelta;\n-\n-/** */\n-public class H2ManagedLocalResult implements LocalResult {\n-    private Session session;\n-    private int visibleColumnCount;\n-    private Expression[] expressions;\n-    private int rowId, rowCount;\n-    private ArrayList<Value[]> rows;\n-    private SortOrder sort;\n-    private TreeMap<Value, Value[]> distinctRows;\n-    private Value[] currentRow;\n-    private int offset;\n-    private int limit = -1;\n-    private boolean fetchPercent;\n-    private SortOrder withTiesSortOrder;\n-    private boolean limitsWereApplied;\n-    private boolean distinct;\n-    private int[] distinctIndexes;\n-    private boolean closed;\n-    private boolean containsLobs;\n-    private Boolean containsNull;\n-\n-    /** Disk spilling (offloading) manager. */\n-    private ResultExternal external;\n-\n+/**\n+ * H2 local result with memory tracker.\n+ */\n+public class H2ManagedLocalResult extends H2BaseLocalResult {\n     /** Query memory tracker. */\n-    private H2MemoryTracker memTracker;\n+    private H2MemoryTracker mem;\n \n     /** Reserved memory. */\n     private long memReserved;\n \n-    /**\n-     * Construct a local result object.\n-     */\n-    public H2ManagedLocalResult() {\n-        // nothing to do\n-    }\n-\n     /**\n      * Constructor.\n      *\n      * @param ses the session\n+     * @param memTracker Query memory tracker.\n      * @param expressions the expression array\n      * @param visibleColCnt the number of visible columns\n      */\n-    public H2ManagedLocalResult(Session ses, Expression[] expressions,\n+    public H2ManagedLocalResult(Session ses, H2MemoryTracker memTracker, Expression[] expressions,\n         int visibleColCnt) {\n-        this.session = ses;\n-        rows = Utils.newSmallArrayList();\n-        this.visibleColumnCount = visibleColCnt;\n-        rowId = -1;\n-        this.expressions = expressions;\n-    }\n-\n-    private void initMemTracker() {\n-        if (memTracker == null)\n-            memTracker = session.memoryTracker() != null ? session.memoryTracker().createChildTracker() : null;\n-    }\n-\n-    /**\n-     * Checks available memory.\n-     *\n-     * @param distinctRowKey Row key.\n-     * @param oldRow Old row.\n-     * @param row New row.\n-     * @return {@code True} if we have available memory.\n-     */\n-    private boolean hasAvailableMemory(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n-        assert !isClosed();\n-\n-        if (memTracker == null)\n-            return true; // No memory management set.\n+        super(ses, expressions, visibleColCnt);\n \n-        long memory = calculateMemoryDelta(distinctRowKey, oldRow, row);\n-\n-        boolean hasMemory = true;\n-\n-        if (memory < 0)\n-            memTracker.release(-memory);\n-        else\n-            hasMemory = memTracker.reserve(memory);\n-\n-        memReserved += memory;\n-\n-        return hasMemory;\n+        this.mem = memTracker;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public boolean isLazy() {\n-        return false;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setMaxMemoryRows(int maxValue) {\n-        // No-op. We do not use rowCount-based memory tracking in this class. {@link memTracker} is used instead.\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public H2ManagedLocalResult createShallowCopy(SessionInterface targetSession) {\n-        if (containsLobs) {\n-            return null;\n-        }\n-\n-        ResultExternal e2 = null;\n-\n-        if (external != null) {\n-            e2 = external.createShallowCopy();\n-\n-            if (e2 == null)\n-                return null;\n-        }\n-\n-        H2ManagedLocalResult cp = new H2ManagedLocalResult();\n-\n-        cp.session = (Session)targetSession;\n-        cp.visibleColumnCount = this.visibleColumnCount;\n-        cp.expressions = this.expressions;\n-        cp.rowId = -1;\n-        cp.rowCount = this.rowCount;\n-        cp.rows = this.rows;\n-        cp.sort = this.sort;\n-        cp.distinctRows = this.distinctRows;\n-        cp.distinct = distinct;\n-        cp.distinctIndexes = distinctIndexes;\n-        cp.currentRow = null;\n-        cp.offset = 0;\n-        cp.limit = -1;\n-        cp.containsNull = containsNull;\n-        cp.external = e2;\n-\n-        return cp;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setSortOrder(SortOrder sort) {\n-        this.sort = sort;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setDistinct() {\n-        assert distinctIndexes == null;\n-        distinct = true;\n-        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n-    }\n+    @Override protected void onUpdate(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n+        assert !isClosed();\n+        assert row != null;\n \n-    /** {@inheritDoc} */\n-    @Override public void setDistinct(int[] distinctIndexes) {\n-        assert !distinct;\n-        this.distinctIndexes = distinctIndexes;\n-        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n-    }\n+        long memory;\n \n-    /**\n-     * @return whether this result is a distinct result\n-     */\n-    private boolean isAnyDistinct() {\n-        return distinct || distinctIndexes != null;\n-    }\n+        // Replace old row.\n+        if (oldRow != null) {\n+            memory = (row.length - oldRow.length) * Constants.MEMORY_POINTER;\n \n-    /** {@inheritDoc} */\n-    @Override public void removeDistinct(Value[] values) {\n-        if (!distinct) {\n-            DbException.throwInternalError();\n-        }\n-        assert values.length == visibleColumnCount;\n-        if (distinctRows != null) {\n-            ValueRow array = ValueRow.get(values);\n-            distinctRows.remove(array);\n-            rowCount = distinctRows.size();\n+            for (int i = 0; i < oldRow.length; i++)\n+                memory -= oldRow[i].getMemory();\n         }\n         // Add new row.\n         else {\n-            rowCount = external.removeRow(values);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean containsDistinct(Value[] values) {\n-        assert values.length == visibleColumnCount;\n-        if (external != null) {\n-            return external.contains(values);\n-        }\n-        if (distinctRows == null) {\n-            distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n-            for (Value[] row : rows) {\n-                ValueRow array = getDistinctRow(row);\n-                distinctRows.put(array, array.getList());\n-            }\n-        }\n-        ValueRow array = ValueRow.get(values);\n-        return distinctRows.get(array) != null;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean containsNull() {\n-        Boolean r = containsNull;\n-        if (r == null) {\n-            r = false;\n-            reset();\n-            loop:\n-            while (next()) {\n-                Value[] row = currentRow;\n-                for (int i = 0; i < visibleColumnCount; i++) {\n-                    if (row[i].containsNull()) {\n-                        r = true;\n-                        break loop;\n-                    }\n-                }\n-            }\n-            reset();\n-            containsNull = r;\n-        }\n-        return r;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void reset() {\n-        rowId = -1;\n-        currentRow = null;\n-        if (external != null)\n-            external.reset();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public Value[] currentRow() {\n-        return currentRow;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean next() {\n-        if (!closed && rowId < rowCount) {\n-            rowId++;\n-            if (rowId < rowCount) {\n-                if (external != null) {\n-                    currentRow = external.next();\n-                } else {\n-                    currentRow = rows.get(rowId);\n-                }\n-                return true;\n-            }\n-            currentRow = null;\n-        }\n-        return false;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public int getRowId() {\n-        return rowId;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean isAfterLast() {\n-        return rowId >= rowCount;\n-    }\n-\n-    /**\n-     * @param values Values.\n-     */\n-    private void cloneLobs(Value[] values) {\n-        for (int i = 0; i < values.length; i++) {\n-            Value v = values[i];\n-            Value v2 = v.copyToResult();\n-            if (v2 != v) {\n-                containsLobs = true;\n-                session.addTemporaryLob(v2);\n-                values[i] = v2;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param values row.\n-     * @return Row,\n-     */\n-    private ValueRow getDistinctRow(Value[] values) {\n-        if (distinctIndexes != null) {\n-            int cnt = distinctIndexes.length;\n-            Value[] newValues = new Value[cnt];\n-            for (int i = 0; i < cnt; i++) {\n-                newValues[i] = values[distinctIndexes[i]];\n-            }\n-            values = newValues;\n-        }\n-        else if (values.length > visibleColumnCount) {\n-            values = Arrays.copyOf(values, visibleColumnCount);\n-        }\n-        return ValueRow.get(values);\n-    }\n-\n-    private void createExternalResult(boolean forcePlainResult) {\n-        QueryMemoryManager memMgr = (QueryMemoryManager)session.groupByDataFactory();\n-        if (forcePlainResult)\n-            external = memMgr.createPlainExternalResult(session);\n-        else {\n-            external = distinct || distinctIndexes != null || sort != null ?\n-                memMgr.createSortedExternalResult(session, distinct, distinctIndexes, visibleColumnCount, sort, rowCount)\n-                : memMgr.createPlainExternalResult(session);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void addRow(Value[] values) {\n-        cloneLobs(values);\n-        initMemTracker();\n-        if (isAnyDistinct()) {\n-            if (distinctRows != null) {\n-                ValueRow array = getDistinctRow(values);\n-                Value[] previous = distinctRows.get(array);\n-                if (previous == null || sort != null && sort.compare(previous, values) > 0) {\n-                    distinctRows.put(array, values);\n-                }\n-                rowCount = distinctRows.size();\n-                if (!hasAvailableMemory(array, previous, values)) {\n-                    addRowsToDisk(false);\n-\n-                    distinctRows = null;\n-                }\n-            } else {\n-                rowCount = external.addRow(values);\n-            }\n-        } else {\n-            rowCount++;\n-            if (external == null) {\n-                rows.add(values);\n-                if (!hasAvailableMemory(null, null, values)) {\n-                    addRowsToDisk(false);\n-                }\n-            }\n-            else\n-                external.addRow(values);\n-        }\n-    }\n-\n-    /**\n-     * Adds rows to disk.\n-     * @param forcePlainResult Whether to force creation of not sorted result.\n-     */\n-    private void addRowsToDisk(boolean forcePlainResult) {\n-        if (external == null) {\n-            createExternalResult(forcePlainResult);\n-        }\n-\n-        if (distinctRows == null) {\n-            rowCount = external.addRows(rows);\n-            rows.clear();\n-        }\n-        else {\n-            rowCount = external.addRows(distinctRows.values());\n-            distinctRows.clear();\n-        }\n-\n-        memTracker.release(memTracker.reserved());\n-\n-        memReserved = 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public int getVisibleColumnCount() {\n-        return visibleColumnCount;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void done() {\n-        initMemTracker();\n-        if (external != null)\n-            addRowsToDisk(false);\n-\n-        else {\n-            if (isAnyDistinct())\n-                rows = new ArrayList<>(distinctRows.values());\n-\n-            if (sort != null && limit != 0 && !limitsWereApplied) {\n-                boolean withLimit = limit > 0 && withTiesSortOrder == null;\n+            memory = Constants.MEMORY_ARRAY + row.length * Constants.MEMORY_POINTER;\n \n-                if (offset > 0 || withLimit)\n-                    sort.sort(rows, offset, withLimit ? limit : rows.size());\n-                else\n-                    sort.sort(rows);\n-            }\n-        }\n-\n-        applyOffsetAndLimit();\n-        reset();\n-    }\n-\n-    private void applyOffsetAndLimit() {\n-        if (limitsWereApplied) {\n-            return;\n-        }\n-        int offset = Math.max(this.offset, 0);\n-        int limit = this.limit;\n-        if (offset == 0 && limit < 0 && !fetchPercent || rowCount == 0) {\n-            return;\n-        }\n-        if (fetchPercent) {\n-            if (limit < 0 || limit > 100) {\n-                throw DbException.getInvalidValueException(\"FETCH PERCENT\", limit);\n-            }\n-            // Oracle rounds percent up, do the same for now\n-            limit = (int) (((long) limit * rowCount + 99) / 100);\n-        }\n-        boolean clearAll = offset >= rowCount || limit == 0;\n-        if (!clearAll) {\n-            int remaining = rowCount - offset;\n-            limit = limit < 0 ? remaining : Math.min(remaining, limit);\n-            if (offset == 0 && remaining <= limit) {\n-                return;\n-            }\n-        } else {\n-            limit = 0;\n-        }\n-        distinctRows = null;\n-        rowCount = limit;\n-        if (external == null) {\n-            if (clearAll) {\n-                rows.clear();\n-                return;\n-            }\n-            int to = offset + limit;\n-            if (withTiesSortOrder != null) {\n-                Value[] expected = rows.get(to - 1);\n-                while (to < rows.size() && withTiesSortOrder.compare(expected, rows.get(to)) == 0) {\n-                    to++;\n-                    rowCount++;\n-                }\n-            }\n-            if (offset != 0 || to != rows.size()) {\n-                // avoid copying the whole array for each row\n-                rows = new ArrayList<>(rows.subList(offset, to));\n-            }\n-        } else {\n-            if (clearAll) {\n-                external.close();\n-                external = null;\n-                return;\n-            }\n-            trimExternal(offset, limit);\n+            if (distinctRowKey != null)\n+                memory += distinctRowKey.getMemory();\n         }\n-    }\n-\n-    /**\n-     * @param offset Offset.\n-     * @param limit Limit.\n-     */\n-    private void trimExternal(int offset, int limit) {\n-        ResultExternal temp = external;\n-        external = null;\n-\n-        temp.reset();\n-        initMemTracker();\n-\n-        while (--offset >= 0)\n-            temp.next();\n-\n-        Value[] row = null;\n-\n-        while (--limit >= 0) {\n-            row = temp.next();\n-            rows.add(row);\n-\n-            if (!hasAvailableMemory(null,null, row))\n-                addRowsToDisk(true);\n-        }\n-        if (withTiesSortOrder != null && row != null) {\n-            Value[] expected = row;\n-\n-            while ((row = temp.next()) != null && withTiesSortOrder.compare(expected, row) == 0) {\n-                rows.add(row);\n-                rowCount++;\n-\n-                if (!hasAvailableMemory(null,null, row))\n-                    addRowsToDisk(true);\n-            }\n-        }\n-\n-        if (external != null)\n-            addRowsToDisk(true);\n-\n-        temp.close();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public int getRowCount() {\n-        return rowCount;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void limitsWereApplied() {\n-        this.limitsWereApplied = true;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public boolean hasNext() {\n-        return !closed && rowId < rowCount - 1;\n-    }\n \n-    /** {@inheritDoc} */\n-    @Override public void setLimit(int limit) {\n-        this.limit = limit;\n-    }\n+        for (int i = 0; i < row.length; i++)\n+            memory += row[i].getMemory();\n \n-    /** {@inheritDoc} */\n-    @Override public void setFetchPercent(boolean fetchPercent) {\n-        this.fetchPercent = fetchPercent;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void setWithTies(SortOrder withTiesSortOrder) {\n-        assert sort == null || sort == withTiesSortOrder;\n-        this.withTiesSortOrder = withTiesSortOrder;\n-    }\n+        if (memory < 0)\n+            mem.release(memory);\n+        else\n+            mem.reserve(memory);\n \n-    /** {@inheritDoc} */\n-    @Override public boolean needToClose() {\n-        return !closed;\n+        memReserved += memory;\n     }\n \n     /** */\n", "next_change": {"commit": "2db025677cc4fb675a1a161fe813c5c06da63bca", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex e45937a060d..b6caf3a685a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -74,7 +74,7 @@ public class H2ManagedLocalResult extends H2BaseLocalResult {\n             memory += row[i].getMemory();\n \n         if (memory < 0)\n-            mem.release(memory);\n+            mem.release(-memory);\n         else\n             mem.reserve(memory);\n \n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex b6caf3a685a..63ef0d9aaf5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -43,42 +86,465 @@ public class H2ManagedLocalResult extends H2BaseLocalResult {\n      */\n     public H2ManagedLocalResult(Session ses, H2MemoryTracker memTracker, Expression[] expressions,\n         int visibleColCnt) {\n-        super(ses, expressions, visibleColCnt);\n+        this.session = ses;\n+        rows = Utils.newSmallArrayList();\n+        this.visibleColumnCount = visibleColCnt;\n+        rowId = -1;\n+        this.expressions = expressions;\n+        this.memTracker = memTracker;\n+\n+        if (ses != null && ses.getQueryContext() != null) {\n+            QueryContext qctx = (QueryContext)ses.getQueryContext();\n \n-        this.mem = memTracker;\n+            ctx = qctx.context();\n+\n+            assert memTracker == null || ctx != null; // Context should be set when we track memory.\n+        }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override protected void onUpdate(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n+    /**\n+     * Checks available memory.\n+     *\n+     * @param distinctRowKey Row key.\n+     * @param oldRow Old row.\n+     * @param row New row.\n+     * @return {@code True} if we have available memory.\n+     */\n+    private boolean hasAvailableMemory(ValueRow distinctRowKey, Value[] oldRow, Value[] row) {\n         assert !isClosed();\n-        assert row != null;\n \n-        long memory;\n+        if (memTracker == null)\n+            return true; // No memory management set.\n+\n+        long memory = calculateMemoryDelta(distinctRowKey, oldRow, row);\n+\n+        boolean hasMemory = true;\n+\n+        if (memory < 0)\n+            memTracker.released(-memory);\n+        else\n+            hasMemory = memTracker.reserved(memory);\n+\n+        memReserved += memory;\n+\n+        return hasMemory;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isLazy() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setMaxMemoryRows(int maxValue) {\n+        // No-op. We do not use rowCount-based memory tracking in this class. {@link memTracker} is used instead.\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public H2ManagedLocalResult createShallowCopy(SessionInterface targetSession) {\n+        if (containsLobs) {\n+            return null;\n+        }\n+\n+        ResultExternal e2 = null;\n+\n+        if (external != null) {\n+            e2 = external.createShallowCopy();\n+\n+            if (e2 == null)\n+                return null;\n+        }\n+\n+        H2ManagedLocalResult cp = new H2ManagedLocalResult();\n+\n+        cp.session = (Session)targetSession;\n+        cp.visibleColumnCount = this.visibleColumnCount;\n+        cp.expressions = this.expressions;\n+        cp.rowId = -1;\n+        cp.rowCount = this.rowCount;\n+        cp.rows = this.rows;\n+        cp.sort = this.sort;\n+        cp.distinctRows = this.distinctRows;\n+        cp.distinct = distinct;\n+        cp.distinctIndexes = distinctIndexes;\n+        cp.currentRow = null;\n+        cp.offset = 0;\n+        cp.limit = -1;\n+        cp.containsNull = containsNull;\n+        cp.external = e2;\n+\n+        return cp;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setSortOrder(SortOrder sort) {\n+        this.sort = sort;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setDistinct() {\n+        assert distinctIndexes == null;\n+        distinct = true;\n+        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setDistinct(int[] distinctIndexes) {\n+        assert !distinct;\n+        this.distinctIndexes = distinctIndexes;\n+        distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n+    }\n \n-        // Replace old row.\n-        if (oldRow != null) {\n-            memory = (row.length - oldRow.length) * Constants.MEMORY_POINTER;\n+    /**\n+     * @return whether this result is a distinct result\n+     */\n+    private boolean isAnyDistinct() {\n+        return distinct || distinctIndexes != null;\n+    }\n \n-            for (int i = 0; i < oldRow.length; i++)\n-                memory -= oldRow[i].getMemory();\n+    /** {@inheritDoc} */\n+    @Override public void removeDistinct(Value[] values) {\n+        if (!distinct) {\n+            DbException.throwInternalError();\n+        }\n+        assert values.length == visibleColumnCount;\n+        if (distinctRows != null) {\n+            ValueRow array = ValueRow.get(values);\n+            distinctRows.remove(array);\n+            rowCount = distinctRows.size();\n         }\n         // Add new row.\n         else {\n-            memory = Constants.MEMORY_ARRAY + row.length * Constants.MEMORY_POINTER;\n+            rowCount = external.removeRow(values);\n+        }\n+    }\n \n-            if (distinctRowKey != null)\n-                memory += distinctRowKey.getMemory();\n+    /** {@inheritDoc} */\n+    @Override public boolean containsDistinct(Value[] values) {\n+        assert values.length == visibleColumnCount;\n+        if (external != null) {\n+            return external.contains(values);\n+        }\n+        if (distinctRows == null) {\n+            distinctRows = new TreeMap<>(session.getDatabase().getCompareMode());\n+            for (Value[] row : rows) {\n+                ValueRow array = getDistinctRow(row);\n+                distinctRows.put(array, array.getList());\n+            }\n         }\n+        ValueRow array = ValueRow.get(values);\n+        return distinctRows.get(array) != null;\n+    }\n \n-        for (int i = 0; i < row.length; i++)\n-            memory += row[i].getMemory();\n+    /** {@inheritDoc} */\n+    @Override public boolean containsNull() {\n+        Boolean r = containsNull;\n+        if (r == null) {\n+            r = false;\n+            reset();\n+            loop:\n+            while (next()) {\n+                Value[] row = currentRow;\n+                for (int i = 0; i < visibleColumnCount; i++) {\n+                    if (row[i].containsNull()) {\n+                        r = true;\n+                        break loop;\n+                    }\n+                }\n+            }\n+            reset();\n+            containsNull = r;\n+        }\n+        return r;\n+    }\n \n-        if (memory < 0)\n-            mem.release(-memory);\n+    /** {@inheritDoc} */\n+    @Override\n+    public void reset() {\n+        rowId = -1;\n+        currentRow = null;\n+        if (external != null) {\n+            external.reset();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Value[] currentRow() {\n+        return currentRow;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean next() {\n+        if (!closed && rowId < rowCount) {\n+            rowId++;\n+            if (rowId < rowCount) {\n+                if (external != null) {\n+                    currentRow = external.next();\n+                } else {\n+                    currentRow = rows.get(rowId);\n+                }\n+                return true;\n+            }\n+            currentRow = null;\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public int getRowId() {\n+        return rowId;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isAfterLast() {\n+        return rowId >= rowCount;\n+    }\n+\n+    /**\n+     * @param values Values.\n+     */\n+    private void cloneLobs(Value[] values) {\n+        for (int i = 0; i < values.length; i++) {\n+            Value v = values[i];\n+            Value v2 = v.copyToResult();\n+            if (v2 != v) {\n+                containsLobs = true;\n+                session.addTemporaryLob(v2);\n+                values[i] = v2;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param values row.\n+     * @return Row,\n+     */\n+    private ValueRow getDistinctRow(Value[] values) {\n+        if (distinctIndexes != null) {\n+            int cnt = distinctIndexes.length;\n+            Value[] newValues = new Value[cnt];\n+            for (int i = 0; i < cnt; i++) {\n+                newValues[i] = values[distinctIndexes[i]];\n+            }\n+            values = newValues;\n+        }\n+        else if (values.length > visibleColumnCount) {\n+            values = Arrays.copyOf(values, visibleColumnCount);\n+        }\n+        return ValueRow.get(values);\n+    }\n+\n+    private void createExternalResult(boolean forcePlainResult) {\n+        assert ctx != null;\n+\n+        if (forcePlainResult)\n+            external = new PlainExternalResult(ctx, memTracker, session);\n         else\n-            mem.reserve(memory);\n+            external = distinct || distinctIndexes != null || sort != null ?\n+                new SortedExternalResult(ctx, session, distinct, distinctIndexes, visibleColumnCount, sort, memTracker,\n+                    rowCount) : new PlainExternalResult(ctx, memTracker, session);\n+    }\n \n-        memReserved += memory;\n+    /** {@inheritDoc} */\n+    @Override public void addRow(Value[] values) {\n+        cloneLobs(values);\n+        if (isAnyDistinct()) {\n+            if (distinctRows != null) {\n+                ValueRow array = getDistinctRow(values);\n+                Value[] previous = distinctRows.get(array);\n+                if (previous == null || sort != null && sort.compare(previous, values) > 0) {\n+                    distinctRows.put(array, values);\n+                }\n+                rowCount = distinctRows.size();\n+                if (!hasAvailableMemory(array, previous, values)) {\n+                    addRowsToDisk(false);\n+\n+                    distinctRows = null;\n+                }\n+            } else {\n+                rowCount = external.addRow(values);\n+            }\n+        } else {\n+            rowCount++;\n+            if (external == null) {\n+                rows.add(values);\n+                if (!hasAvailableMemory(null, null, values)) {\n+                    addRowsToDisk(false);\n+                }\n+            }\n+            else\n+                external.addRow(values);\n+        }\n+    }\n+\n+    /**\n+     * Adds rows to disk.\n+     * @param forcePlainResult Whether to force creation of not sorted result.\n+     */\n+    private void addRowsToDisk(boolean forcePlainResult) {\n+        if (external == null) {\n+            createExternalResult(forcePlainResult);\n+        }\n+\n+        if (distinctRows == null) {\n+            rowCount = external.addRows(rows);\n+            rows.clear();\n+        }\n+        else {\n+            rowCount = external.addRows(distinctRows.values());\n+            distinctRows.clear();\n+        }\n+\n+        memReserved = 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public int getVisibleColumnCount() {\n+        return visibleColumnCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void done() {\n+        if (external != null) {\n+            addRowsToDisk(false);\n+        }\n+        else {\n+            if (isAnyDistinct()) {\n+                rows = new ArrayList<>(distinctRows.values());\n+            }\n+            if (sort != null && limit != 0 && !limitsWereApplied) {\n+                boolean withLimit = limit > 0 && withTiesSortOrder == null;\n+                if (offset > 0 || withLimit) {\n+                    sort.sort(rows, offset, withLimit ? limit : rows.size());\n+                }\n+                else {\n+                    sort.sort(rows);\n+                }\n+            }\n+        }\n+\n+        applyOffsetAndLimit();\n+        reset();\n+    }\n+\n+    private void applyOffsetAndLimit() {\n+        if (limitsWereApplied) {\n+            return;\n+        }\n+        int offset = Math.max(this.offset, 0);\n+        int limit = this.limit;\n+        if (offset == 0 && limit < 0 && !fetchPercent || rowCount == 0) {\n+            return;\n+        }\n+        if (fetchPercent) {\n+            if (limit < 0 || limit > 100) {\n+                throw DbException.getInvalidValueException(\"FETCH PERCENT\", limit);\n+            }\n+            // Oracle rounds percent up, do the same for now\n+            limit = (int) (((long) limit * rowCount + 99) / 100);\n+        }\n+        boolean clearAll = offset >= rowCount || limit == 0;\n+        if (!clearAll) {\n+            int remaining = rowCount - offset;\n+            limit = limit < 0 ? remaining : Math.min(remaining, limit);\n+            if (offset == 0 && remaining <= limit) {\n+                return;\n+            }\n+        } else {\n+            limit = 0;\n+        }\n+        distinctRows = null;\n+        rowCount = limit;\n+        if (external == null) {\n+            if (clearAll) {\n+                rows.clear();\n+                return;\n+            }\n+            int to = offset + limit;\n+            if (withTiesSortOrder != null) {\n+                Value[] expected = rows.get(to - 1);\n+                while (to < rows.size() && withTiesSortOrder.compare(expected, rows.get(to)) == 0) {\n+                    to++;\n+                    rowCount++;\n+                }\n+            }\n+            if (offset != 0 || to != rows.size()) {\n+                // avoid copying the whole array for each row\n+                rows = new ArrayList<>(rows.subList(offset, to));\n+            }\n+        } else {\n+            if (clearAll) {\n+                external.close();\n+                external = null;\n+                return;\n+            }\n+            trimExternal(offset, limit);\n+        }\n+    }\n+\n+    private void trimExternal(int offset, int limit) {\n+        ResultExternal temp = external;\n+        external = null;\n+        temp.reset();\n+        while (--offset >= 0) {\n+            temp.next();\n+        }\n+        Value[] row = null;\n+        while (--limit >= 0) {\n+            row = temp.next();\n+            rows.add(row);\n+            if (!hasAvailableMemory(null,null, row))\n+                addRowsToDisk(true);\n+        }\n+        if (withTiesSortOrder != null && row != null) {\n+            Value[] expected = row;\n+            while ((row = temp.next()) != null && withTiesSortOrder.compare(expected, row) == 0) {\n+                rows.add(row);\n+                rowCount++;\n+                if (!hasAvailableMemory(null,null, row))\n+                    addRowsToDisk(true);\n+            }\n+        }\n+        if (external != null) {\n+            addRowsToDisk(true);\n+        }\n+        temp.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public int getRowCount() {\n+        return rowCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void limitsWereApplied() {\n+        this.limitsWereApplied = true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean hasNext() {\n+        return !closed && rowId < rowCount - 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setLimit(int limit) {\n+        this.limit = limit;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setFetchPercent(boolean fetchPercent) {\n+        this.fetchPercent = fetchPercent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void setWithTies(SortOrder withTiesSortOrder) {\n+        assert sort == null || sort == withTiesSortOrder;\n+        this.withTiesSortOrder = withTiesSortOrder;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean needToClose() {\n+        return !closed;\n     }\n \n     /** */\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\nindex 63ef0d9aaf5..6b8d19774bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2ManagedLocalResult.java\n", "chunk": "@@ -552,7 +555,6 @@ public class H2ManagedLocalResult implements LocalResult {\n         return memReserved;\n     }\n \n-\n     /** {@inheritDoc} */\n     @Override public void close() {\n         if (!closed) {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "2db025677cc4fb675a1a161fe813c5c06da63bca", "committedDate": "2019-07-24 13:25:10 +0300", "message": "GG-21748: SQL: Fix unexpected assertion failure in MemoryTracker.release()."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "4bdd95f670e3b37e41d5d4efdfffe4226c884623", "committedDate": "2020-06-04 16:49:35 +0300", "message": "GG-28564 Performance drop 8.7.15 vs 8.7.13"}, {"oid": "e59250634580750798b04f632b6795cf56863519", "committedDate": "2020-06-07 19:52:03 +0300", "message": "GG-22441 [IGNITE-11872] EmptyLineSeparator check added"}, {"oid": "4a0e2d3d72047117d6a0835cbde5864352591bc9", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29128 [IGNITE-12959] Add support for GenericWhitespace to checkstyle rules (#7749)"}, {"oid": "69705564d6572f3ff8b15a9a5531815462933b47", "committedDate": "2020-06-07 20:06:33 +0300", "message": "GG-28973 [IGNITE-12841] @Override must be on the same line as a method (#7578)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "734869bf4cfe20f7fd79bbfbfbc372e8339aa401", "committedDate": "2021-05-26 12:21:25 +0300", "message": "GG-33232 Fix the performance issue with SQL DISTINCT (use HashMap instead of TreeMap when possible) (#1939)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NzYxOQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392847619", "body": "```\r\n/**\r\n* @return Query id assigned by {@link RunningQueryManager}. \r\n*/\r\n```", "bodyText": "/**\n* @return Query id assigned by {@link RunningQueryManager}. \n*/", "bodyHTML": "<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"/**\n* @return Query id assigned by {@link RunningQueryManager}. \n*/\"><pre><code>/**\n* @return Query id assigned by {@link RunningQueryManager}. \n*/\n</code></pre></div>", "author": "AMashenkov", "createdAt": "2020-03-16T08:20:43Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java", "diffHunk": "@@ -108,6 +114,11 @@ public void printLogMessage(IgniteLogger log, String msg, String additionalInfo)\n         printLogMessage(log, null, msg, additionalInfo);\n     }\n \n+    /** @return Query id assigned by {@link RunningQueryManager}. */", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "f3d5e5b81fa448e1602a1929367726281a6091c6", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex e20bc9e28bc..1e60bf82b19 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -114,11 +108,6 @@ public class H2QueryInfo {\n         printLogMessage(log, null, msg, additionalInfo);\n     }\n \n-    /** @return Query id assigned by {@link RunningQueryManager}. */\n-    public Long runningQueryId() {\n-        return runningQryId;\n-    }\n-\n     /**\n      * @param log Logger.\n      * @param msg Log message\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 1e60bf82b19..3323822cc96 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -108,6 +114,11 @@ public class H2QueryInfo {\n         printLogMessage(log, null, msg, additionalInfo);\n     }\n \n+    /** @return Query id assigned by {@link RunningQueryManager}. */\n+    public Long runningQueryId() {\n+        return runningQryId;\n+    }\n+\n     /**\n      * @param log Logger.\n      * @param msg Log message\n", "next_change": {"commit": "669e2f99c8b80365443a1f2352f4cbafb5df5392", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\nindex 3323822cc96..807e3a7a23a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2QueryInfo.java\n", "chunk": "@@ -105,49 +113,57 @@ public class H2QueryInfo {\n         return U.currentTimeMillis() - beginTs;\n     }\n \n+    /** @return Query id assigned by {@link RunningQueryManager}. */\n+    public Long runningQueryId() {\n+        return runningQryId;\n+    }\n+\n     /**\n-     * @param log Logger.\n-     * @param msg Log message\n-     * @param additionalInfo Additional query info.\n+     * @return Node originator uid.\n      */\n-    public void printLogMessage(IgniteLogger log, String msg, String additionalInfo) {\n-        printLogMessage(log, null, msg, additionalInfo);\n+    public UUID node() {\n+        return node;\n     }\n \n-    /** @return Query id assigned by {@link RunningQueryManager}. */\n-    public Long runningQueryId() {\n-        return runningQryId;\n+    /**\n+     * @param type Query type.\n+     */\n+    public QueryType type() {\n+        return type;\n     }\n \n     /**\n      * @param log Logger.\n      * @param msg Log message\n-     * @param connMgr Connection manager.\n      * @param additionalInfo Additional query info.\n      */\n-    public void printLogMessage(IgniteLogger log, ConnectionManager connMgr, String msg, String additionalInfo) {\n-        StringBuilder msgSb = new StringBuilder(msg + \" [\");\n+    public void printLogMessage(IgniteLogger log, String msg, String additionalInfo) {\n+        String globalQueryId = runningQryId == null ? \"(unknown)\" // compatibility with old versions.\n+            : QueryUtils.globalQueryId(node, runningQryId);\n+\n+        StringBuilder msgSb = new StringBuilder(msg)\n+            .append(\" [globalQueryId=\").append(globalQueryId);\n \n         if (additionalInfo != null)\n-            msgSb.append(additionalInfo).append(\", \");\n+            msgSb.append(\", \").append(additionalInfo);\n \n-        msgSb.append(\"duration=\").append(time()).append(\"ms\")\n+        msgSb\n+            .append(\", duration=\").append(time()).append(\"ms\")\n             .append(\", type=\").append(type)\n             .append(\", distributedJoin=\").append(distributedJoin)\n             .append(\", enforceJoinOrder=\").append(enforceJoinOrder)\n             .append(\", lazy=\").append(lazy)\n-            .append(\", schema=\").append(schema);\n-\n-        msgSb.append(\", sql='\")\n-            .append(sql);\n-\n-        msgSb.append(\"', plan=\").append(stmt.getPlanSQL(false));\n+            .append(\", schema=\").append(schema)\n+            .append(\", sql='\").append(sql)\n+            .append(\"', plan=\").append(stmt.getPlanSQL(false));\n \n         printInfo(msgSb);\n \n         msgSb.append(']');\n \n-        LT.warn(log, msgSb.toString());\n+        // Include 'sql' text into key for compatibility with older versions.\n+        String throttleKey = globalQueryId + \"#\" + (runningQryId == null ? sql : type);\n+        LT.warn(log, throttleKey, msgSb.toString());\n     }\n \n     /**\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "f3d5e5b81fa448e1602a1929367726281a6091c6", "committedDate": "2019-10-25 15:28:05 +0300", "message": "GG-24808 SQL: print warning log message when query's result is big"}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "70c768ce24aee355008841e12766be2b470bb07e", "committedDate": "2021-03-29 18:19:22 +0300", "message": "GG-27961 hide sensitive data on log messages for long running query and huge results query according with the property IGNITE_TO_STRING_INCLUDE_SENSITIVE"}, {"oid": "17d61305c2c1652790dd34670a67bd5509c8c8f7", "committedDate": "2021-04-21 10:22:46 +0300", "message": "GG-33093 Revert \"GG-27961 hide sensitive data on log messages for long running query and huge results query according with the property IGNITE_TO_STRING_INCLUDE_SENSITIVE\""}, {"oid": "f3e3f4dbebb5aa65410e0d26c97bfaa8f25079e1", "committedDate": "2021-07-22 15:27:56 +0300", "message": "GG-33442 Throttle long running query warnings with queryParallelism > 1 (#2015)"}, {"oid": "669e2f99c8b80365443a1f2352f4cbafb5df5392", "committedDate": "2021-12-10 16:37:36 +0300", "message": "GG-34370: Logging globalQueryId for long running queries. (#2220)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0OTY3Mg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392849672", "body": "Let's either uncomment or remove this.", "bodyText": "Let's either uncomment or remove this.", "bodyHTML": "<p dir=\"auto\">Let's either uncomment or remove this.</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:24:59Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java", "diffHunk": "@@ -174,48 +171,38 @@ public QueryMemoryManager(GridKernalContext ctx) {\n     /**\n      * Query memory tracker factory method.\n      *\n-     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota}  will be used.\n-     * Note: Negative values are reserved for disable memory tracking.\n+     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota} will be used.\n      *\n      * @param maxQryMemory Query memory limit in bytes.\n-     * @param qryDesc Query descriptor.\n      * @return Query memory tracker.\n      */\n-    public QueryMemoryTracker createQueryMemoryTracker(long maxQryMemory, String qryDesc) {\n-        assert maxQryMemory >= 0;\n-\n-        if (maxQryMemory == 0)\n-            maxQryMemory = qryQuota;\n-\n+    public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n         long globalQuota0 = globalQuota;\n \n-        if (maxQryMemory == 0 && globalQuota0 == 0) {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"No memory quota configured for the query. \" +\n-                    \"It will be executed without memory tracking: \"  + qryDesc);\n-            }\n-\n-            return null;\n-        }\n+//        if (maxQryMemory == 0 && globalQuota0 == 0 && qryQuota == 0)", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex dbd47db5bee..3d0aa72da77 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -179,9 +179,6 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n     public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n         long globalQuota0 = globalQuota;\n \n-//        if (maxQryMemory == 0 && globalQuota0 == 0 && qryQuota == 0)\n-//            return null;\n-\n         if (globalQuota0 > 0 && globalQuota0 < maxQryMemory) {\n             if (log.isInfoEnabled()) {\n                 LT.info(log, \"Query memory quota cannot exceed global memory quota.\" +\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex dbd47db5bee..65892c13b4a 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -179,9 +179,6 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n     public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n         long globalQuota0 = globalQuota;\n \n-//        if (maxQryMemory == 0 && globalQuota0 == 0 && qryQuota == 0)\n-//            return null;\n-\n         if (globalQuota0 > 0 && globalQuota0 < maxQryMemory) {\n             if (log.isInfoEnabled()) {\n                 LT.info(log, \"Query memory quota cannot exceed global memory quota.\" +\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 65892c13b4a..58ae9e20f92 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -163,168 +109,62 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n         if (size == 0)\n             return; // Nothing to do.\n \n-        assert size > 0;\n+        reserved.accumulateAndGet(-size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to free more memory that ever be reserved: [\" +\n+                    \"reserved=\" + prev + \", toFree=\" + x + ']');\n \n-        reserved.accumulateAndGet(size, RELEASE_OP);\n+            return prev + x;\n+        });\n     }\n \n     /**\n      * Query memory tracker factory method.\n      *\n-     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota} will be used.\n+     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#dfltSqlQryMemoryLimit}  will be used.\n+     * Note: Negative values are reserved for disable memory tracking.\n      *\n-     * @param maxQryMemory Query memory limit in bytes.\n+     * @param maxQueryMemory Query memory limit in bytes.\n      * @return Query memory tracker.\n      */\n-    public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n-        long globalQuota0 = globalQuota;\n-\n-        if (globalQuota0 > 0 && globalQuota0 < maxQryMemory) {\n-            if (log.isInfoEnabled()) {\n-                LT.info(log, \"Query memory quota cannot exceed global memory quota.\" +\n-                    \" It will be reduced to the size of global quota: \" + globalQuota0);\n-            }\n-\n-            maxQryMemory = globalQuota0;\n-        }\n-\n-        if (maxQryMemory == 0)\n-            maxQryMemory = globalQuota0 > 0 ? Math.min(qryQuota, globalQuota0) : qryQuota;\n-\n-        if (maxQryMemory < 0)\n-            maxQryMemory = 0;\n+    public QueryMemoryTracker createQueryMemoryTracker(long maxQueryMemory) {\n+        assert maxQueryMemory >= 0;\n \n-        QueryMemoryTracker tracker = new QueryMemoryTracker(this, maxQryMemory, blockSize, offloadingEnabled);\n+        if (maxQueryMemory == 0)\n+            maxQueryMemory = dfltSqlQryMemoryLimit;\n \n-        if (log.isDebugEnabled())\n-            log.debug(\"Memory tracker created: \" + tracker);\n+        if (dfltSqlQryMemoryLimit < 0)\n+            return null;\n \n-        return tracker;\n-    }\n+        if (globalQuota > 0 && globalQuota < maxQueryMemory) {\n+            U.warn(log, \"Max query memory can't exceeds SQL memory pool size. Will be reduced down to: \" + globalQuota);\n \n-    /**\n-     * Action when quota is exceeded.\n-     * @return {@code false} if it is needed to offload data.\n-     */\n-    public boolean onQuotaExceeded(long size) {\n-        reserved.addAndGet(-size);\n-\n-        if (offloadingEnabled)\n-            return false;\n-        else {\n-            throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            maxQueryMemory = globalQuota;\n         }\n-    }\n-\n-    /**\n-     * Sets new global query quota.\n-     *\n-     * @param newGlobalQuota New global query quota.\n-     */\n-    public synchronized void setGlobalQuota(String newGlobalQuota) {\n-        long globalQuota0 = U.parseBytes(newGlobalQuota);\n-        long heapSize = Runtime.getRuntime().maxMemory();\n-\n-        A.ensure(\n-            heapSize > globalQuota0,\n-            \"Sql global memory quota can't be more than heap size: heapSize=\"\n-                + heapSize + \", quotaSize=\" + globalQuota0\n-        );\n \n-        A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n+        assert maxQueryMemory >= blockSize;\n \n-        globalQuota = globalQuota0;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query global quota was set to \" + globalQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n+        return new QueryMemoryTracker(globalQuota < 0 ? null : this, maxQueryMemory, blockSize);\n     }\n \n     /**\n-     * @return Current global query quota.\n-     */\n-    public String getGlobalQuota() {\n-        return String.valueOf(globalQuota);\n-    }\n-\n-    /**\n-     * Sets new per-query quota.\n+     * Gets memory reserved by running queries.\n      *\n-     * @param newQryQuota New per-query quota.\n+     * @return Reserved memory in bytes.\n      */\n-    public synchronized void setQueryQuota(String newQryQuota) {\n-        long qryQuota0 = U.parseBytes(newQryQuota);\n-\n-        A.ensure(qryQuota0 >= 0, \"Sql query memory quota must be >= 0: quotaSize=\" + qryQuota0);\n-\n-        qryQuota = U.parseBytes(newQryQuota);\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query memory quota was set to \" + qryQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n-\n-        if (qryQuota > globalQuota) {\n-            log.warning(\"The local quota was set higher than global. The new value will be truncated \" +\n-                \"to the size of the global quota [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota);\n-        }\n-    }\n-\n-    /**\n-     * @return Current query quota.\n-     */\n-    public String getQueryQuotaString() {\n-        return String.valueOf(qryQuota);\n+    public long memoryReserved() {\n+        return reserved.get();\n     }\n \n     /**\n-     * Sets offloading enabled flag.\n+     * Gets global memory limit for queries.\n      *\n-     * @param offloadingEnabled Offloading enabled flag.\n-     */\n-    public synchronized void setOffloadingEnabled(boolean offloadingEnabled) {\n-        this.offloadingEnabled = offloadingEnabled;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query query offloading enabled flag was set to \" + offloadingEnabled +\n-                \". Current memory tracking parameters: [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + this.offloadingEnabled + ']');\n-        }\n-    }\n-\n-    /**\n-     * @return Flag whether offloading is enabled.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n-    }\n-\n-    /**\n-     * @return Bytes reserved by all queries.\n+     * @return Max memory in bytes.\n      */\n-    @Override public long reserved() {\n-        return reserved.get();\n-    }\n-\n-    /** */\n-    public long memoryLimit() {\n+    public long maxMemory() {\n         return globalQuota;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public void spill(long size) {\n-        // NO-OP\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void unspill(long size) {\n-        // NO-OP\n-    }\n-\n     /** {@inheritDoc} */\n     @Override public void close() {\n         // Cursors are not tracked and can't be forcibly closed to release resources.\n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 58ae9e20f92..727ed359f06 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -172,4 +179,29 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    private static class ReservationOp implements LongBinaryOperator {\n+        /** Operation result high bound.*/\n+        private final long limit;\n+\n+        /**\n+         * Constructor.\n+         * @param limit Operation result high bound.\n+         */\n+        ReservationOp(long limit) {\n+            this.limit = limit;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long applyAsLong(long prev, long x) {\n+            long res = prev + x;\n+\n+            if (res > limit)\n+                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+\n+            return res;\n+        }\n+    }\n }\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 727ed359f06..788602adfa6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -179,29 +196,4 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n-\n-    /** */\n-    private static class ReservationOp implements LongBinaryOperator {\n-        /** Operation result high bound.*/\n-        private final long limit;\n-\n-        /**\n-         * Constructor.\n-         * @param limit Operation result high bound.\n-         */\n-        ReservationOp(long limit) {\n-            this.limit = limit;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long applyAsLong(long prev, long x) {\n-            long res = prev + x;\n-\n-            if (res > limit)\n-                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-\n-            return res;\n-        }\n-    }\n }\n", "next_change": {"commit": "3c6a5cb36df055ae623a37e59044c99b862b1938", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 788602adfa6..750b2e3b12d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -196,4 +297,196 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    public IgniteLogger log() {\n+        return log;\n+    }\n+\n+    /**\n+     * Cleans spill directory. Spill directory is used for disk\n+     * offloading of the intermediate results of heavy queries.\n+     */\n+    public void cleanSpillDirectory() {\n+        try {\n+            File spillDir = U.resolveWorkDirectory(\n+                ctx.config().getWorkDirectory(),\n+                DISK_SPILL_DIR,\n+                false);\n+\n+            File[] spillFiles = spillDir.listFiles();\n+\n+            if (spillFiles.length == 0)\n+                return;\n+\n+            for (int i = 0; i < spillFiles.length; i++) {\n+                try {\n+                    File spillFile = spillFiles[i];\n+\n+                    String nodeId = spillFile.getName().split(\"_\")[1]; // Spill name pattern: spill_nodeId_fileId.\n+\n+                    UUID nodeUuid = UUID.fromString(nodeId);\n+\n+                    if (!ctx.discovery().alive(nodeUuid) || ctx.localNodeId().equals(nodeUuid))\n+                        spillFile.delete();\n+                }\n+                catch (Exception e) {\n+                    log.debug(\"Error on cleaning spill directory. \" + X.getFullStackTrace(e));\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.warning(\"Failed to cleanup the temporary directory for intermediate \" +\n+                \"SQL query results from the previous node run.\", e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public GroupByData newManagedGroupByData(Session ses, ArrayList<Expression> expressions,\n+        boolean isGrpQry, int[] grpIdx) {\n+\n+        boolean spillingEnabled = ctx.config().isSqlOffloadingEnabled();\n+\n+        if (!spillingEnabled)\n+            return null;\n+\n+        assert isGrpQry; // isGrpQry == false allowed only for window queries which are not supported yet.\n+\n+        return new H2ManagedGroupByData(ses, grpIdx);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @return Plain external result.\n+     */\n+    public ResultExternal createPlainExternalResult(Session ses) {\n+        return new PlainExternalResult(ses);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param distinct Distinct flag.\n+     * @param distinctIndexes Distinct indexes.\n+     * @param visibleColCnt Visible columns count.\n+     * @param sort Sort order.\n+     * @param rowCnt Row count.\n+     * @return Sorted external result.\n+     */\n+    public ResultExternal createSortedExternalResult(Session ses, boolean distinct, int[] distinctIndexes,\n+        int visibleColCnt, SortOrder sort, int rowCnt) {\n+        return new SortedExternalResult(ses, distinct, distinctIndexes, visibleColCnt, sort, rowCnt);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param size Size;\n+     * @return Grouped result;\n+     */\n+    public GroupedExternalResult createGroupedExternalResult(Session ses, int size) {\n+        return new GroupedExternalResult(ses, size);\n+    }\n+\n+    /**\n+     * Creates external data (offload file wrapper).\n+     * @param ses Session.\n+     * @param useHashIdx Flag whether to use hash index.\n+     * @param initSize Initial size.\n+     * @param cls Class of stored values.\n+     * @param <T> Type of stored values.\n+     * @return Created external data (offload file wrapper).\n+     */\n+    public <T> ExternalResultData<T> createExternalData(Session ses, boolean useHashIdx, long initSize, Class<T> cls) {\n+        if (!ses.isOffloadedToDisk()) {\n+            ses.setOffloadedToDisk(true);\n+\n+            metrics.trackQueryOffloaded();\n+        }\n+\n+        return new ExternalResultData<>(log,\n+            ctx.config().getWorkDirectory(),\n+            fileIOFactory,\n+            ctx.localNodeId(),\n+            useHashIdx,\n+            initSize,\n+            cls,\n+            ses.getDatabase().getCompareMode(),\n+            ses.getDatabase());\n+    }\n+\n+    /**\n+     * FileIO decorator for stats collecting.\n+     */\n+    private static class TrackableFileIO extends FileIODecorator {\n+        /** */\n+        private final SqlMemoryStatisticsHolder metrics;\n+\n+        /**\n+         * @param delegate File I/O delegate\n+         */\n+        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n+            super(delegate);\n+\n+            this.metrics = metrics;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf) throws IOException {\n+            int bytesRead = delegate.read(destBuf);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n+            int bytesRead = delegate.read(destBuf, position);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(byte[] buf, int off, int len) throws IOException {\n+            int bytesRead = delegate.read(buf, off, len);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf, position);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(byte[] buf, int off, int len) throws IOException {\n+            int bytesWritten = delegate.write(buf, off, len);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+    }\n }\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 750b2e3b12d..3768f833c89 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -410,83 +456,7 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n             initSize,\n             cls,\n             ses.getDatabase().getCompareMode(),\n-            ses.getDatabase());\n-    }\n-\n-    /**\n-     * FileIO decorator for stats collecting.\n-     */\n-    private static class TrackableFileIO extends FileIODecorator {\n-        /** */\n-        private final SqlMemoryStatisticsHolder metrics;\n-\n-        /**\n-         * @param delegate File I/O delegate\n-         */\n-        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n-            super(delegate);\n-\n-            this.metrics = metrics;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf) throws IOException {\n-            int bytesRead = delegate.read(destBuf);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n-            int bytesRead = delegate.read(destBuf, position);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(byte[] buf, int off, int len) throws IOException {\n-            int bytesRead = delegate.read(buf, off, len);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf, position);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(byte[] buf, int off, int len) throws IOException {\n-            int bytesWritten = delegate.write(buf, off, len);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n+            ses.getDatabase(),\n+            ses.memoryTracker());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "5c7104415d67a2d06fa12b058c6ea8c5410c3393", "committedDate": "2019-07-24 20:42:20 +0300", "message": "GG-21813: SQL: Fix assert in MemoryManager.createMemoryTracker."}, {"oid": "e6adea02b6463c268d3c67bb973e9dbf754a8ff1", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20995: SQL: Metrics of using memory quotas."}, {"oid": "ee923b0183a2f8dc02b9e408f949c48be9c7366d", "committedDate": "2019-10-22 15:09:39 +0300", "message": "GG-24667: SQL: Disable memory quotas by default. This closes #604."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "cb6c1b2a9be6ce52cdbb5cfbfb3c7b5e34fe53cd", "committedDate": "2020-03-05 12:27:31 +0300", "message": "GG-27922 Expose SQL memory quota in bytes for JMX"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "9502a24df45ba7a97e2efa7d21476926e8250c66", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29130 [IGNITE-12953] Add support for SingleSpaceSeparator to the checkstyle (#7734)"}, {"oid": "f4f9676e82ec87f0977f387ad233f993e5c4cb28", "committedDate": "2020-08-18 18:12:18 -0400", "message": "GG-29772 (#1247)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "a8de46705cf54e56edefa158338a3a8ce3bc96e2", "committedDate": "2021-03-10 13:53:17 -0500", "message": "GG-32298 Create a JMX metric to show realtime sql engine memory utililization (#1726)"}, {"oid": "342366623db8d66053fb090ea2bee50826137670", "committedDate": "2021-05-28 10:18:58 -0400", "message": "GG-33258 correct log reporting of sqlOffloadingEnabled (#1943)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MjAxNw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392852017", "body": "Is it ok?\r\nNegative values were allowed for disabling global quota.", "bodyText": "Is it ok?\nNegative values were allowed for disabling global quota.", "bodyHTML": "<p dir=\"auto\">Is it ok?<br>\nNegative values were allowed for disabling global quota.</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:29:50Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java", "diffHunk": "@@ -239,7 +226,18 @@ public boolean onQuotaExceeded(long size) {\n      * @param newGlobalQuota New global query quota.\n      */\n     public synchronized void setGlobalQuota(String newGlobalQuota) {\n-        this.globalQuota = U.parseBytes(newGlobalQuota);\n+        long globalQuota0 = U.parseBytes(newGlobalQuota);\n+        long heapSize = Runtime.getRuntime().maxMemory();\n+\n+        A.ensure(\n+            heapSize > globalQuota0,\n+            \"Sql global memory quota can't be more than heap size: heapSize=\"\n+                + heapSize + \", quotaSize=\" + globalQuota0\n+        );\n+\n+        A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkwNDg4MQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392904881", "bodyText": "according to IgniteConfiguration#setSqlGlobalMemoryQuota 0 means no quota", "author": "korlov42", "createdAt": "2020-03-16T10:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MjAxNw=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex dbd47db5bee..58ae9e20f92 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -163,171 +109,62 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n         if (size == 0)\n             return; // Nothing to do.\n \n-        assert size > 0;\n+        reserved.accumulateAndGet(-size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to free more memory that ever be reserved: [\" +\n+                    \"reserved=\" + prev + \", toFree=\" + x + ']');\n \n-        reserved.accumulateAndGet(size, RELEASE_OP);\n+            return prev + x;\n+        });\n     }\n \n     /**\n      * Query memory tracker factory method.\n      *\n-     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#qryQuota} will be used.\n+     * Note: If 'maxQueryMemory' is zero, then {@link QueryMemoryManager#dfltSqlQryMemoryLimit}  will be used.\n+     * Note: Negative values are reserved for disable memory tracking.\n      *\n-     * @param maxQryMemory Query memory limit in bytes.\n+     * @param maxQueryMemory Query memory limit in bytes.\n      * @return Query memory tracker.\n      */\n-    public GridQueryMemoryMetricProvider createQueryMemoryTracker(long maxQryMemory) {\n-        long globalQuota0 = globalQuota;\n-\n-//        if (maxQryMemory == 0 && globalQuota0 == 0 && qryQuota == 0)\n-//            return null;\n-\n-        if (globalQuota0 > 0 && globalQuota0 < maxQryMemory) {\n-            if (log.isInfoEnabled()) {\n-                LT.info(log, \"Query memory quota cannot exceed global memory quota.\" +\n-                    \" It will be reduced to the size of global quota: \" + globalQuota0);\n-            }\n-\n-            maxQryMemory = globalQuota0;\n-        }\n-\n-        if (maxQryMemory == 0)\n-            maxQryMemory = globalQuota0 > 0 ? Math.min(qryQuota, globalQuota0) : qryQuota;\n-\n-        if (maxQryMemory < 0)\n-            maxQryMemory = 0;\n+    public QueryMemoryTracker createQueryMemoryTracker(long maxQueryMemory) {\n+        assert maxQueryMemory >= 0;\n \n-        QueryMemoryTracker tracker = new QueryMemoryTracker(this, maxQryMemory, blockSize, offloadingEnabled);\n+        if (maxQueryMemory == 0)\n+            maxQueryMemory = dfltSqlQryMemoryLimit;\n \n-        if (log.isDebugEnabled())\n-            log.debug(\"Memory tracker created: \" + tracker);\n+        if (dfltSqlQryMemoryLimit < 0)\n+            return null;\n \n-        return tracker;\n-    }\n+        if (globalQuota > 0 && globalQuota < maxQueryMemory) {\n+            U.warn(log, \"Max query memory can't exceeds SQL memory pool size. Will be reduced down to: \" + globalQuota);\n \n-    /**\n-     * Action when quota is exceeded.\n-     * @return {@code false} if it is needed to offload data.\n-     */\n-    public boolean onQuotaExceeded(long size) {\n-        reserved.addAndGet(-size);\n-\n-        if (offloadingEnabled)\n-            return false;\n-        else {\n-            throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            maxQueryMemory = globalQuota;\n         }\n-    }\n-\n-    /**\n-     * Sets new global query quota.\n-     *\n-     * @param newGlobalQuota New global query quota.\n-     */\n-    public synchronized void setGlobalQuota(String newGlobalQuota) {\n-        long globalQuota0 = U.parseBytes(newGlobalQuota);\n-        long heapSize = Runtime.getRuntime().maxMemory();\n-\n-        A.ensure(\n-            heapSize > globalQuota0,\n-            \"Sql global memory quota can't be more than heap size: heapSize=\"\n-                + heapSize + \", quotaSize=\" + globalQuota0\n-        );\n \n-        A.ensure(globalQuota0 >= 0, \"Sql global memory quota must be >= 0: quotaSize=\" + globalQuota0);\n+        assert maxQueryMemory >= blockSize;\n \n-        globalQuota = globalQuota0;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query global quota was set to \" + globalQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n+        return new QueryMemoryTracker(globalQuota < 0 ? null : this, maxQueryMemory, blockSize);\n     }\n \n     /**\n-     * @return Current global query quota.\n-     */\n-    public String getGlobalQuota() {\n-        return String.valueOf(globalQuota);\n-    }\n-\n-    /**\n-     * Sets new per-query quota.\n+     * Gets memory reserved by running queries.\n      *\n-     * @param newQryQuota New per-query quota.\n+     * @return Reserved memory in bytes.\n      */\n-    public synchronized void setQueryQuota(String newQryQuota) {\n-        long qryQuota0 = U.parseBytes(newQryQuota);\n-\n-        A.ensure(qryQuota0 >= 0, \"Sql query memory quota must be >= 0: quotaSize=\" + qryQuota0);\n-\n-        qryQuota = U.parseBytes(newQryQuota);\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query memory quota was set to \" + qryQuota +  \". Current memory tracking parameters: \" +\n-                \"[qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + offloadingEnabled + ']');\n-        }\n-\n-        if (qryQuota > globalQuota) {\n-            log.warning(\"The local quota was set higher than global. The new value will be truncated \" +\n-                \"to the size of the global quota [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota);\n-        }\n-    }\n-\n-    /**\n-     * @return Current query quota.\n-     */\n-    public String getQueryQuotaString() {\n-        return String.valueOf(qryQuota);\n+    public long memoryReserved() {\n+        return reserved.get();\n     }\n \n     /**\n-     * Sets offloading enabled flag.\n+     * Gets global memory limit for queries.\n      *\n-     * @param offloadingEnabled Offloading enabled flag.\n-     */\n-    public synchronized void setOffloadingEnabled(boolean offloadingEnabled) {\n-        this.offloadingEnabled = offloadingEnabled;\n-\n-        if (log.isInfoEnabled()) {\n-            log.info(\"SQL query query offloading enabled flag was set to \" + offloadingEnabled +\n-                \". Current memory tracking parameters: [qryQuota=\" + qryQuota + \", globalQuota=\" + globalQuota +\n-                \", offloadingEnabled=\" + this.offloadingEnabled + ']');\n-        }\n-    }\n-\n-    /**\n-     * @return Flag whether offloading is enabled.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n-    }\n-\n-    /**\n-     * @return Bytes reserved by all queries.\n+     * @return Max memory in bytes.\n      */\n-    @Override public long reserved() {\n-        return reserved.get();\n-    }\n-\n-    /** */\n-    public long memoryLimit() {\n+    public long maxMemory() {\n         return globalQuota;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override public void spill(long size) {\n-        // NO-OP\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public void unspill(long size) {\n-        // NO-OP\n-    }\n-\n     /** {@inheritDoc} */\n     @Override public void close() {\n         // Cursors are not tracked and can't be forcibly closed to release resources.\n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 58ae9e20f92..727ed359f06 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -172,4 +179,29 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    private static class ReservationOp implements LongBinaryOperator {\n+        /** Operation result high bound.*/\n+        private final long limit;\n+\n+        /**\n+         * Constructor.\n+         * @param limit Operation result high bound.\n+         */\n+        ReservationOp(long limit) {\n+            this.limit = limit;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long applyAsLong(long prev, long x) {\n+            long res = prev + x;\n+\n+            if (res > limit)\n+                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+\n+            return res;\n+        }\n+    }\n }\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 727ed359f06..788602adfa6 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -179,29 +196,4 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n-\n-    /** */\n-    private static class ReservationOp implements LongBinaryOperator {\n-        /** Operation result high bound.*/\n-        private final long limit;\n-\n-        /**\n-         * Constructor.\n-         * @param limit Operation result high bound.\n-         */\n-        ReservationOp(long limit) {\n-            this.limit = limit;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public long applyAsLong(long prev, long x) {\n-            long res = prev + x;\n-\n-            if (res > limit)\n-                throw new IgniteSQLException(\"SQL query run out of memory: Global quota exceeded.\",\n-                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n-\n-            return res;\n-        }\n-    }\n }\n", "next_change": {"commit": "3c6a5cb36df055ae623a37e59044c99b862b1938", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 788602adfa6..750b2e3b12d 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -196,4 +297,196 @@ public class QueryMemoryManager extends H2MemoryTracker {\n         if (log.isDebugEnabled() && reserved.get() != 0)\n             log.debug(\"Potential memory leak in SQL processor. Some query cursors were not closed or forget to free memory.\");\n     }\n+\n+    /** */\n+    public IgniteLogger log() {\n+        return log;\n+    }\n+\n+    /**\n+     * Cleans spill directory. Spill directory is used for disk\n+     * offloading of the intermediate results of heavy queries.\n+     */\n+    public void cleanSpillDirectory() {\n+        try {\n+            File spillDir = U.resolveWorkDirectory(\n+                ctx.config().getWorkDirectory(),\n+                DISK_SPILL_DIR,\n+                false);\n+\n+            File[] spillFiles = spillDir.listFiles();\n+\n+            if (spillFiles.length == 0)\n+                return;\n+\n+            for (int i = 0; i < spillFiles.length; i++) {\n+                try {\n+                    File spillFile = spillFiles[i];\n+\n+                    String nodeId = spillFile.getName().split(\"_\")[1]; // Spill name pattern: spill_nodeId_fileId.\n+\n+                    UUID nodeUuid = UUID.fromString(nodeId);\n+\n+                    if (!ctx.discovery().alive(nodeUuid) || ctx.localNodeId().equals(nodeUuid))\n+                        spillFile.delete();\n+                }\n+                catch (Exception e) {\n+                    log.debug(\"Error on cleaning spill directory. \" + X.getFullStackTrace(e));\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.warning(\"Failed to cleanup the temporary directory for intermediate \" +\n+                \"SQL query results from the previous node run.\", e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public GroupByData newManagedGroupByData(Session ses, ArrayList<Expression> expressions,\n+        boolean isGrpQry, int[] grpIdx) {\n+\n+        boolean spillingEnabled = ctx.config().isSqlOffloadingEnabled();\n+\n+        if (!spillingEnabled)\n+            return null;\n+\n+        assert isGrpQry; // isGrpQry == false allowed only for window queries which are not supported yet.\n+\n+        return new H2ManagedGroupByData(ses, grpIdx);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @return Plain external result.\n+     */\n+    public ResultExternal createPlainExternalResult(Session ses) {\n+        return new PlainExternalResult(ses);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param distinct Distinct flag.\n+     * @param distinctIndexes Distinct indexes.\n+     * @param visibleColCnt Visible columns count.\n+     * @param sort Sort order.\n+     * @param rowCnt Row count.\n+     * @return Sorted external result.\n+     */\n+    public ResultExternal createSortedExternalResult(Session ses, boolean distinct, int[] distinctIndexes,\n+        int visibleColCnt, SortOrder sort, int rowCnt) {\n+        return new SortedExternalResult(ses, distinct, distinctIndexes, visibleColCnt, sort, rowCnt);\n+    }\n+\n+    /**\n+     * @param ses Session.\n+     * @param size Size;\n+     * @return Grouped result;\n+     */\n+    public GroupedExternalResult createGroupedExternalResult(Session ses, int size) {\n+        return new GroupedExternalResult(ses, size);\n+    }\n+\n+    /**\n+     * Creates external data (offload file wrapper).\n+     * @param ses Session.\n+     * @param useHashIdx Flag whether to use hash index.\n+     * @param initSize Initial size.\n+     * @param cls Class of stored values.\n+     * @param <T> Type of stored values.\n+     * @return Created external data (offload file wrapper).\n+     */\n+    public <T> ExternalResultData<T> createExternalData(Session ses, boolean useHashIdx, long initSize, Class<T> cls) {\n+        if (!ses.isOffloadedToDisk()) {\n+            ses.setOffloadedToDisk(true);\n+\n+            metrics.trackQueryOffloaded();\n+        }\n+\n+        return new ExternalResultData<>(log,\n+            ctx.config().getWorkDirectory(),\n+            fileIOFactory,\n+            ctx.localNodeId(),\n+            useHashIdx,\n+            initSize,\n+            cls,\n+            ses.getDatabase().getCompareMode(),\n+            ses.getDatabase());\n+    }\n+\n+    /**\n+     * FileIO decorator for stats collecting.\n+     */\n+    private static class TrackableFileIO extends FileIODecorator {\n+        /** */\n+        private final SqlMemoryStatisticsHolder metrics;\n+\n+        /**\n+         * @param delegate File I/O delegate\n+         */\n+        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n+            super(delegate);\n+\n+            this.metrics = metrics;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf) throws IOException {\n+            int bytesRead = delegate.read(destBuf);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n+            int bytesRead = delegate.read(destBuf, position);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int read(byte[] buf, int off, int len) throws IOException {\n+            int bytesRead = delegate.read(buf, off, len);\n+\n+            if (bytesRead > 0)\n+                metrics.trackOffloadingRead(bytesRead);\n+\n+            return bytesRead;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n+            int bytesWritten = delegate.write(srcBuf, position);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int write(byte[] buf, int off, int len) throws IOException {\n+            int bytesWritten = delegate.write(buf, off, len);\n+\n+            if (bytesWritten > 0)\n+                metrics.trackOffloadingWritten(bytesWritten);\n+\n+            return bytesWritten;\n+        }\n+    }\n }\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\nindex 750b2e3b12d..3768f833c89 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryManager.java\n", "chunk": "@@ -410,83 +456,7 @@ public class QueryMemoryManager implements H2MemoryTracker, ManagedGroupByDataFa\n             initSize,\n             cls,\n             ses.getDatabase().getCompareMode(),\n-            ses.getDatabase());\n-    }\n-\n-    /**\n-     * FileIO decorator for stats collecting.\n-     */\n-    private static class TrackableFileIO extends FileIODecorator {\n-        /** */\n-        private final SqlMemoryStatisticsHolder metrics;\n-\n-        /**\n-         * @param delegate File I/O delegate\n-         */\n-        private TrackableFileIO(FileIO delegate, SqlMemoryStatisticsHolder metrics) {\n-            super(delegate);\n-\n-            this.metrics = metrics;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf) throws IOException {\n-            int bytesRead = delegate.read(destBuf);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(ByteBuffer destBuf, long position) throws IOException {\n-            int bytesRead = delegate.read(destBuf, position);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int read(byte[] buf, int off, int len) throws IOException {\n-            int bytesRead = delegate.read(buf, off, len);\n-\n-            if (bytesRead > 0)\n-                metrics.trackOffloadingRead(bytesRead);\n-\n-            return bytesRead;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(ByteBuffer srcBuf, long position) throws IOException {\n-            int bytesWritten = delegate.write(srcBuf, position);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public int write(byte[] buf, int off, int len) throws IOException {\n-            int bytesWritten = delegate.write(buf, off, len);\n-\n-            if (bytesWritten > 0)\n-                metrics.trackOffloadingWritten(bytesWritten);\n-\n-            return bytesWritten;\n-        }\n+            ses.getDatabase(),\n+            ses.memoryTracker());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "5c7104415d67a2d06fa12b058c6ea8c5410c3393", "committedDate": "2019-07-24 20:42:20 +0300", "message": "GG-21813: SQL: Fix assert in MemoryManager.createMemoryTracker."}, {"oid": "e6adea02b6463c268d3c67bb973e9dbf754a8ff1", "committedDate": "2019-08-12 18:51:33 +0300", "message": "GG-20995: SQL: Metrics of using memory quotas."}, {"oid": "ee923b0183a2f8dc02b9e408f949c48be9c7366d", "committedDate": "2019-10-22 15:09:39 +0300", "message": "GG-24667: SQL: Disable memory quotas by default. This closes #604."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "3c6a5cb36df055ae623a37e59044c99b862b1938", "committedDate": "2020-02-18 17:25:37 +0300", "message": "GG-20997: Statistics for SQL disk offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "cb6c1b2a9be6ce52cdbb5cfbfb3c7b5e34fe53cd", "committedDate": "2020-03-05 12:27:31 +0300", "message": "GG-27922 Expose SQL memory quota in bytes for JMX"}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "9502a24df45ba7a97e2efa7d21476926e8250c66", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29130 [IGNITE-12953] Add support for SingleSpaceSeparator to the checkstyle (#7734)"}, {"oid": "f4f9676e82ec87f0977f387ad233f993e5c4cb28", "committedDate": "2020-08-18 18:12:18 -0400", "message": "GG-29772 (#1247)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "a8de46705cf54e56edefa158338a3a8ce3bc96e2", "committedDate": "2021-03-10 13:53:17 -0500", "message": "GG-32298 Create a JMX metric to show realtime sql engine memory utililization (#1726)"}, {"oid": "342366623db8d66053fb090ea2bee50826137670", "committedDate": "2021-05-28 10:18:58 -0400", "message": "GG-33258 correct log reporting of sqlOffloadingEnabled (#1943)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NDgxOQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392854819", "body": "What do you think about STATE_INITIAL and STATE_CLOSED names?", "bodyText": "What do you think about STATE_INITIAL and STATE_CLOSED names?", "bodyHTML": "<p dir=\"auto\">What do you think about STATE_INITIAL and STATE_CLOSED names?</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:35:48Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java", "diffHunk": "@@ -16,21 +16,33 @@\n \n package org.apache.ignite.internal.processors.query.h2;\n \n-import org.apache.ignite.IgniteLogger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n import org.apache.ignite.internal.processors.cache.query.IgniteQueryErrorCode;\n+import org.apache.ignite.internal.processors.query.GridQueryMemoryMetricProvider;\n import org.apache.ignite.internal.processors.query.IgniteSQLException;\n+import org.apache.ignite.internal.util.tostring.GridToStringExclude;\n import org.apache.ignite.internal.util.typedef.internal.S;\n \n /**\n  * Query memory tracker.\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker implements H2MemoryTracker {\n-    /** Logger. */\n-    private final IgniteLogger log;\n+public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetricProvider {\n+    /** State updater. */\n+    private static final AtomicIntegerFieldUpdater<QueryMemoryTracker> STATE_UPDATER\n+        = AtomicIntegerFieldUpdater.newUpdater(QueryMemoryTracker.class, \"state\");\n+\n+    /** Tracker is not closed and not in the middle of the closing process. */\n+    private static final int NORMALLY_OPERATING_STATE = 0;\n+\n+    /** Tracker is closed or in the middle of the closing process. */\n+    private static final int CLOSING_OR_CLOSED_STATE = 1;", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkwNTcyOQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392905729", "bodyText": "ok", "author": "korlov42", "createdAt": "2020-03-16T10:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NDgxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 459c4a15213..ff2d0f694bc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -36,10 +36,10 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n         = AtomicIntegerFieldUpdater.newUpdater(QueryMemoryTracker.class, \"state\");\n \n     /** Tracker is not closed and not in the middle of the closing process. */\n-    private static final int NORMALLY_OPERATING_STATE = 0;\n+    private static final int STATE_INITIAL = 0;\n \n     /** Tracker is closed or in the middle of the closing process. */\n-    private static final int CLOSING_OR_CLOSED_STATE = 1;\n+    private static final int STATE_CLOSED = 1;\n \n     /** Parent tracker. */\n     @GridToStringExclude\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 459c4a15213..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -36,10 +36,10 @@ public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetri\n         = AtomicIntegerFieldUpdater.newUpdater(QueryMemoryTracker.class, \"state\");\n \n     /** Tracker is not closed and not in the middle of the closing process. */\n-    private static final int NORMALLY_OPERATING_STATE = 0;\n+    private static final int STATE_INITIAL = 0;\n \n     /** Tracker is closed or in the middle of the closing process. */\n-    private static final int CLOSING_OR_CLOSED_STATE = 1;\n+    private static final int STATE_CLOSED = 1;\n \n     /** Parent tracker. */\n     @GridToStringExclude\n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ec42d6a6a50..d0ff5c223da 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -30,247 +27,124 @@ import org.apache.ignite.internal.util.typedef.internal.S;\n  *\n  * Track query memory usage and throws an exception if query tries to allocate memory over limit.\n  */\n-public class QueryMemoryTracker implements H2MemoryTracker, GridQueryMemoryMetricProvider {\n-    /** State updater. */\n-    private static final AtomicIntegerFieldUpdater<QueryMemoryTracker> STATE_UPDATER\n-        = AtomicIntegerFieldUpdater.newUpdater(QueryMemoryTracker.class, \"state\");\n+public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable {\n+    /** Resered field updater. */\n+    private static final AtomicLongFieldUpdater<QueryMemoryTracker> RESERVED_UPD =\n+        AtomicLongFieldUpdater.newUpdater(QueryMemoryTracker.class, \"reserved\");\n \n-    /** Tracker is not closed and not in the middle of the closing process. */\n-    private static final int STATE_INITIAL = 0;\n-\n-    /** Tracker is closed or in the middle of the closing process. */\n-    private static final int STATE_CLOSED = 1;\n+    /** Closed flag updater. */\n+    private static final AtomicReferenceFieldUpdater<QueryMemoryTracker, Boolean> CLOSED_UPD =\n+        AtomicReferenceFieldUpdater.newUpdater(QueryMemoryTracker.class, Boolean.class, \"closed\");\n \n     /** Parent tracker. */\n-    @GridToStringExclude\n     private final H2MemoryTracker parent;\n \n     /** Query memory limit. */\n-    private final long quota;\n-\n-    /**\n-     * Defines an action that occurs when the memory limit is exceeded. Possible variants:\n-     * <ul>\n-     * <li>{@code false} - exception will be thrown.</li>\n-     * <li>{@code true} - intermediate query results will be spilled to the disk.</li>\n-     * </ul>\n-     */\n-    private final boolean offloadingEnabled;\n+    private final long maxMem;\n \n     /** Reservation block size. */\n     private final long blockSize;\n \n     /** Memory reserved on parent. */\n-    private long reservedFromParent;\n+    private volatile long reservedFromParent;\n \n     /** Memory reserved by query. */\n     private volatile long reserved;\n \n-    /** Maximum number of bytes reserved by query. */\n-    private volatile long maxReserved;\n-\n-    /** Number of bytes written on disk at the current moment. */\n-    private volatile long writtenOnDisk;\n-\n-    /** Maximum number of bytes written on disk at the same time. */\n-    private volatile long maxWrittenOnDisk;\n-\n-    /** Total number of bytes written on disk tracked by current tracker. */\n-    private volatile long totalWrittenOnDisk;\n-\n     /** Close flag to prevent tracker reuse. */\n-    private volatile boolean closed;\n-\n-    /** State of the tracker. Can be equal {@link #STATE_INITIAL} or {@link #STATE_CLOSED}*/\n-    private volatile int state;\n-\n-    /** Children. */\n-    private final List<H2MemoryTracker> children = new ArrayList<>();\n-\n-    /** The number of files created by the query. */\n-    private volatile int filesCreated;\n+    private volatile Boolean closed = Boolean.FALSE;\n \n     /**\n      * Constructor.\n      *\n      * @param parent Parent memory tracker.\n-     * @param quota Query memory limit in bytes.\n+     * @param maxMem Query memory limit in bytes.\n      * @param blockSize Reservation block size.\n-     * @param offloadingEnabled Flag whether to fail when memory limit is exceeded.\n-     */\n-    public QueryMemoryTracker(\n-        H2MemoryTracker parent,\n-        long quota,\n-        long blockSize,\n-        boolean offloadingEnabled\n-    ) {\n-        assert quota >= 0;\n-\n-        this.offloadingEnabled = offloadingEnabled;\n-        this.parent = parent;\n-        this.quota = quota;\n-        this.blockSize = quota != 0 ? Math.min(quota, blockSize) : blockSize;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public synchronized boolean reserve(long size) {\n-        assert size >= 0;\n-\n-        checkClosed();\n-\n-        reserved += size;\n-        maxReserved = Math.max(maxReserved, reserved);\n-\n-        if (parent != null && reserved > reservedFromParent) {\n-            if (!reserveFromParent())\n-                return false; // Offloading.\n-        }\n-\n-        if (quota > 0 && reserved >= quota)\n-            return onQuotaExceeded();\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Checks whether tracker was closed.\n-     */\n-    private void checkClosed() {\n-        if (closed)\n-            throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n-    }\n-\n-    /**\n-     * Reserves memory from parent tracker.\n-     * @return {@code false} if offloading is needed.\n      */\n-    private boolean reserveFromParent() {\n-        // If single block size is too small.\n-        long blockSize = Math.max(reserved - reservedFromParent, this.blockSize);\n-\n-        // If we are too close to limit.\n-        if (quota > 0)\n-            blockSize = Math.min(blockSize, quota - reservedFromParent);\n-\n-        if (parent.reserve(blockSize))\n-            reservedFromParent += blockSize;\n-        else\n-            return false;\n+    QueryMemoryTracker(H2MemoryTracker parent, long maxMem, long blockSize) {\n+        assert maxMem > 0;\n \n-        return true;\n-    }\n-\n-    /**\n-     * Action on quota exceeded.\n-     * @return {@code false} if offloading is needed.\n-     */\n-    private boolean onQuotaExceeded() {\n-        if (offloadingEnabled)\n-            return false;\n-        else\n-            throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n-                IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+        this.parent = parent;\n+        this.maxMem = maxMem;\n+        this.blockSize = blockSize;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void release(long size) {\n-        assert size >= 0;\n+    @Override public void reserve(long size) {\n+        assert !closed && size >= 0;\n \n         if (size == 0)\n             return;\n \n-        checkClosed();\n-\n-        reserved -= size;\n-\n-        assert reserved >= 0 : \"Try to free more memory that ever be reserved: [reserved=\" + (reserved + size) +\n-            \", toFree=\" + size + ']';\n-\n-        if (parent != null && reservedFromParent - reserved > blockSize)\n-            releaseFromParent();\n-    }\n-\n-    /**\n-     * Releases memory from parent.\n-     */\n-    private void releaseFromParent() {\n-        long toReleaseFromParent = reservedFromParent - reserved;\n-\n-        parent.release(toReleaseFromParent);\n+        long reserved0 = RESERVED_UPD.accumulateAndGet(this, size, (prev, x) -> {\n+            if (prev + x > maxMem) {\n+                throw new IgniteSQLException(\"SQL query run out of memory: Query quota exceeded.\",\n+                    IgniteQueryErrorCode.QUERY_OUT_OF_MEMORY);\n+            }\n \n-        reservedFromParent -= toReleaseFromParent;\n+            return prev + x;\n+        });\n \n-        assert reservedFromParent >= 0 : reservedFromParent;\n-    }\n+        if (parent != null && reserved0 > reservedFromParent) {\n+            synchronized (this) {\n+                assert !closed;\n \n-    /** {@inheritDoc} */\n-    @Override public long reserved() {\n-        return reserved;\n-    }\n+                if (reserved0 <= reservedFromParent)\n+                    return;\n \n-    /** {@inheritDoc} */\n-    @Override public long maxReserved() {\n-        return maxReserved;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override public long writtenOnDisk() {\n-        return writtenOnDisk;\n-    }\n+                // If single block size is too small.\n+                long blockSize = Math.max(reserved0 - reservedFromParent, this.blockSize);\n+                // If we are too close to limit.\n+                blockSize = Math.min(blockSize, maxMem - reservedFromParent);\n \n-    /** {@inheritDoc} */\n-    @Override public long maxWrittenOnDisk() {\n-        return maxWrittenOnDisk;\n-    }\n+                try {\n+                    parent.reserve(blockSize);\n \n-    /** {@inheritDoc} */\n-    @Override public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n-    }\n+                    reservedFromParent += blockSize;\n+                }\n+                catch (Throwable e) {\n+                    // Fallback if failed to reserve.\n+                    RESERVED_UPD.addAndGet(this, -size);\n \n-    /**\n-     * @return Offloading enabled flag.\n-     */\n-    public boolean isOffloadingEnabled() {\n-        return offloadingEnabled;\n+                    throw e;\n+                }\n+            }\n+        }\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void spill(long size) {\n+    @Override public void release(long size) {\n         assert size >= 0;\n \n         if (size == 0)\n             return;\n \n-        checkClosed();\n+        long reserved = RESERVED_UPD.accumulateAndGet(this, -size, (prev, x) -> {\n+            if (prev + x < 0)\n+                throw new IllegalStateException(\"Try to release more memory that were reserved: [\" +\n+                    \"reserved=\" + prev + \", toRelease=\" + x + ']');\n \n-        if (parent != null)\n-            parent.spill(size);\n+            return prev + x;\n+        });\n \n-        writtenOnDisk += size;\n-        totalWrittenOnDisk += size;\n-        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n-    }\n+        assert !closed && reserved >= 0 || reserved == 0 : \"Invalid reserved memory size:\" + reserved;\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void unspill(long size) {\n-        assert size >= 0;\n+        // For now, won'tQ release memory to parent until tracker closed.\n+       /* if (parent != null && preAllocated - reserved >= 2 * blockSize) {\n+            synchronized (this) {\n+                if (preAllocated - reserved >= 2 * blockSize) {\n+                    parent.release(blockSize);\n \n-        if (size == 0)\n-            return;\n-\n-        checkClosed();\n-\n-        if (parent != null)\n-            parent.unspill(size);\n-\n-        writtenOnDisk -= size;\n+                    preAllocated -= blockSize;\n+                }\n+            }\n+        }*/\n     }\n \n     /**\n-     * @return {@code true} if closed, {@code false} otherwise.\n+     * @return {@code True} if closed, {@code False} otherwise.\n      */\n-    @Override public boolean closed() {\n+    public boolean closed() {\n         return closed;\n     }\n \n", "next_change": {"commit": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex d0ff5c223da..ea3193007a5 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -152,8 +152,13 @@ public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable\n     @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (CLOSED_UPD.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\n-            release(RESERVED_UPD.get(this));\n+        synchronized (this) {\n+            if (closed)\n+                return;\n+\n+            closed = true;\n+\n+            release0(reserved);\n \n             if (parent != null)\n                 parent.release(reservedFromParent);\n", "next_change": {"commit": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex ea3193007a5..557040604bd 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -158,10 +168,10 @@ public class QueryMemoryTracker extends H2MemoryTracker implements AutoCloseable\n \n             closed = true;\n \n-            release0(reserved);\n+            reserved = 0;\n \n             if (parent != null)\n-                parent.release(reservedFromParent);\n+                parent.released(reservedFromParent);\n         }\n     }\n \n", "next_change": {"commit": "ed30d3c44e4c1d6461f1973432e15ae383179398", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 557040604bd..6c365d5b9ad 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -159,20 +178,18 @@ public class QueryMemoryTracker extends H2MemoryTracker {\n     }\n \n     /** {@inheritDoc} */\n-    @Override public void close() {\n+    @Override public synchronized void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        synchronized (this) {\n-            if (closed)\n-                return;\n+        if (closed)\n+            return;\n \n-            closed = true;\n+        closed = true;\n \n-            reserved = 0;\n+        reserved = 0;\n \n-            if (parent != null)\n-                parent.released(reservedFromParent);\n-        }\n+        if (parent != null)\n+            parent.released(reservedFromParent);\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 6c365d5b9ad..436af0792fc 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -190,6 +223,50 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n \n         if (parent != null)\n             parent.released(reservedFromParent);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n+                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n+                \", query=\" + qryDesc + ']');\n+        }\n+    }\n+\n+    /**\n+     * @return Total number of bytes written on disk.\n+     */\n+    public long totalWrittenOnDisk() {\n+        return totalWrittenOnDisk;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n+        this.totalWrittenOnDisk += written;\n+    }\n+\n+    /**\n+     * @return Total bytes reserved by current query.\n+     */\n+    public long totalReserved() {\n+        return totalReserved;\n+    }\n+\n+    /**\n+     * @return Total files number created by current query.\n+     */\n+    public int filesCreated() {\n+        return filesCreated;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        this.filesCreated++;\n+    }\n+\n+    /**\n+     * @return Query descriptor.\n+     */\n+    public String queryDescriptor() {\n+        return qryDesc;\n     }\n \n     /** {@inheritDoc} */\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\nindex 436af0792fc..ec42d6a6a50 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/QueryMemoryTracker.java\n", "chunk": "@@ -203,74 +235,235 @@ public class QueryMemoryTracker implements H2MemoryTracker {\n         return offloadingEnabled;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override public synchronized void spill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.spill(size);\n+\n+        writtenOnDisk += size;\n+        totalWrittenOnDisk += size;\n+        maxWrittenOnDisk = Math.max(maxWrittenOnDisk, writtenOnDisk);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public synchronized void unspill(long size) {\n+        assert size >= 0;\n+\n+        if (size == 0)\n+            return;\n+\n+        checkClosed();\n+\n+        if (parent != null)\n+            parent.unspill(size);\n+\n+        writtenOnDisk -= size;\n+    }\n+\n     /**\n-     * @return {@code True} if closed, {@code False} otherwise.\n+     * @return {@code true} if closed, {@code false} otherwise.\n      */\n-    public synchronized boolean closed() {\n+    @Override public boolean closed() {\n         return closed;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void close() {\n+    @Override public void close() {\n         // It is not expected to be called concurrently with reserve\\release.\n         // But query can be cancelled concurrently on query finish.\n-        if (closed)\n+        if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n             return;\n \n+        synchronized (this) {\n+            for (H2MemoryTracker child : children)\n+                child.close();\n+\n+            children.clear();\n+        }\n+\n         closed = true;\n \n         reserved = 0;\n \n         if (parent != null)\n-            parent.released(reservedFromParent);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Query has been completed with memory metrics: [bytesConsumed=\"  + totalReserved +\n-                \", bytesOffloaded=\" + totalWrittenOnDisk + \", filesCreated=\" + filesCreated +\n-                \", query=\" + qryDesc + ']');\n-        }\n+            parent.release(reservedFromParent);\n     }\n \n-    /**\n-     * @return Total number of bytes written on disk.\n-     */\n-    public long totalWrittenOnDisk() {\n-        return totalWrittenOnDisk;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void incrementFilesCreated() {\n+        if (parent != null)\n+            parent.incrementFilesCreated();\n+\n+        filesCreated++;\n     }\n \n     /** {@inheritDoc} */\n-    @Override public synchronized void addTotalWrittenOnDisk(long written) {\n-        this.totalWrittenOnDisk += written;\n-    }\n+    @Override public synchronized H2MemoryTracker createChildTracker() {\n+        checkClosed();\n \n-    /**\n-     * @return Total bytes reserved by current query.\n-     */\n-    public long totalReserved() {\n-        return totalReserved;\n-    }\n+        H2MemoryTracker child = new ChildMemoryTracker(this);\n \n-    /**\n-     * @return Total files number created by current query.\n-     */\n-    public int filesCreated() {\n-        return filesCreated;\n-    }\n+        children.add(child);\n \n-    /** {@inheritDoc} */\n-    @Override public synchronized void incrementFilesCreated() {\n-        this.filesCreated++;\n+        return child;\n     }\n \n-    /**\n-     * @return Query descriptor.\n-     */\n-    public String queryDescriptor() {\n-        return qryDesc;\n+    /** {@inheritDoc} */\n+    @Override public synchronized void onChildClosed(H2MemoryTracker child) {\n+        if (state != STATE_CLOSED)\n+            children.remove(child);\n     }\n \n     /** {@inheritDoc} */\n     @Override public String toString() {\n         return S.toString(QueryMemoryTracker.class, this);\n     }\n-}\n\\ No newline at end of file\n+\n+    /** */\n+    private static class ChildMemoryTracker implements H2MemoryTracker {\n+        /** State updater. */\n+        private static final AtomicIntegerFieldUpdater<ChildMemoryTracker> STATE_UPDATER\n+            = AtomicIntegerFieldUpdater.newUpdater(ChildMemoryTracker.class, \"state\");\n+\n+        /** */\n+        private final H2MemoryTracker parent;\n+\n+        /** */\n+        private long reserved;\n+\n+        /** */\n+        private long writtenOnDisk;\n+\n+        /** */\n+        private long totalWrittenOnDisk;\n+\n+        /** */\n+        private volatile int state;\n+\n+        /**\n+         * @param parent Parent.\n+         */\n+        public ChildMemoryTracker(H2MemoryTracker parent) {\n+            this.parent = parent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean reserve(long size) {\n+            checkClosed();\n+\n+            boolean res;\n+            try {\n+                res = parent.reserve(size);\n+            }\n+            finally {\n+                reserved += size;\n+            }\n+\n+            return res;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void release(long size) {\n+            checkClosed();\n+\n+            reserved -= size;\n+\n+            parent.release(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long writtenOnDisk() {\n+            return writtenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long totalWrittenOnDisk() {\n+            return totalWrittenOnDisk;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public long reserved() {\n+            return reserved;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void spill(long size) {\n+            checkClosed();\n+\n+            parent.spill(size);\n+\n+            writtenOnDisk += size;\n+            totalWrittenOnDisk += size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void unspill(long size) {\n+            checkClosed();\n+\n+            parent.unspill(size);\n+\n+            writtenOnDisk -= size;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void incrementFilesCreated() {\n+            checkClosed();\n+\n+            parent.incrementFilesCreated();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public H2MemoryTracker createChildTracker() {\n+            checkClosed();\n+\n+            return parent.createChildTracker();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onChildClosed(H2MemoryTracker child) {\n+            parent.onChildClosed(child);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean closed() {\n+            return state == STATE_CLOSED;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() {\n+            if (!STATE_UPDATER.compareAndSet(this, STATE_INITIAL, STATE_CLOSED))\n+                return;\n+\n+            parent.release(reserved);\n+            parent.unspill(writtenOnDisk);\n+\n+            reserved = 0;\n+            writtenOnDisk = 0;\n+\n+            parent.onChildClosed(this);\n+        }\n+\n+        /** */\n+        private void checkClosed() {\n+            if (state == STATE_CLOSED)\n+                throw new TrackerWasClosedException(\"Memory tracker has been closed concurrently.\");\n+        }\n+    }\n+\n+    /** Exception thrown when try to track memory with closed tracker. */\n+    public static class TrackerWasClosedException extends RuntimeException {\n+        /**\n+         * @param msg Message.\n+         */\n+        public TrackerWasClosedException(String msg) {\n+            super(msg);\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NTg4MA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392855880", "body": "Missed loop braces", "bodyText": "Missed loop braces", "bodyHTML": "<p dir=\"auto\">Missed loop braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:37:37Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java", "diffHunk": "@@ -171,6 +170,10 @@ public static Collection parameters() {\n             \"UNION ALL \" +\n             \"SELECT 31, 24, 'TWO-FOUR'\");\n \n+        for (H2ManagedLocalResult res : localResults)", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex 20d12320913..f221928fe97 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -170,9 +170,10 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n             \"UNION ALL \" +\n             \"SELECT 31, 24, 'TWO-FOUR'\");\n \n-        for (H2ManagedLocalResult res : localResults)\n+        for (H2ManagedLocalResult res : localResults) {\n             if (res.memoryTracker() != null)\n                 res.memoryTracker().close();\n+        }\n \n         localResults.clear();\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex 20d12320913..f221928fe97 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -170,9 +170,10 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n             \"UNION ALL \" +\n             \"SELECT 31, 24, 'TWO-FOUR'\");\n \n-        for (H2ManagedLocalResult res : localResults)\n+        for (H2ManagedLocalResult res : localResults) {\n             if (res.memoryTracker() != null)\n                 res.memoryTracker().close();\n+        }\n \n         localResults.clear();\n     }\n", "next_change": {"commit": "19ed2fc1abf3a6fab8ad008bca0cbf1ea585e83c", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex f221928fe97..d0d95381e70 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -170,11 +171,6 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n             \"UNION ALL \" +\n             \"SELECT 31, 24, 'TWO-FOUR'\");\n \n-        for (H2ManagedLocalResult res : localResults) {\n-            if (res.memoryTracker() != null)\n-                res.memoryTracker().close();\n-        }\n-\n         localResults.clear();\n     }\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex d0d95381e70..73f00bae971 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -171,6 +170,11 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n             \"UNION ALL \" +\n             \"SELECT 31, 24, 'TWO-FOUR'\");\n \n+        for (H2ManagedLocalResult res : localResults) {\n+            if (res.memoryTracker() != null)\n+                res.memoryTracker().close();\n+        }\n+\n         localResults.clear();\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "19ed2fc1abf3a6fab8ad008bca0cbf1ea585e83c", "committedDate": "2020-02-27 14:57:10 +0300", "message": "GG-20968: propagate lazy flag to synthetic SELECT used by first step of DML queries"}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "3d8cb9bd848a177878e467913e7bb9eade28ccdd", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29132 [IGNITE-12948] Add support for NoWhitespaceBefore to the checkstyle"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NjA5OQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392856099", "body": "Missed loop braces", "bodyText": "Missed loop braces", "bodyHTML": "<p dir=\"auto\">Missed loop braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:38:03Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java", "diffHunk": "@@ -208,6 +211,10 @@ else if (cacheMode == CacheMode.REPLICATED)\n \n         }\n         finally {\n+            for (H2ManagedLocalResult res : localResults)", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex 20d12320913..f221928fe97 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -211,9 +212,10 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n \n         }\n         finally {\n-            for (H2ManagedLocalResult res : localResults)\n+            for (H2ManagedLocalResult res : localResults) {\n                 if (res.memoryTracker() != null)\n                     res.memoryTracker().close();\n+            }\n \n             localResults.clear();\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex 20d12320913..f221928fe97 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -211,9 +212,10 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n \n         }\n         finally {\n-            for (H2ManagedLocalResult res : localResults)\n+            for (H2ManagedLocalResult res : localResults) {\n                 if (res.memoryTracker() != null)\n                     res.memoryTracker().close();\n+            }\n \n             localResults.clear();\n         }\n", "next_change": {"commit": "19ed2fc1abf3a6fab8ad008bca0cbf1ea585e83c", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex f221928fe97..d0d95381e70 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -212,11 +208,6 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n \n         }\n         finally {\n-            for (H2ManagedLocalResult res : localResults) {\n-                if (res.memoryTracker() != null)\n-                    res.memoryTracker().close();\n-            }\n-\n             localResults.clear();\n         }\n     }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\nindex d0d95381e70..73f00bae971 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/LazyOnDmlTest.java\n", "chunk": "@@ -208,6 +212,11 @@ public class LazyOnDmlTest extends AbstractIndexingCommonTest {\n \n         }\n         finally {\n+            for (H2ManagedLocalResult res : localResults) {\n+                if (res.memoryTracker() != null)\n+                    res.memoryTracker().close();\n+            }\n+\n             localResults.clear();\n         }\n     }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "19ed2fc1abf3a6fab8ad008bca0cbf1ea585e83c", "committedDate": "2020-02-27 14:57:10 +0300", "message": "GG-20968: propagate lazy flag to synthetic SELECT used by first step of DML queries"}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "3d8cb9bd848a177878e467913e7bb9eade28ccdd", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29132 [IGNITE-12948] Add support for NoWhitespaceBefore to the checkstyle"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1Njc4MQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392856781", "body": "Braces", "bodyText": "Braces", "bodyHTML": "<p dir=\"auto\">Braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:39:27Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java", "diffHunk": "@@ -103,6 +103,10 @@\n         maxMem = MB;\n         useJdbcV2GlobalQuotaCfg = false;\n \n+        for (H2ManagedLocalResult res : localResults)", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex 28de4158807..bb2a082b070 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -103,9 +103,10 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n         maxMem = MB;\n         useJdbcV2GlobalQuotaCfg = false;\n \n-        for (H2ManagedLocalResult res : localResults)\n+        for (H2ManagedLocalResult res : localResults) {\n             if (res.memoryTracker() != null)\n                 res.memoryTracker().close();\n+        }\n \n         localResults.clear();\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex 28de4158807..bb2a082b070 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -103,9 +103,10 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n         maxMem = MB;\n         useJdbcV2GlobalQuotaCfg = false;\n \n-        for (H2ManagedLocalResult res : localResults)\n+        for (H2ManagedLocalResult res : localResults) {\n             if (res.memoryTracker() != null)\n                 res.memoryTracker().close();\n+        }\n \n         localResults.clear();\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex bb2a082b070..c77ed15ffc1 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -101,12 +104,6 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n         super.beforeTest();\n \n         maxMem = MB;\n-        useJdbcV2GlobalQuotaCfg = false;\n-\n-        for (H2ManagedLocalResult res : localResults) {\n-            if (res.memoryTracker() != null)\n-                res.memoryTracker().close();\n-        }\n \n         localResults.clear();\n \n", "next_change": {"commit": "ed30d3c44e4c1d6461f1973432e15ae383179398", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex c77ed15ffc1..ba25af42f47 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -104,6 +101,7 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n         super.beforeTest();\n \n         maxMem = MB;\n+        useJdbcV2GlobalQuotaCfg = false;\n \n         localResults.clear();\n \n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex ba25af42f47..bb2a082b070 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -103,6 +103,11 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n         maxMem = MB;\n         useJdbcV2GlobalQuotaCfg = false;\n \n+        for (H2ManagedLocalResult res : localResults) {\n+            if (res.memoryTracker() != null)\n+                res.memoryTracker().close();\n+        }\n+\n         localResults.clear();\n \n         resetMemoryManagerState(grid(0));\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "71b775cdf86a15ed0b8da7e65bed60f175e19a55", "committedDate": "2019-10-30 16:09:15 +0300", "message": "GG-19120 ConnectionManager refactoring"}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "a83651b3a95dc9da9770699af6782fc9f439bc07", "committedDate": "2020-02-17 15:00:05 +0300", "message": "GG-27260 Disable by default configuration memory quota through jdbc thin connection string"}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "4bdd95f670e3b37e41d5d4efdfffe4226c884623", "committedDate": "2020-06-04 16:49:35 +0300", "message": "GG-28564 Performance drop 8.7.15 vs 8.7.13"}, {"oid": "4a0e2d3d72047117d6a0835cbde5864352591bc9", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29128 [IGNITE-12959] Add support for GenericWhitespace to checkstyle rules (#7749)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NjgyNw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r392856827", "body": "braces", "bodyText": "braces", "bodyHTML": "<p dir=\"auto\">braces</p>", "author": "AMashenkov", "createdAt": "2020-03-16T08:39:35Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java", "diffHunk": "@@ -113,6 +117,10 @@\n \n     /** {@inheritDoc} */\n     @Override protected void afterTest() throws Exception {\n+        for (H2ManagedLocalResult res : localResults)", "originalCommit": "f3ec1944c5474ba57bb783aebf7ca7cb89bffa6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex 28de4158807..bb2a082b070 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -117,9 +118,10 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n \n     /** {@inheritDoc} */\n     @Override protected void afterTest() throws Exception {\n-        for (H2ManagedLocalResult res : localResults)\n+        for (H2ManagedLocalResult res : localResults) {\n             if (res.memoryTracker() != null)\n                 res.memoryTracker().close();\n+        }\n \n         checkMemoryManagerState(grid(0));\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex 28de4158807..bb2a082b070 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -117,9 +118,10 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n \n     /** {@inheritDoc} */\n     @Override protected void afterTest() throws Exception {\n-        for (H2ManagedLocalResult res : localResults)\n+        for (H2ManagedLocalResult res : localResults) {\n             if (res.memoryTracker() != null)\n                 res.memoryTracker().close();\n+        }\n \n         checkMemoryManagerState(grid(0));\n \n", "next_change": {"commit": "ca573c54f6778297d8880cad2681b5af54224ee1", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex bb2a082b070..c77ed15ffc1 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -118,11 +115,6 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n \n     /** {@inheritDoc} */\n     @Override protected void afterTest() throws Exception {\n-        for (H2ManagedLocalResult res : localResults) {\n-            if (res.memoryTracker() != null)\n-                res.memoryTracker().close();\n-        }\n-\n         checkMemoryManagerState(grid(0));\n \n         if (startClient())\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\nindex c77ed15ffc1..bb2a082b070 100644\n--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/oom/AbstractQueryMemoryTrackerSelfTest.java\n", "chunk": "@@ -115,6 +118,11 @@ public abstract class AbstractQueryMemoryTrackerSelfTest extends GridCommonAbstr\n \n     /** {@inheritDoc} */\n     @Override protected void afterTest() throws Exception {\n+        for (H2ManagedLocalResult res : localResults) {\n+            if (res.memoryTracker() != null)\n+                res.memoryTracker().close();\n+        }\n+\n         checkMemoryManagerState(grid(0));\n \n         if (startClient())\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "ca573c54f6778297d8880cad2681b5af54224ee1", "committedDate": "2019-07-18 12:47:13 +0300", "message": "GG-18828: SQL: Implementation of memory quotas for SQL queries."}, {"oid": "b2235bd240e1bbedc25fd1d97d0b17a0855f1a13", "committedDate": "2019-07-18 12:47:14 +0300", "message": "GG-20750: SQL: Fix performance drop with enabling global SQL memory quota."}, {"oid": "71b775cdf86a15ed0b8da7e65bed60f175e19a55", "committedDate": "2019-10-30 16:09:15 +0300", "message": "GG-19120 ConnectionManager refactoring"}, {"oid": "b03f13c520dd24702d290fbaccd37c6571cebb3a", "committedDate": "2020-01-17 13:22:19 +0300", "message": "GG-19186: Disk offloading for intermediate query results (disk spilling)."}, {"oid": "a83651b3a95dc9da9770699af6782fc9f439bc07", "committedDate": "2020-02-17 15:00:05 +0300", "message": "GG-27260 Disable by default configuration memory quota through jdbc thin connection string"}, {"oid": "ed30d3c44e4c1d6461f1973432e15ae383179398", "committedDate": "2020-02-17 15:28:23 +0300", "message": "GG-26456: Configuration for SQL memory pool and offloading."}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}, {"oid": "a9e32f74e39dbe101b078800788c129444c0990e", "committedDate": "2020-04-20 11:39:00 +0300", "message": "GG-28463 Introduce separate SQL configuration"}, {"oid": "a95dcd7d81a0f4c9b730f2bdeea03e0b2089a5e7", "committedDate": "2020-04-20 19:31:41 +0300", "message": "GG-28610 SQL: Improve exception handling in the case when query quota is exceeded"}, {"oid": "4bdd95f670e3b37e41d5d4efdfffe4226c884623", "committedDate": "2020-06-04 16:49:35 +0300", "message": "GG-28564 Performance drop 8.7.15 vs 8.7.13"}, {"oid": "4a0e2d3d72047117d6a0835cbde5864352591bc9", "committedDate": "2020-06-07 19:52:04 +0300", "message": "GG-29128 [IGNITE-12959] Add support for GenericWhitespace to checkstyle rules (#7749)"}, {"oid": "49cb16088dc2b708e8b23e63028dd9f4074050e0", "committedDate": "2020-08-28 12:49:28 +0300", "message": "GG-29288 Move H2 module code into internal package."}, {"oid": "e9a7fffa83ea6ab25ba970e5d36b4d34fc31806c", "committedDate": "2023-01-10 13:31:24 +0300", "message": "GG-36023 Ignore attempts to track free memory after the tracker is closed (#2675)"}]}, {"oid": "563d4cd38a2c1d3709270fcb5df13c528a731e19", "url": "https://github.com/gridgain/gridgain/commit/563d4cd38a2c1d3709270fcb5df13c528a731e19", "message": "review fixes", "committedDate": "2020-03-16T11:15:25Z", "type": "forcePushed"}, {"oid": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "url": "https://github.com/gridgain/gridgain/commit/4fb2a479047fbab02d4414132d7d4cc574ffae23", "message": "review fixes", "committedDate": "2020-03-16T13:15:32Z", "type": "commit"}, {"oid": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "url": "https://github.com/gridgain/gridgain/commit/4fb2a479047fbab02d4414132d7d4cc574ffae23", "message": "review fixes", "committedDate": "2020-03-16T13:15:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNjI4NA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r393016284", "body": "Why do we count `unspill` bytes here, but not in `trackReads()`?", "bodyText": "Why do we count unspill bytes here, but not in trackReads()?", "bodyHTML": "<p dir=\"auto\">Why do we count <code>unspill</code> bytes here, but not in <code>trackReads()</code>?</p>", "author": "rkondakov", "createdAt": "2020-03-16T13:19:33Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java", "diffHunk": "@@ -149,7 +149,23 @@ private void trackWrites(int written) {\n                 metrics.trackOffloadingWritten(written);\n \n             if (tracker != null)\n-                tracker.addTotalWrittenOnDisk(written);\n+                tracker.spill(written);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void clear() throws IOException {\n+            super.clear();\n+\n+            tracker.unspill(tracker.writtenOnDisk());\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() throws IOException {\n+            super.close();\n+\n+            tracker.unspill(tracker.writtenOnDisk());", "originalCommit": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAyNjY1NQ==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r393026655", "bodyText": "because when you read some portion of data it still remains on disk.", "author": "korlov42", "createdAt": "2020-03-16T13:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNjI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NTE5Nw==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r393045197", "bodyText": "Ok, I think we need to come to the same understanding of the unspilling term. I've found the only one definition of this word:\n\nWe call the process of flushing a portion\nof the operator\u2019s state to disk spilling and we call the process of bringing back to main\nmemory data spilled to disk unspilling.\n\nI found your definition in the code:\n\nAmount of bytes deleted from disk.\n\nI'm not sure which one is more correct. What do you think?", "author": "rkondakov", "createdAt": "2020-03-16T14:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNjI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjQ2Mg==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r393076462", "bodyText": "as we have discussed verbally I file a ticket for introducing another metric\nhttps://ggsystems.atlassian.net/browse/GG-28137", "author": "korlov42", "createdAt": "2020-03-16T14:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNjI4NA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\nindex 6bbb0fea173..927c624f7d3 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n", "chunk": "@@ -149,23 +149,7 @@ public class TrackableFileIoFactory {\n                 metrics.trackOffloadingWritten(written);\n \n             if (tracker != null)\n-                tracker.spill(written);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void clear() throws IOException {\n-            super.clear();\n-\n-            tracker.unspill(tracker.writtenOnDisk());\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() throws IOException {\n-            super.close();\n-\n-            tracker.unspill(tracker.writtenOnDisk());\n-\n-            tracker.close();\n+                tracker.addTotalWrittenOnDisk(written);\n         }\n     }\n }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\nindex 927c624f7d3..6bbb0fea173 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n", "chunk": "@@ -149,7 +149,23 @@ public class TrackableFileIoFactory {\n                 metrics.trackOffloadingWritten(written);\n \n             if (tracker != null)\n-                tracker.addTotalWrittenOnDisk(written);\n+                tracker.spill(written);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void clear() throws IOException {\n+            super.clear();\n+\n+            tracker.unspill(tracker.writtenOnDisk());\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() throws IOException {\n+            super.close();\n+\n+            tracker.unspill(tracker.writtenOnDisk());\n+\n+            tracker.close();\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNjU3OA==", "url": "https://github.com/gridgain/gridgain/pull/939#discussion_r393016578", "body": "See question below", "bodyText": "See question below", "bodyHTML": "<p dir=\"auto\">See question below</p>", "author": "rkondakov", "createdAt": "2020-03-16T13:20:06Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java", "diffHunk": "@@ -149,7 +149,23 @@ private void trackWrites(int written) {\n                 metrics.trackOffloadingWritten(written);\n \n             if (tracker != null)\n-                tracker.addTotalWrittenOnDisk(written);\n+                tracker.spill(written);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void clear() throws IOException {\n+            super.clear();\n+\n+            tracker.unspill(tracker.writtenOnDisk());", "originalCommit": "4fb2a479047fbab02d4414132d7d4cc574ffae23", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\nindex 6bbb0fea173..927c624f7d3 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n", "chunk": "@@ -149,23 +149,7 @@ public class TrackableFileIoFactory {\n                 metrics.trackOffloadingWritten(written);\n \n             if (tracker != null)\n-                tracker.spill(written);\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void clear() throws IOException {\n-            super.clear();\n-\n-            tracker.unspill(tracker.writtenOnDisk());\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override public void close() throws IOException {\n-            super.close();\n-\n-            tracker.unspill(tracker.writtenOnDisk());\n-\n-            tracker.close();\n+                tracker.addTotalWrittenOnDisk(written);\n         }\n     }\n }\n", "next_change": {"commit": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "changed_code": [{"header": "diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\nindex 927c624f7d3..6bbb0fea173 100644\n--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/disk/TrackableFileIoFactory.java\n", "chunk": "@@ -149,7 +149,23 @@ public class TrackableFileIoFactory {\n                 metrics.trackOffloadingWritten(written);\n \n             if (tracker != null)\n-                tracker.addTotalWrittenOnDisk(written);\n+                tracker.spill(written);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void clear() throws IOException {\n+            super.clear();\n+\n+            tracker.unspill(tracker.writtenOnDisk());\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void close() throws IOException {\n+            super.close();\n+\n+            tracker.unspill(tracker.writtenOnDisk());\n+\n+            tracker.close();\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "58aaab5d7ab3056fff642d2a0c2371dedf85d500", "message": "Merge commit", "committedDate": null}, {"oid": "72b32f6835fac8fef5f3d263c8c3f82c4d9cbf61", "committedDate": "2020-02-28 11:43:29 +0300", "message": "GG-27202 Improved logging for SQL memory quotas and offloading."}, {"oid": "0c0a1f5d03b7cab3062901aff42baa4b12b24fa7", "committedDate": "2020-03-24 16:49:40 +0300", "message": "GG-26598 Expose per query memory usage"}]}, {"oid": "11b374fd4e40c1669174d97da6cb4a599a52ea29", "url": "https://github.com/gridgain/gridgain/commit/11b374fd4e40c1669174d97da6cb4a599a52ea29", "message": "Merge branch 'master' into gg-26598", "committedDate": "2020-03-16T13:37:05Z", "type": "commit"}]}