{"pr_number": 1246, "pr_title": "GG-27999", "pr_author": "sanpwc", "pr_createdAt": "2020-06-17T10:44:35Z", "pr_url": "https://github.com/gridgain/gridgain/pull/1246", "merge_commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "timeline": [{"oid": "c8288b39039e484aa14581f519f05bc203d7f320", "url": "https://github.com/gridgain/gridgain/commit/c8288b39039e484aa14581f519f05bc203d7f320", "message": "GG-27999 Handling primary node left for transaction with syncMode != FULL_SYNC", "committedDate": "2020-06-15T19:14:43Z", "type": "commit"}, {"oid": "353a2cc4630ee6aa84ec896aa9ff520ff0714b76", "url": "https://github.com/gridgain/gridgain/commit/353a2cc4630ee6aa84ec896aa9ff520ff0714b76", "message": "GG-27999 Added tests", "committedDate": "2020-06-17T09:46:36Z", "type": "commit"}, {"oid": "8d32ad5f99cb3ed9707771d522c3465b7269af61", "url": "https://github.com/gridgain/gridgain/commit/8d32ad5f99cb3ed9707771d522c3465b7269af61", "message": "GG-27999 fix after review", "committedDate": "2020-06-17T18:25:50Z", "type": "commit"}, {"oid": "4d15294342e3efec8ae0c8cbd2e9cc1248a450f5", "url": "https://github.com/gridgain/gridgain/commit/4d15294342e3efec8ae0c8cbd2e9cc1248a450f5", "message": "GG-27999 fix checkstyle and licenses", "committedDate": "2020-06-18T07:25:19Z", "type": "commit"}, {"oid": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "url": "https://github.com/gridgain/gridgain/commit/1a77d1943d949f9f00d2e114b5cfca30f12f5949", "message": "Merge branch 'master' into gg-27999", "committedDate": "2020-06-18T08:40:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3Mjc2Mw==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442672763", "body": "What's the point in testing full sync mode with zero backups ?", "bodyText": "What's the point in testing full sync mode with zero backups ?", "bodyHTML": "<p dir=\"auto\">What's the point in testing full sync mode with zero backups ?</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:16:52Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;\n+\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        SpecialSpi spi = new SpecialSpi();\n+\n+        cfg.setCommunicationSpi(spi);\n+\n+        if (igniteInstanceName.contains(\"0\"))\n+            spi0 = spi;\n+\n+        if (igniteInstanceName.contains(\"1\"))\n+            spi1 = spi;\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1Mjc5NA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446852794", "bodyText": "Because it is possible to set FULL_SYNC with zero backups. The fix has code for this case.", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3Mjc2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -97,27 +90,9 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n         stopAllGrids();\n     }\n \n-    /**\n-     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n-     * @throws Exception\n-     */\n-    @Test\n-    public void testNodeFailWithPrimarySync() throws Exception {\n-        testNodeFail(PRIMARY_SYNC);\n-    }\n-\n-    /**\n-     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n-     * @throws Exception\n-     */\n-    @Test\n-    public void testNodeFailWithFullSync() throws Exception {\n-        testNodeFail(FULL_SYNC);\n-    }\n-\n     /**\n      * <ul>\n-     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start 2 nodes with transactional cache, without backups, with {@link IgniteTxExceptionNodeFailTest#syncMode}\n      * <li>Start transaction:\n      *  <ul>\n      *  <li>put a key to a partition on transaction coordinator\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -97,27 +91,9 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n         stopAllGrids();\n     }\n \n-    /**\n-     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n-     * @throws Exception\n-     */\n-    @Test\n-    public void testNodeFailWithPrimarySync() throws Exception {\n-        testNodeFail(PRIMARY_SYNC);\n-    }\n-\n-    /**\n-     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n-     * @throws Exception\n-     */\n-    @Test\n-    public void testNodeFailWithFullSync() throws Exception {\n-        testNodeFail(FULL_SYNC);\n-    }\n-\n     /**\n      * <ul>\n-     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start 2 nodes with transactional cache, without backups, with {@link IgniteTxExceptionNodeFailTest#syncMode}\n      * <li>Start transaction:\n      *  <ul>\n      *  <li>put a key to a partition on transaction coordinator\n", "next_change": {"commit": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..404bf97f16a 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -91,6 +97,27 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n         stopAllGrids();\n     }\n \n+    /** */\n+    @Test\n+    @WithSystemProperty(key = IGNITE_SENSITIVE_DATA_LOGGING, value = \"plain\")\n+    public void testNodeFailBeforeSendGridNearTxFinishResponseWithSensitive() throws Exception {\n+        testNodeFailBeforeSendGridNearTxFinishResponse();\n+    }\n+\n+    /** */\n+    @Test\n+    @WithSystemProperty(key = IGNITE_SENSITIVE_DATA_LOGGING, value = \"hash\")\n+    public void testNodeFailBeforeSendGridNearTxFinishResponseWithHashSensitive() throws Exception {\n+        testNodeFailBeforeSendGridNearTxFinishResponse();\n+    }\n+\n+    /** */\n+    @Test\n+    @WithSystemProperty(key = IGNITE_SENSITIVE_DATA_LOGGING, value = \"none\")\n+    public void testNodeFailBeforeSendGridNearTxFinishResponseWithoutSensitive() throws Exception {\n+        testNodeFailBeforeSendGridNearTxFinishResponse();\n+    }\n+\n     /**\n      * <ul>\n      * <li>Start 2 nodes with transactional cache, without backups, with {@link IgniteTxExceptionNodeFailTest#syncMode}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzAzMQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442673031", "body": "Bad formatting.", "bodyText": "Bad formatting.", "bodyHTML": "<p dir=\"auto\">Bad formatting.</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:17:30Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;\n+\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        SpecialSpi spi = new SpecialSpi();\n+\n+        cfg.setCommunicationSpi(spi);\n+\n+        if (igniteInstanceName.contains(\"0\"))\n+            spi0 = spi;\n+\n+        if (igniteInstanceName.contains(\"1\"))\n+            spi1 = spi;\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode\n+     * @throws Exception\n+     */\n+    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n+        syncMode = testSyncMode;\n+\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key1).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            GridTestUtils.assertThrows(null,\n+                tx::commit,\n+                TransactionHeuristicException.class,\n+                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n+                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n+        }\n+    }\n+\n+    /**\n+     * SPI wich block communication messages and stop a node.\n+     */\n+    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n+        /** {@inheritDoc} */\n+        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n+            throws IgniteSpiException {\n+            if (msg instanceof GridIoMessage) {\n+                Message message = ((GridIoMessage)msg).message();\n+                if (message instanceof GridNearTxFinishResponse) {\n+                    blockMessages((node1, msg1) -> true);\n+                    new Thread(\n+                        new Runnable() {\n+                            @Override public void run() {\n+                                ignite.log().info(\"Stopping node: [\" + ignite.name() + \"]\");\n+\n+                                IgnitionEx.stop(ignite.name(), true, null, true);\n+                            }\n+                            },", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1Mjk2MQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446852961", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..626e263a61b 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -168,40 +149,29 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             grid1.cache(\"cache\").put(key0, 100);\n             grid1.cache(\"cache\").put(key1, 200);\n \n-            GridTestUtils.assertThrows(null,\n-                tx::commit,\n-                TransactionHeuristicException.class,\n-                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n-        }\n-    }\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n \n-    /**\n-     * SPI wich block communication messages and stop a node.\n-     */\n-    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n-        /** {@inheritDoc} */\n-        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n-            throws IgniteSpiException {\n-            if (msg instanceof GridIoMessage) {\n-                Message message = ((GridIoMessage)msg).message();\n-                if (message instanceof GridNearTxFinishResponse) {\n-                    blockMessages((node1, msg1) -> true);\n-                    new Thread(\n-                        new Runnable() {\n-                            @Override public void run() {\n-                                ignite.log().info(\"Stopping node: [\" + ignite.name() + \"]\");\n-\n-                                IgnitionEx.stop(ignite.name(), true, null, true);\n-                            }\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n                             },\n-                        \"node-stopper\"\n-                    ).start();\n+                            \"node-stopper\"\n+                        ).start();\n+                        return true;\n+                    }\n+                    return false;\n                 }\n-            }\n+            );\n \n-            super.sendMessage(node, msg, ackC);\n+            GridTestUtils.assertThrows(null,\n+                tx::commit,\n+                TransactionHeuristicException.class,\n+                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n+                    grid0.localNode().consistentId() + \"] has left the grid\");\n         }\n     }\n-\n }\n", "next_change": {"commit": "99676c1e5d6ab202e9419ca128b43df003aa3268", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 626e263a61b..6f2c6332b44 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -171,7 +173,7 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n                 tx::commit,\n                 TransactionHeuristicException.class,\n                 \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid\");\n+                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n         }\n     }\n }\n", "next_change": {"commit": "b8f4d8291e89496d9f7c69a587c043ea5465675a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 6f2c6332b44..cacb9e6a73b 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -169,11 +172,22 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n                 }\n             );\n \n-            GridTestUtils.assertThrows(null,\n-                tx::commit,\n-                TransactionHeuristicException.class,\n-                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n+            try {\n+                tx.commit();\n+            }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+\n+                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +\n+                    \"partition data has been lost\\\\) \\\\[cacheName=cache, partition=\\\\d+, \" +\n+                    \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 + \", hasValBytes=true\\\\]\\\\]\");\n+\n+                Matcher matcher = msgPattern.matcher(msg);\n+\n+                Assert.isTrue(matcher.find());\n+            }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -180,14 +171,19 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n \n                 Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n \n-                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +\n-                    \"partition data has been lost\\\\) \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                    \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 + \", hasValBytes=true\\\\]\\\\]\");\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                    \", hasValBytes=true\\\\]\\\\]\");\n \n-                Matcher matcher = msgPattern.matcher(msg);\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n                 Assert.isTrue(matcher.find());\n+\n+                passed = true;\n             }\n+\n+            Assert.isTrue(passed);\n         }\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex d5a03d207c3..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -186,4 +189,4 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             Assert.isTrue(passed);\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -168,40 +142,51 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             grid1.cache(\"cache\").put(key0, 100);\n             grid1.cache(\"cache\").put(key1, 200);\n \n-            GridTestUtils.assertThrows(null,\n-                tx::commit,\n-                TransactionHeuristicException.class,\n-                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n-        }\n-    }\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n \n-    /**\n-     * SPI wich block communication messages and stop a node.\n-     */\n-    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n-        /** {@inheritDoc} */\n-        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n-            throws IgniteSpiException {\n-            if (msg instanceof GridIoMessage) {\n-                Message message = ((GridIoMessage)msg).message();\n-                if (message instanceof GridNearTxFinishResponse) {\n-                    blockMessages((node1, msg1) -> true);\n-                    new Thread(\n-                        new Runnable() {\n-                            @Override public void run() {\n-                                ignite.log().info(\"Stopping node: [\" + ignite.name() + \"]\");\n-\n-                                IgnitionEx.stop(ignite.name(), true, null, true);\n-                            }\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n                             },\n-                        \"node-stopper\"\n-                    ).start();\n+                            \"node-stopper\"\n+                        ).start();\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n                 }\n+            );\n+\n+            boolean passed = false;\n+\n+            try {\n+                tx.commit();\n             }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n \n-            super.sendMessage(node, msg, ackC);\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                if (!mvccEnabled(grid1.context())) {\n+                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+\n+                    Matcher matcher = msgPtrn.matcher(msg);\n+\n+                    Assert.isTrue(matcher.find());\n+                }\n+\n+                passed = true;\n+            }\n+\n+            Assert.isTrue(passed);\n         }\n     }\n-\n }\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -106,87 +150,171 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      *\n      * @throws Exception If failed\n      */\n-    @Test\n-    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n-        startGrids(2);\n+    private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+        IgniteEx grid0 = startGrids(2);\n \n-        grid(0).cluster().active(true);\n+        grid0.cluster().state(ClusterState.ACTIVE);\n \n-        IgniteEx grid0 = grid(0);\n         IgniteEx grid1 = grid(1);\n \n-        int key0 = 0;\n-        int key1 = 0;\n+        int key0 = primaryKey(grid0.cache(DEFAULT_CACHE_NAME));\n+        int key1 = primaryKey(grid1.cache(DEFAULT_CACHE_NAME));\n \n-        Affinity<Object> aff = grid1.affinity(\"cache\");\n+        Affinity<Object> aff = grid1.affinity(DEFAULT_CACHE_NAME);\n \n-        for (int i = 1; i < 1000; i++) {\n-            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n-                key0 = i;\n+        assertFalse(\n+            \"Keys have the same mapping [key0=\" + key0 + \", key1=\" + key1 + ']',\n+            aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1))\n+        );\n \n-                break;\n-            }\n-        }\n+        spi(grid0).blockMessages(GridNearTxFinishResponse.class, getTestIgniteInstanceName(1));\n \n-        for (int i = key0; i < 1000; i++) {\n-            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n-                key1 = i;\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(grid0).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n+                }\n \n-                break;\n-            }\n-        }\n+                info(\"Stopping node: [\" + grid0.name() + ']');\n \n-        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+                grid0.close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n \n         try (Transaction tx = grid1.transactions().txStart()) {\n-            grid1.cache(\"cache\").put(key0, 100);\n-            grid1.cache(\"cache\").put(key1, 200);\n-\n-            spi(grid0).blockMessages((node, msg) -> {\n-                    if (msg instanceof GridNearTxFinishResponse) {\n-                        new Thread(\n-                            new Runnable() {\n-                                @Override public void run() {\n-                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n-\n-                                    IgnitionEx.stop(grid0.name(), true, null, true);\n-                                }\n-                            },\n-                            \"node-stopper\"\n-                        ).start();\n-\n-                        return true;\n-                    }\n-\n-                    return false;\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key0, 100);\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key1, 200);\n+\n+            tx.commit();\n+\n+            fail(\"Transaction passed, but no one partition is alive.\");\n+\n+        }\n+        catch (Exception e) {\n+            assertTrue(X.hasCause(e, CacheInvalidStateException.class));\n+\n+            String msg = e.getMessage();\n+\n+            assertTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+            if (!mvccEnabled(grid1.context())) {\n+                Pattern msgPtrn;\n+\n+                if (S.getSensitiveDataLogging() == PLAIN) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+                }\n+                else if (S.getSensitiveDataLogging() == HASH) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=\" + IgniteUtils.hash(key0) + \"\\\\]\");\n+                }\n+                else {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObject\\\\]\");\n                 }\n-            );\n \n-            boolean passed = false;\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n-            try {\n-                tx.commit();\n+                assertTrue(\"Message does not match: [msg=\" + msg + ']', matcher.find());\n             }\n-            catch (Throwable e) {\n-                String msg = e.getMessage();\n+        }\n \n-                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+        stopNodeFut.get(10_000);\n+    }\n \n-                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+    /**\n+     * Test checks the all node leave detector when cache has backups enough.\n+     *\n+     * @throws Exception If failed.\n+     */\n+    @Test\n+    public void cacheWithBackups() throws Exception {\n+        backups = 2;\n \n-                if (!mvccEnabled(grid1.context())) {\n-                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n-                        \", hasValBytes=true\\\\]\\\\]\");\n+        IgniteEx ignite0 = startGrids(3);\n+\n+        ignite0.cluster().state(ClusterState.ACTIVE);\n+\n+        IgniteEx client = startClientGrid(CLIENT);\n \n-                    Matcher matcher = msgPtrn.matcher(msg);\n+        awaitPartitionMapExchange();\n \n-                    Assert.isTrue(matcher.find());\n+        int key = primaryKey(ignite(1).cache(DEFAULT_CACHE_NAME));\n+\n+        spi(ignite(1)).blockMessages(GridNearTxFinishResponse.class, CLIENT);\n+\n+        spi(ignite(2)).blockMessages(GridDhtTxFinishResponse.class, CLIENT);\n+\n+        new TestDiscoveryNodeLeftListener(CLIENT);\n+\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(ignite(1)).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n                 }\n \n-                passed = true;\n-            }\n+                info(\"Stopping node: [\" + ignite(2).name() + ']');\n+\n+                ignite(2).close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n+\n+        try (Transaction tx = client.transactions().txStart()) {\n+            client.cache(DEFAULT_CACHE_NAME).put(key, 100);\n+\n+            tx.commit();\n+        }\n+        catch (Exception e) {\n+            log.error(\"Transaction was not committed.\", e);\n+\n+            fail(\"Transaction should be committed while at last one owner present [err=\" + e.getMessage() + ']');\n+        }\n+\n+        assertEquals(100, client.cache(DEFAULT_CACHE_NAME).get(key));\n+\n+        stopNodeFut.get(10_000);\n+    }\n+\n+    /**\n+     * A test discovery listener to freeze handling node left events.\n+     */\n+    private class TestDiscoveryNodeLeftListener implements DiscoveryEventListener, HighPriorityListener {\n+        /** Name node to subscribe listener. */\n+        private final String nodeToSubscribe;\n+\n+        /**\n+         * @param nodeToSubscribe Node to subscribe.\n+         */\n+        public TestDiscoveryNodeLeftListener(String nodeToSubscribe) {\n+            this.nodeToSubscribe = nodeToSubscribe;\n+\n+            grid(nodeToSubscribe).context().event().addDiscoveryEventListener(this, TYPES);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onEvent(DiscoveryEvent evt, DiscoCache discoCache) {\n+            info(\"Stopping node: [\" + ignite(1).name() + ']');\n+\n+            ignite(1).close();\n+\n+            grid(nodeToSubscribe).context().event().removeDiscoveryEventListener(this, TYPES);\n+        }\n \n-            Assert.isTrue(passed);\n+        /** {@inheritDoc} */\n+        @Override public int order() {\n+            return 0;\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzcxOA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442673718", "body": "TestRecordingCommunicationSpi  is not used in clean way.\r\nCheck for usage examples of methods blockMessage and waitForBlocked in the code base.\r\nYou even don't need the SpecialSpi class.", "bodyText": "TestRecordingCommunicationSpi  is not used in clean way.\nCheck for usage examples of methods blockMessage and waitForBlocked in the code base.\nYou even don't need the SpecialSpi class.", "bodyHTML": "<p dir=\"auto\">TestRecordingCommunicationSpi  is not used in clean way.<br>\nCheck for usage examples of methods blockMessage and waitForBlocked in the code base.<br>\nYou even don't need the SpecialSpi class.</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:19:08Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;\n+\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        SpecialSpi spi = new SpecialSpi();\n+\n+        cfg.setCommunicationSpi(spi);\n+\n+        if (igniteInstanceName.contains(\"0\"))\n+            spi0 = spi;\n+\n+        if (igniteInstanceName.contains(\"1\"))\n+            spi1 = spi;\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode\n+     * @throws Exception\n+     */\n+    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n+        syncMode = testSyncMode;\n+\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key1).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            GridTestUtils.assertThrows(null,\n+                tx::commit,\n+                TransactionHeuristicException.class,\n+                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n+                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n+        }\n+    }\n+\n+    /**\n+     * SPI wich block communication messages and stop a node.\n+     */\n+    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n+        /** {@inheritDoc} */\n+        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n+            throws IgniteSpiException {\n+            if (msg instanceof GridIoMessage) {\n+                Message message = ((GridIoMessage)msg).message();\n+                if (message instanceof GridNearTxFinishResponse) {", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1MzE3Mw==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446853173", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..626e263a61b 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -168,40 +149,29 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             grid1.cache(\"cache\").put(key0, 100);\n             grid1.cache(\"cache\").put(key1, 200);\n \n-            GridTestUtils.assertThrows(null,\n-                tx::commit,\n-                TransactionHeuristicException.class,\n-                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n-        }\n-    }\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n \n-    /**\n-     * SPI wich block communication messages and stop a node.\n-     */\n-    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n-        /** {@inheritDoc} */\n-        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n-            throws IgniteSpiException {\n-            if (msg instanceof GridIoMessage) {\n-                Message message = ((GridIoMessage)msg).message();\n-                if (message instanceof GridNearTxFinishResponse) {\n-                    blockMessages((node1, msg1) -> true);\n-                    new Thread(\n-                        new Runnable() {\n-                            @Override public void run() {\n-                                ignite.log().info(\"Stopping node: [\" + ignite.name() + \"]\");\n-\n-                                IgnitionEx.stop(ignite.name(), true, null, true);\n-                            }\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n                             },\n-                        \"node-stopper\"\n-                    ).start();\n+                            \"node-stopper\"\n+                        ).start();\n+                        return true;\n+                    }\n+                    return false;\n                 }\n-            }\n+            );\n \n-            super.sendMessage(node, msg, ackC);\n+            GridTestUtils.assertThrows(null,\n+                tx::commit,\n+                TransactionHeuristicException.class,\n+                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n+                    grid0.localNode().consistentId() + \"] has left the grid\");\n         }\n     }\n-\n }\n", "next_change": {"commit": "99676c1e5d6ab202e9419ca128b43df003aa3268", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 626e263a61b..6f2c6332b44 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -171,7 +173,7 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n                 tx::commit,\n                 TransactionHeuristicException.class,\n                 \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid\");\n+                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n         }\n     }\n }\n", "next_change": {"commit": "b8f4d8291e89496d9f7c69a587c043ea5465675a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 6f2c6332b44..cacb9e6a73b 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -169,11 +172,22 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n                 }\n             );\n \n-            GridTestUtils.assertThrows(null,\n-                tx::commit,\n-                TransactionHeuristicException.class,\n-                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n+            try {\n+                tx.commit();\n+            }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+\n+                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +\n+                    \"partition data has been lost\\\\) \\\\[cacheName=cache, partition=\\\\d+, \" +\n+                    \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 + \", hasValBytes=true\\\\]\\\\]\");\n+\n+                Matcher matcher = msgPattern.matcher(msg);\n+\n+                Assert.isTrue(matcher.find());\n+            }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -180,14 +171,19 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n \n                 Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n \n-                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +\n-                    \"partition data has been lost\\\\) \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                    \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 + \", hasValBytes=true\\\\]\\\\]\");\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                    \", hasValBytes=true\\\\]\\\\]\");\n \n-                Matcher matcher = msgPattern.matcher(msg);\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n                 Assert.isTrue(matcher.find());\n+\n+                passed = true;\n             }\n+\n+            Assert.isTrue(passed);\n         }\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex d5a03d207c3..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -186,4 +189,4 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             Assert.isTrue(passed);\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -168,40 +142,51 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             grid1.cache(\"cache\").put(key0, 100);\n             grid1.cache(\"cache\").put(key1, 200);\n \n-            GridTestUtils.assertThrows(null,\n-                tx::commit,\n-                TransactionHeuristicException.class,\n-                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n-                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n-        }\n-    }\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n \n-    /**\n-     * SPI wich block communication messages and stop a node.\n-     */\n-    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n-        /** {@inheritDoc} */\n-        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n-            throws IgniteSpiException {\n-            if (msg instanceof GridIoMessage) {\n-                Message message = ((GridIoMessage)msg).message();\n-                if (message instanceof GridNearTxFinishResponse) {\n-                    blockMessages((node1, msg1) -> true);\n-                    new Thread(\n-                        new Runnable() {\n-                            @Override public void run() {\n-                                ignite.log().info(\"Stopping node: [\" + ignite.name() + \"]\");\n-\n-                                IgnitionEx.stop(ignite.name(), true, null, true);\n-                            }\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n                             },\n-                        \"node-stopper\"\n-                    ).start();\n+                            \"node-stopper\"\n+                        ).start();\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n                 }\n+            );\n+\n+            boolean passed = false;\n+\n+            try {\n+                tx.commit();\n             }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n \n-            super.sendMessage(node, msg, ackC);\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                if (!mvccEnabled(grid1.context())) {\n+                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+\n+                    Matcher matcher = msgPtrn.matcher(msg);\n+\n+                    Assert.isTrue(matcher.find());\n+                }\n+\n+                passed = true;\n+            }\n+\n+            Assert.isTrue(passed);\n         }\n     }\n-\n }\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -106,87 +150,171 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      *\n      * @throws Exception If failed\n      */\n-    @Test\n-    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n-        startGrids(2);\n+    private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+        IgniteEx grid0 = startGrids(2);\n \n-        grid(0).cluster().active(true);\n+        grid0.cluster().state(ClusterState.ACTIVE);\n \n-        IgniteEx grid0 = grid(0);\n         IgniteEx grid1 = grid(1);\n \n-        int key0 = 0;\n-        int key1 = 0;\n+        int key0 = primaryKey(grid0.cache(DEFAULT_CACHE_NAME));\n+        int key1 = primaryKey(grid1.cache(DEFAULT_CACHE_NAME));\n \n-        Affinity<Object> aff = grid1.affinity(\"cache\");\n+        Affinity<Object> aff = grid1.affinity(DEFAULT_CACHE_NAME);\n \n-        for (int i = 1; i < 1000; i++) {\n-            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n-                key0 = i;\n+        assertFalse(\n+            \"Keys have the same mapping [key0=\" + key0 + \", key1=\" + key1 + ']',\n+            aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1))\n+        );\n \n-                break;\n-            }\n-        }\n+        spi(grid0).blockMessages(GridNearTxFinishResponse.class, getTestIgniteInstanceName(1));\n \n-        for (int i = key0; i < 1000; i++) {\n-            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n-                key1 = i;\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(grid0).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n+                }\n \n-                break;\n-            }\n-        }\n+                info(\"Stopping node: [\" + grid0.name() + ']');\n \n-        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+                grid0.close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n \n         try (Transaction tx = grid1.transactions().txStart()) {\n-            grid1.cache(\"cache\").put(key0, 100);\n-            grid1.cache(\"cache\").put(key1, 200);\n-\n-            spi(grid0).blockMessages((node, msg) -> {\n-                    if (msg instanceof GridNearTxFinishResponse) {\n-                        new Thread(\n-                            new Runnable() {\n-                                @Override public void run() {\n-                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n-\n-                                    IgnitionEx.stop(grid0.name(), true, null, true);\n-                                }\n-                            },\n-                            \"node-stopper\"\n-                        ).start();\n-\n-                        return true;\n-                    }\n-\n-                    return false;\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key0, 100);\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key1, 200);\n+\n+            tx.commit();\n+\n+            fail(\"Transaction passed, but no one partition is alive.\");\n+\n+        }\n+        catch (Exception e) {\n+            assertTrue(X.hasCause(e, CacheInvalidStateException.class));\n+\n+            String msg = e.getMessage();\n+\n+            assertTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+            if (!mvccEnabled(grid1.context())) {\n+                Pattern msgPtrn;\n+\n+                if (S.getSensitiveDataLogging() == PLAIN) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+                }\n+                else if (S.getSensitiveDataLogging() == HASH) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=\" + IgniteUtils.hash(key0) + \"\\\\]\");\n+                }\n+                else {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObject\\\\]\");\n                 }\n-            );\n \n-            boolean passed = false;\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n-            try {\n-                tx.commit();\n+                assertTrue(\"Message does not match: [msg=\" + msg + ']', matcher.find());\n             }\n-            catch (Throwable e) {\n-                String msg = e.getMessage();\n+        }\n \n-                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+        stopNodeFut.get(10_000);\n+    }\n \n-                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+    /**\n+     * Test checks the all node leave detector when cache has backups enough.\n+     *\n+     * @throws Exception If failed.\n+     */\n+    @Test\n+    public void cacheWithBackups() throws Exception {\n+        backups = 2;\n \n-                if (!mvccEnabled(grid1.context())) {\n-                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n-                        \", hasValBytes=true\\\\]\\\\]\");\n+        IgniteEx ignite0 = startGrids(3);\n+\n+        ignite0.cluster().state(ClusterState.ACTIVE);\n+\n+        IgniteEx client = startClientGrid(CLIENT);\n \n-                    Matcher matcher = msgPtrn.matcher(msg);\n+        awaitPartitionMapExchange();\n \n-                    Assert.isTrue(matcher.find());\n+        int key = primaryKey(ignite(1).cache(DEFAULT_CACHE_NAME));\n+\n+        spi(ignite(1)).blockMessages(GridNearTxFinishResponse.class, CLIENT);\n+\n+        spi(ignite(2)).blockMessages(GridDhtTxFinishResponse.class, CLIENT);\n+\n+        new TestDiscoveryNodeLeftListener(CLIENT);\n+\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(ignite(1)).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n                 }\n \n-                passed = true;\n-            }\n+                info(\"Stopping node: [\" + ignite(2).name() + ']');\n+\n+                ignite(2).close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n+\n+        try (Transaction tx = client.transactions().txStart()) {\n+            client.cache(DEFAULT_CACHE_NAME).put(key, 100);\n+\n+            tx.commit();\n+        }\n+        catch (Exception e) {\n+            log.error(\"Transaction was not committed.\", e);\n+\n+            fail(\"Transaction should be committed while at last one owner present [err=\" + e.getMessage() + ']');\n+        }\n+\n+        assertEquals(100, client.cache(DEFAULT_CACHE_NAME).get(key));\n+\n+        stopNodeFut.get(10_000);\n+    }\n+\n+    /**\n+     * A test discovery listener to freeze handling node left events.\n+     */\n+    private class TestDiscoveryNodeLeftListener implements DiscoveryEventListener, HighPriorityListener {\n+        /** Name node to subscribe listener. */\n+        private final String nodeToSubscribe;\n+\n+        /**\n+         * @param nodeToSubscribe Node to subscribe.\n+         */\n+        public TestDiscoveryNodeLeftListener(String nodeToSubscribe) {\n+            this.nodeToSubscribe = nodeToSubscribe;\n+\n+            grid(nodeToSubscribe).context().event().addDiscoveryEventListener(this, TYPES);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onEvent(DiscoveryEvent evt, DiscoCache discoCache) {\n+            info(\"Stopping node: [\" + ignite(1).name() + ']');\n+\n+            ignite(1).close();\n+\n+            grid(nodeToSubscribe).context().event().removeDiscoveryEventListener(this, TYPES);\n+        }\n \n-            Assert.isTrue(passed);\n+        /** {@inheritDoc} */\n+        @Override public int order() {\n+            return 0;\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDA1OQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442674059", "body": "These class fields look useless.\r\nBetter to fetch spi when it's needed using org.apache.ignite.internal.TestRecordingCommunicationSpi#spi(ignite)", "bodyText": "These class fields look useless.\nBetter to fetch spi when it's needed using org.apache.ignite.internal.TestRecordingCommunicationSpi#spi(ignite)", "bodyHTML": "<p dir=\"auto\">These class fields look useless.<br>\nBetter to fetch spi when it's needed using org.apache.ignite.internal.TestRecordingCommunicationSpi#spi(ignite)</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:19:58Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1MzUyOA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446853528", "bodyText": "Thanks. I removed this field.", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDA1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..626e263a61b 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -43,18 +37,13 @@ import org.junit.Test;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n-    /** Spi for node0 */\n-    private SpecialSpi spi0;\n-\n-    /** Spi for node1 */\n-    private SpecialSpi spi1;\n-\n     /** syncMode */\n     private static CacheWriteSynchronizationMode syncMode;\n \n", "next_change": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 626e263a61b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -28,31 +29,42 @@ import org.apache.ignite.configuration.IgniteConfiguration;\n import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n-import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n         cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -30,51 +29,46 @@ import org.apache.ignite.configuration.IgniteConfiguration;\n import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n-import org.apache.ignite.internal.managers.communication.GridIoMessage;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n-import org.apache.ignite.lang.IgniteInClosure;\n-import org.apache.ignite.plugin.extensions.communication.Message;\n-import org.apache.ignite.spi.IgniteSpiException;\n-import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n+import static org.apache.ignite.internal.processors.cache.mvcc.MvccUtils.mvccEnabled;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n-    /** Spi for node0 */\n-    private SpecialSpi spi0;\n-\n-    /** Spi for node1 */\n-    private SpecialSpi spi1;\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n \n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n-        SpecialSpi spi = new SpecialSpi();\n-\n-        cfg.setCommunicationSpi(spi);\n-\n-        if (igniteInstanceName.contains(\"0\"))\n-            spi0 = spi;\n-\n-        if (igniteInstanceName.contains(\"1\"))\n-            spi1 = spi;\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n \n         return cfg\n             .setDataStorageConfiguration(dsConfig)\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -60,21 +82,22 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n     @Parameterized.Parameter()\n     public CacheWriteSynchronizationMode syncMode;\n \n+    /** Amount backups for cache. */\n+    public int backups = 0;\n+\n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n-\n-        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n-                .setPersistenceEnabled(true));\n-\n-        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n-\n-        return cfg\n-            .setDataStorageConfiguration(dsConfig)\n-            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+        return super.getConfiguration(igniteInstanceName)\n+            .setConsistentId(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setDataStorageConfiguration(new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                    .setMaxSize(100L * 1024 * 1024)\n+                    .setPersistenceEnabled(true)))\n+            .setCacheConfiguration(new CacheConfiguration(DEFAULT_CACHE_NAME)\n                 .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n-                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+                .setWriteSynchronizationMode(syncMode)\n+                .setBackups(backups));\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDE1NA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442674154", "body": "Same as above.", "bodyText": "Same as above.", "bodyHTML": "<p dir=\"auto\">Same as above.</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:20:08Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1MzYwMA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446853600", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDE1NA=="}], "type": "inlineReview", "revised_code": {"commit": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..626e263a61b 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -43,18 +37,13 @@ import org.junit.Test;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n-    /** Spi for node0 */\n-    private SpecialSpi spi0;\n-\n-    /** Spi for node1 */\n-    private SpecialSpi spi1;\n-\n     /** syncMode */\n     private static CacheWriteSynchronizationMode syncMode;\n \n", "next_change": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 626e263a61b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -28,31 +29,42 @@ import org.apache.ignite.configuration.IgniteConfiguration;\n import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n-import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n         cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 9715696e540..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -30,51 +29,46 @@ import org.apache.ignite.configuration.IgniteConfiguration;\n import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n-import org.apache.ignite.internal.managers.communication.GridIoMessage;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n-import org.apache.ignite.lang.IgniteInClosure;\n-import org.apache.ignite.plugin.extensions.communication.Message;\n-import org.apache.ignite.spi.IgniteSpiException;\n-import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n+import static org.apache.ignite.internal.processors.cache.mvcc.MvccUtils.mvccEnabled;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n-    /** Spi for node0 */\n-    private SpecialSpi spi0;\n-\n-    /** Spi for node1 */\n-    private SpecialSpi spi1;\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n \n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n-        SpecialSpi spi = new SpecialSpi();\n-\n-        cfg.setCommunicationSpi(spi);\n-\n-        if (igniteInstanceName.contains(\"0\"))\n-            spi0 = spi;\n-\n-        if (igniteInstanceName.contains(\"1\"))\n-            spi1 = spi;\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n \n         return cfg\n             .setDataStorageConfiguration(dsConfig)\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -60,21 +82,22 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n     @Parameterized.Parameter()\n     public CacheWriteSynchronizationMode syncMode;\n \n+    /** Amount backups for cache. */\n+    public int backups = 0;\n+\n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n-\n-        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n-                .setPersistenceEnabled(true));\n-\n-        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n-\n-        return cfg\n-            .setDataStorageConfiguration(dsConfig)\n-            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+        return super.getConfiguration(igniteInstanceName)\n+            .setConsistentId(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setDataStorageConfiguration(new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                    .setMaxSize(100L * 1024 * 1024)\n+                    .setPersistenceEnabled(true)))\n+            .setCacheConfiguration(new CacheConfiguration(DEFAULT_CACHE_NAME)\n                 .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n-                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+                .setWriteSynchronizationMode(syncMode)\n+                .setBackups(backups));\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTY3OQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442679679", "body": "Doesn't look good to me. The transaction can still be in prepared state and recovering for other primaries.\r\nI think it's ok to trigger heuristic exception only if near tx is in commiting state and a primary node has failed. No need to check for backups therefore.", "bodyText": "Doesn't look good to me. The transaction can still be in prepared state and recovering for other primaries.\nI think it's ok to trigger heuristic exception only if near tx is in commiting state and a primary node has failed. No need to check for backups therefore.", "bodyHTML": "<p dir=\"auto\">Doesn't look good to me. The transaction can still be in prepared state and recovering for other primaries.<br>\nI think it's ok to trigger heuristic exception only if near tx is in commiting state and a primary node has failed. No need to check for backups therefore.</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:32:13Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -1032,6 +1033,25 @@ public GridDistributedTxMapping mapping() {\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n+                        else {\n+                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+\n+                            return true;", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg0OTM2Mg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446849362", "bodyText": "Test https://ggtc.gridgain.com/project.html?projectId=Tests_GridGainCeEeUe_Latest_CE&testNameId=1912185254194727833&tab=testDetails&branch_Tests_GridGainCeEeUe_Latest_CE=gg-27999 failed when I removed backups check. So I think return it.", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 3c28d2fbda4..38ac4524d02 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1034,24 +1036,21 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                             }\n                         }\n                         else {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+                            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                    m.primary().consistentId() + \"] has left the grid\"));\n \n-                            return true;\n+                                return true;\n+                            }\n                         }\n                     }\n                 }\n                 else {\n-                    Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-                    if (txNodes != null) {\n-                        Collection<UUID> backups = txNodes.get(nodeId);\n+                    if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                        onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                            m.primary().consistentId() + \"] has left the grid and there\"));\n \n-                        if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n-\n-                            return true;\n-                        }\n+                        return true;\n                     }\n                 }\n \n", "next_change": {"commit": "6a32b7b33e83d43560866689850b71d233b33d03", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 38ac4524d02..e01194583c6 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1048,7 +1048,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                 else {\n                     if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n                         onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                            m.primary().consistentId() + \"] has left the grid and there\"));\n+                            m.primary().consistentId() + \"] has left the grid\"));\n \n                         return true;\n                     }\n", "next_change": {"commit": "b6a5bd02bdaff9c086b21931d6b9e09d2af6220d", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex e01194583c6..50cf71ee238 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1047,10 +1047,18 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                 }\n                 else {\n                     if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                        onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                            m.primary().consistentId() + \"] has left the grid\"));\n+                        Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n \n-                        return true;\n+                        if (txNodes != null) {\n+                            Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                            if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n+                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                    m.primary().consistentId() + \"] has left the grid\"));\n+\n+                                return true;\n+                            }\n+                        }\n                     }\n                 }\n \n", "next_change": {"commit": "99676c1e5d6ab202e9419ca128b43df003aa3268", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 50cf71ee238..acc577e005a 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1035,30 +1051,6 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n-                        else {\n-                            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                    m.primary().consistentId() + \"] has left the grid\"));\n-\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-                else {\n-                    if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                        Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-\n-                        if (txNodes != null) {\n-                            Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                            if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n-                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                    m.primary().consistentId() + \"] has left the grid\"));\n-\n-                                return true;\n-                            }\n-                        }\n                     }\n                 }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 3c28d2fbda4..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1033,25 +1055,6 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n-                        else {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n-\n-                            return true;\n-                        }\n-                    }\n-                }\n-                else {\n-                    Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-                    if (txNodes != null) {\n-                        Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                        if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n-\n-                            return true;\n-                        }\n                     }\n                 }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fde59079a307ffe401b00d6f157c13ea22e6dec0", "committedDate": "2020-08-29 20:30:09 +0300", "message": "GG-21041 Tracing: atomic cache.get() flow."}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}, {"oid": "542de83c1e7d45061bb31f2f9a533fd31d1e51b4", "committedDate": "2021-06-25 17:36:33 +0300", "message": "GG-33365 Contention in lock on Compound future."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTc3NA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442679774", "body": "Same as above.", "bodyText": "Same as above.", "bodyHTML": "<p dir=\"auto\">Same as above.</p>", "author": "ascherbakoff", "createdAt": "2020-06-19T07:32:25Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -1032,6 +1033,25 @@ public GridDistributedTxMapping mapping() {\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n+                        else {\n+                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+\n+                            return true;\n+                        }\n+                    }\n+                }\n+                else {\n+                    Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+                    if (txNodes != null) {\n+                        Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                        if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n+                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+\n+                            return true;\n+                        }", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 3c28d2fbda4..38ac4524d02 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1034,24 +1036,21 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                             }\n                         }\n                         else {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+                            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                    m.primary().consistentId() + \"] has left the grid\"));\n \n-                            return true;\n+                                return true;\n+                            }\n                         }\n                     }\n                 }\n                 else {\n-                    Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-                    if (txNodes != null) {\n-                        Collection<UUID> backups = txNodes.get(nodeId);\n+                    if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                        onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                            m.primary().consistentId() + \"] has left the grid and there\"));\n \n-                        if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n-\n-                            return true;\n-                        }\n+                        return true;\n                     }\n                 }\n \n", "next_change": {"commit": "6a32b7b33e83d43560866689850b71d233b33d03", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 38ac4524d02..e01194583c6 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1048,7 +1048,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                 else {\n                     if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n                         onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                            m.primary().consistentId() + \"] has left the grid and there\"));\n+                            m.primary().consistentId() + \"] has left the grid\"));\n \n                         return true;\n                     }\n", "next_change": {"commit": "b6a5bd02bdaff9c086b21931d6b9e09d2af6220d", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex e01194583c6..50cf71ee238 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1047,10 +1047,18 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                 }\n                 else {\n                     if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                        onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                            m.primary().consistentId() + \"] has left the grid\"));\n+                        Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n \n-                        return true;\n+                        if (txNodes != null) {\n+                            Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                            if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n+                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                    m.primary().consistentId() + \"] has left the grid\"));\n+\n+                                return true;\n+                            }\n+                        }\n                     }\n                 }\n \n", "next_change": {"commit": "99676c1e5d6ab202e9419ca128b43df003aa3268", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 50cf71ee238..acc577e005a 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1035,30 +1051,6 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n-                        else {\n-                            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                    m.primary().consistentId() + \"] has left the grid\"));\n-\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-                else {\n-                    if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                        Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-\n-                        if (txNodes != null) {\n-                            Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                            if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n-                                onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                    m.primary().consistentId() + \"] has left the grid\"));\n-\n-                                return true;\n-                            }\n-                        }\n                     }\n                 }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 3c28d2fbda4..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1033,25 +1055,6 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n-                        else {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n-\n-                            return true;\n-                        }\n-                    }\n-                }\n-                else {\n-                    Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-                    if (txNodes != null) {\n-                        Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                        if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n-                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n-\n-                            return true;\n-                        }\n                     }\n                 }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fde59079a307ffe401b00d6f157c13ea22e6dec0", "committedDate": "2020-08-29 20:30:09 +0300", "message": "GG-21041 Tracing: atomic cache.get() flow."}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}, {"oid": "542de83c1e7d45061bb31f2f9a533fd31d1e51b4", "committedDate": "2021-06-25 17:36:33 +0300", "message": "GG-33365 Contention in lock on Compound future."}]}, {"oid": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "url": "https://github.com/gridgain/gridgain/commit/05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "message": "GG-27999 fix after review", "committedDate": "2020-06-19T14:12:58Z", "type": "commit"}, {"oid": "6a32b7b33e83d43560866689850b71d233b33d03", "url": "https://github.com/gridgain/gridgain/commit/6a32b7b33e83d43560866689850b71d233b33d03", "message": "GG-27999 fix after review", "committedDate": "2020-06-19T14:30:16Z", "type": "commit"}, {"oid": "b6a5bd02bdaff9c086b21931d6b9e09d2af6220d", "url": "https://github.com/gridgain/gridgain/commit/b6a5bd02bdaff9c086b21931d6b9e09d2af6220d", "message": "GG-27999 fix after run all on teamcity", "committedDate": "2020-06-29T08:39:38Z", "type": "commit"}, {"oid": "3f3e383645e67c86078019c3b42d402e94399ba5", "url": "https://github.com/gridgain/gridgain/commit/3f3e383645e67c86078019c3b42d402e94399ba5", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-27999", "committedDate": "2020-06-29T09:10:12Z", "type": "commit"}, {"oid": "99676c1e5d6ab202e9419ca128b43df003aa3268", "url": "https://github.com/gridgain/gridgain/commit/99676c1e5d6ab202e9419ca128b43df003aa3268", "message": "GG-27999 fix after review", "committedDate": "2020-06-30T12:30:19Z", "type": "commit"}, {"oid": "f8ca5ee89a9de8698afefc90ce5e59f8328f075a", "url": "https://github.com/gridgain/gridgain/commit/f8ca5ee89a9de8698afefc90ce5e59f8328f075a", "message": "GG-27999 get backups via tx", "committedDate": "2020-06-30T14:12:41Z", "type": "commit"}, {"oid": "8bf1de2b8717ceb8f5817ff9f88dcf81d13434f9", "url": "https://github.com/gridgain/gridgain/commit/8bf1de2b8717ceb8f5817ff9f88dcf81d13434f9", "message": "GG-27999 cleanup", "committedDate": "2020-07-01T20:27:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQzMjA1Ng==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r449432056", "body": "You should print informative partition loss message here, like here:\r\norg.apache.ignite.internal.processors.cache.distributed.dht.GridDhtTopologyFutureAdapter#validateKey.\r\n\r\nnew CacheInvalidStateException(\"Failed to commit a transaction (all partition owners have left the grid, partition data has been lost) [cacheName=cache, partition=10, key=somekey]\")\r\n\r\nI think better to avoid heuristic exception and use CacheException instread.", "bodyText": "You should print informative partition loss message here, like here:\norg.apache.ignite.internal.processors.cache.distributed.dht.GridDhtTopologyFutureAdapter#validateKey.\nnew CacheInvalidStateException(\"Failed to commit a transaction (all partition owners have left the grid, partition data has been lost) [cacheName=cache, partition=10, key=somekey]\")\nI think better to avoid heuristic exception and use CacheException instread.", "bodyHTML": "<p dir=\"auto\">You should print informative partition loss message here, like here:<br>\norg.apache.ignite.internal.processors.cache.distributed.dht.GridDhtTopologyFutureAdapter#validateKey.</p>\n<p dir=\"auto\">new CacheInvalidStateException(\"Failed to commit a transaction (all partition owners have left the grid, partition data has been lost) [cacheName=cache, partition=10, key=somekey]\")</p>\n<p dir=\"auto\">I think better to avoid heuristic exception and use CacheException instread.</p>", "author": "ascherbakoff", "createdAt": "2020-07-03T07:50:22Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,7 +982,27 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+\n+                Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                boolean hasBackups = false;\n+\n+                if (backups != null)\n+                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n+\n+                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n+                    onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +", "originalCommit": "8bf1de2b8717ceb8f5817ff9f88dcf81d13434f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b8f4d8291e89496d9f7c69a587c043ea5465675a", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex fe0a95855ad..4a69bebd0de 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -993,9 +993,20 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                     hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n \n                 if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n-                    onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                        m.primary().consistentId() + \"] has left the grid and there are no backup nodes\",\n-                        new CacheInvalidStateException()));\n+                    IgniteTxEntry firstTxEntry = m.entries().iterator().next();\n+\n+                    String strTxEntry = \"\";\n+\n+                    if (firstTxEntry != null)\n+                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n+                            \", partition=\" + firstTxEntry.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n+                            \"]\";\n+\n+                    onDone(new CacheInvalidStateException(\"Failed to commit a transaction \" +\n+                        \"(all partition owners have left the grid, partition data has been lost)\" +\n+                        strTxEntry)\n+                    );\n \n                     return true;\n                 }\n", "next_change": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 4a69bebd0de..ed562a5afa1 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -993,27 +998,26 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                     hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n \n                 if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n-                    IgniteTxEntry firstTxEntry = m.entries().iterator().next();\n-\n                     String strTxEntry = \"\";\n \n-                    if (firstTxEntry != null)\n+                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n+\n+                    if (entryIter.hasNext()) {\n+                        IgniteTxEntry firstTxEntry = entryIter.next();\n+\n                         strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n                             \", partition=\" + firstTxEntry.key().partition() +\n                             (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n                             \"]\";\n+                    }\n \n-                    onDone(new CacheInvalidStateException(\"Failed to commit a transaction \" +\n-                        \"(all partition owners have left the grid, partition data has been lost)\" +\n-                        strTxEntry)\n-                    );\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG + strTxEntry));\n \n                     return true;\n                 }\n             }\n \n             if (nodeId.equals(m.primary().id())) {\n-\n                 if (msgLog.isDebugEnabled()) {\n                     msgLog.debug(\"Near finish fut, mini future node left [txId=\" + tx.nearXidVersion() +\n                         \", node=\" + m.primary().id() + ']');\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex fe0a95855ad..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -983,26 +989,19 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-\n-                Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                boolean hasBackups = false;\n-\n-                if (backups != null)\n-                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n-\n-                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n-                    onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n-                        m.primary().consistentId() + \"] has left the grid and there are no backup nodes\",\n-                        new CacheInvalidStateException()));\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n+                    .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n+                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n+                            \", partition=\" + e.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n+                            \"]\").findFirst().orElse(\"\")));\n \n                     return true;\n                 }\n             }\n \n             if (nodeId.equals(m.primary().id())) {\n-\n                 if (msgLog.isDebugEnabled()) {\n                     msgLog.debug(\"Near finish fut, mini future node left [txId=\" + tx.nearXidVersion() +\n                         \", node=\" + m.primary().id() + ']');\n", "next_change": null}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fde59079a307ffe401b00d6f157c13ea22e6dec0", "committedDate": "2020-08-29 20:30:09 +0300", "message": "GG-21041 Tracing: atomic cache.get() flow."}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}, {"oid": "542de83c1e7d45061bb31f2f9a533fd31d1e51b4", "committedDate": "2021-06-25 17:36:33 +0300", "message": "GG-33365 Contention in lock on Compound future."}]}, {"oid": "b8f4d8291e89496d9f7c69a587c043ea5465675a", "url": "https://github.com/gridgain/gridgain/commit/b8f4d8291e89496d9f7c69a587c043ea5465675a", "message": "GG-2799 fix after review", "committedDate": "2020-07-03T13:05:16Z", "type": "commit"}, {"oid": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "url": "https://github.com/gridgain/gridgain/commit/7be549368ac7e8930c9ed1d3abd339de4056ad66", "message": "GG-27999 fix after review", "committedDate": "2020-07-03T14:11:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NTkzNg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450145936", "body": "We don't need an empty line here", "bodyText": "We don't need an empty line here", "bodyHTML": "<p dir=\"auto\">We don't need an empty line here</p>", "author": "glukos", "createdAt": "2020-07-06T11:01:44Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,7 +983,41 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+\n+                Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                boolean hasBackups = false;\n+\n+                if (backups != null)\n+                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n+\n+                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n+                    String strTxEntry = \"\";\n+\n+                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n+\n+                    if (entryIter.hasNext()) {\n+                        IgniteTxEntry firstTxEntry = entryIter.next();\n+\n+                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n+                            \", partition=\" + firstTxEntry.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n+                            \"]\";\n+                    }\n+\n+                    onDone(new CacheInvalidStateException(\"Failed to commit a transaction \" +\n+                        \"(all partition owners have left the grid, partition data has been lost)\" +\n+                        strTxEntry)\n+                    );\n+\n+                    return true;\n+                }\n+            }\n+\n             if (nodeId.equals(m.primary().id())) {\n+", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTI1OA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205258", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NTkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex e34ace8fff2..ed562a5afa1 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -1007,17 +1011,13 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                             \"]\";\n                     }\n \n-                    onDone(new CacheInvalidStateException(\"Failed to commit a transaction \" +\n-                        \"(all partition owners have left the grid, partition data has been lost)\" +\n-                        strTxEntry)\n-                    );\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG + strTxEntry));\n \n                     return true;\n                 }\n             }\n \n             if (nodeId.equals(m.primary().id())) {\n-\n                 if (msgLog.isDebugEnabled()) {\n                     msgLog.debug(\"Near finish fut, mini future node left [txId=\" + tx.nearXidVersion() +\n                         \", node=\" + m.primary().id() + ']');\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex e34ace8fff2..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -984,40 +989,19 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-\n-                Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                boolean hasBackups = false;\n-\n-                if (backups != null)\n-                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n-\n-                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n-                    String strTxEntry = \"\";\n-\n-                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n-\n-                    if (entryIter.hasNext()) {\n-                        IgniteTxEntry firstTxEntry = entryIter.next();\n-\n-                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n-                            \", partition=\" + firstTxEntry.key().partition() +\n-                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n-                            \"]\";\n-                    }\n-\n-                    onDone(new CacheInvalidStateException(\"Failed to commit a transaction \" +\n-                        \"(all partition owners have left the grid, partition data has been lost)\" +\n-                        strTxEntry)\n-                    );\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n+                    .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n+                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n+                            \", partition=\" + e.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n+                            \"]\").findFirst().orElse(\"\")));\n \n                     return true;\n                 }\n             }\n \n             if (nodeId.equals(m.primary().id())) {\n-\n                 if (msgLog.isDebugEnabled()) {\n                     msgLog.debug(\"Near finish fut, mini future node left [txId=\" + tx.nearXidVersion() +\n                         \", node=\" + m.primary().id() + ']');\n", "next_change": null}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fde59079a307ffe401b00d6f157c13ea22e6dec0", "committedDate": "2020-08-29 20:30:09 +0300", "message": "GG-21041 Tracing: atomic cache.get() flow."}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}, {"oid": "542de83c1e7d45061bb31f2f9a533fd31d1e51b4", "committedDate": "2021-06-25 17:36:33 +0300", "message": "GG-33365 Contention in lock on Compound future."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NjQwOQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450146409", "body": "We can use @RunWith(Parameterized.class) instead for testing with various values of this parameter.", "bodyText": "We can use @RunWith(Parameterized.class) instead for testing with various values of this parameter.", "bodyHTML": "<p dir=\"auto\">We can use <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/RunWith/hovercard\" href=\"https://github.com/RunWith\">@RunWith</a>(Parameterized.class) instead for testing with various values of this parameter.</p>", "author": "glukos", "createdAt": "2020-07-06T11:02:46Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTMwNA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205304", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NjQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -31,31 +30,41 @@ import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n         cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -31,31 +30,42 @@ import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n+import static org.apache.ignite.internal.processors.cache.mvcc.MvccUtils.mvccEnabled;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n         cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -60,21 +82,22 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n     @Parameterized.Parameter()\n     public CacheWriteSynchronizationMode syncMode;\n \n+    /** Amount backups for cache. */\n+    public int backups = 0;\n+\n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n-\n-        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n-                .setPersistenceEnabled(true));\n-\n-        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n-\n-        return cfg\n-            .setDataStorageConfiguration(dsConfig)\n-            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+        return super.getConfiguration(igniteInstanceName)\n+            .setConsistentId(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setDataStorageConfiguration(new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                    .setMaxSize(100L * 1024 * 1024)\n+                    .setPersistenceEnabled(true)))\n+            .setCacheConfiguration(new CacheConfiguration(DEFAULT_CACHE_NAME)\n                 .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n-                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+                .setWriteSynchronizationMode(syncMode)\n+                .setBackups(backups));\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzMQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450147231", "body": "It's better to preset DataRegionConfiguration#maxSize to reasonable value (e.g. 100 mb). By default, Ignite node allocates 20% of physical memory, which sometimes causes OOMs on TC.", "bodyText": "It's better to preset DataRegionConfiguration#maxSize to reasonable value (e.g. 100 mb). By default, Ignite node allocates 20% of physical memory, which sometimes causes OOMs on TC.", "bodyHTML": "<p dir=\"auto\">It's better to preset DataRegionConfiguration#maxSize to reasonable value (e.g. 100 mb). By default, Ignite node allocates 20% of physical memory, which sometimes causes OOMs on TC.</p>", "author": "glukos", "createdAt": "2020-07-06T11:04:31Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTMzMg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205332", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -31,31 +30,41 @@ import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n         cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -31,31 +30,42 @@ import org.apache.ignite.internal.IgniteEx;\n import org.apache.ignite.internal.IgnitionEx;\n import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n-import org.apache.ignite.internal.util.typedef.internal.U;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n import org.apache.ignite.transactions.Transaction;\n import org.apache.ignite.transactions.TransactionHeuristicException;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n import org.locationtech.jts.util.Assert;\n \n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n+import static org.apache.ignite.internal.processors.cache.mvcc.MvccUtils.mvccEnabled;\n \n /**\n  * Tests check a result of commit when a node fail before\n  * send {@link GridNearTxFinishResponse} to transaction coodinator\n  */\n+@RunWith(Parameterized.class)\n public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n     /** syncMode */\n-    private static CacheWriteSynchronizationMode syncMode;\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n \n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n         IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n \n         DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n                 .setPersistenceEnabled(true));\n \n         cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -60,21 +82,22 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n     @Parameterized.Parameter()\n     public CacheWriteSynchronizationMode syncMode;\n \n+    /** Amount backups for cache. */\n+    public int backups = 0;\n+\n     /** {@inheritDoc} */\n     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n-\n-        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n-            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n-                .setPersistenceEnabled(true));\n-\n-        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n-\n-        return cfg\n-            .setDataStorageConfiguration(dsConfig)\n-            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+        return super.getConfiguration(igniteInstanceName)\n+            .setConsistentId(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setDataStorageConfiguration(new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                    .setMaxSize(100L * 1024 * 1024)\n+                    .setPersistenceEnabled(true)))\n+            .setCacheConfiguration(new CacheConfiguration(DEFAULT_CACHE_NAME)\n                 .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n-                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+                .setWriteSynchronizationMode(syncMode)\n+                .setBackups(backups));\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0Nzg2MQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450147861", "body": "Please add description for parameter and exception class. IDEA highlights absence of a comment as a warning. Applicable to several more places in the test class.", "bodyText": "Please add description for parameter and exception class. IDEA highlights absence of a comment as a warning. Applicable to several more places in the test class.", "bodyHTML": "<p dir=\"auto\">Please add description for parameter and exception class. IDEA highlights absence of a comment as a warning. Applicable to several more places in the test class.</p>", "author": "glukos", "createdAt": "2020-07-06T11:05:49Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODAwNg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450148006", "bodyText": "", "author": "glukos", "createdAt": "2020-07-06T11:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0Nzg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTM4Ng==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205386", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0Nzg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -112,12 +103,10 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n      * </ul>\n      *\n-     * @param testSyncMode\n-     * @throws Exception\n+     * @throws Exception If failed\n      */\n-    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n-        syncMode = testSyncMode;\n-\n+    @Test\n+    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n         startGrids(2);\n \n         grid(0).cluster().active(true);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -112,12 +104,10 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n      * </ul>\n      *\n-     * @param testSyncMode\n-     * @throws Exception\n+     * @throws Exception If failed\n      */\n-    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n-        syncMode = testSyncMode;\n-\n+    @Test\n+    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n         startGrids(2);\n \n         grid(0).cluster().active(true);\n", "next_change": {"commit": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..404bf97f16a 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -106,8 +133,7 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      *\n      * @throws Exception If failed\n      */\n-    @Test\n-    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+    private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n         startGrids(2);\n \n         grid(0).cluster().active(true);\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 404bf97f16a..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -134,98 +151,170 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      * @throws Exception If failed\n      */\n     private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n-        startGrids(2);\n+        IgniteEx grid0 = startGrids(2);\n \n-        grid(0).cluster().active(true);\n+        grid0.cluster().state(ClusterState.ACTIVE);\n \n-        IgniteEx grid0 = grid(0);\n         IgniteEx grid1 = grid(1);\n \n-        int key0 = 0;\n-        int key1 = 0;\n+        int key0 = primaryKey(grid0.cache(DEFAULT_CACHE_NAME));\n+        int key1 = primaryKey(grid1.cache(DEFAULT_CACHE_NAME));\n \n-        Affinity<Object> aff = grid1.affinity(\"cache\");\n+        Affinity<Object> aff = grid1.affinity(DEFAULT_CACHE_NAME);\n \n-        for (int i = 1; i < 1000; i++) {\n-            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n-                key0 = i;\n+        assertFalse(\n+            \"Keys have the same mapping [key0=\" + key0 + \", key1=\" + key1 + ']',\n+            aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1))\n+        );\n \n-                break;\n-            }\n-        }\n+        spi(grid0).blockMessages(GridNearTxFinishResponse.class, getTestIgniteInstanceName(1));\n \n-        for (int i = key0; i < 1000; i++) {\n-            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n-                key1 = i;\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(grid0).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n+                }\n \n-                break;\n-            }\n-        }\n+                info(\"Stopping node: [\" + grid0.name() + ']');\n+\n+                grid0.close();\n \n-        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+            },\n+            \"node-stopper\"\n+        );\n \n         try (Transaction tx = grid1.transactions().txStart()) {\n-            grid1.cache(\"cache\").put(key0, 100);\n-            grid1.cache(\"cache\").put(key1, 200);\n-\n-            spi(grid0).blockMessages((node, msg) -> {\n-                    if (msg instanceof GridNearTxFinishResponse) {\n-                        new Thread(\n-                            new Runnable() {\n-                                @Override public void run() {\n-                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n-\n-                                    IgnitionEx.stop(grid0.name(), true, null, true);\n-                                }\n-                            },\n-                            \"node-stopper\"\n-                        ).start();\n-\n-                        return true;\n-                    }\n-\n-                    return false;\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key0, 100);\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key1, 200);\n+\n+            tx.commit();\n+\n+            fail(\"Transaction passed, but no one partition is alive.\");\n+\n+        }\n+        catch (Exception e) {\n+            assertTrue(X.hasCause(e, CacheInvalidStateException.class));\n+\n+            String msg = e.getMessage();\n+\n+            assertTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+            if (!mvccEnabled(grid1.context())) {\n+                Pattern msgPtrn;\n+\n+                if (S.getSensitiveDataLogging() == PLAIN) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+                }\n+                else if (S.getSensitiveDataLogging() == HASH) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=\" + IgniteUtils.hash(key0) + \"\\\\]\");\n+                }\n+                else {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObject\\\\]\");\n                 }\n-            );\n \n-            boolean passed = false;\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n-            try {\n-                tx.commit();\n+                assertTrue(\"Message does not match: [msg=\" + msg + ']', matcher.find());\n             }\n-            catch (Throwable e) {\n-                String msg = e.getMessage();\n+        }\n \n-                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+        stopNodeFut.get(10_000);\n+    }\n \n-                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+    /**\n+     * Test checks the all node leave detector when cache has backups enough.\n+     *\n+     * @throws Exception If failed.\n+     */\n+    @Test\n+    public void cacheWithBackups() throws Exception {\n+        backups = 2;\n+\n+        IgniteEx ignite0 = startGrids(3);\n+\n+        ignite0.cluster().state(ClusterState.ACTIVE);\n+\n+        IgniteEx client = startClientGrid(CLIENT);\n \n-                if (!mvccEnabled(grid1.context())) {\n-                    Pattern msgPtrn;\n+        awaitPartitionMapExchange();\n \n-                    if (S.getSensitiveDataLogging() == PLAIN) {\n-                        msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                                \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n-                                \", hasValBytes=true\\\\]\\\\]\");\n-                    }\n-                    else if (S.getSensitiveDataLogging() == HASH) {\n-                        msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                                \"key=\" + IgniteUtils.hash(key0) + \"\\\\]\");\n-                    }\n-                    else {\n-                        msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                                \"key=KeyCacheObject\\\\]\");\n-                    }\n+        int key = primaryKey(ignite(1).cache(DEFAULT_CACHE_NAME));\n \n-                    Matcher matcher = msgPtrn.matcher(msg);\n+        spi(ignite(1)).blockMessages(GridNearTxFinishResponse.class, CLIENT);\n \n-                    Assert.isTrue(matcher.find(), msg);\n+        spi(ignite(2)).blockMessages(GridDhtTxFinishResponse.class, CLIENT);\n+\n+        new TestDiscoveryNodeLeftListener(CLIENT);\n+\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(ignite(1)).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n                 }\n \n-                passed = true;\n-            }\n+                info(\"Stopping node: [\" + ignite(2).name() + ']');\n+\n+                ignite(2).close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n+\n+        try (Transaction tx = client.transactions().txStart()) {\n+            client.cache(DEFAULT_CACHE_NAME).put(key, 100);\n+\n+            tx.commit();\n+        }\n+        catch (Exception e) {\n+            log.error(\"Transaction was not committed.\", e);\n+\n+            fail(\"Transaction should be committed while at last one owner present [err=\" + e.getMessage() + ']');\n+        }\n+\n+        assertEquals(100, client.cache(DEFAULT_CACHE_NAME).get(key));\n+\n+        stopNodeFut.get(10_000);\n+    }\n+\n+    /**\n+     * A test discovery listener to freeze handling node left events.\n+     */\n+    private class TestDiscoveryNodeLeftListener implements DiscoveryEventListener, HighPriorityListener {\n+        /** Name node to subscribe listener. */\n+        private final String nodeToSubscribe;\n+\n+        /**\n+         * @param nodeToSubscribe Node to subscribe.\n+         */\n+        public TestDiscoveryNodeLeftListener(String nodeToSubscribe) {\n+            this.nodeToSubscribe = nodeToSubscribe;\n+\n+            grid(nodeToSubscribe).context().event().addDiscoveryEventListener(this, TYPES);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onEvent(DiscoveryEvent evt, DiscoCache discoCache) {\n+            info(\"Stopping node: [\" + ignite(1).name() + ']');\n+\n+            ignite(1).close();\n+\n+            grid(nodeToSubscribe).context().event().removeDiscoveryEventListener(this, TYPES);\n+        }\n \n-            Assert.isTrue(passed);\n+        /** {@inheritDoc} */\n+        @Override public int order() {\n+            return 0;\n         }\n     }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODgzMA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450148830", "body": "Let's use cleanPersistenceDir();\r\nAttempt to clean the whole work dir may fail locally (e.g. if I have a log file opened).", "bodyText": "Let's use cleanPersistenceDir();\nAttempt to clean the whole work dir may fail locally (e.g. if I have a log file opened).", "bodyHTML": "<p dir=\"auto\">Let's use cleanPersistenceDir();<br>\nAttempt to clean the whole work dir may fail locally (e.g. if I have a log file opened).</p>", "author": "glukos", "createdAt": "2020-07-06T11:08:07Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTQ0MA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205440", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODgzMA=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -71,7 +80,7 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n     @Override protected void beforeTest() throws Exception {\n         super.beforeTest();\n \n-        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+        cleanPersistenceDir();\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -71,7 +81,7 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n     @Override protected void beforeTest() throws Exception {\n         super.beforeTest();\n \n-        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+        cleanPersistenceDir();\n     }\n \n     /** {@inheritDoc} */\n", "next_change": null}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0OTM4Mg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450149382", "body": "If it's possible, extract message in TX code as a public static final constant use reuse it in this test. If someone has to change the message, this test will fail.", "bodyText": "If it's possible, extract message in TX code as a public static final constant use reuse it in this test. If someone has to change the message, this test will fail.", "bodyHTML": "<p dir=\"auto\">If it's possible, extract message in TX code as a public static final constant use reuse it in this test. If someone has to change the message, this test will fail.</p>", "author": "glukos", "createdAt": "2020-07-06T11:09:24Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode\n+     * @throws Exception\n+     */\n+    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n+        syncMode = testSyncMode;\n+\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key1).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n+\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n+                            },\n+                            \"node-stopper\"\n+                        ).start();\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+            );\n+\n+            try {\n+                tx.commit();\n+            }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+\n+                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTQ4MQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205481", "bodyText": "partly fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0OTM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a7b455d946d866ead689fb078b3d07c56ee0489a", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..d5a03d207c3 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -180,14 +171,19 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n \n                 Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n \n-                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +\n-                    \"partition data has been lost\\\\) \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                    \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 + \", hasValBytes=true\\\\]\\\\]\");\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                    \", hasValBytes=true\\\\]\\\\]\");\n \n-                Matcher matcher = msgPattern.matcher(msg);\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n                 Assert.isTrue(matcher.find());\n+\n+                passed = true;\n             }\n+\n+            Assert.isTrue(passed);\n         }\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex d5a03d207c3..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -186,4 +189,4 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             Assert.isTrue(passed);\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex cacb9e6a73b..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -180,14 +172,21 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n \n                 Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n \n-                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +\n-                    \"partition data has been lost\\\\) \\\\[cacheName=cache, partition=\\\\d+, \" +\n-                    \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 + \", hasValBytes=true\\\\]\\\\]\");\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n \n-                Matcher matcher = msgPattern.matcher(msg);\n+                if (!mvccEnabled(grid1.context())) {\n+                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n \n-                Assert.isTrue(matcher.find());\n+                    Matcher matcher = msgPtrn.matcher(msg);\n+\n+                    Assert.isTrue(matcher.find());\n+                }\n+\n+                passed = true;\n             }\n+\n+            Assert.isTrue(passed);\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -106,87 +150,171 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      *\n      * @throws Exception If failed\n      */\n-    @Test\n-    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n-        startGrids(2);\n+    private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+        IgniteEx grid0 = startGrids(2);\n \n-        grid(0).cluster().active(true);\n+        grid0.cluster().state(ClusterState.ACTIVE);\n \n-        IgniteEx grid0 = grid(0);\n         IgniteEx grid1 = grid(1);\n \n-        int key0 = 0;\n-        int key1 = 0;\n+        int key0 = primaryKey(grid0.cache(DEFAULT_CACHE_NAME));\n+        int key1 = primaryKey(grid1.cache(DEFAULT_CACHE_NAME));\n \n-        Affinity<Object> aff = grid1.affinity(\"cache\");\n+        Affinity<Object> aff = grid1.affinity(DEFAULT_CACHE_NAME);\n \n-        for (int i = 1; i < 1000; i++) {\n-            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n-                key0 = i;\n+        assertFalse(\n+            \"Keys have the same mapping [key0=\" + key0 + \", key1=\" + key1 + ']',\n+            aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1))\n+        );\n \n-                break;\n-            }\n-        }\n+        spi(grid0).blockMessages(GridNearTxFinishResponse.class, getTestIgniteInstanceName(1));\n \n-        for (int i = key0; i < 1000; i++) {\n-            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n-                key1 = i;\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(grid0).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n+                }\n \n-                break;\n-            }\n-        }\n+                info(\"Stopping node: [\" + grid0.name() + ']');\n \n-        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+                grid0.close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n \n         try (Transaction tx = grid1.transactions().txStart()) {\n-            grid1.cache(\"cache\").put(key0, 100);\n-            grid1.cache(\"cache\").put(key1, 200);\n-\n-            spi(grid0).blockMessages((node, msg) -> {\n-                    if (msg instanceof GridNearTxFinishResponse) {\n-                        new Thread(\n-                            new Runnable() {\n-                                @Override public void run() {\n-                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n-\n-                                    IgnitionEx.stop(grid0.name(), true, null, true);\n-                                }\n-                            },\n-                            \"node-stopper\"\n-                        ).start();\n-\n-                        return true;\n-                    }\n-\n-                    return false;\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key0, 100);\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key1, 200);\n+\n+            tx.commit();\n+\n+            fail(\"Transaction passed, but no one partition is alive.\");\n+\n+        }\n+        catch (Exception e) {\n+            assertTrue(X.hasCause(e, CacheInvalidStateException.class));\n+\n+            String msg = e.getMessage();\n+\n+            assertTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+            if (!mvccEnabled(grid1.context())) {\n+                Pattern msgPtrn;\n+\n+                if (S.getSensitiveDataLogging() == PLAIN) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+                }\n+                else if (S.getSensitiveDataLogging() == HASH) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=\" + IgniteUtils.hash(key0) + \"\\\\]\");\n+                }\n+                else {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObject\\\\]\");\n                 }\n-            );\n \n-            boolean passed = false;\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n-            try {\n-                tx.commit();\n+                assertTrue(\"Message does not match: [msg=\" + msg + ']', matcher.find());\n             }\n-            catch (Throwable e) {\n-                String msg = e.getMessage();\n+        }\n \n-                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+        stopNodeFut.get(10_000);\n+    }\n \n-                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+    /**\n+     * Test checks the all node leave detector when cache has backups enough.\n+     *\n+     * @throws Exception If failed.\n+     */\n+    @Test\n+    public void cacheWithBackups() throws Exception {\n+        backups = 2;\n \n-                if (!mvccEnabled(grid1.context())) {\n-                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n-                        \", hasValBytes=true\\\\]\\\\]\");\n+        IgniteEx ignite0 = startGrids(3);\n+\n+        ignite0.cluster().state(ClusterState.ACTIVE);\n+\n+        IgniteEx client = startClientGrid(CLIENT);\n \n-                    Matcher matcher = msgPtrn.matcher(msg);\n+        awaitPartitionMapExchange();\n \n-                    Assert.isTrue(matcher.find());\n+        int key = primaryKey(ignite(1).cache(DEFAULT_CACHE_NAME));\n+\n+        spi(ignite(1)).blockMessages(GridNearTxFinishResponse.class, CLIENT);\n+\n+        spi(ignite(2)).blockMessages(GridDhtTxFinishResponse.class, CLIENT);\n+\n+        new TestDiscoveryNodeLeftListener(CLIENT);\n+\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(ignite(1)).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n                 }\n \n-                passed = true;\n-            }\n+                info(\"Stopping node: [\" + ignite(2).name() + ']');\n+\n+                ignite(2).close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n+\n+        try (Transaction tx = client.transactions().txStart()) {\n+            client.cache(DEFAULT_CACHE_NAME).put(key, 100);\n+\n+            tx.commit();\n+        }\n+        catch (Exception e) {\n+            log.error(\"Transaction was not committed.\", e);\n+\n+            fail(\"Transaction should be committed while at last one owner present [err=\" + e.getMessage() + ']');\n+        }\n+\n+        assertEquals(100, client.cache(DEFAULT_CACHE_NAME).get(key));\n+\n+        stopNodeFut.get(10_000);\n+    }\n+\n+    /**\n+     * A test discovery listener to freeze handling node left events.\n+     */\n+    private class TestDiscoveryNodeLeftListener implements DiscoveryEventListener, HighPriorityListener {\n+        /** Name node to subscribe listener. */\n+        private final String nodeToSubscribe;\n+\n+        /**\n+         * @param nodeToSubscribe Node to subscribe.\n+         */\n+        public TestDiscoveryNodeLeftListener(String nodeToSubscribe) {\n+            this.nodeToSubscribe = nodeToSubscribe;\n+\n+            grid(nodeToSubscribe).context().event().addDiscoveryEventListener(this, TYPES);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onEvent(DiscoveryEvent evt, DiscoCache discoCache) {\n+            info(\"Stopping node: [\" + ignite(1).name() + ']');\n+\n+            ignite(1).close();\n+\n+            grid(nodeToSubscribe).context().event().removeDiscoveryEventListener(this, TYPES);\n+        }\n \n-            Assert.isTrue(passed);\n+        /** {@inheritDoc} */\n+        @Override public int order() {\n+            return 0;\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"oid": "a7b455d946d866ead689fb078b3d07c56ee0489a", "url": "https://github.com/gridgain/gridgain/commit/a7b455d946d866ead689fb078b3d07c56ee0489a", "message": "GG-27999 fix after review", "committedDate": "2020-07-06T13:02:32Z", "type": "commit"}, {"oid": "5c6e1edad430c9c04ca6958f0a9324710ad0ee94", "url": "https://github.com/gridgain/gridgain/commit/5c6e1edad430c9c04ca6958f0a9324710ad0ee94", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-27999", "committedDate": "2020-07-06T19:32:33Z", "type": "commit"}, {"oid": "f290ab81a6fca7969b2d61bbd3740d8804d899a6", "url": "https://github.com/gridgain/gridgain/commit/f290ab81a6fca7969b2d61bbd3740d8804d899a6", "message": "GG-27999 workaround for mvcc suite", "committedDate": "2020-07-07T12:59:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3MTc3OQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450871779", "body": "Missing new line ?", "bodyText": "Missing new line ?", "bodyHTML": "<p dir=\"auto\">Missing new line ?</p>", "author": "ascherbakoff", "createdAt": "2020-07-07T13:39:47Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n+import static org.apache.ignite.internal.processors.cache.mvcc.MvccUtils.mvccEnabled;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+@RunWith(Parameterized.class)\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n+    /** syncMode */\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache, without backups, with {@link IgniteTxExceptionNodeFailTest#syncMode}\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @throws Exception If failed\n+     */\n+    @Test\n+    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n+\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n+                            },\n+                            \"node-stopper\"\n+                        ).start();\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+            );\n+\n+            boolean passed = false;\n+\n+            try {\n+                tx.commit();\n+            }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                if (!mvccEnabled(grid1.context())) {\n+                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+\n+                    Matcher matcher = msgPtrn.matcher(msg);\n+\n+                    Assert.isTrue(matcher.find());\n+                }\n+\n+                passed = true;\n+            }\n+\n+            Assert.isTrue(passed);\n+        }\n+    }\n+}", "originalCommit": "f290ab81a6fca7969b2d61bbd3740d8804d899a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex e1812508a32..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -189,4 +189,4 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             Assert.isTrue(passed);\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex e1812508a32..0f9eb0a8b4c 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -189,4 +189,4 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n             Assert.isTrue(passed);\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\nindex 0f9eb0a8b4c..1a46150c71e 100644\n--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java\n", "chunk": "@@ -106,87 +150,171 @@ public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n      *\n      * @throws Exception If failed\n      */\n-    @Test\n-    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n-        startGrids(2);\n+    private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+        IgniteEx grid0 = startGrids(2);\n \n-        grid(0).cluster().active(true);\n+        grid0.cluster().state(ClusterState.ACTIVE);\n \n-        IgniteEx grid0 = grid(0);\n         IgniteEx grid1 = grid(1);\n \n-        int key0 = 0;\n-        int key1 = 0;\n+        int key0 = primaryKey(grid0.cache(DEFAULT_CACHE_NAME));\n+        int key1 = primaryKey(grid1.cache(DEFAULT_CACHE_NAME));\n \n-        Affinity<Object> aff = grid1.affinity(\"cache\");\n+        Affinity<Object> aff = grid1.affinity(DEFAULT_CACHE_NAME);\n \n-        for (int i = 1; i < 1000; i++) {\n-            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n-                key0 = i;\n+        assertFalse(\n+            \"Keys have the same mapping [key0=\" + key0 + \", key1=\" + key1 + ']',\n+            aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1))\n+        );\n \n-                break;\n-            }\n-        }\n+        spi(grid0).blockMessages(GridNearTxFinishResponse.class, getTestIgniteInstanceName(1));\n \n-        for (int i = key0; i < 1000; i++) {\n-            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n-                key1 = i;\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(grid0).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n+                }\n \n-                break;\n-            }\n-        }\n+                info(\"Stopping node: [\" + grid0.name() + ']');\n \n-        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+                grid0.close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n \n         try (Transaction tx = grid1.transactions().txStart()) {\n-            grid1.cache(\"cache\").put(key0, 100);\n-            grid1.cache(\"cache\").put(key1, 200);\n-\n-            spi(grid0).blockMessages((node, msg) -> {\n-                    if (msg instanceof GridNearTxFinishResponse) {\n-                        new Thread(\n-                            new Runnable() {\n-                                @Override public void run() {\n-                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n-\n-                                    IgnitionEx.stop(grid0.name(), true, null, true);\n-                                }\n-                            },\n-                            \"node-stopper\"\n-                        ).start();\n-\n-                        return true;\n-                    }\n-\n-                    return false;\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key0, 100);\n+            grid1.cache(DEFAULT_CACHE_NAME).put(key1, 200);\n+\n+            tx.commit();\n+\n+            fail(\"Transaction passed, but no one partition is alive.\");\n+\n+        }\n+        catch (Exception e) {\n+            assertTrue(X.hasCause(e, CacheInvalidStateException.class));\n+\n+            String msg = e.getMessage();\n+\n+            assertTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+            if (!mvccEnabled(grid1.context())) {\n+                Pattern msgPtrn;\n+\n+                if (S.getSensitiveDataLogging() == PLAIN) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+                }\n+                else if (S.getSensitiveDataLogging() == HASH) {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=\" + IgniteUtils.hash(key0) + \"\\\\]\");\n+                }\n+                else {\n+                    msgPtrn = Pattern.compile(\" \\\\[cacheName=\" + DEFAULT_CACHE_NAME +\n+                        \", partition=\\\\d+, \" +\n+                        \"key=KeyCacheObject\\\\]\");\n                 }\n-            );\n \n-            boolean passed = false;\n+                Matcher matcher = msgPtrn.matcher(msg);\n \n-            try {\n-                tx.commit();\n+                assertTrue(\"Message does not match: [msg=\" + msg + ']', matcher.find());\n             }\n-            catch (Throwable e) {\n-                String msg = e.getMessage();\n+        }\n \n-                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+        stopNodeFut.get(10_000);\n+    }\n \n-                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+    /**\n+     * Test checks the all node leave detector when cache has backups enough.\n+     *\n+     * @throws Exception If failed.\n+     */\n+    @Test\n+    public void cacheWithBackups() throws Exception {\n+        backups = 2;\n \n-                if (!mvccEnabled(grid1.context())) {\n-                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n-                        \", hasValBytes=true\\\\]\\\\]\");\n+        IgniteEx ignite0 = startGrids(3);\n+\n+        ignite0.cluster().state(ClusterState.ACTIVE);\n+\n+        IgniteEx client = startClientGrid(CLIENT);\n \n-                    Matcher matcher = msgPtrn.matcher(msg);\n+        awaitPartitionMapExchange();\n \n-                    Assert.isTrue(matcher.find());\n+        int key = primaryKey(ignite(1).cache(DEFAULT_CACHE_NAME));\n+\n+        spi(ignite(1)).blockMessages(GridNearTxFinishResponse.class, CLIENT);\n+\n+        spi(ignite(2)).blockMessages(GridDhtTxFinishResponse.class, CLIENT);\n+\n+        new TestDiscoveryNodeLeftListener(CLIENT);\n+\n+        IgniteInternalFuture stopNodeFut = GridTestUtils.runAsync(() -> {\n+                try {\n+                    spi(ignite(1)).waitForBlocked();\n+                }\n+                catch (InterruptedException e) {\n+                    log.error(\"Waiting is interrupted.\", e);\n                 }\n \n-                passed = true;\n-            }\n+                info(\"Stopping node: [\" + ignite(2).name() + ']');\n+\n+                ignite(2).close();\n+\n+            },\n+            \"node-stopper\"\n+        );\n+\n+        try (Transaction tx = client.transactions().txStart()) {\n+            client.cache(DEFAULT_CACHE_NAME).put(key, 100);\n+\n+            tx.commit();\n+        }\n+        catch (Exception e) {\n+            log.error(\"Transaction was not committed.\", e);\n+\n+            fail(\"Transaction should be committed while at last one owner present [err=\" + e.getMessage() + ']');\n+        }\n+\n+        assertEquals(100, client.cache(DEFAULT_CACHE_NAME).get(key));\n+\n+        stopNodeFut.get(10_000);\n+    }\n+\n+    /**\n+     * A test discovery listener to freeze handling node left events.\n+     */\n+    private class TestDiscoveryNodeLeftListener implements DiscoveryEventListener, HighPriorityListener {\n+        /** Name node to subscribe listener. */\n+        private final String nodeToSubscribe;\n+\n+        /**\n+         * @param nodeToSubscribe Node to subscribe.\n+         */\n+        public TestDiscoveryNodeLeftListener(String nodeToSubscribe) {\n+            this.nodeToSubscribe = nodeToSubscribe;\n+\n+            grid(nodeToSubscribe).context().event().addDiscoveryEventListener(this, TYPES);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void onEvent(DiscoveryEvent evt, DiscoCache discoCache) {\n+            info(\"Stopping node: [\" + ignite(1).name() + ']');\n+\n+            ignite(1).close();\n+\n+            grid(nodeToSubscribe).context().event().removeDiscoveryEventListener(this, TYPES);\n+        }\n \n-            Assert.isTrue(passed);\n+        /** {@inheritDoc} */\n+        @Override public int order() {\n+            return 0;\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}]}, {"oid": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "url": "https://github.com/gridgain/gridgain/commit/673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "message": "GG-27999 fix", "committedDate": "2020-07-07T14:25:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxMTI4OA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r451511288", "body": "Too much of lines.\r\nThis can be simplified to something like:\r\n\r\n```\r\nif (concat(of(m.primary().id()), m.backups().stream()).noneMatch(uuid -> cctx.discovery().alive(uuid))) {\r\n                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\r\n                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\r\n                            \", partition=\" + e.key().partition() +\r\n                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\r\n                            \"]\").findFirst().orElse(\"\")));\r\n\r\n                    return true;\r\n}\r\n```", "bodyText": "Too much of lines.\nThis can be simplified to something like:\nif (concat(of(m.primary().id()), m.backups().stream()).noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n                            \", partition=\" + e.key().partition() +\n                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n                            \"]\").findFirst().orElse(\"\")));\n\n                    return true;\n}", "bodyHTML": "<p dir=\"auto\">Too much of lines.<br>\nThis can be simplified to something like:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (concat(of(m.primary().id()), m.backups().stream()).noneMatch(uuid -&gt; cctx.discovery().alive(uuid))) {\n                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                        m.entries().stream().map(e -&gt; &quot; [cacheName=&quot; + e.cached().context().name() +\n                            &quot;, partition=&quot; + e.key().partition() +\n                            (S.includeSensitive() ? &quot;, key=&quot; + e.key() : &quot;&quot;) +\n                            &quot;]&quot;).findFirst().orElse(&quot;&quot;)));\n\n                    return true;\n}\"><pre><code>if (concat(of(m.primary().id()), m.backups().stream()).noneMatch(uuid -&gt; cctx.discovery().alive(uuid))) {\n                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                        m.entries().stream().map(e -&gt; \" [cacheName=\" + e.cached().context().name() +\n                            \", partition=\" + e.key().partition() +\n                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n                            \"]\").findFirst().orElse(\"\")));\n\n                    return true;\n}\n</code></pre></div>", "author": "ascherbakoff", "createdAt": "2020-07-08T12:37:34Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,6 +987,36 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+\n+                Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                boolean hasBackups = false;\n+\n+                if (backups != null)\n+                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n+\n+                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n+                    String strTxEntry = \"\";\n+\n+                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n+\n+                    if (entryIter.hasNext()) {\n+                        IgniteTxEntry firstTxEntry = entryIter.next();\n+\n+                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n+                            \", partition=\" + firstTxEntry.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n+                            \"]\";\n+                    }\n+\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG + strTxEntry));\n+\n+                    return true;\n+                }\n+            }", "originalCommit": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93460ec63751bfb067e5871c2e1ecea08df70d87", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex ed562a5afa1..f1949128206 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -988,30 +988,12 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-\n-                Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                boolean hasBackups = false;\n-\n-                if (backups != null)\n-                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n-\n-                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n-                    String strTxEntry = \"\";\n-\n-                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n-\n-                    if (entryIter.hasNext()) {\n-                        IgniteTxEntry firstTxEntry = entryIter.next();\n-\n-                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n-                            \", partition=\" + firstTxEntry.key().partition() +\n-                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n-                            \"]\";\n-                    }\n-\n-                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG + strTxEntry));\n+                if (concat(of(m.primary().id()), tx.transactionNodes().get(nodeId).stream()).noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n+                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n+                            \", partition=\" + e.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n+                            \"]\").findFirst().orElse(\"\")));\n \n                     return true;\n                 }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex ed562a5afa1..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -988,30 +989,13 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n-\n-                Collection<UUID> backups = txNodes.get(nodeId);\n-\n-                boolean hasBackups = false;\n-\n-                if (backups != null)\n-                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n-\n-                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n-                    String strTxEntry = \"\";\n-\n-                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n-\n-                    if (entryIter.hasNext()) {\n-                        IgniteTxEntry firstTxEntry = entryIter.next();\n-\n-                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n-                            \", partition=\" + firstTxEntry.key().partition() +\n-                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n-                            \"]\";\n-                    }\n-\n-                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG + strTxEntry));\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n+                    .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n+                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n+                            \", partition=\" + e.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n+                            \"]\").findFirst().orElse(\"\")));\n \n                     return true;\n                 }\n", "next_change": {"commit": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 42af4c3ffd5..fa66a6b054b 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -993,8 +989,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                     .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                     onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                         m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n-                            \", partition=\" + e.key().partition() +\n-                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n+                            \", partition=\" + e.key().partition() + \", key=\" + e.key() +\n                             \"]\").findFirst().orElse(\"\")));\n \n                     return true;\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex fa66a6b054b..501dba955cc 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -985,7 +985,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(m.primary().id(), emptySet()).stream())\n                     .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                     onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                         m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fde59079a307ffe401b00d6f157c13ea22e6dec0", "committedDate": "2020-08-29 20:30:09 +0300", "message": "GG-21041 Tracing: atomic cache.get() flow."}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}, {"oid": "542de83c1e7d45061bb31f2f9a533fd31d1e51b4", "committedDate": "2021-06-25 17:36:33 +0300", "message": "GG-33365 Contention in lock on Compound future."}]}, {"oid": "93460ec63751bfb067e5871c2e1ecea08df70d87", "url": "https://github.com/gridgain/gridgain/commit/93460ec63751bfb067e5871c2e1ecea08df70d87", "message": "GG-27999 fix after review", "committedDate": "2020-07-08T14:50:23Z", "type": "commit"}, {"oid": "1222baf7e4dc2472dcae6ada7484fcbb844977ad", "url": "https://github.com/gridgain/gridgain/commit/1222baf7e4dc2472dcae6ada7484fcbb844977ad", "message": "GG-27999 fix after review", "committedDate": "2020-07-08T16:19:40Z", "type": "commit"}, {"oid": "47b8762a9e01671bff202a7a7d17d35086bcf782", "url": "https://github.com/gridgain/gridgain/commit/47b8762a9e01671bff202a7a7d17d35086bcf782", "message": "GG-27999 fix after review", "committedDate": "2020-07-09T07:46:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY2NjQzMg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r452666432", "body": "Weird code, must be:\r\nOptional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream()) -> tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream()\r\n\r\nNever forget about static imports codestyle rule.", "bodyText": "Weird code, must be:\nOptional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream()) -> tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream()\nNever forget about static imports codestyle rule.", "bodyHTML": "<p dir=\"auto\">Weird code, must be:<br>\nOptional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream()) -&gt; tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream()</p>\n<p dir=\"auto\">Never forget about static imports codestyle rule.</p>", "author": "ascherbakoff", "createdAt": "2020-07-10T07:18:06Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,6 +988,19 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                if (concat(of(m.primary().id()), Optional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream())", "originalCommit": "47b8762a9e01671bff202a7a7d17d35086bcf782", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f360b83757f50974a04f78a17319e00aed2a8772", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 295193e984c..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -989,7 +989,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                if (concat(of(m.primary().id()), Optional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream())\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n                     .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                     onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                         m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 295193e984c..42af4c3ffd5 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -989,7 +989,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                if (concat(of(m.primary().id()), Optional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream())\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n                     .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                     onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                         m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n", "next_change": {"commit": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex 42af4c3ffd5..fa66a6b054b 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -993,8 +989,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n                     .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                     onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                         m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n-                            \", partition=\" + e.key().partition() +\n-                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n+                            \", partition=\" + e.key().partition() + \", key=\" + e.key() +\n                             \"]\").findFirst().orElse(\"\")));\n \n                     return true;\n", "next_change": {"commit": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "changed_code": [{"header": "diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\nindex fa66a6b054b..501dba955cc 100644\n--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java\n", "chunk": "@@ -985,7 +985,7 @@ public final class GridNearTxFinishFuture<K, V> extends GridCacheCompoundIdentit\n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n             if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n-                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream())\n+                if (concat(of(m.primary().id()), tx.transactionNodes().getOrDefault(m.primary().id(), emptySet()).stream())\n                     .noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                     onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                         m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "0744365bfa77ce0eef37b1ab8801e6e6c070f505", "message": "Merge commit", "committedDate": null}, {"oid": "fde59079a307ffe401b00d6f157c13ea22e6dec0", "committedDate": "2020-08-29 20:30:09 +0300", "message": "GG-21041 Tracing: atomic cache.get() flow."}, {"oid": "fee7c275f6cb26d7fe79936d008a180bd17f001b", "committedDate": "2020-12-29 10:09:27 +0300", "message": "GG-30501 Added IGNITE_SENSITIVE_DATA_LOGGING system property with possible values: \"plain\", \"hash\", \"none\". Deprecated IGNITE_TO_STRING_INCLUDE_SENSITIVE system property."}, {"oid": "e542250e523fc5dbfc15df3f9c3ad1eca7774596", "committedDate": "2021-01-25 11:14:16 +0300", "message": "GG-32451 False alarm to lose all transaction nodes (#1729)"}, {"oid": "542de83c1e7d45061bb31f2f9a533fd31d1e51b4", "committedDate": "2021-06-25 17:36:33 +0300", "message": "GG-33365 Contention in lock on Compound future."}]}, {"oid": "f360b83757f50974a04f78a17319e00aed2a8772", "url": "https://github.com/gridgain/gridgain/commit/f360b83757f50974a04f78a17319e00aed2a8772", "message": "GG-27999 fix after review", "committedDate": "2020-07-10T07:34:29Z", "type": "commit"}]}