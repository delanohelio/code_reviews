{"pr_number": 367, "pr_title": "Report date data as a standardized format", "pr_author": "jordanw-bq", "pr_createdAt": "2020-02-15T00:06:42Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367", "timeline": [{"oid": "8bd01ac795d1ebb0e4a7e7380e4a66e2f0a48cde", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/8bd01ac795d1ebb0e4a7e7380e4a66e2f0a48cde", "message": "expose date fields using a standardized date format", "committedDate": "2020-02-13T00:33:26Z", "type": "commit"}, {"oid": "c9c797314f8160d667d9a2e4312647eb5e5d7aca", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c9c797314f8160d667d9a2e4312647eb5e5d7aca", "message": "move date format logic to new class", "committedDate": "2020-02-14T21:25:09Z", "type": "commit"}, {"oid": "795a0bb91a034adb768c365b2d56a581c6f54b29", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/795a0bb91a034adb768c365b2d56a581c6f54b29", "message": "add tests for DateTimeFormatter", "committedDate": "2020-02-14T23:39:18Z", "type": "commit"}, {"oid": "1afa19283cc0cfc57e50a398df1fe1b278ef911d", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/1afa19283cc0cfc57e50a398df1fe1b278ef911d", "message": "added some negative tests", "committedDate": "2020-02-14T23:50:29Z", "type": "commit"}, {"oid": "b220ce4dd17c06ec1841924fb91e1d6b01fe91bc", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/b220ce4dd17c06ec1841924fb91e1d6b01fe91bc", "message": "style fixes", "committedDate": "2020-02-15T00:18:58Z", "type": "commit"}, {"oid": "2ae4195a41419305c44483944bae841795d59393", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/2ae4195a41419305c44483944bae841795d59393", "message": "testing locale fixes", "committedDate": "2020-02-18T19:35:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NDY4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r381644682", "body": "Please rename to follow Java convention CamelCase. To make it shorter, I think you can remove prefix `testApplyJDBCDateFormat_`, ex. `testEpochSecond()`, `testBasicDate()` etc.", "bodyText": "Please rename to follow Java convention CamelCase. To make it shorter, I think you can remove prefix testApplyJDBCDateFormat_, ex. testEpochSecond(), testBasicDate() etc.", "bodyHTML": "<p dir=\"auto\">Please rename to follow Java convention CamelCase. To make it shorter, I think you can remove prefix <code>testApplyJDBCDateFormat_</code>, ex. <code>testEpochSecond()</code>, <code>testBasicDate()</code> etc.</p>", "author": "dai-chen", "createdAt": "2020-02-20T01:25:02Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatterTest.java", "diffHunk": "@@ -0,0 +1,627 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.junit.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.*;\n+\n+public class DateFieldFormatterTest\n+{\n+\n+  @Test\n+  public void testApplyJDBCDateFormat_kibana_sample_data_ecommerce_order_date()", "originalCommit": "2ae4195a41419305c44483944bae841795d59393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTQ5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382855491", "bodyText": "Renamed", "author": "jordanw-bq", "createdAt": "2020-02-21T23:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NDY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/test/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatterTest.java b/src/test/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatterTest.java\nindex d64c4cd2..b08dc219 100644\n--- a/src/test/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatterTest.java\n+++ b/src/test/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatterTest.java\n", "chunk": "@@ -19,609 +19,675 @@ import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import org.junit.Test;\n \n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n import static org.junit.Assert.*;\n \n-public class DateFieldFormatterTest\n-{\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_kibana_sample_data_ecommerce_order_date()\n-  {\n-    String columnName = \"order_date\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = \"2020-02-24T09:28:48+00:00\";\n-    String expectedDateValue = \"2020-02-24 09:28:48.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_kibana_sample_data_flights_timestamp()\n-  {\n-    String columnName = \"timestamp\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = \"2020-02-03T00:00:00\";\n-    String expectedDateValue = \"2020-02-03 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_kibana_sample_data_logs_utc_date()\n-  {\n-    String columnName = \"utc_date\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = \"2020-02-02T00:39:02.912Z\";\n-    String expectedDateValue = \"2020-02-02 00:39:02.912\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_epochMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.EPOCH_MILLIS;\n-    String originalDateValue = \"727430805000\";\n-    String expectedDateValue = \"1993-01-19 08:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_epochSecond()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.EPOCH_SECOND;\n-    String originalDateValue = \"727430805\";\n-    String expectedDateValue = \"1993-01-19 08:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateOptionalTime_date()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = \"1993-01-19\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateOptionalTime_dateAndTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = \"1993-01-19T00:06:45.123-0800\";\n-    String expectedDateValue = \"1993-01-19 08:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicDate()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_DATE;\n-    String originalDateValue = \"19930119\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicDateTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_DATE_TIME;\n-    String originalDateValue = \"19930119T120645.123-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicDateTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_DATE_TIME_NO_MILLIS;\n-    String originalDateValue = \"19930119T120645-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicOrdinalDate()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_ORDINAL_DATE;\n-    String originalDateValue = \"1993019\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicOrdinalDateTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_ORDINAL_DATE_TIME;\n-    String originalDateValue = \"1993019T120645.123-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicOrdinalDateTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_ORDINAL_DATE_TIME_NO_MILLIS;\n-    String originalDateValue = \"1993019T120645-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_TIME;\n-    String originalDateValue = \"120645.123-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_TIME_NO_MILLIS;\n-    String originalDateValue = \"120645-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicTTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_T_TIME;\n-    String originalDateValue = \"T120645.123-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicTTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_T_TIME_NO_MILLIS;\n-    String originalDateValue = \"T120645-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicWeekDate()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_WEEK_DATE;\n-    String originalDateValue = \"1993W042\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicWeekDateTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_WEEK_DATE_TIME;\n-    String originalDateValue = \"1993W042T120645.123-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_basicWeekDateTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.BASIC_WEEK_DATE_TIME_NO_MILLIS;\n-    String originalDateValue = \"1993W042T120645-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_date()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE;\n-    String originalDateValue = \"1993-01-19\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateHour()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_HOUR;\n-    String originalDateValue = \"1993-01-19T12\";\n-    String expectedDateValue = \"1993-01-19 12:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateHourMinute()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_HOUR_MINUTE;\n-    String originalDateValue = \"1993-01-19T12:06\";\n-    String expectedDateValue = \"1993-01-19 12:06:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateHourMinuteSecond()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_HOUR_MINUTE_SECOND;\n-    String originalDateValue = \"1993-01-19T12:06:45\";\n-    String expectedDateValue = \"1993-01-19 12:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateHourMinuteSecondFraction()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_HOUR_MINUTE_SECOND_FRACTION;\n-    String originalDateValue = \"1993-01-19T12:06:45.123\";\n-    String expectedDateValue = \"1993-01-19 12:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateHourMinuteSecondMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_HOUR_MINUTE_SECOND_MILLIS;\n-    String originalDateValue = \"1993-01-19T12:06:45.123\";\n-    String expectedDateValue = \"1993-01-19 12:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_TIME;\n-    String originalDateValue = \"1993-01-19T12:06:45.123-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_dateTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_TIME_NO_MILLIS;\n-    String originalDateValue = \"1993-01-19T12:06:45-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_hour()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.HOUR;\n-    String originalDateValue = \"12\";\n-    String expectedDateValue = \"1970-01-01 12:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_hourMinute()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.HOUR_MINUTE;\n-    String originalDateValue = \"12:06\";\n-    String expectedDateValue = \"1970-01-01 12:06:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_hourMinuteSecond()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.HOUR_MINUTE_SECOND;\n-    String originalDateValue = \"12:06:45\";\n-    String expectedDateValue = \"1970-01-01 12:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_hourMinuteSecondFraction()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.HOUR_MINUTE_SECOND_FRACTION;\n-    String originalDateValue = \"12:06:45.123\";\n-    String expectedDateValue = \"1970-01-01 12:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_hourMinuteSecondMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.HOUR_MINUTE_SECOND_MILLIS;\n-    String originalDateValue = \"12:06:45.123\";\n-    String expectedDateValue = \"1970-01-01 12:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_ordinalDate()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.ORDINAL_DATE;\n-    String originalDateValue = \"1993-019\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_ordinalDateTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.ORDINAL_DATE_TIME;\n-    String originalDateValue = \"1993-019T12:06:45.123-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_ordinalDateTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.ORDINAL_DATE_TIME_NO_MILLIS;\n-    String originalDateValue = \"1993-019T12:06:45-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_time()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.TIME;\n-    String originalDateValue = \"12:06:45.123-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_timeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.TIME_NO_MILLIS;\n-    String originalDateValue = \"12:06:45-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_tTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.T_TIME;\n-    String originalDateValue = \"T12:06:45.123-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_tTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.T_TIME_NO_MILLIS;\n-    String originalDateValue = \"T12:06:45-0800\";\n-    String expectedDateValue = \"1970-01-01 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_weekDate()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.WEEK_DATE;\n-    String originalDateValue = \"1993-W04-2\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_weekDateTime()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.WEEK_DATE_TIME;\n-    String originalDateValue = \"1993-W04-2T12:06:45.123-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.123\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_weekDateTimeNoMillis()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.WEEK_DATE_TIME_NO_MILLIS;\n-    String originalDateValue = \"1993-W04-2T12:06:45-0800\";\n-    String expectedDateValue = \"1993-01-19 20:06:45.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_weekyear()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.WEEK_YEAR;\n-    String originalDateValue = \"1993\";\n-    String expectedDateValue = \"1993-01-01 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_weekyearWeek()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.WEEKYEAR_WEEK;\n-    String originalDateValue = \"1993-W04\";\n-    String expectedDateValue = \"1993-01-17 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_weekyearWeekDay()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.WEEKYEAR_WEEK_DAY;\n-    String originalDateValue = \"1993-W04-2\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_year()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.YEAR;\n-    String originalDateValue = \"1993\";\n-    String expectedDateValue = \"1993-01-01 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_yearMonth()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.YEAR_MONTH;\n-    String originalDateValue = \"1993-01\";\n-    String expectedDateValue = \"1993-01-01 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_yearMonthDay()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.YEAR_MONTH_DAY;\n-    String originalDateValue = \"1993-01-19\";\n-    String expectedDateValue = \"1993-01-19 00:00:00.000\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_incorrectFormat()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = \"1581724085\";\n-    // Invalid format for date value; should return original value\n-    String expectedDateValue = \"1581724085\";\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  @Test\n-  public void testApplyJDBCDateFormat_nullDateData()\n-  {\n-    String columnName = \"date_field\";\n-    DateFormat dateFormat = DateFormat.DATE_OPTIONAL_TIME;\n-    String originalDateValue = null;\n-    // Nulls should be preserved\n-    String expectedDateValue = null;\n-\n-    verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n-  }\n-\n-  private void verifyFormatting(String columnName, DateFormat dateFormat, String originalDateValue, String expectedDateValue)\n-  {\n-    List<Schema.Column> columns = buildColumnList(columnName);\n-    Map<String, String> dateFieldFormatMap = buildDateFieldFormatMap(columnName, dateFormat);\n-\n-    Map<String, Object> rowSource = new HashMap<>();\n-    rowSource.put(columnName, originalDateValue);\n-\n-    DateFieldFormatter dateFieldFormatter = new DateFieldFormatter(dateFieldFormatMap, columns);\n-    executeFormattingAndCompare(dateFieldFormatter, rowSource, columnName, expectedDateValue);\n-  }\n-\n-  private void executeFormattingAndCompare(\n-      DateFieldFormatter formatter,\n-      Map<String, Object> rowSource,\n-      String columnToCheck,\n-      String expectedDateValue) {\n-    formatter.applyJDBCDateFormat(rowSource);\n-    assertEquals(expectedDateValue, rowSource.get(columnToCheck));\n-  }\n-\n-  private List<Schema.Column> buildColumnList(String columnName) {\n-    return ImmutableList.<Schema.Column>builder()\n-        .add(new Schema.Column(columnName, null, Schema.Type.DATE))\n-        .build();\n-  }\n-\n-  private Map<String, String> buildDateFieldFormatMap(String columnName, DateFormat dateFormat) {\n-    return ImmutableMap.<String, String>builder()\n-        .put(columnName, dateFormat.nameLowerCase())\n-        .build();\n-  }\n-\n+public class DateFieldFormatterTest {\n+\n+    @Test\n+    public void testKibanaSampleDataEcommerceOrderDateField()\n+    {\n+        String columnName = \"order_date\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"2020-02-24T09:28:48+00:00\";\n+        String expectedDateValue = \"2020-02-24 09:28:48.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testKibanaSampleDataFlightsTimestampField()\n+    {\n+        String columnName = \"timestamp\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"2020-02-03T00:00:00\";\n+        String expectedDateValue = \"2020-02-03 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testKibanaSampleDataFlightsTimestampFieldNoTime()\n+    {\n+        String columnName = \"timestamp\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"2020-02-03T\";\n+        String expectedDateValue = \"2020-02-03 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testKibanaSampleDataLogsUtcDateField()\n+    {\n+        String columnName = \"utc_date\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"2020-02-02T00:39:02.912Z\";\n+        String expectedDateValue = \"2020-02-02 00:39:02.912\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testEpochMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"epoch_millis\";\n+        String originalDateValue = \"727430805000\";\n+        String expectedDateValue = \"1993-01-19 08:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testEpochSecond()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"epoch_second\";\n+        String originalDateValue = \"727430805\";\n+        String expectedDateValue = \"1993-01-19 08:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateOptionalTimeDateOnly()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"1993-01-19\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateOptionalTimeDateAndTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"1993-01-19T00:06:45.123-0800\";\n+        String expectedDateValue = \"1993-01-19 08:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicDate()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_date\";\n+        String originalDateValue = \"19930119\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicDateTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_date_time\";\n+        String originalDateValue = \"19930119T120645.123-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicDateTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_date_time_no_millis\";\n+        String originalDateValue = \"19930119T120645-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicOrdinalDate()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_ordinal_date\";\n+        String originalDateValue = \"1993019\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicOrdinalDateTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_ordinal_date_time\";\n+        String originalDateValue = \"1993019T120645.123-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicOrdinalDateTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_ordinal_date_time_no_millis\";\n+        String originalDateValue = \"1993019T120645-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_time\";\n+        String originalDateValue = \"120645.123-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_time_no_millis\";\n+        String originalDateValue = \"120645-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicTTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_t_time\";\n+        String originalDateValue = \"T120645.123-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicTTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_t_time_no_millis\";\n+        String originalDateValue = \"T120645-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicWeekDate()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_week_date\";\n+        String originalDateValue = \"1993W042\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicWeekDateTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_week_date_time\";\n+        String originalDateValue = \"1993W042T120645.123-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testBasicWeekDateTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"basic_week_date_time_no_millis\";\n+        String originalDateValue = \"1993W042T120645-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDate()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date\";\n+        String originalDateValue = \"1993-01-19\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateHour()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_hour\";\n+        String originalDateValue = \"1993-01-19T12\";\n+        String expectedDateValue = \"1993-01-19 12:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateHourMinute()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_hour_minute\";\n+        String originalDateValue = \"1993-01-19T12:06\";\n+        String expectedDateValue = \"1993-01-19 12:06:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateHourMinuteSecond()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_hour_minute_second\";\n+        String originalDateValue = \"1993-01-19T12:06:45\";\n+        String expectedDateValue = \"1993-01-19 12:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateHourMinuteSecondFraction()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_hour_minute_second_fraction\";\n+        String originalDateValue = \"1993-01-19T12:06:45.123\";\n+        String expectedDateValue = \"1993-01-19 12:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateHourMinuteSecondMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_hour_minute_second_millis\";\n+        String originalDateValue = \"1993-01-19T12:06:45.123\";\n+        String expectedDateValue = \"1993-01-19 12:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_time\";\n+        String originalDateValue = \"1993-01-19T12:06:45.123-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testDateTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_time_no_millis\";\n+        String originalDateValue = \"1993-01-19T12:06:45-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testHour()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"hour\";\n+        String originalDateValue = \"12\";\n+        String expectedDateValue = \"1970-01-01 12:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testHourMinute()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"hour_minute\";\n+        String originalDateValue = \"12:06\";\n+        String expectedDateValue = \"1970-01-01 12:06:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testHourMinuteSecond()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"hour_minute_second\";\n+        String originalDateValue = \"12:06:45\";\n+        String expectedDateValue = \"1970-01-01 12:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testHourMinuteSecondFraction()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"hour_minute_second_fraction\";\n+        String originalDateValue = \"12:06:45.123\";\n+        String expectedDateValue = \"1970-01-01 12:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testHourMinuteSecondMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"hour_minute_second_millis\";\n+        String originalDateValue = \"12:06:45.123\";\n+        String expectedDateValue = \"1970-01-01 12:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testOrdinalDate()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"ordinal_date\";\n+        String originalDateValue = \"1993-019\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testOrdinalDateTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"ordinal_date_time\";\n+        String originalDateValue = \"1993-019T12:06:45.123-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testOrdinalDateTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"ordinal_date_time_no_millis\";\n+        String originalDateValue = \"1993-019T12:06:45-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"time\";\n+        String originalDateValue = \"12:06:45.123-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"time_no_millis\";\n+        String originalDateValue = \"12:06:45-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testTTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"t_time\";\n+        String originalDateValue = \"T12:06:45.123-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testTTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"t_time_no_millis\";\n+        String originalDateValue = \"T12:06:45-0800\";\n+        String expectedDateValue = \"1970-01-01 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testWeekDate()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"week_date\";\n+        String originalDateValue = \"1993-W04-2\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testWeekDateTime()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"week_date_time\";\n+        String originalDateValue = \"1993-W04-2T12:06:45.123-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.123\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testWeekDateTimeNoMillis()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"week_date_time_no_millis\";\n+        String originalDateValue = \"1993-W04-2T12:06:45-0800\";\n+        String expectedDateValue = \"1993-01-19 20:06:45.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testWeekyear()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"week_year\";\n+        String originalDateValue = \"1993\";\n+        String expectedDateValue = \"1993-01-01 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testWeekyearWeek()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"weekyear_week\";\n+        String originalDateValue = \"1993-W04\";\n+        String expectedDateValue = \"1993-01-17 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testWeekyearWeekDay()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"weekyear_week_day\";\n+        String originalDateValue = \"1993-W04-2\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testYear()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"year\";\n+        String originalDateValue = \"1993\";\n+        String expectedDateValue = \"1993-01-01 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testYearMonth()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"year_month\";\n+        String originalDateValue = \"1993-01\";\n+        String expectedDateValue = \"1993-01-01 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testYearMonthDay()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"year_month_day\";\n+        String originalDateValue = \"1993-01-19\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testCustomFormat()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"EEE, MMM d, ''yy\";\n+\n+        String originalDateValue = \"Tue, Jan 19, '93\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testMultipleFormats()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_optional_time||epoch_millis\";\n+\n+        String originalDateValue = \"1993-01-19\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+\n+        originalDateValue = \"727401600000\";\n+        expectedDateValue = \"1993-01-19 00:00:00.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testMultipleCustomFormats()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"EEE, MMM d, ''yy||yyMMddHHmmssZ\";\n+\n+        String originalDateValue = \"Tue, Jan 19, '93\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+\n+        originalDateValue = \"930119000000-0000\";\n+        expectedDateValue = \"1993-01-19 00:00:00.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testNamedAndCustomFormats()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"EEE, MMM d, ''yy||hour_minute_second\";\n+\n+        String originalDateValue = \"Tue, Jan 19, '93\";\n+        String expectedDateValue = \"1993-01-19 00:00:00.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+\n+        originalDateValue = \"12:06:45\";\n+        expectedDateValue = \"1970-01-01 12:06:45.000\";\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testIncorrectFormat()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = \"1581724085\";\n+        // Invalid format for date value; should return original value\n+        String expectedDateValue = \"1581724085\";\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    @Test\n+    public void testNullDateData()\n+    {\n+        String columnName = \"date_field\";\n+        String dateFormat = \"date_optional_time\";\n+        String originalDateValue = null;\n+        // Nulls should be preserved\n+        String expectedDateValue = null;\n+\n+        verifyFormatting(columnName, dateFormat, originalDateValue, expectedDateValue);\n+    }\n+\n+    private void verifyFormatting(String columnName, String dateFormatProperty, String originalDateValue, String expectedDateValue)\n+    {\n+        List<Schema.Column> columns = buildColumnList(columnName);\n+        Map<String, List<String>> dateFieldFormatMap = buildDateFieldFormatMap(columnName, dateFormatProperty);\n+\n+        Map<String, Object> rowSource = new HashMap<>();\n+        rowSource.put(columnName, originalDateValue);\n+\n+        DateFieldFormatter dateFieldFormatter = new DateFieldFormatter(dateFieldFormatMap, columns, new HashMap<>());\n+        executeFormattingAndCompare(dateFieldFormatter, rowSource, columnName, expectedDateValue);\n+    }\n+\n+    private void executeFormattingAndCompare(\n+            DateFieldFormatter formatter,\n+            Map<String, Object> rowSource,\n+            String columnToCheck,\n+            String expectedDateValue) {\n+        formatter.applyJDBCDateFormat(rowSource);\n+        assertEquals(expectedDateValue, rowSource.get(columnToCheck));\n+    }\n+\n+    private List<Schema.Column> buildColumnList(String columnName) {\n+        return ImmutableList.<Schema.Column>builder()\n+                .add(new Schema.Column(columnName, null, Schema.Type.DATE))\n+                .build();\n+    }\n+\n+    private Map<String, List<String>> buildDateFieldFormatMap(String columnName, String dateFormatProperty) {\n+        return ImmutableMap.<String, List<String>>builder()\n+                .put(columnName, Arrays.asList(dateFormatProperty.split(\"\\\\|\\\\|\")))\n+                .build();\n+    }\n }\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTEyNw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r381645127", "body": "remove unused code?", "bodyText": "remove unused code?", "bodyHTML": "<p dir=\"auto\">remove unused code?</p>", "author": "dai-chen", "createdAt": "2020-02-20T01:25:47Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFormat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+// import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+// import java.util.TimeZone;\n+\n+public enum DateFormat {\n+  // Special cases that are parsed separately\n+  DATE_OPTIONAL_TIME(\"\"),\n+  EPOCH_MILLIS(\"\"),\n+  EPOCH_SECOND(\"\"),\n+\n+  BASIC_DATE(Date.BASIC_DATE),\n+  BASIC_DATE_TIME(Date.BASIC_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n+  BASIC_DATE_TIME_NO_MILLIS(Date.BASIC_DATE + Time.T + Time.BASIC_TIME + Time.TZ),\n+\n+  BASIC_ORDINAL_DATE(Date.BASIC_ORDINAL_DATE),\n+  BASIC_ORDINAL_DATE_TIME(Date.BASIC_ORDINAL_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n+  BASIC_ORDINAL_DATE_TIME_NO_MILLIS(Date.BASIC_ORDINAL_DATE+ Time.T + Time.BASIC_TIME + Time.TZ),\n+\n+  BASIC_TIME(Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n+  BASIC_TIME_NO_MILLIS(Time.BASIC_TIME + Time.TZ),\n+\n+  BASIC_T_TIME(Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n+  BASIC_T_TIME_NO_MILLIS(Time.T + Time.BASIC_TIME + Time.TZ),\n+\n+  BASIC_WEEK_DATE(Date.BASIC_WEEK_DATE),\n+  BASIC_WEEK_DATE_TIME(Date.BASIC_WEEK_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n+  BASIC_WEEK_DATE_TIME_NO_MILLIS(Date.BASIC_WEEK_DATE + Time.T + Time.BASIC_TIME + Time.TZ),\n+\n+  DATE(Date.DATE),\n+  DATE_HOUR(Date.DATE + Time.T + Time.HOUR),\n+  DATE_HOUR_MINUTE(Date.DATE + Time.T + Time.HOUR_MINUTE),\n+  DATE_HOUR_MINUTE_SECOND(Date.DATE + Time.T + Time.TIME),\n+  DATE_HOUR_MINUTE_SECOND_FRACTION(Date.DATE + Time.T + Time.TIME + Time.MILLIS),\n+  DATE_HOUR_MINUTE_SECOND_MILLIS(Date.DATE + Time.T + Time.TIME + Time.MILLIS),\n+  DATE_TIME(Date.DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n+  DATE_TIME_NO_MILLIS(Date.DATE + Time.T + Time.TIME + Time.TZZ),\n+\n+  HOUR(Time.HOUR),\n+  HOUR_MINUTE(Time.HOUR_MINUTE),\n+  HOUR_MINUTE_SECOND(Time.TIME),\n+  HOUR_MINUTE_SECOND_FRACTION(Time.TIME + Time.MILLIS),\n+  HOUR_MINUTE_SECOND_MILLIS(Time.TIME + Time.MILLIS),\n+\n+  ORDINAL_DATE(Date.ORDINAL_DATE),\n+  ORDINAL_DATE_TIME(Date.ORDINAL_DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n+  ORDINAL_DATE_TIME_NO_MILLIS(Date.ORDINAL_DATE + Time.T + Time.TIME + Time.TZZ),\n+\n+  TIME(Time.TIME + Time.MILLIS + Time.TZZ),\n+  TIME_NO_MILLIS(Time.TIME + Time.TZZ),\n+\n+  T_TIME(Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n+  T_TIME_NO_MILLIS(Time.T + Time.TIME + Time.TZZ),\n+\n+  WEEK_DATE(Date.WEEK_DATE),\n+  WEEK_DATE_TIME(Date.WEEK_DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n+  WEEK_DATE_TIME_NO_MILLIS(Date.WEEK_DATE + Time.T + Time.TIME + Time.TZZ),\n+\n+  // Note: input mapping is \"weekyear\", but output value is \"week_year\"\n+  WEEK_YEAR(Date.WEEKYEAR),\n+  WEEKYEAR_WEEK(Date.WEEKYEAR_WEEK),\n+  WEEKYEAR_WEEK_DAY(Date.WEEK_DATE),\n+\n+  YEAR(Date.YEAR),\n+  YEAR_MONTH(Date.YEAR_MONTH),\n+  YEAR_MONTH_DAY(Date.DATE);\n+\n+  private static class Date {\n+    static String BASIC_DATE = \"yyyyMMdd\";\n+    static String BASIC_ORDINAL_DATE = \"yyyyDDD\";\n+    static String BASIC_WEEK_DATE = \"YYYY'W'wwu\";\n+\n+    static String DATE = \"yyyy-MM-dd\";\n+    static String ORDINAL_DATE = \"yyyy-DDD\";\n+\n+    static String YEAR = \"yyyy\";\n+    static String YEAR_MONTH = \"yyyy-MM\";\n+\n+    static String WEEK_DATE = \"YYYY-'W'ww-u\";\n+    static String WEEKYEAR = \"YYYY\";\n+    static String WEEKYEAR_WEEK = \"YYYY-'W'ww\";\n+  }\n+\n+  private static class Time {\n+    static String T = \"'T'\";\n+    static String BASIC_TIME = \"HHmmss\";\n+    static String TIME = \"HH:mm:ss\";\n+\n+    static String HOUR = \"HH\";\n+    static String HOUR_MINUTE = \"HH:mm\";\n+\n+    static String MILLIS = \".SSS\";\n+    static String TZ = \"Z\";\n+    static String TZZ = \"XX\";\n+  }\n+\n+  private String formatString;\n+\n+  DateFormat(String formatString) {\n+    this.formatString = formatString;\n+  }\n+\n+  public String getFormatString() {\n+    return formatString;\n+  }\n+\n+  public String nameLowerCase() {\n+    return name().toLowerCase();\n+  }\n+\n+  public static String getFormattedDate(java.util.Date date, String dateFormat) {\n+    Instant instant = date.toInstant();\n+    ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of(\"Etc/UTC\"));\n+    // return zdt.format(DateTimeFormatter.ofPattern(dateFormat));\n+    return zdt.format(DateTimeFormatter.ofPattern(dateFormat));\n+    // return DateTimeFormatter.ofLocalizedDateTime().format(date.toInstant());\n+    // SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);\n+    // formatter.applyLocalizedPattern(dateFormat);\n+    // formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    // return formatter.format(date);\n+    // formatter.", "originalCommit": "2ae4195a41419305c44483944bae841795d59393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTQ2OA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382855468", "bodyText": "Removed", "author": "jordanw-bq", "createdAt": "2020-02-21T23:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTEyNw=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFormat.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFormat.java\nindex 2f9689c2..c3baa0d9 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFormat.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFormat.java\n", "chunk": "@@ -15,128 +15,120 @@\n \n package com.amazon.opendistroforelasticsearch.sql.executor.format;\n \n-// import java.text.SimpleDateFormat;\n import java.time.Instant;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n-// import java.util.TimeZone;\n-\n-public enum DateFormat {\n-  // Special cases that are parsed separately\n-  DATE_OPTIONAL_TIME(\"\"),\n-  EPOCH_MILLIS(\"\"),\n-  EPOCH_SECOND(\"\"),\n-\n-  BASIC_DATE(Date.BASIC_DATE),\n-  BASIC_DATE_TIME(Date.BASIC_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n-  BASIC_DATE_TIME_NO_MILLIS(Date.BASIC_DATE + Time.T + Time.BASIC_TIME + Time.TZ),\n-\n-  BASIC_ORDINAL_DATE(Date.BASIC_ORDINAL_DATE),\n-  BASIC_ORDINAL_DATE_TIME(Date.BASIC_ORDINAL_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n-  BASIC_ORDINAL_DATE_TIME_NO_MILLIS(Date.BASIC_ORDINAL_DATE+ Time.T + Time.BASIC_TIME + Time.TZ),\n-\n-  BASIC_TIME(Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n-  BASIC_TIME_NO_MILLIS(Time.BASIC_TIME + Time.TZ),\n-\n-  BASIC_T_TIME(Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n-  BASIC_T_TIME_NO_MILLIS(Time.T + Time.BASIC_TIME + Time.TZ),\n-\n-  BASIC_WEEK_DATE(Date.BASIC_WEEK_DATE),\n-  BASIC_WEEK_DATE_TIME(Date.BASIC_WEEK_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ),\n-  BASIC_WEEK_DATE_TIME_NO_MILLIS(Date.BASIC_WEEK_DATE + Time.T + Time.BASIC_TIME + Time.TZ),\n-\n-  DATE(Date.DATE),\n-  DATE_HOUR(Date.DATE + Time.T + Time.HOUR),\n-  DATE_HOUR_MINUTE(Date.DATE + Time.T + Time.HOUR_MINUTE),\n-  DATE_HOUR_MINUTE_SECOND(Date.DATE + Time.T + Time.TIME),\n-  DATE_HOUR_MINUTE_SECOND_FRACTION(Date.DATE + Time.T + Time.TIME + Time.MILLIS),\n-  DATE_HOUR_MINUTE_SECOND_MILLIS(Date.DATE + Time.T + Time.TIME + Time.MILLIS),\n-  DATE_TIME(Date.DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n-  DATE_TIME_NO_MILLIS(Date.DATE + Time.T + Time.TIME + Time.TZZ),\n-\n-  HOUR(Time.HOUR),\n-  HOUR_MINUTE(Time.HOUR_MINUTE),\n-  HOUR_MINUTE_SECOND(Time.TIME),\n-  HOUR_MINUTE_SECOND_FRACTION(Time.TIME + Time.MILLIS),\n-  HOUR_MINUTE_SECOND_MILLIS(Time.TIME + Time.MILLIS),\n-\n-  ORDINAL_DATE(Date.ORDINAL_DATE),\n-  ORDINAL_DATE_TIME(Date.ORDINAL_DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n-  ORDINAL_DATE_TIME_NO_MILLIS(Date.ORDINAL_DATE + Time.T + Time.TIME + Time.TZZ),\n-\n-  TIME(Time.TIME + Time.MILLIS + Time.TZZ),\n-  TIME_NO_MILLIS(Time.TIME + Time.TZZ),\n-\n-  T_TIME(Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n-  T_TIME_NO_MILLIS(Time.T + Time.TIME + Time.TZZ),\n-\n-  WEEK_DATE(Date.WEEK_DATE),\n-  WEEK_DATE_TIME(Date.WEEK_DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ),\n-  WEEK_DATE_TIME_NO_MILLIS(Date.WEEK_DATE + Time.T + Time.TIME + Time.TZZ),\n-\n-  // Note: input mapping is \"weekyear\", but output value is \"week_year\"\n-  WEEK_YEAR(Date.WEEKYEAR),\n-  WEEKYEAR_WEEK(Date.WEEKYEAR_WEEK),\n-  WEEKYEAR_WEEK_DAY(Date.WEEK_DATE),\n-\n-  YEAR(Date.YEAR),\n-  YEAR_MONTH(Date.YEAR_MONTH),\n-  YEAR_MONTH_DAY(Date.DATE);\n-\n-  private static class Date {\n-    static String BASIC_DATE = \"yyyyMMdd\";\n-    static String BASIC_ORDINAL_DATE = \"yyyyDDD\";\n-    static String BASIC_WEEK_DATE = \"YYYY'W'wwu\";\n-\n-    static String DATE = \"yyyy-MM-dd\";\n-    static String ORDINAL_DATE = \"yyyy-DDD\";\n-\n-    static String YEAR = \"yyyy\";\n-    static String YEAR_MONTH = \"yyyy-MM\";\n-\n-    static String WEEK_DATE = \"YYYY-'W'ww-u\";\n-    static String WEEKYEAR = \"YYYY\";\n-    static String WEEKYEAR_WEEK = \"YYYY-'W'ww\";\n-  }\n-\n-  private static class Time {\n-    static String T = \"'T'\";\n-    static String BASIC_TIME = \"HHmmss\";\n-    static String TIME = \"HH:mm:ss\";\n-\n-    static String HOUR = \"HH\";\n-    static String HOUR_MINUTE = \"HH:mm\";\n-\n-    static String MILLIS = \".SSS\";\n-    static String TZ = \"Z\";\n-    static String TZZ = \"XX\";\n-  }\n-\n-  private String formatString;\n-\n-  DateFormat(String formatString) {\n-    this.formatString = formatString;\n-  }\n-\n-  public String getFormatString() {\n-    return formatString;\n-  }\n-\n-  public String nameLowerCase() {\n-    return name().toLowerCase();\n-  }\n-\n-  public static String getFormattedDate(java.util.Date date, String dateFormat) {\n-    Instant instant = date.toInstant();\n-    ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of(\"Etc/UTC\"));\n-    // return zdt.format(DateTimeFormatter.ofPattern(dateFormat));\n-    return zdt.format(DateTimeFormatter.ofPattern(dateFormat));\n-    // return DateTimeFormatter.ofLocalizedDateTime().format(date.toInstant());\n-    // SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);\n-    // formatter.applyLocalizedPattern(dateFormat);\n-    // formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    // return formatter.format(date);\n-    // formatter.\n-  }\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class DateFormat {\n+\n+    private static Map<String, String> formatMap = new HashMap<>();\n+\n+    static {\n+        // Special cases that are parsed separately\n+        formatMap.put(\"date_optional_time\", \"\");\n+        formatMap.put(\"epoch_millis\", \"\");\n+        formatMap.put(\"epoch_second\", \"\");\n+\n+        formatMap.put(\"basic_date\", Date.BASIC_DATE);\n+        formatMap.put(\"basic_date_time\", Date.BASIC_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ);\n+        formatMap.put(\"basic_date_time_no_millis\", Date.BASIC_DATE + Time.T + Time.BASIC_TIME + Time.TZ);\n+\n+        formatMap.put(\"basic_ordinal_date\", Date.BASIC_ORDINAL_DATE);\n+        formatMap.put(\"basic_ordinal_date_time\",\n+                      Date.BASIC_ORDINAL_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ);\n+        formatMap.put(\"basic_ordinal_date_time_no_millis\", Date.BASIC_ORDINAL_DATE+ Time.T + Time.BASIC_TIME + Time.TZ);\n+\n+        formatMap.put(\"basic_time\", Time.BASIC_TIME + Time.MILLIS + Time.TZ);\n+        formatMap.put(\"basic_time_no_millis\", Time.BASIC_TIME + Time.TZ);\n+\n+        formatMap.put(\"basic_t_time\", Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ);\n+        formatMap.put(\"basic_t_time_no_millis\", Time.T + Time.BASIC_TIME + Time.TZ);\n+\n+        formatMap.put(\"basic_week_date\", Date.BASIC_WEEK_DATE);\n+        formatMap.put(\"basic_week_date_time\", Date.BASIC_WEEK_DATE + Time.T + Time.BASIC_TIME + Time.MILLIS + Time.TZ);\n+        formatMap.put(\"basic_week_date_time_no_millis\", Date.BASIC_WEEK_DATE + Time.T + Time.BASIC_TIME + Time.TZ);\n+\n+        formatMap.put(\"date\", Date.DATE);\n+        formatMap.put(\"date_hour\", Date.DATE + Time.T + Time.HOUR);\n+        formatMap.put(\"date_hour_minute\", Date.DATE + Time.T + Time.HOUR_MINUTE);\n+        formatMap.put(\"date_hour_minute_second\", Date.DATE + Time.T + Time.TIME);\n+        formatMap.put(\"date_hour_minute_second_fraction\", Date.DATE + Time.T + Time.TIME + Time.MILLIS);\n+        formatMap.put(\"date_hour_minute_second_millis\", Date.DATE + Time.T + Time.TIME + Time.MILLIS);\n+        formatMap.put(\"date_time\", Date.DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ);\n+        formatMap.put(\"date_time_no_millis\", Date.DATE + Time.T + Time.TIME + Time.TZZ);\n+\n+        formatMap.put(\"hour\", Time.HOUR);\n+        formatMap.put(\"hour_minute\", Time.HOUR_MINUTE);\n+        formatMap.put(\"hour_minute_second\", Time.TIME);\n+        formatMap.put(\"hour_minute_second_fraction\", Time.TIME + Time.MILLIS);\n+        formatMap.put(\"hour_minute_second_millis\", Time.TIME + Time.MILLIS);\n+\n+        formatMap.put(\"ordinal_date\", Date.ORDINAL_DATE);\n+        formatMap.put(\"ordinal_date_time\", Date.ORDINAL_DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ);\n+        formatMap.put(\"ordinal_date_time_no_millis\", Date.ORDINAL_DATE + Time.T + Time.TIME + Time.TZZ);\n+\n+        formatMap.put(\"time\", Time.TIME + Time.MILLIS + Time.TZZ);\n+        formatMap.put(\"time_no_millis\", Time.TIME + Time.TZZ);\n+\n+        formatMap.put(\"t_time\", Time.T + Time.TIME + Time.MILLIS + Time.TZZ);\n+        formatMap.put(\"t_time_no_millis\", Time.T + Time.TIME + Time.TZZ);\n+\n+        formatMap.put(\"week_date\", Date.WEEK_DATE);\n+        formatMap.put(\"week_date_time\", Date.WEEK_DATE + Time.T + Time.TIME + Time.MILLIS + Time.TZZ);\n+        formatMap.put(\"week_date_time_no_millis\", Date.WEEK_DATE + Time.T + Time.TIME + Time.TZZ);\n+\n+        // Note: input mapping is \"weekyear\", but output value is \"week_year\"\n+        formatMap.put(\"week_year\", Date.WEEKYEAR);\n+        formatMap.put(\"weekyear_week\", Date.WEEKYEAR_WEEK);\n+        formatMap.put(\"weekyear_week_day\", Date.WEEK_DATE);\n+\n+        formatMap.put(\"year\", Date.YEAR);\n+        formatMap.put(\"year_month\", Date.YEAR_MONTH);\n+        formatMap.put(\"year_month_day\", Date.DATE);\n+    }\n+\n+    private DateFormat() {\n+    }\n+\n+    public static String getFormatString(String formatName) {\n+        return formatMap.get(formatName);\n+    }\n+\n+    public static String getFormattedDate(java.util.Date date, String dateFormat) {\n+        Instant instant = date.toInstant();\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.of(\"Etc/UTC\"));\n+        return zdt.format(DateTimeFormatter.ofPattern(dateFormat));\n+    }\n+\n+    private static class Date {\n+        static String BASIC_DATE = \"yyyyMMdd\";\n+        static String BASIC_ORDINAL_DATE = \"yyyyDDD\";\n+        static String BASIC_WEEK_DATE = \"YYYY'W'wwu\";\n+\n+        static String DATE = \"yyyy-MM-dd\";\n+        static String ORDINAL_DATE = \"yyyy-DDD\";\n+\n+        static String YEAR = \"yyyy\";\n+        static String YEAR_MONTH = \"yyyy-MM\";\n+\n+        static String WEEK_DATE = \"YYYY-'W'ww-u\";\n+        static String WEEKYEAR = \"YYYY\";\n+        static String WEEKYEAR_WEEK = \"YYYY-'W'ww\";\n+    }\n+\n+    private static class Time {\n+        static String T = \"'T'\";\n+        static String BASIC_TIME = \"HHmmss\";\n+        static String TIME = \"HH:mm:ss\";\n+\n+        static String HOUR = \"HH\";\n+        static String HOUR_MINUTE = \"HH:mm\";\n+\n+        static String MILLIS = \".SSS\";\n+        static String TZ = \"Z\";\n+        static String TZZ = \"XX\";\n+    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0OTUwMw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r381649503", "body": "Please add JavaDoc for new class and its public methods.", "bodyText": "Please add JavaDoc for new class and its public methods.", "bodyHTML": "<p dir=\"auto\">Please add JavaDoc for new class and its public methods.</p>", "author": "dai-chen", "createdAt": "2020-02-20T01:33:04Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.ParseException;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DateFieldFormatter {", "originalCommit": "2ae4195a41419305c44483944bae841795d59393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTQxMA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382855410", "bodyText": "Added JavaDoc comments to new class & public methods", "author": "jordanw-bq", "createdAt": "2020-02-21T23:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0OTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjAyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382856021", "bodyText": "Thanks!", "author": "dai-chen", "createdAt": "2020-02-21T23:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0OTUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\nindex 0a7c050e..f05d340b 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n", "chunk": "@@ -15,82 +15,181 @@\n \n package com.amazon.opendistroforelasticsearch.sql.executor.format;\n \n+import com.amazon.opendistroforelasticsearch.sql.esdomain.LocalClusterState;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.FieldMappings;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.TypeMappings;\n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.lang3.time.DateUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Date;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n \n+/**\n+ * Formatter to transform date fields into a consistent format for consumption by clients.\n+ */\n public class DateFieldFormatter {\n     private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n     private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+    private static final String FORMAT_DELIMITER = \"\\\\|\\\\|\";\n \n     private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION_NO_TIME = \"yyyy-MM-dd'T'\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n-    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";\n+    private static final String FORMAT_DOT_DATE = DateFormat.getFormatString(\"date\");\n+\n+    private final Map<String, List<String>> dateFieldFormatMap;\n+    private final Map<String, String> fieldAliasMap;\n+    private Set<String> dateColumns;\n \n-    private final Map<String, String> dateFieldFormatMap;\n-    private List<Schema.Column> columns;\n+    public DateFieldFormatter(String indexName, List<Schema.Column> columns, Map<String, String> fieldAliasMap) {\n+        this.dateFieldFormatMap = getDateFieldFormatMap(indexName);\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n+    }\n \n-    public DateFieldFormatter(Map<String, String> dateFieldFormatMap, List<Schema.Column> columns) {\n+    @VisibleForTesting\n+    protected DateFieldFormatter(Map<String, List<String>> dateFieldFormatMap,\n+                                 List<Schema.Column> columns,\n+                                 Map<String, String> fieldAliasMap) {\n         this.dateFieldFormatMap = dateFieldFormatMap;\n-        this.columns = columns;\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n     }\n \n+    /**\n+     * Apply the JDBC date format ({@code yyyy-MM-dd HH:mm:ss.SSS}) to date values in the current row.\n+     *\n+     * @param rowSource The row in which to format the date values.\n+     */\n     public void applyJDBCDateFormat(Map<String, Object> rowSource) {\n-        for (Schema.Column column : columns) {\n-            String columnType = column.getType();\n-            String columnName = column.getName();\n-\n-            if (columnType.equals(Schema.Type.DATE.nameLowerCase())) {\n-                String columnFormat = dateFieldFormatMap.get(columnName);\n-                DateFormat format = DateFormat.valueOf(columnFormat.toUpperCase());\n-\n-                Object columnOriginalDate = rowSource.get(columnName);\n-                if (columnOriginalDate == null) {\n-                    // Don't try to parse null date values\n-                    continue;\n-                }\n+        for (String columnName : dateColumns) {\n+            Object columnOriginalDate = rowSource.get(columnName);\n+            if (columnOriginalDate == null) {\n+                // Don't try to parse null date values\n+                continue;\n+            }\n+\n+            List<String> formats = getFormatsForColumn(columnName);\n+            if (formats == null) {\n+                LOG.warn(\"Could not determine date formats for column {}; returning original value\", columnName);\n+                continue;\n+            }\n+\n+            Date date = parseDateString(formats, columnOriginalDate.toString());\n+            if (date != null) {\n+                rowSource.put(columnName, DateFormat.getFormattedDate(date, FORMAT_JDBC));\n+                break;\n+            } else {\n+                LOG.warn(\"Could not parse date value; returning original value\");\n+            }\n+        }\n+    }\n+\n+    private List<String> getFormatsForColumn(String columnName) {\n+        // Handle special cases for column names\n+        if (fieldAliasMap.get(columnName) != null) {\n+            // Column was aliased, and we need to find the base name for the column\n+            columnName = fieldAliasMap.get(columnName);\n+        } else if (columnName.split(\"\\\\.\").length == 2) {\n+            // Column is part of a join, and is qualified by the table alias\n+            columnName = columnName.split(\"\\\\.\")[1];\n+        }\n+        return dateFieldFormatMap.get(columnName);\n+    }\n+\n+    private Set<String> getDateColumns(List<Schema.Column> columns) {\n+        return columns.stream()\n+            .filter(column -> column.getType().equals(Schema.Type.DATE.nameLowerCase()))\n+            .map(Schema.Column::getName)\n+            .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, List<String>> getDateFieldFormatMap(String indexName) {\n+        LocalClusterState state = LocalClusterState.state();\n+        Map<String, List<String>> formatMap = new HashMap<>();\n \n-                Date date = parseDateString(format, columnOriginalDate.toString());\n-                if (date != null) {\n-                    rowSource.put(columnName, DateFormat.getFormattedDate(date, FORMAT_JDBC));\n+        String[] indices = indexName.split(\"\\\\|\");\n+        Collection<TypeMappings> typeProperties = state.getFieldMappings(indices)\n+            .allMappings();\n+\n+        for (TypeMappings mappings: typeProperties) {\n+            FieldMappings fieldMappings = mappings.firstMapping();\n+            for (Map.Entry<String, Map<String, Object>> field : fieldMappings.data().entrySet()) {\n+                String fieldName = field.getKey();\n+                Map<String, Object> properties = field.getValue();\n+\n+                if (properties.containsKey(\"format\")) {\n+                    formatMap.put(fieldName, getFormatsFromProperties(properties.get(\"format\").toString()));\n                 } else {\n-                    LOG.warn(\"Could not parse date value; returning original value\");\n+                    // Give all field types a format, since operations such as casts\n+                    // can change the output type for a field to `date`.\n+                    formatMap.put(fieldName, getFormatsFromProperties(\"date_optional_time\"));\n                 }\n             }\n         }\n+\n+        return formatMap;\n     }\n \n-    private Date parseDateString(DateFormat format, String columnOriginalDate) {\n-        try {\n-            switch (format) {\n-                case DATE_OPTIONAL_TIME:\n-                    return DateUtils.parseDate(\n-                        columnOriginalDate,\n-                        FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION,\n-                        FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION,\n-                        FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION,\n-                        FORMAT_DOT_DATE_AND_TIME,\n-                        FORMAT_DOT_DATE);\n-                case EPOCH_MILLIS:\n-                    return new Date(Long.parseLong(columnOriginalDate));\n-                case EPOCH_SECOND:\n-                    return new Date(Long.parseLong(columnOriginalDate) * 1000);\n-                default:\n-                    return DateUtils.parseDate(columnOriginalDate, format.getFormatString());\n+    private List<String> getFormatsFromProperties(String formatProperty) {\n+        String[] formats = formatProperty.split(FORMAT_DELIMITER);\n+        return Arrays.asList(formats);\n+    }\n+\n+    private Date parseDateString(List<String> formats, String columnOriginalDate) {\n+        TimeZone originalDefaultTimeZone = TimeZone.getDefault();\n+        Date parsedDate = null;\n+\n+        // Apache Commons DateUtils uses the default TimeZone for the JVM when parsing.\n+        // However, since all dates on Elasticsearch are stored as UTC, we need to\n+        // parse these values using the UTC timezone.\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n+        for (String columnFormat : formats) {\n+            try {\n+                switch (columnFormat) {\n+                    case \"date_optional_time\":\n+                        parsedDate = DateUtils.parseDate(\n+                            columnOriginalDate,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION_NO_TIME,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION,\n+                            FORMAT_DOT_DATE_AND_TIME,\n+                            FORMAT_DOT_DATE);\n+                        break;\n+                    case \"epoch_millis\":\n+                        parsedDate = new Date(Long.parseLong(columnOriginalDate));\n+                        break;\n+                    case \"epoch_second\":\n+                        parsedDate = new Date(Long.parseLong(columnOriginalDate) * 1000);\n+                        break;\n+                    default:\n+                        String formatString = DateFormat.getFormatString(columnFormat);\n+                        if (formatString == null) {\n+                            // Custom format; take as-is\n+                            formatString = columnFormat;\n+                        }\n+                        parsedDate = DateUtils.parseDate(columnOriginalDate, formatString);\n+                }\n+            } catch (ParseException | NumberFormatException e) {\n+                LOG.warn(String.format(\"Could not parse date string %s as %s\", columnOriginalDate, columnFormat));\n             }\n-        } catch (ParseException e) {\n-            LOG.error(\n-                String.format(\"Error parsing date string %s as %s\", columnOriginalDate, format.nameLowerCase()),\n-                e);\n         }\n-        return null;\n-    }\n+        // Reset default timezone after parsing\n+        TimeZone.setDefault(originalDefaultTimeZone);\n \n+        return parsedDate;\n+    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NTgzMg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r381655832", "body": "I think you should pick columns of `DATE` type into a `Set` in your constructor to save this for loop. Otherwise it runs for each row in the result set.", "bodyText": "I think you should pick columns of DATE type into a Set in your constructor to save this for loop. Otherwise it runs for each row in the result set.", "bodyHTML": "<p dir=\"auto\">I think you should pick columns of <code>DATE</code> type into a <code>Set</code> in your constructor to save this for loop. Otherwise it runs for each row in the result set.</p>", "author": "dai-chen", "createdAt": "2020-02-20T01:44:27Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.ParseException;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DateFieldFormatter {\n+    private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n+    private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+\n+    private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n+    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";\n+\n+    private final Map<String, String> dateFieldFormatMap;\n+    private List<Schema.Column> columns;\n+\n+    public DateFieldFormatter(Map<String, String> dateFieldFormatMap, List<Schema.Column> columns) {\n+        this.dateFieldFormatMap = dateFieldFormatMap;\n+        this.columns = columns;\n+    }\n+\n+    public void applyJDBCDateFormat(Map<String, Object> rowSource) {\n+        for (Schema.Column column : columns) {", "originalCommit": "2ae4195a41419305c44483944bae841795d59393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTM2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382855362", "bodyText": "Now saving date columns in constructor (saving as List, since it seems that Sets cannot be iterated through with this foreach syntax", "author": "jordanw-bq", "createdAt": "2020-02-21T23:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1Njk0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382856949", "bodyText": "Thanks for the changes! But I assume a Set<String> with all field names of DATE type is sufficient right? Why original Column saved in a list with for-loop ran for each row in result set?", "author": "dai-chen", "createdAt": "2020-02-21T23:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MzMzNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382863336", "bodyText": "Oh yes, this makes sense! Since all I need is the name of the column. Will make this change", "author": "jordanw-bq", "createdAt": "2020-02-22T00:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NTU0OA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384055548", "bodyText": "Addressed (now only storing a Set<String> for date column names)", "author": "jordanw-bq", "createdAt": "2020-02-25T18:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NTgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\nindex 0a7c050e..f05d340b 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n", "chunk": "@@ -15,82 +15,181 @@\n \n package com.amazon.opendistroforelasticsearch.sql.executor.format;\n \n+import com.amazon.opendistroforelasticsearch.sql.esdomain.LocalClusterState;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.FieldMappings;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.TypeMappings;\n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.lang3.time.DateUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Date;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n \n+/**\n+ * Formatter to transform date fields into a consistent format for consumption by clients.\n+ */\n public class DateFieldFormatter {\n     private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n     private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+    private static final String FORMAT_DELIMITER = \"\\\\|\\\\|\";\n \n     private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION_NO_TIME = \"yyyy-MM-dd'T'\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n-    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";\n+    private static final String FORMAT_DOT_DATE = DateFormat.getFormatString(\"date\");\n+\n+    private final Map<String, List<String>> dateFieldFormatMap;\n+    private final Map<String, String> fieldAliasMap;\n+    private Set<String> dateColumns;\n \n-    private final Map<String, String> dateFieldFormatMap;\n-    private List<Schema.Column> columns;\n+    public DateFieldFormatter(String indexName, List<Schema.Column> columns, Map<String, String> fieldAliasMap) {\n+        this.dateFieldFormatMap = getDateFieldFormatMap(indexName);\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n+    }\n \n-    public DateFieldFormatter(Map<String, String> dateFieldFormatMap, List<Schema.Column> columns) {\n+    @VisibleForTesting\n+    protected DateFieldFormatter(Map<String, List<String>> dateFieldFormatMap,\n+                                 List<Schema.Column> columns,\n+                                 Map<String, String> fieldAliasMap) {\n         this.dateFieldFormatMap = dateFieldFormatMap;\n-        this.columns = columns;\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n     }\n \n+    /**\n+     * Apply the JDBC date format ({@code yyyy-MM-dd HH:mm:ss.SSS}) to date values in the current row.\n+     *\n+     * @param rowSource The row in which to format the date values.\n+     */\n     public void applyJDBCDateFormat(Map<String, Object> rowSource) {\n-        for (Schema.Column column : columns) {\n-            String columnType = column.getType();\n-            String columnName = column.getName();\n-\n-            if (columnType.equals(Schema.Type.DATE.nameLowerCase())) {\n-                String columnFormat = dateFieldFormatMap.get(columnName);\n-                DateFormat format = DateFormat.valueOf(columnFormat.toUpperCase());\n-\n-                Object columnOriginalDate = rowSource.get(columnName);\n-                if (columnOriginalDate == null) {\n-                    // Don't try to parse null date values\n-                    continue;\n-                }\n+        for (String columnName : dateColumns) {\n+            Object columnOriginalDate = rowSource.get(columnName);\n+            if (columnOriginalDate == null) {\n+                // Don't try to parse null date values\n+                continue;\n+            }\n+\n+            List<String> formats = getFormatsForColumn(columnName);\n+            if (formats == null) {\n+                LOG.warn(\"Could not determine date formats for column {}; returning original value\", columnName);\n+                continue;\n+            }\n+\n+            Date date = parseDateString(formats, columnOriginalDate.toString());\n+            if (date != null) {\n+                rowSource.put(columnName, DateFormat.getFormattedDate(date, FORMAT_JDBC));\n+                break;\n+            } else {\n+                LOG.warn(\"Could not parse date value; returning original value\");\n+            }\n+        }\n+    }\n+\n+    private List<String> getFormatsForColumn(String columnName) {\n+        // Handle special cases for column names\n+        if (fieldAliasMap.get(columnName) != null) {\n+            // Column was aliased, and we need to find the base name for the column\n+            columnName = fieldAliasMap.get(columnName);\n+        } else if (columnName.split(\"\\\\.\").length == 2) {\n+            // Column is part of a join, and is qualified by the table alias\n+            columnName = columnName.split(\"\\\\.\")[1];\n+        }\n+        return dateFieldFormatMap.get(columnName);\n+    }\n+\n+    private Set<String> getDateColumns(List<Schema.Column> columns) {\n+        return columns.stream()\n+            .filter(column -> column.getType().equals(Schema.Type.DATE.nameLowerCase()))\n+            .map(Schema.Column::getName)\n+            .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, List<String>> getDateFieldFormatMap(String indexName) {\n+        LocalClusterState state = LocalClusterState.state();\n+        Map<String, List<String>> formatMap = new HashMap<>();\n \n-                Date date = parseDateString(format, columnOriginalDate.toString());\n-                if (date != null) {\n-                    rowSource.put(columnName, DateFormat.getFormattedDate(date, FORMAT_JDBC));\n+        String[] indices = indexName.split(\"\\\\|\");\n+        Collection<TypeMappings> typeProperties = state.getFieldMappings(indices)\n+            .allMappings();\n+\n+        for (TypeMappings mappings: typeProperties) {\n+            FieldMappings fieldMappings = mappings.firstMapping();\n+            for (Map.Entry<String, Map<String, Object>> field : fieldMappings.data().entrySet()) {\n+                String fieldName = field.getKey();\n+                Map<String, Object> properties = field.getValue();\n+\n+                if (properties.containsKey(\"format\")) {\n+                    formatMap.put(fieldName, getFormatsFromProperties(properties.get(\"format\").toString()));\n                 } else {\n-                    LOG.warn(\"Could not parse date value; returning original value\");\n+                    // Give all field types a format, since operations such as casts\n+                    // can change the output type for a field to `date`.\n+                    formatMap.put(fieldName, getFormatsFromProperties(\"date_optional_time\"));\n                 }\n             }\n         }\n+\n+        return formatMap;\n     }\n \n-    private Date parseDateString(DateFormat format, String columnOriginalDate) {\n-        try {\n-            switch (format) {\n-                case DATE_OPTIONAL_TIME:\n-                    return DateUtils.parseDate(\n-                        columnOriginalDate,\n-                        FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION,\n-                        FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION,\n-                        FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION,\n-                        FORMAT_DOT_DATE_AND_TIME,\n-                        FORMAT_DOT_DATE);\n-                case EPOCH_MILLIS:\n-                    return new Date(Long.parseLong(columnOriginalDate));\n-                case EPOCH_SECOND:\n-                    return new Date(Long.parseLong(columnOriginalDate) * 1000);\n-                default:\n-                    return DateUtils.parseDate(columnOriginalDate, format.getFormatString());\n+    private List<String> getFormatsFromProperties(String formatProperty) {\n+        String[] formats = formatProperty.split(FORMAT_DELIMITER);\n+        return Arrays.asList(formats);\n+    }\n+\n+    private Date parseDateString(List<String> formats, String columnOriginalDate) {\n+        TimeZone originalDefaultTimeZone = TimeZone.getDefault();\n+        Date parsedDate = null;\n+\n+        // Apache Commons DateUtils uses the default TimeZone for the JVM when parsing.\n+        // However, since all dates on Elasticsearch are stored as UTC, we need to\n+        // parse these values using the UTC timezone.\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n+        for (String columnFormat : formats) {\n+            try {\n+                switch (columnFormat) {\n+                    case \"date_optional_time\":\n+                        parsedDate = DateUtils.parseDate(\n+                            columnOriginalDate,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION_NO_TIME,\n+                            FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION,\n+                            FORMAT_DOT_DATE_AND_TIME,\n+                            FORMAT_DOT_DATE);\n+                        break;\n+                    case \"epoch_millis\":\n+                        parsedDate = new Date(Long.parseLong(columnOriginalDate));\n+                        break;\n+                    case \"epoch_second\":\n+                        parsedDate = new Date(Long.parseLong(columnOriginalDate) * 1000);\n+                        break;\n+                    default:\n+                        String formatString = DateFormat.getFormatString(columnFormat);\n+                        if (formatString == null) {\n+                            // Custom format; take as-is\n+                            formatString = columnFormat;\n+                        }\n+                        parsedDate = DateUtils.parseDate(columnOriginalDate, formatString);\n+                }\n+            } catch (ParseException | NumberFormatException e) {\n+                LOG.warn(String.format(\"Could not parse date string %s as %s\", columnOriginalDate, columnFormat));\n             }\n-        } catch (ParseException e) {\n-            LOG.error(\n-                String.format(\"Error parsing date string %s as %s\", columnOriginalDate, format.nameLowerCase()),\n-                e);\n         }\n-        return null;\n-    }\n+        // Reset default timezone after parsing\n+        TimeZone.setDefault(originalDefaultTimeZone);\n \n+        return parsedDate;\n+    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NzY0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r381657646", "body": "I think you may not need to touch this class or the `LocalClusterState` either. Because `LocalClusterState` has the mapping, you can just use it outside or in your new added Formatter class.", "bodyText": "I think you may not need to touch this class or the LocalClusterState either. Because LocalClusterState has the mapping, you can just use it outside or in your new added Formatter class.", "bodyHTML": "<p dir=\"auto\">I think you may not need to touch this class or the <code>LocalClusterState</code> either. Because <code>LocalClusterState</code> has the mapping, you can just use it outside or in your new added Formatter class.</p>", "author": "dai-chen", "createdAt": "2020-02-20T01:47:44Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/antlr/semantic/visitor/ESMappingLoader.java", "diffHunk": "@@ -105,9 +105,25 @@ private void defineIndexType(String indexName) {\n \n     private void loadAllFieldsWithType(String indexName) {\n         FieldMappings mappings = getFieldMappings(indexName);\n+        saveDateFormats(mappings);\n         mappings.flat(this::defineFieldName);\n     }\n \n+    private void saveDateFormats(FieldMappings mappings) {", "originalCommit": "2ae4195a41419305c44483944bae841795d59393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTIwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382855205", "bodyText": "Now fetching information from LocalClusterState in my Formatter class", "author": "jordanw-bq", "createdAt": "2020-02-21T23:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NzY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzcyMA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382857720", "bodyText": "Any chance to avoid the changes in LocalClusterState? It is a global state which can not be used for state per query.", "author": "dai-chen", "createdAt": "2020-02-21T23:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NzY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MzY1NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r383493654", "bodyText": "Moved changes out of LocalClusterState", "author": "jordanw-bq", "createdAt": "2020-02-24T20:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NzY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "bda0b47e3eef38b2de6ee9abd27d70c9b084e514", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/antlr/semantic/visitor/ESMappingLoader.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/antlr/semantic/visitor/ESMappingLoader.java\nindex 40da373b..4ac08000 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/antlr/semantic/visitor/ESMappingLoader.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/antlr/semantic/visitor/ESMappingLoader.java\n", "chunk": "@@ -104,24 +106,8 @@ public class ESMappingLoader implements GenericSqlParseTreeVisitor<Type> {\n     }\n \n     private void loadAllFieldsWithType(String indexName) {\n-        FieldMappings mappings = getFieldMappings(indexName);\n-        saveDateFormats(mappings);\n-        mappings.flat(this::defineFieldName);\n-    }\n-\n-    private void saveDateFormats(FieldMappings mappings) {\n-        for (Map.Entry<String, Map<String, Object>> data : mappings.data().entrySet()) {\n-            String fieldName = data.getKey();\n-            Object type = data.getValue().get(\"type\");\n-            if (\"date\".equals(type)) {\n-                Object fieldDateFormat = data.getValue().get(\"format\");\n-                if (fieldDateFormat == null) {\n-                    // Default format when not specified is \"date_optional_time\"\n-                    fieldDateFormat = \"date_optional_time\";\n-                }\n-                clusterState.pushDateFieldFormat(fieldName, fieldDateFormat.toString());\n-            }\n-        }\n+        Set<FieldMappings> mappings = getFieldMappings(indexName);\n+        mappings.forEach(mapping -> mapping.flat(this::defineFieldName));\n     }\n \n     /*\n", "next_change": null}]}}, {"oid": "428f18970e40190eed673188b99f41a613730bc8", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/428f18970e40190eed673188b99f41a613730bc8", "message": "addressed code review comments and build failures", "committedDate": "2020-02-21T22:13:19Z", "type": "commit"}, {"oid": "65a2e4934815568369d5ed538be44a4100092dcd", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/65a2e4934815568369d5ed538be44a4100092dcd", "message": "Merge branch 'master' into 342-standardized-datetime\n\n# Conflicts:\n#\tsrc/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/Protocol.java\n#\tsrc/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/SelectResultSet.java", "committedDate": "2020-02-21T22:22:26Z", "type": "commit"}, {"oid": "0e430222dba5fd1687bacb6a1febaef9cdad33dd", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/0e430222dba5fd1687bacb6a1febaef9cdad33dd", "message": "post-merge fix", "committedDate": "2020-02-21T22:25:12Z", "type": "commit"}, {"oid": "a1a87102569779beb1f882847226693af25878b8", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/a1a87102569779beb1f882847226693af25878b8", "message": "additional fixes", "committedDate": "2020-02-21T23:30:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1ODQ4NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r382858484", "body": "As my other comment said, this is not thread safe.", "bodyText": "As my other comment said, this is not thread safe.", "bodyHTML": "<p dir=\"auto\">As my other comment said, this is not thread safe.</p>", "author": "dai-chen", "createdAt": "2020-02-21T23:55:10Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/parser/FieldMaker.java", "diffHunk": "@@ -118,6 +119,7 @@ private Field makeFieldImpl(SQLExpr expr, String alias, String tableAlias) throw\n             if (alias == null) {\n                 alias = \"cast_\" + castExpr.getExpr().toString();\n             }\n+            LocalClusterState.state().putAliasInMap(alias, castExpr.getExpr().toString());", "originalCommit": "a1a87102569779beb1f882847226693af25878b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MzU4MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r383493580", "bodyText": "Moved changes out of LocalClusterState", "author": "jordanw-bq", "createdAt": "2020-02-24T20:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1ODQ4NA=="}], "type": "inlineReview", "revised_code": {"commit": "a4afc757fb9f813464eb31d28d3a1ce6999759bf", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/parser/FieldMaker.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/parser/FieldMaker.java\nindex 927c7145..2439b779 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/parser/FieldMaker.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/parser/FieldMaker.java\n", "chunk": "@@ -119,7 +118,6 @@ public class FieldMaker {\n             if (alias == null) {\n                 alias = \"cast_\" + castExpr.getExpr().toString();\n             }\n-            LocalClusterState.state().putAliasInMap(alias, castExpr.getExpr().toString());\n             ArrayList<SQLExpr> methodParameters = new ArrayList<>();\n             methodParameters.add(((SQLCastExpr) expr).getExpr());\n             return makeMethodField(\"CAST\", methodParameters, null, alias, tableAlias, true);\n", "next_change": null}]}}, {"oid": "f92185c4a1ad4b3767e57d6b183f56398fcb787a", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/f92185c4a1ad4b3767e57d6b183f56398fcb787a", "message": "get CAST alias info from result set class, rather than cluster state", "committedDate": "2020-02-24T20:02:58Z", "type": "commit"}, {"oid": "6f31ca79ba9018701d291bf845198468543bef7b", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/6f31ca79ba9018701d291bf845198468543bef7b", "message": "remove unused import", "committedDate": "2020-02-24T20:06:05Z", "type": "commit"}, {"oid": "e0d406ae9c19d6bcf78971b690a2a0bdaf0a8dd4", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/e0d406ae9c19d6bcf78971b690a2a0bdaf0a8dd4", "message": "remove unused import", "committedDate": "2020-02-24T20:09:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4NTg3OA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384185878", "body": "What is the difference between DateFormat.Date and FORMAT_DOT_DATE?", "bodyText": "What is the difference between DateFormat.Date and FORMAT_DOT_DATE?", "bodyHTML": "<p dir=\"auto\">What is the difference between DateFormat.Date and FORMAT_DOT_DATE?</p>", "author": "penghuo", "createdAt": "2020-02-25T23:18:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.LocalClusterState;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.FieldMappings;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.TypeMappings;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Formatter to transform date fields into a consistent format for consumption by clients.\n+ */\n+public class DateFieldFormatter {\n+    private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n+    private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+\n+    private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n+    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";", "originalCommit": "e0d406ae9c19d6bcf78971b690a2a0bdaf0a8dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4ODg5MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384188890", "bodyText": "No difference; changed to now reference DateFormat.DATE instead", "author": "jordanw-bq", "createdAt": "2020-02-25T23:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4NTg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\nindex 2c16c472..f05d340b 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n", "chunk": "@@ -38,14 +40,16 @@ import java.util.stream.Collectors;\n public class DateFieldFormatter {\n     private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n     private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+    private static final String FORMAT_DELIMITER = \"\\\\|\\\\|\";\n \n     private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION_NO_TIME = \"yyyy-MM-dd'T'\";\n     private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n-    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";\n+    private static final String FORMAT_DOT_DATE = DateFormat.getFormatString(\"date\");\n \n-    private final Map<String, String> dateFieldFormatMap;\n+    private final Map<String, List<String>> dateFieldFormatMap;\n     private final Map<String, String> fieldAliasMap;\n     private Set<String> dateColumns;\n \n", "next_change": null}]}}, {"oid": "2583eedd5f1d05cc29132477ead47af06408ce35", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/2583eedd5f1d05cc29132477ead47af06408ce35", "message": "reduce duplication & reference enum value", "committedDate": "2020-02-25T23:25:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NDg5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384194892", "body": "How does multiple date format covered?\r\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/date.html#multiple-date-formats", "bodyText": "How does multiple date format covered?\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/date.html#multiple-date-formats", "bodyHTML": "<p dir=\"auto\">How does multiple date format covered?<br>\n<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html#multiple-date-formats\" rel=\"nofollow\">https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html#multiple-date-formats</a></p>", "author": "penghuo", "createdAt": "2020-02-25T23:42:57Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.LocalClusterState;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.FieldMappings;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.TypeMappings;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Formatter to transform date fields into a consistent format for consumption by clients.\n+ */\n+public class DateFieldFormatter {\n+    private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n+    private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+\n+    private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n+    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";\n+\n+    private final Map<String, String> dateFieldFormatMap;\n+    private final Map<String, String> fieldAliasMap;\n+    private Set<String> dateColumns;\n+\n+    public DateFieldFormatter(String indexName, List<Schema.Column> columns, Map<String, String> fieldAliasMap) {\n+        this.dateFieldFormatMap = getDateFieldFormatMap(indexName);\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n+    }\n+\n+    @VisibleForTesting\n+    protected DateFieldFormatter(Map<String, String> dateFieldFormatMap,\n+                                 List<Schema.Column> columns,\n+                                 Map<String, String> fieldAliasMap) {\n+        this.dateFieldFormatMap = dateFieldFormatMap;\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n+    }\n+\n+    /**\n+     * Apply the JDBC date format ({@code yyyy-MM-dd HH:mm:ss.SSS}) to date values in the current row.\n+     *\n+     * @param rowSource The row in which to format the date values.\n+     */\n+    public void applyJDBCDateFormat(Map<String, Object> rowSource) {\n+        for (String columnName : dateColumns) {\n+            Object columnOriginalDate = rowSource.get(columnName);\n+            if (columnOriginalDate == null) {\n+                // Don't try to parse null date values\n+                continue;\n+            }\n+\n+            String columnFormat = getFormatForColumn(columnName);\n+            if (columnFormat == null) {\n+                LOG.warn(\"Could not determine date format for column {}; returning original value\", columnName);\n+                continue;\n+            }\n+            DateFormat format = DateFormat.valueOf(columnFormat.toUpperCase());\n+\n+            Date date = parseDateString(format, columnOriginalDate.toString());\n+            if (date != null) {\n+                rowSource.put(columnName, DateFormat.getFormattedDate(date, FORMAT_JDBC));\n+            } else {\n+                LOG.warn(\"Could not parse date value; returning original value\");\n+            }\n+        }\n+    }\n+\n+    private String getFormatForColumn(String columnName) {\n+        // Handle special cases for column names\n+        if (fieldAliasMap.get(columnName) != null) {\n+            // Column was aliased, and we need to find the base name for the column\n+            columnName = fieldAliasMap.get(columnName);\n+        } else if (columnName.split(\"\\\\.\").length == 2) {\n+            // Column is part of a join, and is qualified by the table alias\n+            columnName = columnName.split(\"\\\\.\")[1];\n+        }\n+        return dateFieldFormatMap.get(columnName);\n+    }\n+\n+    private Set<String> getDateColumns(List<Schema.Column> columns) {\n+        return columns.stream()\n+            .filter(column -> column.getType().equals(Schema.Type.DATE.nameLowerCase()))\n+            .map(Schema.Column::getName)\n+            .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, String> getDateFieldFormatMap(String indexName) {\n+        LocalClusterState state = LocalClusterState.state();\n+        Map<String, String> formatMap = new HashMap<>();\n+\n+        String[] indices = indexName.split(\"\\\\|\");\n+        Collection<TypeMappings> typeProperties = state.getFieldMappings(indices)\n+            .allMappings();\n+\n+        for (TypeMappings mappings: typeProperties) {\n+            FieldMappings fieldMappings = mappings.firstMapping();\n+            for (Map.Entry<String, Map<String, Object>> field : fieldMappings.data().entrySet()) {\n+                String fieldName = field.getKey();\n+                Map<String, Object> properties = field.getValue();\n+\n+                if (properties.containsKey(\"format\")) {", "originalCommit": "e0d406ae9c19d6bcf78971b690a2a0bdaf0a8dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjE3MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384202170", "bodyText": "Currently not handled; will add handling & testing for this", "author": "jordanw-bq", "createdAt": "2020-02-26T00:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NDg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1ODQ0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384758441", "bodyText": "Added handling & tests for multiple formats", "author": "jordanw-bq", "createdAt": "2020-02-26T20:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NDg5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\nindex 2c16c472..f05d340b 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n", "chunk": "@@ -127,11 +131,11 @@ public class DateFieldFormatter {\n                 Map<String, Object> properties = field.getValue();\n \n                 if (properties.containsKey(\"format\")) {\n-                    formatMap.put(fieldName, properties.get(\"format\").toString());\n+                    formatMap.put(fieldName, getFormatsFromProperties(properties.get(\"format\").toString()));\n                 } else {\n                     // Give all field types a format, since operations such as casts\n                     // can change the output type for a field to `date`.\n-                    formatMap.put(fieldName, \"date_optional_time\");\n+                    formatMap.put(fieldName, getFormatsFromProperties(\"date_optional_time\"));\n                 }\n             }\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTQ1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384195455", "body": "Is it possible the columnFormat is not included in the DateFormat? For example, custom-date-formats, https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#custom-date-formats", "bodyText": "Is it possible the columnFormat is not included in the DateFormat? For example, custom-date-formats, https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#custom-date-formats", "bodyHTML": "<p dir=\"auto\">Is it possible the columnFormat is not included in the DateFormat? For example, custom-date-formats, <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#custom-date-formats\" rel=\"nofollow\">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#custom-date-formats</a></p>", "author": "penghuo", "createdAt": "2020-02-25T23:44:35Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.executor.format;\n+\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.LocalClusterState;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.FieldMappings;\n+import com.amazon.opendistroforelasticsearch.sql.esdomain.mapping.TypeMappings;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Formatter to transform date fields into a consistent format for consumption by clients.\n+ */\n+public class DateFieldFormatter {\n+    private static final Logger LOG = LogManager.getLogger(DateFieldFormatter.class);\n+    private static final String FORMAT_JDBC = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+\n+    private static final String FORMAT_DOT_DATE_AND_TIME = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_LOGS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_FLIGHTS_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    private static final String FORMAT_DOT_KIBANA_SAMPLE_DATA_ECOMMERCE_EXCEPTION = \"yyyy-MM-dd'T'HH:mm:ssXXX\";\n+    private static final String FORMAT_DOT_DATE = \"yyyy-MM-dd\";\n+\n+    private final Map<String, String> dateFieldFormatMap;\n+    private final Map<String, String> fieldAliasMap;\n+    private Set<String> dateColumns;\n+\n+    public DateFieldFormatter(String indexName, List<Schema.Column> columns, Map<String, String> fieldAliasMap) {\n+        this.dateFieldFormatMap = getDateFieldFormatMap(indexName);\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n+    }\n+\n+    @VisibleForTesting\n+    protected DateFieldFormatter(Map<String, String> dateFieldFormatMap,\n+                                 List<Schema.Column> columns,\n+                                 Map<String, String> fieldAliasMap) {\n+        this.dateFieldFormatMap = dateFieldFormatMap;\n+        this.dateColumns = getDateColumns(columns);\n+        this.fieldAliasMap = fieldAliasMap;\n+    }\n+\n+    /**\n+     * Apply the JDBC date format ({@code yyyy-MM-dd HH:mm:ss.SSS}) to date values in the current row.\n+     *\n+     * @param rowSource The row in which to format the date values.\n+     */\n+    public void applyJDBCDateFormat(Map<String, Object> rowSource) {\n+        for (String columnName : dateColumns) {\n+            Object columnOriginalDate = rowSource.get(columnName);\n+            if (columnOriginalDate == null) {\n+                // Don't try to parse null date values\n+                continue;\n+            }\n+\n+            String columnFormat = getFormatForColumn(columnName);\n+            if (columnFormat == null) {\n+                LOG.warn(\"Could not determine date format for column {}; returning original value\", columnName);\n+                continue;\n+            }\n+            DateFormat format = DateFormat.valueOf(columnFormat.toUpperCase());", "originalCommit": "e0d406ae9c19d6bcf78971b690a2a0bdaf0a8dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAzNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384202036", "bodyText": "Yeah, this does look to be a possible case. Will add handling & testing for this", "author": "jordanw-bq", "createdAt": "2020-02-26T00:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1ODU4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/367#discussion_r384758589", "bodyText": "Updated implementation & added tests for handling custom formats", "author": "jordanw-bq", "createdAt": "2020-02-26T20:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c57d72ad22b1df39b5f89838a41fbf2e8a76829", "changed_code": [{"header": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\nindex 2c16c472..f05d340b 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/sql/executor/format/DateFieldFormatter.java\n", "chunk": "@@ -77,23 +81,23 @@ public class DateFieldFormatter {\n                 continue;\n             }\n \n-            String columnFormat = getFormatForColumn(columnName);\n-            if (columnFormat == null) {\n-                LOG.warn(\"Could not determine date format for column {}; returning original value\", columnName);\n+            List<String> formats = getFormatsForColumn(columnName);\n+            if (formats == null) {\n+                LOG.warn(\"Could not determine date formats for column {}; returning original value\", columnName);\n                 continue;\n             }\n-            DateFormat format = DateFormat.valueOf(columnFormat.toUpperCase());\n \n-            Date date = parseDateString(format, columnOriginalDate.toString());\n+            Date date = parseDateString(formats, columnOriginalDate.toString());\n             if (date != null) {\n                 rowSource.put(columnName, DateFormat.getFormattedDate(date, FORMAT_JDBC));\n+                break;\n             } else {\n                 LOG.warn(\"Could not parse date value; returning original value\");\n             }\n         }\n     }\n \n-    private String getFormatForColumn(String columnName) {\n+    private List<String> getFormatsForColumn(String columnName) {\n         // Handle special cases for column names\n         if (fieldAliasMap.get(columnName) != null) {\n             // Column was aliased, and we need to find the base name for the column\n", "next_change": null}]}}, {"oid": "b5b2eac464d872595be216b5a2d356a25633ac63", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/b5b2eac464d872595be216b5a2d356a25633ac63", "message": "setting default timezone to UTC while parsing date values", "committedDate": "2020-02-26T00:53:21Z", "type": "commit"}, {"oid": "e5649f001d5d7635d64df5adf2529ad9a80b6332", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/e5649f001d5d7635d64df5adf2529ad9a80b6332", "message": "add support for custom & multiple formats", "committedDate": "2020-02-26T20:19:28Z", "type": "commit"}, {"oid": "1532683b470d5018ce8e85ff7f766c4553ac33f8", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/1532683b470d5018ce8e85ff7f766c4553ac33f8", "message": "add case for Kibana flights date data with T but no time field", "committedDate": "2020-02-27T00:12:49Z", "type": "commit"}]}