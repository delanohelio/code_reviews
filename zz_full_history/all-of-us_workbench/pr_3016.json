{"pr_number": 3016, "pr_title": "[RW-2840][risk=low] Support delegated user credentials without private keys", "pr_author": "gjuggler", "pr_createdAt": "2020-01-21T13:37:21Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3016", "merge_commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "timeline": [{"oid": "ea56a316832784144b5461b858d2312f1b5dc469", "url": "https://github.com/all-of-us/workbench/commit/ea56a316832784144b5461b858d2312f1b5dc469", "message": "Get integration tests into working shape.", "committedDate": "2020-01-21T02:34:29Z", "type": "commit"}, {"oid": "342fdcd8a1c58db1d65f1e628e77f324e42357fe", "url": "https://github.com/all-of-us/workbench/commit/342fdcd8a1c58db1d65f1e628e77f324e42357fe", "message": "Simplify some of the integration test config and remove unused WorkbenchEnvironment.", "committedDate": "2020-01-21T02:35:33Z", "type": "commit"}, {"oid": "927b454c5959dea89d05f49edf85b88c92c30104", "url": "https://github.com/all-of-us/workbench/commit/927b454c5959dea89d05f49edf85b88c92c30104", "message": "Fix command-line tools.", "committedDate": "2020-01-21T02:37:58Z", "type": "commit"}, {"oid": "43e25c4e288762e28576fc992f77dd71a08e0073", "url": "https://github.com/all-of-us/workbench/commit/43e25c4e288762e28576fc992f77dd71a08e0073", "message": "Formatting fixes.", "committedDate": "2020-01-21T02:38:58Z", "type": "commit"}, {"oid": "abecff4b0b037d5cca1f34b37f6c53bbb43c19bb", "url": "https://github.com/all-of-us/workbench/commit/abecff4b0b037d5cca1f34b37f6c53bbb43c19bb", "message": "Create a DelegatedUserCredentials class and migrate all usage away from GCS-stored keys.", "committedDate": "2020-01-21T02:43:14Z", "type": "commit"}, {"oid": "caf2da08cd3aafe9d57858faf3a9930f2189084c", "url": "https://github.com/all-of-us/workbench/commit/caf2da08cd3aafe9d57858faf3a9930f2189084c", "message": "Bring back GCS-stored key code and add feature flag to toggle between key and keyless usage.", "committedDate": "2020-01-21T02:48:15Z", "type": "commit"}, {"oid": "ea4ed6d5b91ad7b3edac60b80239ac66d0d282e4", "url": "https://github.com/all-of-us/workbench/commit/ea4ed6d5b91ad7b3edac60b80239ac66d0d282e4", "message": "Tweak things a bit so DirectoryService is only instantiated from within a request context; this fixes the local API smoke tests.", "committedDate": "2020-01-21T02:48:32Z", "type": "commit"}, {"oid": "f6caf847786cb2e83dede4690911eadd1e86c911", "url": "https://github.com/all-of-us/workbench/commit/f6caf847786cb2e83dede4690911eadd1e86c911", "message": "Add unit tests for DelegatedUserCredentials", "committedDate": "2020-01-21T02:48:32Z", "type": "commit"}, {"oid": "a78ec749808a2c21c38a5379837341f539919cd6", "url": "https://github.com/all-of-us/workbench/commit/a78ec749808a2c21c38a5379837341f539919cd6", "message": "Fix rebase error.", "committedDate": "2020-01-21T02:50:35Z", "type": "commit"}, {"oid": "165e591708f0837063c065e46d33a5e5ba696b0c", "url": "https://github.com/all-of-us/workbench/commit/165e591708f0837063c065e46d33a5e5ba696b0c", "message": "Doc and formatting fixes.", "committedDate": "2020-01-21T13:09:57Z", "type": "commit"}, {"oid": "fb262760de52015bbc193d3d304bc15d6ee972cd", "url": "https://github.com/all-of-us/workbench/commit/fb262760de52015bbc193d3d304bc15d6ee972cd", "message": "Spotless format fixes.", "committedDate": "2020-01-21T13:13:22Z", "type": "commit"}, {"oid": "1c66db8856cc54f7fd3546aa94b196d26c5f659b", "url": "https://github.com/all-of-us/workbench/commit/1c66db8856cc54f7fd3546aa94b196d26c5f659b", "message": "Remove unintended Gradle build file change.", "committedDate": "2020-01-21T13:38:15Z", "type": "commit"}, {"oid": "018cc9d1824035e69cd9eee74d72c34b2be5fd3c", "url": "https://github.com/all-of-us/workbench/commit/018cc9d1824035e69cd9eee74d72c34b2be5fd3c", "message": "Revert a couple unintended rebase errors.", "committedDate": "2020-01-21T13:41:20Z", "type": "commit"}, {"oid": "299bf5e62068d7e4b4e1c8e90af9e2346c9c7ef6", "url": "https://github.com/all-of-us/workbench/commit/299bf5e62068d7e4b4e1c8e90af9e2346c9c7ef6", "message": "Spotless formatting.", "committedDate": "2020-01-21T13:41:32Z", "type": "commit"}, {"oid": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "url": "https://github.com/all-of-us/workbench/commit/3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "message": "Add a couple test comments and remove an unnecessary instance var.", "committedDate": "2020-01-21T13:52:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNTczOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369105738", "body": "Could we rename `ImpersonatedCredentials` `ImpersonatedServiceCredentials` to make this more obvious?", "bodyText": "Could we rename ImpersonatedCredentials ImpersonatedServiceCredentials to make this more obvious?", "bodyHTML": "<p dir=\"auto\">Could we rename <code>ImpersonatedCredentials</code> <code>ImpersonatedServiceCredentials</code> to make this more obvious?</p>", "author": "jaycarlton", "createdAt": "2020-01-21T16:27:32Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2Mjc0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369362743", "bodyText": "Unfortunately not \u2013\u00a0ImpersonatedCredentials is from the Google-provided oauth2 library. I agree, the naming is confusing.", "author": "gjuggler", "createdAt": "2020-01-22T04:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNTczOA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjA1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369106052", "body": "Is this just a GAE feature?", "bodyText": "Is this just a GAE feature?", "bodyHTML": "<p dir=\"auto\">Is this just a GAE feature?</p>", "author": "jaycarlton", "createdAt": "2020-01-21T16:28:03Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MjkxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369362915", "bodyText": "It's common to all Google API clients: https://cloud.google.com/docs/authentication/production#finding_credentials_automatically", "author": "gjuggler", "createdAt": "2020-01-22T04:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjA1Mg=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwOTczMA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369109730", "body": "why is the directory named service?", "bodyText": "why is the directory named service?", "bodyHTML": "<p dir=\"auto\">why is the directory named service?</p>", "author": "jaycarlton", "createdAt": "2020-01-21T16:34:00Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzI3MA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363270", "bodyText": "Fair point \u2013\u00a0changed.", "author": "gjuggler", "createdAt": "2020-01-22T04:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwOTczMA=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..33a7ec1b3 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -47,9 +47,10 @@ import java.util.List;\n  *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n  *     \"admin-gsuite-user@my-gsuite-domain.com\",\n  *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n- *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n- *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n- *     .build();\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n  * </pre>\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -47,59 +46,58 @@ import java.util.List;\n  *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n  *     \"admin-gsuite-user@my-gsuite-domain.com\",\n  *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n- *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n- *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n- *     .build();\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n  * </pre>\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = new ArrayList<>();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjA3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369142075", "body": "nit: you can use `Optional.ofNullable(client).orElseGet(IamCredentialsClient::create);`", "bodyText": "nit: you can use Optional.ofNullable(client).orElseGet(IamCredentialsClient::create);", "bodyHTML": "<p dir=\"auto\">nit: you can use <code>Optional.ofNullable(client).orElseGet(IamCredentialsClient::create);</code></p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:32:47Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {\n+    // The first step is to call the IamCredentials API to generate a signed JWT with the\n+    // appropriate claims. This call is authorized with application default credentials (ADCs). The\n+    // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n+    // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n+    JsonWebToken.Payload payload = createClaims();\n+\n+    if (client == null) {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NDE4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369364183", "bodyText": "Personally I find the if-else more readable.", "author": "gjuggler", "createdAt": "2020-01-22T04:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjY5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369622698", "bodyText": "The root issue for me here is having a nullable field to begin with. Instead of accessing the private client directly, you could have a private Optional< IamCredentialsClient > get IamCredentialsClient(). so it's just getClient().orElseGet(...) here. Or even do the default inside the accessor.\nI like the closely packed style because someone maintaining the code later will be less likely to just stick something in one of the branches without updating all the other places.", "author": "jaycarlton", "createdAt": "2020-01-22T15:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..33a7ec1b3 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -132,7 +133,7 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createClaims();\n+    JsonWebToken.Payload payload = createJwtPayload();\n \n     if (client == null) {\n       client = IamCredentialsClient.create();\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -133,23 +130,15 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createJwtPayload();\n-\n-    if (client == null) {\n-      client = IamCredentialsClient.create();\n-    }\n     SignJwtRequest jwtRequest =\n         SignJwtRequest.newBuilder()\n             .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n-            .setPayload(JSON_FACTORY.toString(payload))\n+            .setPayload(JSON_FACTORY.toString(createJwtPayload()))\n             .build();\n-    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+    String jwt = credentialsClient.signJwt(jwtRequest).getSignedJwt();\n \n     // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n     // an access token.\n-    if (httpTransport == null) {\n-      httpTransport = new NetHttpTransport();\n-    }\n     TokenRequest tokenRequest =\n         new TokenRequest(\n             httpTransport,\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -132,23 +130,15 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createClaims();\n-\n-    if (client == null) {\n-      client = IamCredentialsClient.create();\n-    }\n     SignJwtRequest jwtRequest =\n         SignJwtRequest.newBuilder()\n             .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n-            .setPayload(JSON_FACTORY.toString(payload))\n+            .setPayload(JSON_FACTORY.toString(createJwtPayload()))\n             .build();\n-    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+    String jwt = credentialsClient.signJwt(jwtRequest).getSignedJwt();\n \n     // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n     // an access token.\n-    if (httpTransport == null) {\n-      httpTransport = new NetHttpTransport();\n-    }\n     TokenRequest tokenRequest =\n         new TokenRequest(\n             httpTransport,\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjYyOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369142628", "body": "FWIW, you could put this a Spring configuration and inject `Provider<AccessToken>`", "bodyText": "FWIW, you could put this a Spring configuration and inject Provider<AccessToken>", "bodyHTML": "<p dir=\"auto\">FWIW, you could put this a Spring configuration and inject <code>Provider&lt;AccessToken&gt;</code></p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:34:03Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NDAxMA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369364010", "bodyText": "That wouldn't work \u2013\u00a0this is an override of a method from the Google-provided OAuth2Credentials module (code).\nThis is the crux of why migrating to the newer GoogleCredentials package was a pre-requisite for this task: it allowed for seamless integration with Google's existing machinery by leveraging this hook for credential-generating subclasses.", "author": "gjuggler", "createdAt": "2020-01-22T04:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjYyOA=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..33a7ec1b3 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -132,7 +133,7 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createClaims();\n+    JsonWebToken.Payload payload = createJwtPayload();\n \n     if (client == null) {\n       client = IamCredentialsClient.create();\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -133,23 +130,15 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createJwtPayload();\n-\n-    if (client == null) {\n-      client = IamCredentialsClient.create();\n-    }\n     SignJwtRequest jwtRequest =\n         SignJwtRequest.newBuilder()\n             .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n-            .setPayload(JSON_FACTORY.toString(payload))\n+            .setPayload(JSON_FACTORY.toString(createJwtPayload()))\n             .build();\n-    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+    String jwt = credentialsClient.signJwt(jwtRequest).getSignedJwt();\n \n     // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n     // an access token.\n-    if (httpTransport == null) {\n-      httpTransport = new NetHttpTransport();\n-    }\n     TokenRequest tokenRequest =\n         new TokenRequest(\n             httpTransport,\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -132,23 +130,15 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createClaims();\n-\n-    if (client == null) {\n-      client = IamCredentialsClient.create();\n-    }\n     SignJwtRequest jwtRequest =\n         SignJwtRequest.newBuilder()\n             .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n-            .setPayload(JSON_FACTORY.toString(payload))\n+            .setPayload(JSON_FACTORY.toString(createJwtPayload()))\n             .build();\n-    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+    String jwt = credentialsClient.signJwt(jwtRequest).getSignedJwt();\n \n     // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n     // an access token.\n-    if (httpTransport == null) {\n-      httpTransport = new NetHttpTransport();\n-    }\n     TokenRequest tokenRequest =\n         new TokenRequest(\n             httpTransport,\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MzUxOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369143518", "body": "nit: I was looking for a simpler way to do this, and the `Calendar` class might be one way. https://stackoverflow.com/a/1655450/12345554", "bodyText": "nit: I was looking for a simpler way to do this, and the Calendar class might be one way. https://stackoverflow.com/a/1655450/12345554", "bodyHTML": "<p dir=\"auto\">nit: I was looking for a simpler way to do this, and the <code>Calendar</code> class might be one way. <a href=\"https://stackoverflow.com/a/1655450/12345554\" rel=\"nofollow\">https://stackoverflow.com/a/1655450/12345554</a></p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:35:53Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {\n+    // The first step is to call the IamCredentials API to generate a signed JWT with the\n+    // appropriate claims. This call is authorized with application default credentials (ADCs). The\n+    // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n+    // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n+    JsonWebToken.Payload payload = createClaims();\n+\n+    if (client == null) {\n+      client = IamCredentialsClient.create();\n+    }\n+    SignJwtRequest jwtRequest =\n+        SignJwtRequest.newBuilder()\n+            .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n+            .setPayload(JSON_FACTORY.toString(payload))\n+            .build();\n+    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+\n+    // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n+    // an access token.\n+    if (httpTransport == null) {\n+      httpTransport = new NetHttpTransport();\n+    }\n+    TokenRequest tokenRequest =\n+        new TokenRequest(\n+            httpTransport,\n+            JSON_FACTORY,\n+            new GenericUrl(GoogleOAuthConstants.TOKEN_SERVER_URL),\n+            JWT_BEARER_GRANT_TYPE);\n+    tokenRequest.put(\"assertion\", jwt);\n+    TokenResponse tokenResponse = tokenRequest.execute();\n+    return new AccessToken(\n+        tokenResponse.getAccessToken(),\n+        Date.from(Instant.now().plusSeconds(tokenResponse.getExpiresInSeconds())));", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NTA3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369365071", "bodyText": "This is the best I could manage with Calendar:\nCalendar calendar = Calendar.getInstance(); // no fluent API\ncalendar.add(Math.toIntExact(tokenResponse.getExpiresInSeconds()), Calendar.SECOND); // calendar.add only supports integer arguments\ncalendar.getTime(); // Returns Date instance\nInstant seems like the best option here.", "author": "gjuggler", "createdAt": "2020-01-22T04:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MzUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -159,6 +149,6 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     TokenResponse tokenResponse = tokenRequest.execute();\n     return new AccessToken(\n         tokenResponse.getAccessToken(),\n-        Date.from(Instant.now().plusSeconds(tokenResponse.getExpiresInSeconds())));\n+        Date.from(Instant.now(clock).plusSeconds(tokenResponse.getExpiresInSeconds())));\n   }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -159,6 +149,6 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     TokenResponse tokenResponse = tokenRequest.execute();\n     return new AccessToken(\n         tokenResponse.getAccessToken(),\n-        Date.from(Instant.now().plusSeconds(tokenResponse.getExpiresInSeconds())));\n+        Date.from(Instant.now(clock).plusSeconds(tokenResponse.getExpiresInSeconds())));\n   }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NDI3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369144271", "body": "I'm not used to seeing the WorkbenchConfig passed int like this FWIW. I kinda feel like this should just take in the service account name and the project ID directly.", "bodyText": "I'm not used to seeing the WorkbenchConfig passed int like this FWIW. I kinda feel like this should just take in the service account name and the project ID directly.", "bodyHTML": "<p dir=\"auto\">I'm not used to seeing the WorkbenchConfig passed int like this FWIW. I kinda feel like this should just take in the service account name and the project ID directly.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:37:30Z", "path": "api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java", "diffHunk": "@@ -66,25 +69,9 @@ public static String getScopedServiceAccessToken(List<String> scopes) throws IOE\n     return scopedCreds.getAccessToken().getTokenValue();\n   }\n \n-  /**\n-   * Converts a service account Google credential into credentials for impersonating an end user.\n-   * This method assumes that the given service account has been enabled for domain-wide delegation,\n-   * and the given set of scopes have been included in the GSuite admin panel.\n-   *\n-   * <p>See docs/domain-delegation.md for more details.\n-   *\n-   * @param originalCredentials\n-   * @param userEmail Email address of the user to impersonate.\n-   * @param scopes The list of Google / OAuth API scopes to be authorized for.\n-   * @return\n-   * @throws IOException\n-   */\n-  public static GoogleCredentials getImpersonatedCredentials(\n-      GoogleCredentials originalCredentials, String userEmail, List<String> scopes)\n-      throws IOException {\n-    GoogleCredentials impersonatedCreds =\n-        originalCredentials.createScoped(scopes).createDelegated(userEmail);\n-    impersonatedCreds.refresh();\n-    return impersonatedCreds;\n+  public static String getServiceAccountEmail(\n+      String serviceAccountName, WorkbenchConfig workbenchConfig) {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NjM2NA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369366364", "bodyText": "Sounds reasonable \u2013 done.\nUltimately, this kind of thing feels like it might naturally belong as a method on the WorkbenchConfig object itself. Similar to the Cloud Task / App Engine location methods we recently added... I wonder if it wouldn't be heresy to start adding some basic bits of read-only logic to that data class.", "author": "gjuggler", "createdAt": "2020-01-22T04:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NDI3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\nindex 4a5a84679..95e5003f5 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n", "chunk": "@@ -69,9 +68,7 @@ public class ServiceAccounts {\n     return scopedCreds.getAccessToken().getTokenValue();\n   }\n \n-  public static String getServiceAccountEmail(\n-      String serviceAccountName, WorkbenchConfig workbenchConfig) {\n-    return String.format(\n-        \"%s@%s.iam.gserviceaccount.com\", serviceAccountName, workbenchConfig.server.projectId);\n+  public static String getServiceAccountEmail(String serviceAccountName, String projectId) {\n+    return String.format(\"%s@%s.iam.gserviceaccount.com\", serviceAccountName, projectId);\n   }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\nindex 4a5a84679..95e5003f5 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n", "chunk": "@@ -69,9 +68,7 @@ public class ServiceAccounts {\n     return scopedCreds.getAccessToken().getTokenValue();\n   }\n \n-  public static String getServiceAccountEmail(\n-      String serviceAccountName, WorkbenchConfig workbenchConfig) {\n-    return String.format(\n-        \"%s@%s.iam.gserviceaccount.com\", serviceAccountName, workbenchConfig.server.projectId);\n+  public static String getServiceAccountEmail(String serviceAccountName, String projectId) {\n+    return String.format(\"%s@%s.iam.gserviceaccount.com\", serviceAccountName, projectId);\n   }\n }\n", "next_change": {"commit": "493cf02523762a18af9ae279a57c8041452866e5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\nindex 95e5003f5..fbcf84ddc 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n", "chunk": "@@ -63,9 +68,7 @@ public class ServiceAccounts {\n    * credentials.\n    */\n   public static String getScopedServiceAccessToken(List<String> scopes) throws IOException {\n-    GoogleCredentials scopedCreds = getScopedServiceCredentials(scopes);\n-    scopedCreds.refreshIfExpired();\n-    return scopedCreds.getAccessToken().getTokenValue();\n+    return getScopedServiceCredentials(scopes).getAccessToken().getTokenValue();\n   }\n \n   public static String getServiceAccountEmail(String serviceAccountName, String projectId) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "493cf02523762a18af9ae279a57c8041452866e5", "committedDate": "2020-01-30 13:22:45 -0500", "message": "[RW-4277][risk=low] Users can set workspace billing account back to free tier (#3040)"}, {"oid": "fe8b4edaeee7c0a06d5fd647009433849aa72366", "committedDate": "2020-04-08 21:26:14 -0700", "message": "[RW-4573][risk=low] Switch delete-workspaces to use SA creds (#3371)"}, {"oid": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "committedDate": "2021-10-11 12:25:07 -0700", "message": "[risk=low] Factor out impersonation to common factory (#5735)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NTg1OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369145858", "body": "nit: make `delegatedCreds` `final` so that anyone fiddling with the logic below doesn't forget to initialize it.\r\n\r\nCan we split this function into on that gets delegated credentials and another that gets the Firecloud API client? I kinda wonder if the first function would belong in this service.", "bodyText": "nit: make delegatedCreds final so that anyone fiddling with the logic below doesn't forget to initialize it.\nCan we split this function into on that gets delegated credentials and another that gets the Firecloud API client? I kinda wonder if the first function would belong in this service.", "bodyHTML": "<p dir=\"auto\">nit: make <code>delegatedCreds</code> <code>final</code> so that anyone fiddling with the logic below doesn't forget to initialize it.</p>\n<p dir=\"auto\">Can we split this function into on that gets delegated credentials and another that gets the Firecloud API client? I kinda wonder if the first function would belong in this service.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:40:54Z", "path": "api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java", "diffHunk": "@@ -132,14 +133,24 @@ public FireCloudServiceImpl(\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    // Load credentials for the firecloud-admin Service Account. This account has been granted\n-    // domain-wide delegation for the OAuth scopes required by FireCloud.\n-    GoogleCredentials impersonatedUserCredentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            fcAdminCredsProvider.get(), userEmail, FIRECLOUD_API_OAUTH_SCOPES);\n+    OAuth2Credentials delegatedCreds;", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NzA5MA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369367090", "bodyText": "Added final. I don't think splitting this method into two 3-line methods will provide a meaningful benefit.", "author": "gjuggler", "createdAt": "2020-01-22T04:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NTg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex a2a8ac017..746cda923 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -133,11 +135,12 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n               FIRECLOUD_API_OAUTH_SCOPES);\n     } else {\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 746cda923..2b18fade7 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -142,7 +150,9 @@ public class FireCloudServiceImpl implements FireCloudService {\n               ServiceAccounts.getServiceAccountEmail(\n                   ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES);\n+              FIRECLOUD_API_OAUTH_SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           fcAdminCredsProvider\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex a2a8ac017..1b6d8428b 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -133,13 +142,16 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES);\n+              FIRECLOUD_API_OAUTH_SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           fcAdminCredsProvider\n", "next_change": {"commit": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 1b6d8428b..8bdccf116 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -142,23 +144,14 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    final OAuth2Credentials delegatedCreds;\n-    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n-      delegatedCreds =\n-          new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\n-                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-              userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES,\n-              iamCredentialsClient,\n-              httpTransport);\n-    } else {\n-      delegatedCreds =\n-          fcAdminCredsProvider\n-              .get()\n-              .createScoped(FIRECLOUD_API_OAUTH_SCOPES)\n-              .createDelegated(userEmail);\n-    }\n+    final OAuth2Credentials delegatedCreds =\n+        new DelegatedUserCredentials(\n+            ServiceAccounts.getServiceAccountEmail(\n+                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n+            userEmail,\n+            FIRECLOUD_API_OAUTH_SCOPES,\n+            iamCredentialsClient,\n+            httpTransport);\n     delegatedCreds.refreshIfExpired();\n \n     ApiClient apiClient = FireCloudConfig.buildApiClient(configProvider.get());\n", "next_change": {"commit": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 8bdccf116..12b91ef7a 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -115,48 +123,26 @@ public class FireCloudServiceImpl implements FireCloudService {\n           Provider<StaticNotebooksApi> endUserStaticNotebooksApiProvider,\n       @Qualifier(FireCloudConfig.SERVICE_ACCOUNT_STATIC_NOTEBOOKS_API)\n           Provider<StaticNotebooksApi> serviceAccountStaticNotebooksApiProvider,\n-      FirecloudRetryHandler retryHandler,\n-      IamCredentialsClient iamCredentialsClient,\n-      HttpTransport httpTransport) {\n+      @Qualifier(FireCloudCacheConfig.SERVICE_ACCOUNT_REQUEST_SCOPED_GROUP_CACHE)\n+          Provider<LoadingCache<String, FirecloudManagedGroupWithMembers>>\n+              requestScopedGroupCacheProvider,\n+      FirecloudApiClientFactory firecloudApiClientFactory,\n+      FirecloudRetryHandler retryHandler) {\n     this.configProvider = configProvider;\n     this.profileApiProvider = profileApiProvider;\n     this.billingApiProvider = billingApiProvider;\n+    this.serviceAccountBillingV2ApiProvider = serviceAccountBillingV2ApiProvider;\n+    this.endUserBillingV2ApiProvider = endUserBillingV2ApiProvider;\n     this.groupsApiProvider = groupsApiProvider;\n     this.nihApiProvider = nihApiProvider;\n     this.endUserWorkspacesApiProvider = endUserWorkspacesApiProvider;\n     this.serviceAccountWorkspaceApiProvider = serviceAccountWorkspaceApiProvider;\n     this.statusApiProvider = statusApiProvider;\n-    this.retryHandler = retryHandler;\n     this.endUserStaticNotebooksApiProvider = endUserStaticNotebooksApiProvider;\n     this.serviceAccountStaticNotebooksApiProvider = serviceAccountStaticNotebooksApiProvider;\n-    this.iamCredentialsClient = iamCredentialsClient;\n-    this.httpTransport = httpTransport;\n-  }\n-\n-  /**\n-   * Given an email address of an AoU user, generates a FireCloud ApiClient instance with an access\n-   * token suitable for accessing data on behalf of that user.\n-   *\n-   * <p>This relies on domain-wide delegation of authority in Google's OAuth flow; see\n-   * /api/docs/domain-wide-delegation.md for more details.\n-   *\n-   * @param userEmail\n-   * @return\n-   */\n-  public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    final OAuth2Credentials delegatedCreds =\n-        new DelegatedUserCredentials(\n-            ServiceAccounts.getServiceAccountEmail(\n-                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-            userEmail,\n-            FIRECLOUD_API_OAUTH_SCOPES,\n-            iamCredentialsClient,\n-            httpTransport);\n-    delegatedCreds.refreshIfExpired();\n-\n-    ApiClient apiClient = FireCloudConfig.buildApiClient(configProvider.get());\n-    apiClient.setAccessToken(delegatedCreds.getAccessToken().getTokenValue());\n-    return apiClient;\n+    this.requestScopedGroupCacheProvider = requestScopedGroupCacheProvider;\n+    this.firecloudApiClientFactory = firecloudApiClientFactory;\n+    this.retryHandler = retryHandler;\n   }\n \n   @Override\n", "next_change": {"commit": "166163c460ec5c801a5ec4a816123dfd0fed92ec", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 12b91ef7a..796bd7a82 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -136,10 +142,11 @@ public class FireCloudServiceImpl implements FireCloudService {\n     this.groupsApiProvider = groupsApiProvider;\n     this.nihApiProvider = nihApiProvider;\n     this.endUserWorkspacesApiProvider = endUserWorkspacesApiProvider;\n+    this.endUserLenientTimeoutWorkspacesApiProvider = endUserLenientTimeoutWorkspacesApiProvider;\n     this.serviceAccountWorkspaceApiProvider = serviceAccountWorkspaceApiProvider;\n     this.statusApiProvider = statusApiProvider;\n+    this.termsOfServiceApiProvider = termsOfServiceApiProvider;\n     this.endUserStaticNotebooksApiProvider = endUserStaticNotebooksApiProvider;\n-    this.serviceAccountStaticNotebooksApiProvider = serviceAccountStaticNotebooksApiProvider;\n     this.requestScopedGroupCacheProvider = requestScopedGroupCacheProvider;\n     this.firecloudApiClientFactory = firecloudApiClientFactory;\n     this.retryHandler = retryHandler;\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "493cf02523762a18af9ae279a57c8041452866e5", "committedDate": "2020-01-30 13:22:45 -0500", "message": "[RW-4277][risk=low] Users can set workspace billing account back to free tier (#3040)"}, {"oid": "7c3217c3265bf6d5fd1be4b1816d1fcd45c3d63f", "committedDate": "2020-03-30 12:28:18 -0700", "message": "[RW-4583][risk=low] Switch to Rawls cloneWorkspace (#3315)"}, {"oid": "452bab947f2dc2a4186b3720191d72ce9174d032", "committedDate": "2020-04-20 10:05:57 -0700", "message": "[RW-4713][risk=moderate] Fix admin page auth and rename service methods (#3437)"}, {"oid": "dd9c971761982cf90054a9028b83908a1b34ffe8", "committedDate": "2020-04-21 14:01:42 -0400", "message": "[RW-4737][risk=no] Enable Google Private IP Adddress flag on new project creation (#3438)"}, {"oid": "d2b6435fc8afc8447769f21bfded310b800e3858", "committedDate": "2020-06-16 15:35:59 -0400", "message": "[RW-4257][risk=moderate] Add support for the new Shibboleth service (#3676)"}, {"oid": "d911a075b431740f89fe3b3d154b8586c7a39238", "committedDate": "2020-06-22 09:25:58 -0700", "message": "[RW-5013][risk=no] Correct the parameter order on BP removal... (#3694)"}, {"oid": "9f0413d0fd9de4ae2563ce383f73218332422eae", "committedDate": "2020-07-21 16:17:21 -0700", "message": "[RW-5295][risk=low] Consolidate field masking, fix mapper (#3805)"}, {"oid": "c2fed4f7bf527603ba17adb17a291be4153440f6", "committedDate": "2020-09-14 16:30:35 -0400", "message": "[risk=low][RW-5475] Admin read-only notebook endpoint (#3999)"}, {"oid": "b3d0ecafc70efb7a8b38cb9fe7dd1ec3a54c3532", "committedDate": "2020-09-17 17:06:20 -0400", "message": "[risk=low][RW-3627] Delete project when deleting workspace (#3985)"}, {"oid": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "committedDate": "2020-11-20 08:12:44 -0500", "message": "[risk=low][RW-4798][RW-4688][RW-3882][RW-4308][RW-5091] Teardown Feature Flags, part 1 (#4308)"}, {"oid": "fc76ba68856b4a0c668e925d4e3dcc7f7c32dc4c", "committedDate": "2021-02-23 10:16:12 -0500", "message": "[risk=medium][RW-5241] Add Access Tier to Billing Buffer (#4576)"}, {"oid": "a716a2999c3e726fedd023a702629d267704910e", "committedDate": "2021-02-25 13:35:06 -0500", "message": "[RW-6180][risk=medium] update Workspace logic for Multi Tier  (#4607)"}, {"oid": "84a9d5648a94c5d11d720531bb952dbf0e4c2127", "committedDate": "2021-04-01 11:26:51 -0400", "message": "[RW-6417][risk=low] Switch from workspaceNamespace to googleProject when using Runtime APIs (#4759)"}, {"oid": "bde74cad78429d245937b40bef3d0df9ebb73a2b", "committedDate": "2021-05-10 16:22:30 -0400", "message": "[RW-6438][Billing V2 Step 1]convert firecloud to swagger 3 (#4953)"}, {"oid": "801948c17f3907ada0a820054661356ce9ecb66e", "committedDate": "2021-05-24 16:05:53 -0400", "message": "[RW-6438][risk=low] Adding Firecloud v2 billing endpoint that is protected by a feature flag. (#4965)"}, {"oid": "8ece9e762070e258a0e51f5ef63905e3cab12211", "committedDate": "2021-06-28 09:21:59 -0700", "message": "[RW-6919][risk=moderate] Cache Firecloud group lookups (#5164)"}, {"oid": "48b08ba7af41a265628113ff97906d5dd9e0ca28", "committedDate": "2021-07-07 15:58:27 -0400", "message": "[RW-6896][risk=low]: Call Terra to update billing account.  (#5185)"}, {"oid": "13748e9a7a4ea709f4eed9d4a0934b5bb812f846", "committedDate": "2021-08-06 17:14:45 -0400", "message": "[no ticket] Change v2_billing APIs' interface according to recent FireCloud change (#5366)"}, {"oid": "fb9fae123576c225e674e105b77a176ceb0ac8f1", "committedDate": "2021-08-26 10:34:37 -0400", "message": "[no ticket][risk=no] Set bucket location when cloning workspaces for PPW. (#5476)"}, {"oid": "ed4503dd1fe4f949d6bf066cbd229006d85c188d", "committedDate": "2021-10-04 21:56:13 -0400", "message": "[RW-7278][risk=low]Remove PPW feature flag (#5687)"}, {"oid": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "committedDate": "2021-10-11 12:25:07 -0700", "message": "[risk=low] Factor out impersonation to common factory (#5735)"}, {"oid": "0912ada215ceef05ae2336348772c309c3c0c6f0", "committedDate": "2021-10-20 09:30:34 -0700", "message": "[risk=no] Update Terra Workspace model to latest (#5785)"}, {"oid": "527f179967b01dae78159d737eec34853b354779", "committedDate": "2021-10-26 14:41:43 -0700", "message": "[risk=no] Fix FirecloudService parameter names (#5815)"}, {"oid": "f239a18f023374363a8d80fa6b2579178dd37846", "committedDate": "2021-11-24 20:57:22 -0500", "message": "[RW-7312][risk=no]  UX should account for GCS object copy delay in workspace clone"}, {"oid": "0799895ab2462dfec1ab679c73b36701965501f0", "committedDate": "2021-12-01 12:11:04 -0500", "message": "[risk=no][RW-7255] Prohibit apostrophes in usernames (#5972)"}, {"oid": "6cce8185b9d7d415d9d28ab77fb456faad2a8cfe", "committedDate": "2022-03-17 13:47:34 -0400", "message": "[risk=low][RW-7833] New users call Terra's Accept TOS endpoint (#6454)"}, {"oid": "b81964d75da0e07b0fa0a3565cae69d7969f293d", "committedDate": "2022-03-17 13:19:30 -0700", "message": "[RW-8054][risk=low] Fix ShareWorkspace for CT published workspaces (#6464)"}, {"oid": "29e1a34cbc595c0ce7a7cfd7725ff5b027ceca88", "committedDate": "2022-03-29 13:15:23 -0400", "message": "[RW-7834][risk=low]Require TOS acceptance on login when users are not Terra-TOS compliant (#6479)"}, {"oid": "4969dc22b07b3d32c52c142729b7a05a33cb07ef", "committedDate": "2022-06-08 09:14:14 -0400", "message": "gcs location (#6761)"}, {"oid": "166163c460ec5c801a5ec4a816123dfd0fed92ec", "committedDate": "2022-07-13 13:14:31 -0700", "message": "[RW-8585][risk=low] Reduce request deadline to Terra, except for create/clone workspace (#6837)"}, {"oid": "efa3f0343fd3ccaff074a8a7be6da0dde3cfd3bd", "committedDate": "2022-11-28 17:26:16 -0500", "message": "[risk=low][no ticket] Notebooks API: add tests and refactor (#7197)"}, {"oid": "3c4cae470c4987ae9cbbebe281f0bab8cf0e08a1", "committedDate": "2022-12-08 17:42:40 -0500", "message": "[risk=low][RW-9269] Keep test users TOS-compliant via cron (#7219)"}, {"oid": "d58ed2809cc7321c481a9adc17ffa26d28aee138", "committedDate": "2022-12-22 10:00:07 -0500", "message": "[risk=low][RW-9270] Continue deleting workspaces if one is not found (#7265)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NjQ5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369146498", "body": "FWIW this could also be provided by spring configuration methods: one to give you up-to-date delegated credentials and another to give the firecloud API. Both would need to be prototype scope I think.", "bodyText": "FWIW this could also be provided by spring configuration methods: one to give you up-to-date delegated credentials and another to give the firecloud API. Both would need to be prototype scope I think.", "bodyHTML": "<p dir=\"auto\">FWIW this could also be provided by spring configuration methods: one to give you up-to-date delegated credentials and another to give the firecloud API. Both would need to be prototype scope I think.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:42:20Z", "path": "api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java", "diffHunk": "@@ -132,14 +133,24 @@ public FireCloudServiceImpl(\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    // Load credentials for the firecloud-admin Service Account. This account has been granted\n-    // domain-wide delegation for the OAuth scopes required by FireCloud.\n-    GoogleCredentials impersonatedUserCredentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            fcAdminCredsProvider.get(), userEmail, FIRECLOUD_API_OAUTH_SCOPES);\n+    OAuth2Credentials delegatedCreds;\n+    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n+      delegatedCreds =\n+          new DelegatedUserCredentials(\n+              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              userEmail,\n+              FIRECLOUD_API_OAUTH_SCOPES);\n+    } else {\n+      delegatedCreds =\n+          fcAdminCredsProvider\n+              .get()\n+              .createScoped(FIRECLOUD_API_OAUTH_SCOPES)\n+              .createDelegated(userEmail);\n+    }\n+    delegatedCreds.refreshIfExpired();", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2ODg5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369368896", "bodyText": "What benefit would that give us? My instinct is to try and only add configuration when it's immediately needed, or plausibly required in the near term.\n(More pragmatically, I'm trying to be fairly surgical in these PRs to avoid adding unnecessary outage or rollback risk to the roll-out of this feature.)", "author": "gjuggler", "createdAt": "2020-01-22T04:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NjQ5OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex a2a8ac017..2b18fade7 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -133,13 +143,16 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES);\n+              FIRECLOUD_API_OAUTH_SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           fcAdminCredsProvider\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex a2a8ac017..1b6d8428b 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -133,13 +142,16 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES);\n+              FIRECLOUD_API_OAUTH_SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           fcAdminCredsProvider\n", "next_change": {"commit": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 1b6d8428b..8bdccf116 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -142,23 +144,14 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    final OAuth2Credentials delegatedCreds;\n-    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n-      delegatedCreds =\n-          new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\n-                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-              userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES,\n-              iamCredentialsClient,\n-              httpTransport);\n-    } else {\n-      delegatedCreds =\n-          fcAdminCredsProvider\n-              .get()\n-              .createScoped(FIRECLOUD_API_OAUTH_SCOPES)\n-              .createDelegated(userEmail);\n-    }\n+    final OAuth2Credentials delegatedCreds =\n+        new DelegatedUserCredentials(\n+            ServiceAccounts.getServiceAccountEmail(\n+                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n+            userEmail,\n+            FIRECLOUD_API_OAUTH_SCOPES,\n+            iamCredentialsClient,\n+            httpTransport);\n     delegatedCreds.refreshIfExpired();\n \n     ApiClient apiClient = FireCloudConfig.buildApiClient(configProvider.get());\n", "next_change": {"commit": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 8bdccf116..12b91ef7a 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -115,48 +123,26 @@ public class FireCloudServiceImpl implements FireCloudService {\n           Provider<StaticNotebooksApi> endUserStaticNotebooksApiProvider,\n       @Qualifier(FireCloudConfig.SERVICE_ACCOUNT_STATIC_NOTEBOOKS_API)\n           Provider<StaticNotebooksApi> serviceAccountStaticNotebooksApiProvider,\n-      FirecloudRetryHandler retryHandler,\n-      IamCredentialsClient iamCredentialsClient,\n-      HttpTransport httpTransport) {\n+      @Qualifier(FireCloudCacheConfig.SERVICE_ACCOUNT_REQUEST_SCOPED_GROUP_CACHE)\n+          Provider<LoadingCache<String, FirecloudManagedGroupWithMembers>>\n+              requestScopedGroupCacheProvider,\n+      FirecloudApiClientFactory firecloudApiClientFactory,\n+      FirecloudRetryHandler retryHandler) {\n     this.configProvider = configProvider;\n     this.profileApiProvider = profileApiProvider;\n     this.billingApiProvider = billingApiProvider;\n+    this.serviceAccountBillingV2ApiProvider = serviceAccountBillingV2ApiProvider;\n+    this.endUserBillingV2ApiProvider = endUserBillingV2ApiProvider;\n     this.groupsApiProvider = groupsApiProvider;\n     this.nihApiProvider = nihApiProvider;\n     this.endUserWorkspacesApiProvider = endUserWorkspacesApiProvider;\n     this.serviceAccountWorkspaceApiProvider = serviceAccountWorkspaceApiProvider;\n     this.statusApiProvider = statusApiProvider;\n-    this.retryHandler = retryHandler;\n     this.endUserStaticNotebooksApiProvider = endUserStaticNotebooksApiProvider;\n     this.serviceAccountStaticNotebooksApiProvider = serviceAccountStaticNotebooksApiProvider;\n-    this.iamCredentialsClient = iamCredentialsClient;\n-    this.httpTransport = httpTransport;\n-  }\n-\n-  /**\n-   * Given an email address of an AoU user, generates a FireCloud ApiClient instance with an access\n-   * token suitable for accessing data on behalf of that user.\n-   *\n-   * <p>This relies on domain-wide delegation of authority in Google's OAuth flow; see\n-   * /api/docs/domain-wide-delegation.md for more details.\n-   *\n-   * @param userEmail\n-   * @return\n-   */\n-  public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    final OAuth2Credentials delegatedCreds =\n-        new DelegatedUserCredentials(\n-            ServiceAccounts.getServiceAccountEmail(\n-                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-            userEmail,\n-            FIRECLOUD_API_OAUTH_SCOPES,\n-            iamCredentialsClient,\n-            httpTransport);\n-    delegatedCreds.refreshIfExpired();\n-\n-    ApiClient apiClient = FireCloudConfig.buildApiClient(configProvider.get());\n-    apiClient.setAccessToken(delegatedCreds.getAccessToken().getTokenValue());\n-    return apiClient;\n+    this.requestScopedGroupCacheProvider = requestScopedGroupCacheProvider;\n+    this.firecloudApiClientFactory = firecloudApiClientFactory;\n+    this.retryHandler = retryHandler;\n   }\n \n   @Override\n", "next_change": {"commit": "166163c460ec5c801a5ec4a816123dfd0fed92ec", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 12b91ef7a..796bd7a82 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -136,10 +142,11 @@ public class FireCloudServiceImpl implements FireCloudService {\n     this.groupsApiProvider = groupsApiProvider;\n     this.nihApiProvider = nihApiProvider;\n     this.endUserWorkspacesApiProvider = endUserWorkspacesApiProvider;\n+    this.endUserLenientTimeoutWorkspacesApiProvider = endUserLenientTimeoutWorkspacesApiProvider;\n     this.serviceAccountWorkspaceApiProvider = serviceAccountWorkspaceApiProvider;\n     this.statusApiProvider = statusApiProvider;\n+    this.termsOfServiceApiProvider = termsOfServiceApiProvider;\n     this.endUserStaticNotebooksApiProvider = endUserStaticNotebooksApiProvider;\n-    this.serviceAccountStaticNotebooksApiProvider = serviceAccountStaticNotebooksApiProvider;\n     this.requestScopedGroupCacheProvider = requestScopedGroupCacheProvider;\n     this.firecloudApiClientFactory = firecloudApiClientFactory;\n     this.retryHandler = retryHandler;\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "493cf02523762a18af9ae279a57c8041452866e5", "committedDate": "2020-01-30 13:22:45 -0500", "message": "[RW-4277][risk=low] Users can set workspace billing account back to free tier (#3040)"}, {"oid": "7c3217c3265bf6d5fd1be4b1816d1fcd45c3d63f", "committedDate": "2020-03-30 12:28:18 -0700", "message": "[RW-4583][risk=low] Switch to Rawls cloneWorkspace (#3315)"}, {"oid": "452bab947f2dc2a4186b3720191d72ce9174d032", "committedDate": "2020-04-20 10:05:57 -0700", "message": "[RW-4713][risk=moderate] Fix admin page auth and rename service methods (#3437)"}, {"oid": "dd9c971761982cf90054a9028b83908a1b34ffe8", "committedDate": "2020-04-21 14:01:42 -0400", "message": "[RW-4737][risk=no] Enable Google Private IP Adddress flag on new project creation (#3438)"}, {"oid": "d2b6435fc8afc8447769f21bfded310b800e3858", "committedDate": "2020-06-16 15:35:59 -0400", "message": "[RW-4257][risk=moderate] Add support for the new Shibboleth service (#3676)"}, {"oid": "d911a075b431740f89fe3b3d154b8586c7a39238", "committedDate": "2020-06-22 09:25:58 -0700", "message": "[RW-5013][risk=no] Correct the parameter order on BP removal... (#3694)"}, {"oid": "9f0413d0fd9de4ae2563ce383f73218332422eae", "committedDate": "2020-07-21 16:17:21 -0700", "message": "[RW-5295][risk=low] Consolidate field masking, fix mapper (#3805)"}, {"oid": "c2fed4f7bf527603ba17adb17a291be4153440f6", "committedDate": "2020-09-14 16:30:35 -0400", "message": "[risk=low][RW-5475] Admin read-only notebook endpoint (#3999)"}, {"oid": "b3d0ecafc70efb7a8b38cb9fe7dd1ec3a54c3532", "committedDate": "2020-09-17 17:06:20 -0400", "message": "[risk=low][RW-3627] Delete project when deleting workspace (#3985)"}, {"oid": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "committedDate": "2020-11-20 08:12:44 -0500", "message": "[risk=low][RW-4798][RW-4688][RW-3882][RW-4308][RW-5091] Teardown Feature Flags, part 1 (#4308)"}, {"oid": "fc76ba68856b4a0c668e925d4e3dcc7f7c32dc4c", "committedDate": "2021-02-23 10:16:12 -0500", "message": "[risk=medium][RW-5241] Add Access Tier to Billing Buffer (#4576)"}, {"oid": "a716a2999c3e726fedd023a702629d267704910e", "committedDate": "2021-02-25 13:35:06 -0500", "message": "[RW-6180][risk=medium] update Workspace logic for Multi Tier  (#4607)"}, {"oid": "84a9d5648a94c5d11d720531bb952dbf0e4c2127", "committedDate": "2021-04-01 11:26:51 -0400", "message": "[RW-6417][risk=low] Switch from workspaceNamespace to googleProject when using Runtime APIs (#4759)"}, {"oid": "bde74cad78429d245937b40bef3d0df9ebb73a2b", "committedDate": "2021-05-10 16:22:30 -0400", "message": "[RW-6438][Billing V2 Step 1]convert firecloud to swagger 3 (#4953)"}, {"oid": "801948c17f3907ada0a820054661356ce9ecb66e", "committedDate": "2021-05-24 16:05:53 -0400", "message": "[RW-6438][risk=low] Adding Firecloud v2 billing endpoint that is protected by a feature flag. (#4965)"}, {"oid": "8ece9e762070e258a0e51f5ef63905e3cab12211", "committedDate": "2021-06-28 09:21:59 -0700", "message": "[RW-6919][risk=moderate] Cache Firecloud group lookups (#5164)"}, {"oid": "48b08ba7af41a265628113ff97906d5dd9e0ca28", "committedDate": "2021-07-07 15:58:27 -0400", "message": "[RW-6896][risk=low]: Call Terra to update billing account.  (#5185)"}, {"oid": "13748e9a7a4ea709f4eed9d4a0934b5bb812f846", "committedDate": "2021-08-06 17:14:45 -0400", "message": "[no ticket] Change v2_billing APIs' interface according to recent FireCloud change (#5366)"}, {"oid": "fb9fae123576c225e674e105b77a176ceb0ac8f1", "committedDate": "2021-08-26 10:34:37 -0400", "message": "[no ticket][risk=no] Set bucket location when cloning workspaces for PPW. (#5476)"}, {"oid": "ed4503dd1fe4f949d6bf066cbd229006d85c188d", "committedDate": "2021-10-04 21:56:13 -0400", "message": "[RW-7278][risk=low]Remove PPW feature flag (#5687)"}, {"oid": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "committedDate": "2021-10-11 12:25:07 -0700", "message": "[risk=low] Factor out impersonation to common factory (#5735)"}, {"oid": "0912ada215ceef05ae2336348772c309c3c0c6f0", "committedDate": "2021-10-20 09:30:34 -0700", "message": "[risk=no] Update Terra Workspace model to latest (#5785)"}, {"oid": "527f179967b01dae78159d737eec34853b354779", "committedDate": "2021-10-26 14:41:43 -0700", "message": "[risk=no] Fix FirecloudService parameter names (#5815)"}, {"oid": "f239a18f023374363a8d80fa6b2579178dd37846", "committedDate": "2021-11-24 20:57:22 -0500", "message": "[RW-7312][risk=no]  UX should account for GCS object copy delay in workspace clone"}, {"oid": "0799895ab2462dfec1ab679c73b36701965501f0", "committedDate": "2021-12-01 12:11:04 -0500", "message": "[risk=no][RW-7255] Prohibit apostrophes in usernames (#5972)"}, {"oid": "6cce8185b9d7d415d9d28ab77fb456faad2a8cfe", "committedDate": "2022-03-17 13:47:34 -0400", "message": "[risk=low][RW-7833] New users call Terra's Accept TOS endpoint (#6454)"}, {"oid": "b81964d75da0e07b0fa0a3565cae69d7969f293d", "committedDate": "2022-03-17 13:19:30 -0700", "message": "[RW-8054][risk=low] Fix ShareWorkspace for CT published workspaces (#6464)"}, {"oid": "29e1a34cbc595c0ce7a7cfd7725ff5b027ceca88", "committedDate": "2022-03-29 13:15:23 -0400", "message": "[RW-7834][risk=low]Require TOS acceptance on login when users are not Terra-TOS compliant (#6479)"}, {"oid": "4969dc22b07b3d32c52c142729b7a05a33cb07ef", "committedDate": "2022-06-08 09:14:14 -0400", "message": "gcs location (#6761)"}, {"oid": "166163c460ec5c801a5ec4a816123dfd0fed92ec", "committedDate": "2022-07-13 13:14:31 -0700", "message": "[RW-8585][risk=low] Reduce request deadline to Terra, except for create/clone workspace (#6837)"}, {"oid": "efa3f0343fd3ccaff074a8a7be6da0dde3cfd3bd", "committedDate": "2022-11-28 17:26:16 -0500", "message": "[risk=low][no ticket] Notebooks API: add tests and refactor (#7197)"}, {"oid": "3c4cae470c4987ae9cbbebe281f0bab8cf0e08a1", "committedDate": "2022-12-08 17:42:40 -0500", "message": "[risk=low][RW-9269] Keep test users TOS-compliant via cron (#7219)"}, {"oid": "d58ed2809cc7321c481a9adc17ffa26d28aee138", "committedDate": "2022-12-22 10:00:07 -0500", "message": "[risk=low][RW-9270] Continue deleting workspaces if one is not found (#7265)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTQ4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369149485", "body": "nit: If these two methods will live side-by-side, you might want to have an enum like ImpersonationOptions.DELEGATE and pass that into the function. if this branch is going away after the gate is removed, then it's not important.", "bodyText": "nit: If these two methods will live side-by-side, you might want to have an enum like ImpersonationOptions.DELEGATE and pass that into the function. if this branch is going away after the gate is removed, then it's not important.", "bodyHTML": "<p dir=\"auto\">nit: If these two methods will live side-by-side, you might want to have an enum like ImpersonationOptions.DELEGATE and pass that into the function. if this branch is going away after the gate is removed, then it's not important.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:48:40Z", "path": "api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java", "diffHunk": "@@ -28,32 +30,41 @@\n   public static final List<String> SCOPES =\n       Arrays.asList(CloudResourceManagerScopes.CLOUD_PLATFORM_READ_ONLY);\n \n-  private final Provider<ServiceAccountCredentials> cloudResourceManagerAdminCredsProvider;\n+  private final Provider<ServiceAccountCredentials> credentialsProvider;\n+  private final Provider<WorkbenchConfig> configProvider;\n   private final HttpTransport httpTransport;\n   private final GoogleRetryHandler retryHandler;\n \n   @Autowired\n   public CloudResourceManagerServiceImpl(\n       @Qualifier(Constants.CLOUD_RESOURCE_MANAGER_ADMIN_CREDS)\n-          Provider<ServiceAccountCredentials> cloudResourceManagerAdminCredsProvider,\n+          Provider<ServiceAccountCredentials> credentialsProvider,\n+      Provider<WorkbenchConfig> configProvider,\n       HttpTransport httpTransport,\n       GoogleRetryHandler retryHandler) {\n-    this.cloudResourceManagerAdminCredsProvider = cloudResourceManagerAdminCredsProvider;\n+    this.credentialsProvider = credentialsProvider;\n+    this.configProvider = configProvider;\n     this.httpTransport = httpTransport;\n     this.retryHandler = retryHandler;\n   }\n \n   private CloudResourceManager getCloudResourceManagerServiceWithImpersonation(DbUser user)\n       throws IOException {\n-    // Load credentials for the cloud-resource-manager Service Account. This account has been\n-    // granted\n-    // domain-wide delegation for the OAuth scopes required by cloud apis.\n-    GoogleCredentials credentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            cloudResourceManagerAdminCredsProvider.get(), user.getUsername(), SCOPES);\n+    OAuth2Credentials delegatedCreds;\n+    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n+      delegatedCreds =\n+          new DelegatedUserCredentials(\n+              ServiceAccounts.getServiceAccountEmail(\"cloud-resource-admin\", configProvider.get()),\n+              user.getUsername(),\n+              SCOPES);\n+    } else {\n+      delegatedCreds =", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTIxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369215", "bodyText": "The branch will go away once the rollout is complete and feature flag gets torn down.", "author": "gjuggler", "createdAt": "2020-01-22T04:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\nindex 6fd602f36..2d62181ea 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n", "chunk": "@@ -50,11 +50,12 @@ public class CloudResourceManagerServiceImpl implements CloudResourceManagerServ\n \n   private CloudResourceManager getCloudResourceManagerServiceWithImpersonation(DbUser user)\n       throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"cloud-resource-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  \"cloud-resource-admin\", configProvider.get().server.projectId),\n               user.getUsername(),\n               SCOPES);\n     } else {\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\nindex 2d62181ea..4cf2c1f57 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n", "chunk": "@@ -55,9 +61,11 @@ public class CloudResourceManagerServiceImpl implements CloudResourceManagerServ\n       delegatedCreds =\n           new DelegatedUserCredentials(\n               ServiceAccounts.getServiceAccountEmail(\n-                  \"cloud-resource-admin\", configProvider.get().server.projectId),\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               user.getUsername(),\n-              SCOPES);\n+              SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           credentialsProvider.get().createScoped(SCOPES).createDelegated(user.getUsername());\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\nindex 6fd602f36..4cf2c1f57 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n", "chunk": "@@ -41,22 +45,27 @@ public class CloudResourceManagerServiceImpl implements CloudResourceManagerServ\n           Provider<ServiceAccountCredentials> credentialsProvider,\n       Provider<WorkbenchConfig> configProvider,\n       HttpTransport httpTransport,\n-      GoogleRetryHandler retryHandler) {\n+      GoogleRetryHandler retryHandler,\n+      IamCredentialsClient iamCredentialsClient) {\n     this.credentialsProvider = credentialsProvider;\n     this.configProvider = configProvider;\n     this.httpTransport = httpTransport;\n     this.retryHandler = retryHandler;\n+    this.iamCredentialsClient = iamCredentialsClient;\n   }\n \n   private CloudResourceManager getCloudResourceManagerServiceWithImpersonation(DbUser user)\n       throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"cloud-resource-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               user.getUsername(),\n-              SCOPES);\n+              SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           credentialsProvider.get().createScoped(SCOPES).createDelegated(user.getUsername());\n", "next_change": {"commit": "f4ff0961546d731c9b23e983aa2489984c5fdaf4", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\nindex 4cf2c1f57..d90120266 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n", "chunk": "@@ -72,24 +76,35 @@ public class CloudResourceManagerServiceImpl implements CloudResourceManagerServ\n     }\n     delegatedCreds.refreshIfExpired();\n \n-    return new CloudResourceManager.Builder(\n+    return new Builder(\n             httpTransport, getDefaultJsonFactory(), new HttpCredentialsAdapter(delegatedCreds))\n         .setApplicationName(APPLICATION_NAME)\n         .build();\n   }\n \n   @Override\n-  public List<Project> getAllProjectsForUser(DbUser user) {\n-    try {\n-      return retryHandler.runAndThrowChecked(\n-          (context) ->\n-              getCloudResourceManagerServiceWithImpersonation(user)\n-                  .projects()\n-                  .list()\n-                  .execute()\n-                  .getProjects());\n-    } catch (IOException e) {\n-      throw ExceptionUtils.convertGoogleIOException(e);\n-    }\n+  public List<Project> getAllProjectsForUser(DbUser user) throws IOException {\n+    return retryHandler.runAndThrowChecked(\n+        (context) -> {\n+          List<Project> projects = new ArrayList<>();\n+          Optional<String> pageToken = Optional.empty();\n+          do {\n+            ListProjectsResponse resp =\n+                getCloudResourceManagerServiceWithImpersonation(user)\n+                    .projects()\n+                    .list()\n+                    .setPageToken(pageToken.orElse(null))\n+                    .execute();\n+            if (resp.getProjects() != null) {\n+              projects.addAll(resp.getProjects());\n+            }\n+\n+            // The API does not specify null or empty string; treat both as empty to be safe.\n+            pageToken =\n+                Optional.ofNullable(resp.getNextPageToken())\n+                    .filter(((Predicate<String>) String::isEmpty).negate());\n+          } while (pageToken.isPresent());\n+          return projects;\n+        });\n   }\n }\n", "next_change": {"commit": "ea7ed892e7e71ba9a6072418ff3369851f570d04", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\nindex d90120266..1e260c559 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n", "chunk": "@@ -107,4 +103,28 @@ public class CloudResourceManagerServiceImpl implements CloudResourceManagerServ\n           return projects;\n         });\n   }\n+\n+  @Override\n+  public Policy getIamPolicy(String googleProject) {\n+    return retryHandler.run(\n+        (context) -> {\n+          return serviceCloudResouceManager\n+              .get()\n+              .projects()\n+              .getIamPolicy(googleProject, new GetIamPolicyRequest())\n+              .execute();\n+        });\n+  }\n+\n+  @Override\n+  public Policy setIamPolicy(String googleProject, Policy policy) {\n+    return retryHandler.run(\n+        (context) -> {\n+          return serviceCloudResouceManager\n+              .get()\n+              .projects()\n+              .setIamPolicy(googleProject, new SetIamPolicyRequest().setPolicy(policy))\n+              .execute();\n+        });\n+  }\n }\n", "next_change": {"commit": "c97462eada92e27899e660f52edf13918a098143", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\nindex 1e260c559..4b830fb99 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java\n", "chunk": "@@ -123,7 +123,8 @@ public class CloudResourceManagerServiceImpl implements CloudResourceManagerServ\n           return serviceCloudResouceManager\n               .get()\n               .projects()\n-              .setIamPolicy(googleProject, new SetIamPolicyRequest().setPolicy(policy))\n+              .setIamPolicy(\n+                  \"projects/\" + googleProject, new SetIamPolicyRequest().setPolicy(policy))\n               .execute();\n         });\n   }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "39d4dedb17a8688abe56505c87c70c422c5eb669", "committedDate": "2020-05-29 14:32:21 -0700", "message": "[RW-4906][risk=low] bulkAuditProjectAccess improvements (#3626)"}, {"oid": "ef7290cdacb65a95d127b8c798f55f93d8cbef32", "committedDate": "2020-06-01 00:10:02 -0700", "message": "[RW-4906][risk=no] Handle 0 projects case, add regression test (#3629)"}, {"oid": "f4ff0961546d731c9b23e983aa2489984c5fdaf4", "committedDate": "2020-06-25 11:45:05 -0400", "message": "[RW-4825][risk = no] prerequisites for egress alert enhancements (#3703)"}, {"oid": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "committedDate": "2020-11-20 08:12:44 -0500", "message": "[risk=low][RW-4798][RW-4688][RW-3882][RW-4308][RW-5091] Teardown Feature Flags, part 1 (#4308)"}, {"oid": "ea7ed892e7e71ba9a6072418ff3369851f570d04", "committedDate": "2021-12-01 13:35:58 -0500", "message": "[RW-7394][risk=low]: Grant user permission to run workflows when sharing/cloning/creating workspaces (#5903)"}, {"oid": "0441beed2d8be63ead00d3c75d9992466b8fe6db", "committedDate": "2022-07-20 10:48:24 -0400", "message": "[risk=low][RW-8325] Upgrade cloudresourcemanager to latest (#6814)"}, {"oid": "33c96d8975b3abb48c795f95a616a12f63f79302", "committedDate": "2022-07-22 09:59:03 -0400", "message": "[risk=low][RW-8325]  Revert update which broke Controlled Tier workspace creation (#6880)"}, {"oid": "c97462eada92e27899e660f52edf13918a098143", "committedDate": "2022-07-22 16:06:43 -0400", "message": "[risk=low][RW-8325] Update cloudresourcemanager again (#6883)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTgyNA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369149824", "body": "nit: final", "bodyText": "nit: final", "bodyHTML": "<p dir=\"auto\">nit: final</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:49:21Z", "path": "api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java", "diffHunk": "@@ -87,25 +88,24 @@ public DirectoryServiceImpl(\n     this.retryHandler = retryHandler;\n   }\n \n-  private GoogleCredentials createCredentialWithImpersonation() throws IOException {\n-    String gSuiteDomain = configProvider.get().googleDirectoryService.gSuiteDomain;\n-    return ServiceAccounts.getImpersonatedCredentials(\n-        googleCredentialsProvider.get(), \"directory-service@\" + gSuiteDomain, SCOPES);\n-  }\n+  private Directory getGoogleDirectoryService() {\n+    OAuth2Credentials delegatedCreds;", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTc2OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369768", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-22T04:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\nindex ed72d79b0..2aaa30096 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n", "chunk": "@@ -89,12 +96,13 @@ public class DirectoryServiceImpl implements DirectoryService {\n   }\n \n   private Directory getGoogleDirectoryService() {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"gsuite-admin\", configProvider.get()),\n-              \"directory-service@\" + gSuiteDomain(),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n+              DIRECTORY_SERVICE_USERNAME + \"@\" + gSuiteDomain(),\n               SCOPES);\n     } else {\n       delegatedCreds =\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\nindex 2aaa30096..9656a196b 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n", "chunk": "@@ -103,7 +107,9 @@ public class DirectoryServiceImpl implements DirectoryService {\n               ServiceAccounts.getServiceAccountEmail(\n                   ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               DIRECTORY_SERVICE_USERNAME + \"@\" + gSuiteDomain(),\n-              SCOPES);\n+              SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           googleCredentialsProvider\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\nindex ed72d79b0..9656a196b 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n", "chunk": "@@ -81,21 +90,26 @@ public class DirectoryServiceImpl implements DirectoryService {\n           Provider<ServiceAccountCredentials> googleCredentialsProvider,\n       Provider<WorkbenchConfig> configProvider,\n       HttpTransport httpTransport,\n-      GoogleRetryHandler retryHandler) {\n+      GoogleRetryHandler retryHandler,\n+      IamCredentialsClient iamCredentialsClient) {\n     this.googleCredentialsProvider = googleCredentialsProvider;\n     this.configProvider = configProvider;\n     this.httpTransport = httpTransport;\n     this.retryHandler = retryHandler;\n+    this.iamCredentialsClient = iamCredentialsClient;\n   }\n \n   private Directory getGoogleDirectoryService() {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"gsuite-admin\", configProvider.get()),\n-              \"directory-service@\" + gSuiteDomain(),\n-              SCOPES);\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n+              DIRECTORY_SERVICE_USERNAME + \"@\" + gSuiteDomain(),\n+              SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           googleCredentialsProvider\n", "next_change": {"commit": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\nindex 9656a196b..ce96b2a19 100644\n--- a/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java\n", "chunk": "@@ -100,26 +107,18 @@ public class DirectoryServiceImpl implements DirectoryService {\n   }\n \n   private Directory getGoogleDirectoryService() {\n-    final OAuth2Credentials delegatedCreds;\n-    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n-      delegatedCreds =\n-          new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\n-                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-              DIRECTORY_SERVICE_USERNAME + \"@\" + gSuiteDomain(),\n-              SCOPES,\n-              iamCredentialsClient,\n-              httpTransport);\n-    } else {\n-      delegatedCreds =\n-          googleCredentialsProvider\n-              .get()\n-              .createScoped(SCOPES)\n-              .createDelegated(\"directory-service@\" + gSuiteDomain());\n-    }\n+    final OAuth2Credentials delegatedCreds =\n+        new DelegatedUserCredentials(\n+            ServiceAccounts.getServiceAccountEmail(\n+                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n+            DIRECTORY_SERVICE_USERNAME + \"@\" + gSuiteDomain(),\n+            SCOPES,\n+            iamCredentialsClient,\n+            httpTransport);\n \n     return new Directory.Builder(\n             httpTransport, getDefaultJsonFactory(), new HttpCredentialsAdapter(delegatedCreds))\n+        .setApplicationName(APPLICATION_NAME)\n         .build();\n   }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "500b88169400626c3851901cf3ce58fb1174cece", "committedDate": "2020-01-30 13:42:49 -0500", "message": "[RW-4314][risk=no] Gauge metric for GSuite Domain Account Count (#3023)"}, {"oid": "812bd4d4f2bda830fa3c6c5843c50c739ad3387b", "committedDate": "2020-02-06 16:23:06 -0500", "message": "[RW-4315][risk=no] Workaround for Count Metrics (#3095)"}, {"oid": "258aa7f7cd880a35b006e139401fd0d694d4bbb1", "committedDate": "2020-03-10 16:37:58 -0400", "message": "[RW-4498][risk=no] supply not-really-optional name param (#3240)"}, {"oid": "976d4b6575271c444528727aaced72abcd71152c", "committedDate": "2020-06-25 09:10:47 -0400", "message": "[RW-4929][risk=low] Add flag control & GSuite email extraction for dev auto-registration (#3708)"}, {"oid": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "committedDate": "2020-11-20 08:12:44 -0500", "message": "[risk=low][RW-4798][RW-4688][RW-3882][RW-4308][RW-5091] Teardown Feature Flags, part 1 (#4308)"}, {"oid": "32ce61a7edb04b853f44aa90c1967b2ababa47e9", "committedDate": "2021-04-09 17:42:49 -0700", "message": "[RW-6564][risk=low] Optimize bulkSyncTwoFactorAuth by using a batch gsuite lookup (#4811)"}, {"oid": "c0a9e253551320cb4377946d7f86483b940d1d7a", "committedDate": "2021-09-08 16:00:22 -0700", "message": "[risk=no] Refactor DirectoryService.getUser to mitigate NPEs (#5545)"}, {"oid": "6a68b15b084a0286a078e807b19ac407e61bd7c7", "committedDate": "2022-06-07 13:03:45 -0400", "message": "[RW-8445][risk=low] Add signout endpoint that sign out user RW gsuite account (#6747)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDM1NA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369150354", "body": "nit: you could argue for putting this into a test resource file", "bodyText": "nit: you could argue for putting this into a test resource file", "bodyHTML": "<p dir=\"auto\">nit: you could argue for putting this into a test resource file</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:50:29Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTg3Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369877", "bodyText": "Could do, but Google's own tests include similar strings inline, so I felt following that pattern was warranted.", "author": "gjuggler", "createdAt": "2020-01-22T04:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..e0b9bff16 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -38,8 +42,9 @@ public class DelegatedUserCredentialsTest {\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+  static final String MOCK_ACCESS_TOKEN = \"access-token\";\n \n-  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n   // A random private key string generated for testing purposed with the following commands:\n   // $ openssl genrsa -out keypair.pem 512\n   // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -42,7 +42,7 @@ public class DelegatedUserCredentialsTest {\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n-  static final String MOCK_ACCESS_TOKEN = \"access-token\";\n+  static final String MOCK_ACCESS_TOKEN = \"FAKE_ya29.QQIBibTwvKkE39hY8mdkT_mXZoRh7...\";\n \n   static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n   // A random private key string generated for testing purposed with the following commands:\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -38,8 +42,9 @@ public class DelegatedUserCredentialsTest {\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+  static final String MOCK_ACCESS_TOKEN = \"FAKE_ya29.QQIBibTwvKkE39hY8mdkT_mXZoRh7...\";\n \n-  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n   // A random private key string generated for testing purposed with the following commands:\n   // $ openssl genrsa -out keypair.pem 512\n   // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDgyNw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369150827", "body": "I'd spell this out. On reading the first time it's hard to keep up with the context.", "bodyText": "I'd spell this out. On reading the first time it's hard to keep up with the context.", "bodyHTML": "<p dir=\"auto\">I'd spell this out. On reading the first time it's hard to keep up with the context.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:51:25Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =\n+      \"-----BEGIN PRIVATE KEY-----\\n\"\n+          + \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA04/ClUlp9Y1HEOPe\\n\"\n+          + \"2FGpSkkSkR94c2JD1Wet2qyVvXLlCBqQyTYtJugSaBWNSDe/M+6astFrWLOSZU2o\\n\"\n+          + \"OVK1AwIDAQABAkEAwQQX8zvXgEA05iP/3Dwkx7GDTwP3UM4GNV0yMJ/kvcG8lTzh\\n\"\n+          + \"/WpVThpktn5roeoiwOcQP3jbGbUTlGw2JJYVAQIhAO2jAKAoqoBIiEimrES0eery\\n\"\n+          + \"8aVmJEu+LzO2+ZgjNRZJAiEA4+juaKu6PxbBHtV4NVN1viX0mIRUxr4jcrZGlz3d\\n\"\n+          + \"QOsCIFRCxggEI2DVVy2bm93IuKosdq6VJy2MRCRsLthZM4uxAiB0A/HApJJFZT7f\\n\"\n+          + \"hEkR1C9eoRGWxd4l4UpILZNXj+1eCwIgZOwMPzJi5thQysHlvf0cqBO/7tv2fd6K\\n\"\n+          + \"qzJzcrNQfMs=\\n\"\n+          + \"-----END PRIVATE KEY-----\";\n+\n+  // We'll handle mocking out the call to the IAM Credentials API.\n+  @Mock private IamCredentialsClient mockIamCredentialsClient;\n+  // Google's API client library provides a convenient mock for their token server API,\n+  // so we'll use that to mock out the call to request an access token.\n+  private MockTokenServerTransport mockTokenServerTransport;\n+  private DelegatedUserCredentials creds;", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTk5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369998", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-22T04:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDgyNw=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..e0b9bff16 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -60,15 +65,15 @@ public class DelegatedUserCredentialsTest {\n   // Google's API client library provides a convenient mock for their token server API,\n   // so we'll use that to mock out the call to request an access token.\n   private MockTokenServerTransport mockTokenServerTransport;\n-  private DelegatedUserCredentials creds;\n+  private DelegatedUserCredentials delegatedCredentials;\n \n   @Before\n   public void setUp() {\n     mockTokenServerTransport = new MockTokenServerTransport();\n \n-    creds = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n-    creds.setHttpTransport(mockTokenServerTransport);\n-    creds.setIamCredentialsClient(mockIamCredentialsClient);\n+    delegatedCredentials = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n+    delegatedCredentials.setHttpTransport(mockTokenServerTransport);\n+    delegatedCredentials.setIamCredentialsClient(mockIamCredentialsClient);\n   }\n \n   /**\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -66,14 +66,21 @@ public class DelegatedUserCredentialsTest {\n   // so we'll use that to mock out the call to request an access token.\n   private MockTokenServerTransport mockTokenServerTransport;\n   private DelegatedUserCredentials delegatedCredentials;\n+  private FakeClock fakeClock;\n \n   @Before\n   public void setUp() {\n     mockTokenServerTransport = new MockTokenServerTransport();\n-\n-    delegatedCredentials = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n-    delegatedCredentials.setHttpTransport(mockTokenServerTransport);\n-    delegatedCredentials.setIamCredentialsClient(mockIamCredentialsClient);\n+    fakeClock = new FakeClock(Instant.ofEpochSecond(12345));\n+\n+    delegatedCredentials =\n+        new DelegatedUserCredentials(\n+            SERVICE_ACCOUNT_EMAIL,\n+            USER_EMAIL,\n+            SCOPES,\n+            mockIamCredentialsClient,\n+            mockTokenServerTransport);\n+    delegatedCredentials.setClock(fakeClock);\n   }\n \n   /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -60,15 +65,22 @@ public class DelegatedUserCredentialsTest {\n   // Google's API client library provides a convenient mock for their token server API,\n   // so we'll use that to mock out the call to request an access token.\n   private MockTokenServerTransport mockTokenServerTransport;\n-  private DelegatedUserCredentials creds;\n+  private DelegatedUserCredentials delegatedCredentials;\n+  private FakeClock fakeClock;\n \n   @Before\n   public void setUp() {\n     mockTokenServerTransport = new MockTokenServerTransport();\n-\n-    creds = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n-    creds.setHttpTransport(mockTokenServerTransport);\n-    creds.setIamCredentialsClient(mockIamCredentialsClient);\n+    fakeClock = new FakeClock(Instant.ofEpochSecond(12345));\n+\n+    delegatedCredentials =\n+        new DelegatedUserCredentials(\n+            SERVICE_ACCOUNT_EMAIL,\n+            USER_EMAIL,\n+            SCOPES,\n+            mockIamCredentialsClient,\n+            mockTokenServerTransport);\n+    delegatedCredentials.setClock(fakeClock);\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NDU4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369154587", "body": "Do you want scopes to be writeable? If not, I'd do `Collections.emptyList()`", "bodyText": "Do you want scopes to be writeable? If not, I'd do Collections.emptyList()", "bodyHTML": "<p dir=\"auto\">Do you want scopes to be writeable? If not, I'd do <code>Collections.emptyList()</code></p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:58:56Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzM2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363367", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-22T04:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NDU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..33a7ec1b3 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -88,7 +89,7 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     this.scopes = scopes;\n \n     if (this.scopes == null) {\n-      this.scopes = new ArrayList<>();\n+      this.scopes = Collections.emptyList();\n     }\n   }\n \n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -47,59 +46,58 @@ import java.util.List;\n  *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n  *     \"admin-gsuite-user@my-gsuite-domain.com\",\n  *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n- *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n- *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n- *     .build();\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n  * </pre>\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = new ArrayList<>();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NTA1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369155055", "body": "nit: The name of the function doesn't suggest to me the type. Maybe `createClaimsJwt()`?", "bodyText": "nit: The name of the function doesn't suggest to me the type. Maybe createClaimsJwt()?", "bodyHTML": "<p dir=\"auto\">nit: The name of the function doesn't suggest to me the type. Maybe <code>createClaimsJwt()</code>?</p>", "author": "jaycarlton", "createdAt": "2020-01-21T17:59:54Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzY1OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363658", "bodyText": "Good catch \u2013\u00a0I'll go with createJwtPayload for even more alignment.", "author": "gjuggler", "createdAt": "2020-01-22T04:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NTA1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..33a7ec1b3 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -114,7 +115,7 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n    * @return\n    */\n   @VisibleForTesting\n-  public JsonWebToken.Payload createClaims() {\n+  public JsonWebToken.Payload createJwtPayload() {\n     JsonWebToken.Payload payload = new JsonWebToken.Payload();\n     payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n     payload.setExpirationTimeSeconds(\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -114,7 +112,7 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n    * @return\n    */\n   @VisibleForTesting\n-  public JsonWebToken.Payload createClaims() {\n+  public JsonWebToken.Payload createJwtPayload() {\n     JsonWebToken.Payload payload = new JsonWebToken.Payload();\n     payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n     payload.setExpirationTimeSeconds(\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NzcyMw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369157723", "body": "These comments are great. It might help to have a readme going over the different auth types we have and in what situations we should use each one.", "bodyText": "These comments are great. It might help to have a readme going over the different auth types we have and in what situations we should use each one.", "bodyHTML": "<p dir=\"auto\">These comments are great. It might help to have a readme going over the different auth types we have and in what situations we should use each one.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T18:05:34Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzUzNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363535", "bodyText": "I agree some system overview docs are long overdue, but I won't bite that off for this PR.", "author": "gjuggler", "createdAt": "2020-01-22T04:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NzcyMw=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -47,59 +46,58 @@ import java.util.List;\n  *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n  *     \"admin-gsuite-user@my-gsuite-domain.com\",\n  *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n- *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n- *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n- *     .build();\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n  * </pre>\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = new ArrayList<>();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 4d2aee35d..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -47,59 +46,58 @@ import java.util.List;\n  *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n  *     \"admin-gsuite-user@my-gsuite-domain.com\",\n  *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n- *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n- *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n- *     .build();\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n  * </pre>\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = new ArrayList<>();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1ODM5OQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369158399", "body": "I feel like the user name should be configured in the JSON, even though we don't expect it to change. IOW someone else who finds this class on github would have to change that, so it doesn't feel like it should live in code.", "bodyText": "I feel like the user name should be configured in the JSON, even though we don't expect it to change. IOW someone else who finds this class on github would have to change that, so it doesn't feel like it should live in code.", "bodyHTML": "<p dir=\"auto\">I feel like the user name should be configured in the JSON, even though we don't expect it to change. IOW someone else who finds this class on github would have to change that, so it doesn't feel like it should live in code.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T18:07:03Z", "path": "api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java", "diffHunk": "@@ -132,14 +133,24 @@ public FireCloudServiceImpl(\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    // Load credentials for the firecloud-admin Service Account. This account has been granted\n-    // domain-wide delegation for the OAuth scopes required by FireCloud.\n-    GoogleCredentials impersonatedUserCredentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            fcAdminCredsProvider.get(), userEmail, FIRECLOUD_API_OAUTH_SCOPES);\n+    OAuth2Credentials delegatedCreds;\n+    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n+      delegatedCreds =\n+          new DelegatedUserCredentials(\n+              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NzI3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369367271", "bodyText": "This class isn't meant to be a reusable library, so I don't think we should be worrying about making things ultra-portable in the near term. At the very least I'll bump these up to class-level constants so they're not raw strings hanging in the code.", "author": "gjuggler", "createdAt": "2020-01-22T04:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1ODM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex a2a8ac017..746cda923 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -133,11 +135,12 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n               FIRECLOUD_API_OAUTH_SCOPES);\n     } else {\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 746cda923..2b18fade7 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -142,7 +150,9 @@ public class FireCloudServiceImpl implements FireCloudService {\n               ServiceAccounts.getServiceAccountEmail(\n                   ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES);\n+              FIRECLOUD_API_OAUTH_SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           fcAdminCredsProvider\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex a2a8ac017..1b6d8428b 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -133,13 +142,16 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    OAuth2Credentials delegatedCreds;\n+    final OAuth2Credentials delegatedCreds;\n     if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n       delegatedCreds =\n           new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              ServiceAccounts.getServiceAccountEmail(\n+                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n               userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES);\n+              FIRECLOUD_API_OAUTH_SCOPES,\n+              iamCredentialsClient,\n+              httpTransport);\n     } else {\n       delegatedCreds =\n           fcAdminCredsProvider\n", "next_change": {"commit": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 1b6d8428b..8bdccf116 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -142,23 +144,14 @@ public class FireCloudServiceImpl implements FireCloudService {\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    final OAuth2Credentials delegatedCreds;\n-    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n-      delegatedCreds =\n-          new DelegatedUserCredentials(\n-              ServiceAccounts.getServiceAccountEmail(\n-                  ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-              userEmail,\n-              FIRECLOUD_API_OAUTH_SCOPES,\n-              iamCredentialsClient,\n-              httpTransport);\n-    } else {\n-      delegatedCreds =\n-          fcAdminCredsProvider\n-              .get()\n-              .createScoped(FIRECLOUD_API_OAUTH_SCOPES)\n-              .createDelegated(userEmail);\n-    }\n+    final OAuth2Credentials delegatedCreds =\n+        new DelegatedUserCredentials(\n+            ServiceAccounts.getServiceAccountEmail(\n+                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n+            userEmail,\n+            FIRECLOUD_API_OAUTH_SCOPES,\n+            iamCredentialsClient,\n+            httpTransport);\n     delegatedCreds.refreshIfExpired();\n \n     ApiClient apiClient = FireCloudConfig.buildApiClient(configProvider.get());\n", "next_change": {"commit": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 8bdccf116..12b91ef7a 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -115,48 +123,26 @@ public class FireCloudServiceImpl implements FireCloudService {\n           Provider<StaticNotebooksApi> endUserStaticNotebooksApiProvider,\n       @Qualifier(FireCloudConfig.SERVICE_ACCOUNT_STATIC_NOTEBOOKS_API)\n           Provider<StaticNotebooksApi> serviceAccountStaticNotebooksApiProvider,\n-      FirecloudRetryHandler retryHandler,\n-      IamCredentialsClient iamCredentialsClient,\n-      HttpTransport httpTransport) {\n+      @Qualifier(FireCloudCacheConfig.SERVICE_ACCOUNT_REQUEST_SCOPED_GROUP_CACHE)\n+          Provider<LoadingCache<String, FirecloudManagedGroupWithMembers>>\n+              requestScopedGroupCacheProvider,\n+      FirecloudApiClientFactory firecloudApiClientFactory,\n+      FirecloudRetryHandler retryHandler) {\n     this.configProvider = configProvider;\n     this.profileApiProvider = profileApiProvider;\n     this.billingApiProvider = billingApiProvider;\n+    this.serviceAccountBillingV2ApiProvider = serviceAccountBillingV2ApiProvider;\n+    this.endUserBillingV2ApiProvider = endUserBillingV2ApiProvider;\n     this.groupsApiProvider = groupsApiProvider;\n     this.nihApiProvider = nihApiProvider;\n     this.endUserWorkspacesApiProvider = endUserWorkspacesApiProvider;\n     this.serviceAccountWorkspaceApiProvider = serviceAccountWorkspaceApiProvider;\n     this.statusApiProvider = statusApiProvider;\n-    this.retryHandler = retryHandler;\n     this.endUserStaticNotebooksApiProvider = endUserStaticNotebooksApiProvider;\n     this.serviceAccountStaticNotebooksApiProvider = serviceAccountStaticNotebooksApiProvider;\n-    this.iamCredentialsClient = iamCredentialsClient;\n-    this.httpTransport = httpTransport;\n-  }\n-\n-  /**\n-   * Given an email address of an AoU user, generates a FireCloud ApiClient instance with an access\n-   * token suitable for accessing data on behalf of that user.\n-   *\n-   * <p>This relies on domain-wide delegation of authority in Google's OAuth flow; see\n-   * /api/docs/domain-wide-delegation.md for more details.\n-   *\n-   * @param userEmail\n-   * @return\n-   */\n-  public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    final OAuth2Credentials delegatedCreds =\n-        new DelegatedUserCredentials(\n-            ServiceAccounts.getServiceAccountEmail(\n-                ADMIN_SERVICE_ACCOUNT_NAME, configProvider.get().server.projectId),\n-            userEmail,\n-            FIRECLOUD_API_OAUTH_SCOPES,\n-            iamCredentialsClient,\n-            httpTransport);\n-    delegatedCreds.refreshIfExpired();\n-\n-    ApiClient apiClient = FireCloudConfig.buildApiClient(configProvider.get());\n-    apiClient.setAccessToken(delegatedCreds.getAccessToken().getTokenValue());\n-    return apiClient;\n+    this.requestScopedGroupCacheProvider = requestScopedGroupCacheProvider;\n+    this.firecloudApiClientFactory = firecloudApiClientFactory;\n+    this.retryHandler = retryHandler;\n   }\n \n   @Override\n", "next_change": {"commit": "166163c460ec5c801a5ec4a816123dfd0fed92ec", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\nindex 12b91ef7a..796bd7a82 100644\n--- a/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n+++ b/api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java\n", "chunk": "@@ -136,10 +142,11 @@ public class FireCloudServiceImpl implements FireCloudService {\n     this.groupsApiProvider = groupsApiProvider;\n     this.nihApiProvider = nihApiProvider;\n     this.endUserWorkspacesApiProvider = endUserWorkspacesApiProvider;\n+    this.endUserLenientTimeoutWorkspacesApiProvider = endUserLenientTimeoutWorkspacesApiProvider;\n     this.serviceAccountWorkspaceApiProvider = serviceAccountWorkspaceApiProvider;\n     this.statusApiProvider = statusApiProvider;\n+    this.termsOfServiceApiProvider = termsOfServiceApiProvider;\n     this.endUserStaticNotebooksApiProvider = endUserStaticNotebooksApiProvider;\n-    this.serviceAccountStaticNotebooksApiProvider = serviceAccountStaticNotebooksApiProvider;\n     this.requestScopedGroupCacheProvider = requestScopedGroupCacheProvider;\n     this.firecloudApiClientFactory = firecloudApiClientFactory;\n     this.retryHandler = retryHandler;\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "493cf02523762a18af9ae279a57c8041452866e5", "committedDate": "2020-01-30 13:22:45 -0500", "message": "[RW-4277][risk=low] Users can set workspace billing account back to free tier (#3040)"}, {"oid": "7c3217c3265bf6d5fd1be4b1816d1fcd45c3d63f", "committedDate": "2020-03-30 12:28:18 -0700", "message": "[RW-4583][risk=low] Switch to Rawls cloneWorkspace (#3315)"}, {"oid": "452bab947f2dc2a4186b3720191d72ce9174d032", "committedDate": "2020-04-20 10:05:57 -0700", "message": "[RW-4713][risk=moderate] Fix admin page auth and rename service methods (#3437)"}, {"oid": "dd9c971761982cf90054a9028b83908a1b34ffe8", "committedDate": "2020-04-21 14:01:42 -0400", "message": "[RW-4737][risk=no] Enable Google Private IP Adddress flag on new project creation (#3438)"}, {"oid": "d2b6435fc8afc8447769f21bfded310b800e3858", "committedDate": "2020-06-16 15:35:59 -0400", "message": "[RW-4257][risk=moderate] Add support for the new Shibboleth service (#3676)"}, {"oid": "d911a075b431740f89fe3b3d154b8586c7a39238", "committedDate": "2020-06-22 09:25:58 -0700", "message": "[RW-5013][risk=no] Correct the parameter order on BP removal... (#3694)"}, {"oid": "9f0413d0fd9de4ae2563ce383f73218332422eae", "committedDate": "2020-07-21 16:17:21 -0700", "message": "[RW-5295][risk=low] Consolidate field masking, fix mapper (#3805)"}, {"oid": "c2fed4f7bf527603ba17adb17a291be4153440f6", "committedDate": "2020-09-14 16:30:35 -0400", "message": "[risk=low][RW-5475] Admin read-only notebook endpoint (#3999)"}, {"oid": "b3d0ecafc70efb7a8b38cb9fe7dd1ec3a54c3532", "committedDate": "2020-09-17 17:06:20 -0400", "message": "[risk=low][RW-3627] Delete project when deleting workspace (#3985)"}, {"oid": "10015c2c672a4d9da320c4e91636bedc8f4ad731", "committedDate": "2020-11-20 08:12:44 -0500", "message": "[risk=low][RW-4798][RW-4688][RW-3882][RW-4308][RW-5091] Teardown Feature Flags, part 1 (#4308)"}, {"oid": "fc76ba68856b4a0c668e925d4e3dcc7f7c32dc4c", "committedDate": "2021-02-23 10:16:12 -0500", "message": "[risk=medium][RW-5241] Add Access Tier to Billing Buffer (#4576)"}, {"oid": "a716a2999c3e726fedd023a702629d267704910e", "committedDate": "2021-02-25 13:35:06 -0500", "message": "[RW-6180][risk=medium] update Workspace logic for Multi Tier  (#4607)"}, {"oid": "84a9d5648a94c5d11d720531bb952dbf0e4c2127", "committedDate": "2021-04-01 11:26:51 -0400", "message": "[RW-6417][risk=low] Switch from workspaceNamespace to googleProject when using Runtime APIs (#4759)"}, {"oid": "bde74cad78429d245937b40bef3d0df9ebb73a2b", "committedDate": "2021-05-10 16:22:30 -0400", "message": "[RW-6438][Billing V2 Step 1]convert firecloud to swagger 3 (#4953)"}, {"oid": "801948c17f3907ada0a820054661356ce9ecb66e", "committedDate": "2021-05-24 16:05:53 -0400", "message": "[RW-6438][risk=low] Adding Firecloud v2 billing endpoint that is protected by a feature flag. (#4965)"}, {"oid": "8ece9e762070e258a0e51f5ef63905e3cab12211", "committedDate": "2021-06-28 09:21:59 -0700", "message": "[RW-6919][risk=moderate] Cache Firecloud group lookups (#5164)"}, {"oid": "48b08ba7af41a265628113ff97906d5dd9e0ca28", "committedDate": "2021-07-07 15:58:27 -0400", "message": "[RW-6896][risk=low]: Call Terra to update billing account.  (#5185)"}, {"oid": "13748e9a7a4ea709f4eed9d4a0934b5bb812f846", "committedDate": "2021-08-06 17:14:45 -0400", "message": "[no ticket] Change v2_billing APIs' interface according to recent FireCloud change (#5366)"}, {"oid": "fb9fae123576c225e674e105b77a176ceb0ac8f1", "committedDate": "2021-08-26 10:34:37 -0400", "message": "[no ticket][risk=no] Set bucket location when cloning workspaces for PPW. (#5476)"}, {"oid": "ed4503dd1fe4f949d6bf066cbd229006d85c188d", "committedDate": "2021-10-04 21:56:13 -0400", "message": "[RW-7278][risk=low]Remove PPW feature flag (#5687)"}, {"oid": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "committedDate": "2021-10-11 12:25:07 -0700", "message": "[risk=low] Factor out impersonation to common factory (#5735)"}, {"oid": "0912ada215ceef05ae2336348772c309c3c0c6f0", "committedDate": "2021-10-20 09:30:34 -0700", "message": "[risk=no] Update Terra Workspace model to latest (#5785)"}, {"oid": "527f179967b01dae78159d737eec34853b354779", "committedDate": "2021-10-26 14:41:43 -0700", "message": "[risk=no] Fix FirecloudService parameter names (#5815)"}, {"oid": "f239a18f023374363a8d80fa6b2579178dd37846", "committedDate": "2021-11-24 20:57:22 -0500", "message": "[RW-7312][risk=no]  UX should account for GCS object copy delay in workspace clone"}, {"oid": "0799895ab2462dfec1ab679c73b36701965501f0", "committedDate": "2021-12-01 12:11:04 -0500", "message": "[risk=no][RW-7255] Prohibit apostrophes in usernames (#5972)"}, {"oid": "6cce8185b9d7d415d9d28ab77fb456faad2a8cfe", "committedDate": "2022-03-17 13:47:34 -0400", "message": "[risk=low][RW-7833] New users call Terra's Accept TOS endpoint (#6454)"}, {"oid": "b81964d75da0e07b0fa0a3565cae69d7969f293d", "committedDate": "2022-03-17 13:19:30 -0700", "message": "[RW-8054][risk=low] Fix ShareWorkspace for CT published workspaces (#6464)"}, {"oid": "29e1a34cbc595c0ce7a7cfd7725ff5b027ceca88", "committedDate": "2022-03-29 13:15:23 -0400", "message": "[RW-7834][risk=low]Require TOS acceptance on login when users are not Terra-TOS compliant (#6479)"}, {"oid": "4969dc22b07b3d32c52c142729b7a05a33cb07ef", "committedDate": "2022-06-08 09:14:14 -0400", "message": "gcs location (#6761)"}, {"oid": "166163c460ec5c801a5ec4a816123dfd0fed92ec", "committedDate": "2022-07-13 13:14:31 -0700", "message": "[RW-8585][risk=low] Reduce request deadline to Terra, except for create/clone workspace (#6837)"}, {"oid": "efa3f0343fd3ccaff074a8a7be6da0dde3cfd3bd", "committedDate": "2022-11-28 17:26:16 -0500", "message": "[risk=low][no ticket] Notebooks API: add tests and refactor (#7197)"}, {"oid": "3c4cae470c4987ae9cbbebe281f0bab8cf0e08a1", "committedDate": "2022-12-08 17:42:40 -0500", "message": "[risk=low][RW-9269] Keep test users TOS-compliant via cron (#7219)"}, {"oid": "d58ed2809cc7321c481a9adc17ffa26d28aee138", "committedDate": "2022-12-22 10:00:07 -0500", "message": "[risk=low][RW-9270] Continue deleting workspaces if one is not found (#7265)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTczOQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369159739", "body": "Is there anything else you can mock & verify? Looks like all we verify is that the token value is preserved.", "bodyText": "Is there anything else you can mock & verify? Looks like all we verify is that the token value is preserved.", "bodyHTML": "<p dir=\"auto\">Is there anything else you can mock &amp; verify? Looks like all we verify is that the token value is preserved.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T18:10:02Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =\n+      \"-----BEGIN PRIVATE KEY-----\\n\"\n+          + \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA04/ClUlp9Y1HEOPe\\n\"\n+          + \"2FGpSkkSkR94c2JD1Wet2qyVvXLlCBqQyTYtJugSaBWNSDe/M+6astFrWLOSZU2o\\n\"\n+          + \"OVK1AwIDAQABAkEAwQQX8zvXgEA05iP/3Dwkx7GDTwP3UM4GNV0yMJ/kvcG8lTzh\\n\"\n+          + \"/WpVThpktn5roeoiwOcQP3jbGbUTlGw2JJYVAQIhAO2jAKAoqoBIiEimrES0eery\\n\"\n+          + \"8aVmJEu+LzO2+ZgjNRZJAiEA4+juaKu6PxbBHtV4NVN1viX0mIRUxr4jcrZGlz3d\\n\"\n+          + \"QOsCIFRCxggEI2DVVy2bm93IuKosdq6VJy2MRCRsLthZM4uxAiB0A/HApJJFZT7f\\n\"\n+          + \"hEkR1C9eoRGWxd4l4UpILZNXj+1eCwIgZOwMPzJi5thQysHlvf0cqBO/7tv2fd6K\\n\"\n+          + \"qzJzcrNQfMs=\\n\"\n+          + \"-----END PRIVATE KEY-----\";\n+\n+  // We'll handle mocking out the call to the IAM Credentials API.\n+  @Mock private IamCredentialsClient mockIamCredentialsClient;\n+  // Google's API client library provides a convenient mock for their token server API,\n+  // so we'll use that to mock out the call to request an access token.\n+  private MockTokenServerTransport mockTokenServerTransport;\n+  private DelegatedUserCredentials creds;\n+\n+  @Before\n+  public void setUp() {\n+    mockTokenServerTransport = new MockTokenServerTransport();\n+\n+    creds = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n+    creds.setHttpTransport(mockTokenServerTransport);\n+    creds.setIamCredentialsClient(mockIamCredentialsClient);\n+  }\n+\n+  /**\n+   * Creates a PrivateKey from a PKCS8 private key string. This is effectively a copy of\n+   * ServiceAccountCredentials.privateKeyFromPkcs8 which is privately scoped.\n+   */\n+  private static PrivateKey privateKeyFromPkcs8(String privateKeyPem) throws IOException {\n+    Reader reader = new StringReader(privateKeyPem);\n+    PemReader.Section section = PemReader.readFirstSectionAndClose(reader, \"PRIVATE KEY\");\n+    if (section == null) {\n+      throw new IOException(\"Invalid PKCS8 data.\");\n+    }\n+    byte[] bytes = section.getBase64DecodedBytes();\n+    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytes);\n+    try {\n+      KeyFactory keyFactory = SecurityUtils.getRsaKeyFactory();\n+      PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n+      return privateKey;\n+    } catch (NoSuchAlgorithmException | InvalidKeySpecException exception) {\n+      throw new IOException(\"Unexpected expcetion reading PKCS data\", exception);\n+    }\n+  }\n+\n+  /**\n+   * Given a JWT payload, create a self-signed JWT using an OAuth2 compliant algorithm. This method\n+   * mocks out the behavior of the IAM Credentials API, which signs JWTs using Google-managed\n+   * service account private keys.\n+   */\n+  private static String createSelfSignedJwt(JsonWebToken.Payload payload)\n+      throws IOException, GeneralSecurityException {\n+    JsonWebSignature.Header header = new JsonWebSignature.Header();\n+    header.setAlgorithm(\"RS256\");\n+    header.setType(\"JWT\");\n+    header.setKeyId(SA_PRIVATE_KEY_ID);\n+\n+    return JsonWebSignature.signUsingRsaSha256(\n+        privateKeyFromPkcs8(SA_PRIVATE_KEY_PKCS8),\n+        JacksonFactory.getDefaultInstance(),\n+        header,\n+        payload);\n+  }\n+\n+  @Test\n+  public void testClaims() {\n+    JsonWebToken.Payload payload = creds.createClaims();\n+\n+    assertThat(payload.getAudience()).isEqualTo(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    assertThat(payload.getIssuer()).isEqualTo(SERVICE_ACCOUNT_EMAIL);\n+    assertThat(payload.getSubject()).isEqualTo(USER_EMAIL);\n+    assertThat(payload.get(\"scope\")).isEqualTo(String.join(\" \", SCOPES));\n+  }\n+\n+  @Test\n+  public void testRefreshFlow() throws IOException {\n+    // Mock out the IAM Credentials API client to create a self-signed JsonWebSignature instead of\n+    // calling Google's API.\n+    when(mockIamCredentialsClient.signJwt(any(SignJwtRequest.class)))\n+        .then(\n+            invocation -> {\n+              SignJwtRequest request = invocation.getArgument(0);\n+              JsonWebToken.Payload payload =\n+                  DelegatedUserCredentials.JSON_FACTORY.fromInputStream(\n+                      new ByteArrayInputStream(request.getPayload().getBytes()),\n+                      JsonWebToken.Payload.class);\n+              return SignJwtResponse.newBuilder()\n+                  .setSignedJwt(createSelfSignedJwt(payload))\n+                  .build();\n+            });\n+    // Register the expected service account & access token with the mock token server transport.\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+\n+    // Kick off the refresh flow.\n+    creds.refresh();\n+", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM3NDkxOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369374918", "bodyText": "I added a couple more assertions.\nA key goal of this test is to ensure that we're correctly passing the signed JWT from IAM Credentials over to the token server. This check is performed by the mock token server transport as part of its internal implementation.", "author": "gjuggler", "createdAt": "2020-01-22T05:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..e0b9bff16 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -138,11 +143,23 @@ public class DelegatedUserCredentialsTest {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());\n+    assertThat(captor.getValue().getName())\n+        .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n+\n+    // The mockTokenServerTransport class runs some lightweight verification of its own (i.e.,\n+    // ensuring the signed JWT can be parsed and that the service account is known). Beyond that,\n+    // we mainly care that the access token is returned and has a correct expiration.\n+    assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n+    assertThat(\n+            delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n+        .isEqualTo(Instant.now().getEpochSecond() + 3600);\n   }\n }\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -160,6 +167,6 @@ public class DelegatedUserCredentialsTest {\n     assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n     assertThat(\n             delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n-        .isEqualTo(Instant.now().getEpochSecond() + 3600);\n+        .isEqualTo(Instant.now(fakeClock).getEpochSecond() + 3600);\n   }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -138,11 +150,23 @@ public class DelegatedUserCredentialsTest {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient).signJwt(captor.capture());\n+    assertThat(captor.getValue().getName())\n+        .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n+\n+    // The mockTokenServerTransport class runs some lightweight verification of its own (i.e.,\n+    // ensuring the signed JWT can be parsed and that the service account is known). Beyond that,\n+    // we mainly care that the access token is returned and has a correct expiration.\n+    assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n+    assertThat(\n+            delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n+        .isEqualTo(Instant.now(fakeClock).getEpochSecond() + 3600);\n   }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTg1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369159851", "body": "I'd make \"access-token\" a constant.", "bodyText": "I'd make \"access-token\" a constant.", "bodyHTML": "<p dir=\"auto\">I'd make \"access-token\" a constant.</p>", "author": "jaycarlton", "createdAt": "2020-01-21T18:10:17Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =\n+      \"-----BEGIN PRIVATE KEY-----\\n\"\n+          + \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA04/ClUlp9Y1HEOPe\\n\"\n+          + \"2FGpSkkSkR94c2JD1Wet2qyVvXLlCBqQyTYtJugSaBWNSDe/M+6astFrWLOSZU2o\\n\"\n+          + \"OVK1AwIDAQABAkEAwQQX8zvXgEA05iP/3Dwkx7GDTwP3UM4GNV0yMJ/kvcG8lTzh\\n\"\n+          + \"/WpVThpktn5roeoiwOcQP3jbGbUTlGw2JJYVAQIhAO2jAKAoqoBIiEimrES0eery\\n\"\n+          + \"8aVmJEu+LzO2+ZgjNRZJAiEA4+juaKu6PxbBHtV4NVN1viX0mIRUxr4jcrZGlz3d\\n\"\n+          + \"QOsCIFRCxggEI2DVVy2bm93IuKosdq6VJy2MRCRsLthZM4uxAiB0A/HApJJFZT7f\\n\"\n+          + \"hEkR1C9eoRGWxd4l4UpILZNXj+1eCwIgZOwMPzJi5thQysHlvf0cqBO/7tv2fd6K\\n\"\n+          + \"qzJzcrNQfMs=\\n\"\n+          + \"-----END PRIVATE KEY-----\";\n+\n+  // We'll handle mocking out the call to the IAM Credentials API.\n+  @Mock private IamCredentialsClient mockIamCredentialsClient;\n+  // Google's API client library provides a convenient mock for their token server API,\n+  // so we'll use that to mock out the call to request an access token.\n+  private MockTokenServerTransport mockTokenServerTransport;\n+  private DelegatedUserCredentials creds;\n+\n+  @Before\n+  public void setUp() {\n+    mockTokenServerTransport = new MockTokenServerTransport();\n+\n+    creds = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n+    creds.setHttpTransport(mockTokenServerTransport);\n+    creds.setIamCredentialsClient(mockIamCredentialsClient);\n+  }\n+\n+  /**\n+   * Creates a PrivateKey from a PKCS8 private key string. This is effectively a copy of\n+   * ServiceAccountCredentials.privateKeyFromPkcs8 which is privately scoped.\n+   */\n+  private static PrivateKey privateKeyFromPkcs8(String privateKeyPem) throws IOException {\n+    Reader reader = new StringReader(privateKeyPem);\n+    PemReader.Section section = PemReader.readFirstSectionAndClose(reader, \"PRIVATE KEY\");\n+    if (section == null) {\n+      throw new IOException(\"Invalid PKCS8 data.\");\n+    }\n+    byte[] bytes = section.getBase64DecodedBytes();\n+    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytes);\n+    try {\n+      KeyFactory keyFactory = SecurityUtils.getRsaKeyFactory();\n+      PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n+      return privateKey;\n+    } catch (NoSuchAlgorithmException | InvalidKeySpecException exception) {\n+      throw new IOException(\"Unexpected expcetion reading PKCS data\", exception);\n+    }\n+  }\n+\n+  /**\n+   * Given a JWT payload, create a self-signed JWT using an OAuth2 compliant algorithm. This method\n+   * mocks out the behavior of the IAM Credentials API, which signs JWTs using Google-managed\n+   * service account private keys.\n+   */\n+  private static String createSelfSignedJwt(JsonWebToken.Payload payload)\n+      throws IOException, GeneralSecurityException {\n+    JsonWebSignature.Header header = new JsonWebSignature.Header();\n+    header.setAlgorithm(\"RS256\");\n+    header.setType(\"JWT\");\n+    header.setKeyId(SA_PRIVATE_KEY_ID);\n+\n+    return JsonWebSignature.signUsingRsaSha256(\n+        privateKeyFromPkcs8(SA_PRIVATE_KEY_PKCS8),\n+        JacksonFactory.getDefaultInstance(),\n+        header,\n+        payload);\n+  }\n+\n+  @Test\n+  public void testClaims() {\n+    JsonWebToken.Payload payload = creds.createClaims();\n+\n+    assertThat(payload.getAudience()).isEqualTo(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    assertThat(payload.getIssuer()).isEqualTo(SERVICE_ACCOUNT_EMAIL);\n+    assertThat(payload.getSubject()).isEqualTo(USER_EMAIL);\n+    assertThat(payload.get(\"scope\")).isEqualTo(String.join(\" \", SCOPES));\n+  }\n+\n+  @Test\n+  public void testRefreshFlow() throws IOException {\n+    // Mock out the IAM Credentials API client to create a self-signed JsonWebSignature instead of\n+    // calling Google's API.\n+    when(mockIamCredentialsClient.signJwt(any(SignJwtRequest.class)))\n+        .then(\n+            invocation -> {\n+              SignJwtRequest request = invocation.getArgument(0);\n+              JsonWebToken.Payload payload =\n+                  DelegatedUserCredentials.JSON_FACTORY.fromInputStream(\n+                      new ByteArrayInputStream(request.getPayload().getBytes()),\n+                      JsonWebToken.Payload.class);\n+              return SignJwtResponse.newBuilder()\n+                  .setSignedJwt(createSelfSignedJwt(payload))\n+                  .build();\n+            });\n+    // Register the expected service account & access token with the mock token server transport.\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM3NDU2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369374566", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-22T05:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTg1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..e0b9bff16 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -138,11 +143,23 @@ public class DelegatedUserCredentialsTest {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());\n+    assertThat(captor.getValue().getName())\n+        .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n+\n+    // The mockTokenServerTransport class runs some lightweight verification of its own (i.e.,\n+    // ensuring the signed JWT can be parsed and that the service account is known). Beyond that,\n+    // we mainly care that the access token is returned and has a correct expiration.\n+    assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n+    assertThat(\n+            delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n+        .isEqualTo(Instant.now().getEpochSecond() + 3600);\n   }\n }\n", "next_change": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -160,6 +167,6 @@ public class DelegatedUserCredentialsTest {\n     assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n     assertThat(\n             delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n-        .isEqualTo(Instant.now().getEpochSecond() + 3600);\n+        .isEqualTo(Instant.now(fakeClock).getEpochSecond() + 3600);\n   }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex acd003581..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -138,11 +150,23 @@ public class DelegatedUserCredentialsTest {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient).signJwt(captor.capture());\n+    assertThat(captor.getValue().getName())\n+        .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n+\n+    // The mockTokenServerTransport class runs some lightweight verification of its own (i.e.,\n+    // ensuring the signed JWT can be parsed and that the service account is known). Beyond that,\n+    // we mainly care that the access token is returned and has a correct expiration.\n+    assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n+    assertThat(\n+            delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n+        .isEqualTo(Instant.now(fakeClock).getEpochSecond() + 3600);\n   }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MDIyMg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369160222", "body": "nit: private link from public doc. Maybe just RW-2840 is enough?", "bodyText": "nit: private link from public doc. Maybe just RW-2840 is enough?", "bodyHTML": "<p dir=\"auto\">nit: private link from public doc. Maybe just RW-2840 is enough?</p>", "author": "jaycarlton", "createdAt": "2020-01-21T18:11:05Z", "path": "common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java", "diffHunk": "@@ -209,6 +209,10 @@ public static WorkbenchConfig createEmptyConfig() {\n     // Whether or not AoU should handle inbound SumoLogic high-egress event requests.\n     // See RW-2253.\n     public boolean enableSumoLogicEventHandling;\n+    // Causes the server to use an API-based method for generating delegated user credentials,\n+    // as opposed to reading service account private keys from GCS.\n+    // See https://precisionmedicineinitiative.atlassian.net/browse/RW-2840 for details.", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM3NTA4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369375086", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-22T05:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MDIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "changed_code": [{"header": "diff --git a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\nindex d07136899..84d3ae70f 100644\n--- a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n+++ b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n", "chunk": "@@ -198,20 +198,20 @@ public class WorkbenchConfig {\n     // security perimeter.\n     public boolean enableVpcServicePerimeter;\n     // Flag to indicate whether to enable the new Create Account flow\n-    // https://precisionmedicineinitiative.atlassian.net/browse/RW-3284\n+    // See RW-3284.\n     public boolean enableNewAccountCreation;\n     // Flag to indicate if USER/WORKSPACE data is exported to RDR\n     public boolean enableRdrExport;\n     // Setting this to true will prevent users from making compute increasing operations on\n     // inactive billing workspaces\n-    // https://precisionmedicineinitiative.atlassian.net/browse/RW-3209\n+    // See RW-3209.\n     public boolean enableBillingLockout;\n     // Whether or not AoU should handle inbound SumoLogic high-egress event requests.\n     // See RW-2253.\n     public boolean enableSumoLogicEventHandling;\n     // Causes the server to use an API-based method for generating delegated user credentials,\n     // as opposed to reading service account private keys from GCS.\n-    // See https://precisionmedicineinitiative.atlassian.net/browse/RW-2840 for details.\n+    // See RW-2840.\n     public boolean useKeylessDelegatedCredentials;\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\nindex d07136899..84d3ae70f 100644\n--- a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n+++ b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n", "chunk": "@@ -198,20 +198,20 @@ public class WorkbenchConfig {\n     // security perimeter.\n     public boolean enableVpcServicePerimeter;\n     // Flag to indicate whether to enable the new Create Account flow\n-    // https://precisionmedicineinitiative.atlassian.net/browse/RW-3284\n+    // See RW-3284.\n     public boolean enableNewAccountCreation;\n     // Flag to indicate if USER/WORKSPACE data is exported to RDR\n     public boolean enableRdrExport;\n     // Setting this to true will prevent users from making compute increasing operations on\n     // inactive billing workspaces\n-    // https://precisionmedicineinitiative.atlassian.net/browse/RW-3209\n+    // See RW-3209.\n     public boolean enableBillingLockout;\n     // Whether or not AoU should handle inbound SumoLogic high-egress event requests.\n     // See RW-2253.\n     public boolean enableSumoLogicEventHandling;\n     // Causes the server to use an API-based method for generating delegated user credentials,\n     // as opposed to reading service account private keys from GCS.\n-    // See https://precisionmedicineinitiative.atlassian.net/browse/RW-2840 for details.\n+    // See RW-2840.\n     public boolean useKeylessDelegatedCredentials;\n   }\n \n", "next_change": {"commit": "2df7db432e04635c4d4645d287ff7e21a30f00e0", "changed_code": [{"header": "diff --git a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\nindex 84d3ae70f..1f0e4e625 100644\n--- a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n+++ b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n", "chunk": "@@ -213,6 +213,9 @@ public class WorkbenchConfig {\n     // as opposed to reading service account private keys from GCS.\n     // See RW-2840.\n     public boolean useKeylessDelegatedCredentials;\n+    // Whether we send emails to users after they pass Free Tier usage thresholds\n+    // Blocked by RW-4135: do not enable in an environment where contact_email can be NULL\n+    public boolean sendFreeTierAlertEmails;\n   }\n \n   public static class ActionAuditConfig {\n", "next_change": {"commit": "a9fe3295ccc8e4e4377e13b2d98046ddf98c93f3", "changed_code": [{"header": "diff --git a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\nindex 1f0e4e625..159da75dd 100644\n--- a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n+++ b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n", "chunk": "@@ -216,6 +218,9 @@ public class WorkbenchConfig {\n     // Whether we send emails to users after they pass Free Tier usage thresholds\n     // Blocked by RW-4135: do not enable in an environment where contact_email can be NULL\n     public boolean sendFreeTierAlertEmails;\n+    // Flag to indicate whether to use the new Moodle badges API\n+    // https://precisionmedicineinitiative.atlassian.net/browse/RW-2957\n+    public boolean enableMoodleV2Api;\n   }\n \n   public static class ActionAuditConfig {\n", "next_change": {"commit": "a25e3b68dae7550bd8c5368f5f095b9d9b823914", "changed_code": [{"header": "diff --git a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\nindex 159da75dd..23e9ec9d4 100644\n--- a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n+++ b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n", "chunk": "@@ -221,6 +237,10 @@ public class WorkbenchConfig {\n     // Flag to indicate whether to use the new Moodle badges API\n     // https://precisionmedicineinitiative.atlassian.net/browse/RW-2957\n     public boolean enableMoodleV2Api;\n+    // Do we require new users to have a contact email with a verified institutional affiliation,\n+    // enforced by pattern-matching the user's contact email against the institution's\n+    // set of whitelisted email domains or addresses\n+    public boolean requireInstitutionalVerification;\n   }\n \n   public static class ActionAuditConfig {\n", "next_change": {"commit": "d505c381af31ecf7d87c54e0528024a22e59013f", "changed_code": [{"header": "diff --git a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\nindex 23e9ec9d4..378966287 100644\n--- a/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n+++ b/common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java\n", "chunk": "@@ -241,6 +237,8 @@ public class WorkbenchConfig {\n     // enforced by pattern-matching the user's contact email against the institution's\n     // set of whitelisted email domains or addresses\n     public boolean requireInstitutionalVerification;\n+    // Flag to indicate whether to use the new age type options in cohort builder age wizard\n+    public boolean enableCBAgeTypeOptions;\n   }\n \n   public static class ActionAuditConfig {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "2df7db432e04635c4d4645d287ff7e21a30f00e0", "committedDate": "2020-01-28 11:10:40 -0500", "message": "[risk=low][RW-3661] Send Free Tier alert emails (#3021)"}, {"oid": "a9fe3295ccc8e4e4377e13b2d98046ddf98c93f3", "committedDate": "2020-01-29 15:01:38 -0500", "message": "[risk=no][RW-2957] Moodle v2 API Integration (#3032)"}, {"oid": "493cf02523762a18af9ae279a57c8041452866e5", "committedDate": "2020-01-30 13:22:45 -0500", "message": "[RW-4277][risk=low] Users can set workspace billing account back to free tier (#3040)"}, {"oid": "62b7aece7f45051e3ea399d8077830da5b8f1de5", "committedDate": "2020-02-03 15:12:19 -0800", "message": "[RW-4132][risk=moderate] Integrate with Zendesk for workspace review requests (#3072)"}, {"oid": "3645bffd70fa44003722798bddfb4744684e89aa", "committedDate": "2020-02-12 18:59:54 -0500", "message": "[RW-3685][risk=low] Add a config variable controlling invitation key verification (#3110)"}, {"oid": "a25e3b68dae7550bd8c5368f5f095b9d9b823914", "committedDate": "2020-02-20 17:41:04 -0500", "message": "[risk=low][RW-4259]Enforce Verified Institutional Affiliation (API only) for new account creation if feature flag is set (#3139)"}, {"oid": "0dc31a770e724beeea52921a9d84eefa8f1d0779", "committedDate": "2020-02-25 14:16:18 -0500", "message": "remove references to free tier time limits (#3184)"}, {"oid": "d505c381af31ecf7d87c54e0528024a22e59013f", "committedDate": "2020-02-27 14:48:16 -0600", "message": "[RW-4429][risk=no] Add age type options in CB age wizard (#3198)"}, {"oid": "de394565d5b6ada942ded617fa28675c4109c0b3", "committedDate": "2020-02-28 16:32:50 -0500", "message": "[RW-4446][risk=no] Clean up the enableNewAccountCreation flag (#3199)"}, {"oid": "3d2a990cc81bbb01097fae9bcdd6ea1b7524b551", "committedDate": "2020-03-04 11:02:00 -0500", "message": "[RW-4472][risk=no] Update free tier credit limit to $300 (#3210)"}, {"oid": "7de6df1b4ad83258f413dd0a5616d2adfec6875b", "committedDate": "2020-03-04 12:17:16 -0500", "message": "[RW-4242][Risk=moderate] Remove common api (#3211)"}]}, {"oid": "8a44f30151402bbed4d867cf437ae00247d1c19c", "url": "https://github.com/all-of-us/workbench/commit/8a44f30151402bbed4d867cf437ae00247d1c19c", "message": "Responding to PR comments.", "committedDate": "2020-01-22T05:25:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNzY5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369627697", "body": "Cool. `times(1)` is the default, so you can leave that out.", "bodyText": "Cool. times(1) is the default, so you can leave that out.", "bodyHTML": "<p dir=\"auto\">Cool. <code>times(1)</code> is the default, so you can leave that out.</p>", "author": "jaycarlton", "createdAt": "2020-01-22T15:27:37Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -138,11 +143,23 @@ public void testRefreshFlow() throws IOException {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -150,7 +157,7 @@ public class DelegatedUserCredentialsTest {\n \n     // Verify the call to IAM Credentials API.\n     ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n-    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());\n+    verify(mockIamCredentialsClient).signJwt(captor.capture());\n     assertThat(captor.getValue().getName())\n         .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -150,7 +157,7 @@ public class DelegatedUserCredentialsTest {\n \n     // Verify the call to IAM Credentials API.\n     ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n-    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());\n+    verify(mockIamCredentialsClient).signJwt(captor.capture());\n     assertThat(captor.getValue().getName())\n         .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyODM3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369628372", "body": "I'd declare a static `Instant` so you have the same calculation every time. May need to inject a fake clock somewhere though.", "bodyText": "I'd declare a static Instant so you have the same calculation every time. May need to inject a fake clock somewhere though.", "bodyHTML": "<p dir=\"auto\">I'd declare a static <code>Instant</code> so you have the same calculation every time. May need to inject a fake clock somewhere though.</p>", "author": "jaycarlton", "createdAt": "2020-01-22T15:28:40Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -138,11 +143,23 @@ public void testRefreshFlow() throws IOException {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());\n+    assertThat(captor.getValue().getName())\n+        .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n+\n+    // The mockTokenServerTransport class runs some lightweight verification of its own (i.e.,\n+    // ensuring the signed JWT can be parsed and that the service account is known). Beyond that,\n+    // we mainly care that the access token is returned and has a correct expiration.\n+    assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n+    assertThat(\n+            delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzcwOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967708", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-26T01:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyODM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -160,6 +167,6 @@ public class DelegatedUserCredentialsTest {\n     assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n     assertThat(\n             delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n-        .isEqualTo(Instant.now().getEpochSecond() + 3600);\n+        .isEqualTo(Instant.now(fakeClock).getEpochSecond() + 3600);\n   }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -160,6 +167,6 @@ public class DelegatedUserCredentialsTest {\n     assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n     assertThat(\n             delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())\n-        .isEqualTo(Instant.now().getEpochSecond() + 3600);\n+        .isEqualTo(Instant.now(fakeClock).getEpochSecond() + 3600);\n   }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTA3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369629075", "body": "Is this what access tokens look like? It's fine for test purposes, but I find it easier to pick up a new class if the test methods use data that look like the real thing.", "bodyText": "Is this what access tokens look like? It's fine for test purposes, but I find it easier to pick up a new class if the test methods use data that look like the real thing.", "bodyHTML": "<p dir=\"auto\">Is this what access tokens look like? It's fine for test purposes, but I find it easier to pick up a new class if the test methods use data that look like the real thing.</p>", "author": "jaycarlton", "createdAt": "2020-01-22T15:29:48Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -38,8 +42,9 @@\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+  static final String MOCK_ACCESS_TOKEN = \"access-token\";", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzQ5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967497", "bodyText": "Updated with something more realistic. (Heartwarming side note: without the FAKE_ prefix, git-secrets catches this and prevents a successful commit.)", "author": "gjuggler", "createdAt": "2020-01-26T01:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -42,7 +42,7 @@ public class DelegatedUserCredentialsTest {\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n-  static final String MOCK_ACCESS_TOKEN = \"access-token\";\n+  static final String MOCK_ACCESS_TOKEN = \"FAKE_ya29.QQIBibTwvKkE39hY8mdkT_mXZoRh7...\";\n \n   static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n   // A random private key string generated for testing purposed with the following commands:\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\nindex e0b9bff16..fd5bdd199 100644\n--- a/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n+++ b/api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java\n", "chunk": "@@ -42,7 +42,7 @@ public class DelegatedUserCredentialsTest {\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n-  static final String MOCK_ACCESS_TOKEN = \"access-token\";\n+  static final String MOCK_ACCESS_TOKEN = \"FAKE_ya29.QQIBibTwvKkE39hY8mdkT_mXZoRh7...\";\n \n   static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n   // A random private key string generated for testing purposed with the following commands:\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "a91baeab6c35b5139e9ced1d8dfb39d8577daa63", "committedDate": "2021-06-04 13:29:06 -0400", "message": "[RW-6791][risk=no] Upgrade to junit 5 (#5033)"}, {"oid": "710836017e9c767489faa9c9a9c40295a37af577", "committedDate": "2021-11-04 16:02:20 -0700", "message": "[risk=no] FakeClockConfiguration rework (#5843)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTkwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369629905", "body": "Do we need to accept a null list here? If possible I would avoid this kind of convention and just use overloaded constructors.", "bodyText": "Do we need to accept a null list here? If possible I would avoid this kind of convention and just use overloaded constructors.", "bodyHTML": "<p dir=\"auto\">Do we need to accept a null list here? If possible I would avoid this kind of convention and just use overloaded constructors.</p>", "author": "jaycarlton", "createdAt": "2020-01-22T15:31:02Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -88,7 +89,7 @@ public DelegatedUserCredentials(\n     this.scopes = scopes;", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzM3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967371", "bodyText": "Fair point. I removed all code that deals with a null list.", "author": "gjuggler", "createdAt": "2020-01-26T01:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0Nzk5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369747998", "body": "nit: line wrapping", "bodyText": "nit: line wrapping", "bodyHTML": "<p dir=\"auto\">nit: line wrapping</p>", "author": "calbach", "createdAt": "2020-01-22T19:07:54Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1NDYyNg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370954626", "bodyText": "Spotless must not have liked my poor man's list formatting. Split out into separate paragraphs.", "author": "gjuggler", "createdAt": "2020-01-25T20:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0Nzk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MDM2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369750367", "body": "Why the lazy initialization of the IAM client and HTTP transport?", "bodyText": "Why the lazy initialization of the IAM client and HTTP transport?", "bodyHTML": "<p dir=\"auto\">Why the lazy initialization of the IAM client and HTTP transport?</p>", "author": "calbach", "createdAt": "2020-01-22T19:12:37Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = Collections.emptyList();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createJwtPayload() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {\n+    // The first step is to call the IamCredentials API to generate a signed JWT with the\n+    // appropriate claims. This call is authorized with application default credentials (ADCs). The\n+    // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n+    // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n+    JsonWebToken.Payload payload = createJwtPayload();\n+\n+    if (client == null) {\n+      client = IamCredentialsClient.create();", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzM4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967389", "bodyText": "See my response to your comment above \u2013 I switched to requiring constructor DI for these classes.", "author": "gjuggler", "createdAt": "2020-01-26T01:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MDM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -133,23 +130,15 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createJwtPayload();\n-\n-    if (client == null) {\n-      client = IamCredentialsClient.create();\n-    }\n     SignJwtRequest jwtRequest =\n         SignJwtRequest.newBuilder()\n             .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n-            .setPayload(JSON_FACTORY.toString(payload))\n+            .setPayload(JSON_FACTORY.toString(createJwtPayload()))\n             .build();\n-    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+    String jwt = credentialsClient.signJwt(jwtRequest).getSignedJwt();\n \n     // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n     // an access token.\n-    if (httpTransport == null) {\n-      httpTransport = new NetHttpTransport();\n-    }\n     TokenRequest tokenRequest =\n         new TokenRequest(\n             httpTransport,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -133,23 +130,15 @@ public class DelegatedUserCredentials extends OAuth2Credentials {\n     // appropriate claims. This call is authorized with application default credentials (ADCs). The\n     // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n     // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n-    JsonWebToken.Payload payload = createJwtPayload();\n-\n-    if (client == null) {\n-      client = IamCredentialsClient.create();\n-    }\n     SignJwtRequest jwtRequest =\n         SignJwtRequest.newBuilder()\n             .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n-            .setPayload(JSON_FACTORY.toString(payload))\n+            .setPayload(JSON_FACTORY.toString(createJwtPayload()))\n             .build();\n-    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+    String jwt = credentialsClient.signJwt(jwtRequest).getSignedJwt();\n \n     // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n     // an access token.\n-    if (httpTransport == null) {\n-      httpTransport = new NetHttpTransport();\n-    }\n     TokenRequest tokenRequest =\n         new TokenRequest(\n             httpTransport,\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MTQzMQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369751431", "body": "This seems high to me. I think 5 minutes might be more typical for this kind of token. Do we have a use case where we'd need a long-lived token here? (and if it expires, the refresh should kick in - right?)", "bodyText": "This seems high to me. I think 5 minutes might be more typical for this kind of token. Do we have a use case where we'd need a long-lived token here? (and if it expires, the refresh should kick in - right?)", "bodyHTML": "<p dir=\"auto\">This seems high to me. I think 5 minutes might be more typical for this kind of token. Do we have a use case where we'd need a long-lived token here? (and if it expires, the refresh should kick in - right?)</p>", "author": "calbach", "createdAt": "2020-01-22T19:14:46Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1NDQ2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370954462", "bodyText": "AFAICT, 60min appears to be Google's default expiration for oauth2 access tokens if left blank (c.f. https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateAccessToken#request-body and https://stackoverflow.com/questions/13851157/oauth2-and-google-api-access-token-expiration-time).\nAnother clue comes from logic in the base OAuth2Credentials class, which refreshes a token if the expiration time is any less than 5 minutes away: https://github.com/googleapis/google-auth-library-java/blob/master/oauth2_http/java/com/google/auth/oauth2/OAuth2Credentials.java#L58. So requesting an expiration of 5 minutes would effectively mean we can never reuse an access token. (That said, to be fair I think most services are regenerating delegated credentials for each inbound request anyway, so we're likely not yet using the benefit of cached access tokens.)\nI don't disagree that an hour feels like more than we \"need\", but given that it seems to be pretty widely used, I'm inclined to leave as-is.", "author": "gjuggler", "createdAt": "2020-01-25T20:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MTQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MDg2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369760867", "body": "The documentation for this client indicates that it should be closed: https://github.com/googleapis/java-iamcredentials/blob/master/google-cloud-iamcredentials/src/main/java/com/google/cloud/iam/credentials/v1/IamCredentialsClient.java#L56-L57\r\n\r\nProviding this as a spring singleton and moving this to be a constructor parameter (callers would inject the client and pass it through) would probably be my preferred solution to this.", "bodyText": "The documentation for this client indicates that it should be closed: https://github.com/googleapis/java-iamcredentials/blob/master/google-cloud-iamcredentials/src/main/java/com/google/cloud/iam/credentials/v1/IamCredentialsClient.java#L56-L57\nProviding this as a spring singleton and moving this to be a constructor parameter (callers would inject the client and pass it through) would probably be my preferred solution to this.", "bodyHTML": "<p dir=\"auto\">The documentation for this client indicates that it should be closed: <a href=\"https://github.com/googleapis/java-iamcredentials/blob/master/google-cloud-iamcredentials/src/main/java/com/google/cloud/iam/credentials/v1/IamCredentialsClient.java#L56-L57\">https://github.com/googleapis/java-iamcredentials/blob/master/google-cloud-iamcredentials/src/main/java/com/google/cloud/iam/credentials/v1/IamCredentialsClient.java#L56-L57</a></p>\n<p dir=\"auto\">Providing this as a spring singleton and moving this to be a constructor parameter (callers would inject the client and pass it through) would probably be my preferred solution to this.</p>", "author": "calbach", "createdAt": "2020-01-22T19:33:36Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzMzOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967338", "bodyText": "Good point \u2013 I'd been trying to avoid getting too deep into changing our Spring dependencies, but the combination of the .close() method and the awkwardness of logic to lazily create default instances forced me to take a stab at a full dependency-injected approach. It's cleaner in this class, but I still get a bad feeling when dealing with our service-level Spring DI (especially in tests). I tried to clean things up a bit, including adding autowiring to one of our test classes (to reduce the churn when we add new dependencies) and fixing an awful bit of Spring config leakage between our unit and integration tests (see the change to build.gradle \u2013\u00a0that one really had me surprised).", "author": "gjuggler", "createdAt": "2020-01-26T01:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MDg2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\nindex 33a7ec1b3..162a5f7da 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java\n", "chunk": "@@ -55,52 +54,50 @@ import java.util.List;\n  */\n public class DelegatedUserCredentials extends OAuth2Credentials {\n \n+  // 60 minutes is the default access token duration time for Google-generated OAuth2 tokens.\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n   static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n   static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n   static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n-  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n \n   // The email of the service account whose system-managed key should be used to sign the JWT\n   // assertion which is exchanged for an access token. This service account:\n-  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n-  // - Does not need to be the same service account (SA) as the application default credentials\n-  // (ADC)\n-  //     service account. If they are different, the ADC account must have the Service Account Token\n-  //     Creator role granted on this service account. See\n-  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n-  //     details.\n+  // (1) Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  //\n+  // (2) Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC) service account. If they are different, the ADC account must have the Service Account\n+  // Token Creator role granted on this service account. See\n+  // https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  // details.\n   private String serviceAccountEmail;\n   // The full G Suite email address of the user for whom an access token will be generated.\n   private String userEmail;\n   // The set of Google OAuth scopes to be requested.\n   private List<String> scopes;\n-  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n-  // a default NetHttpTransport instance is used.\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server.\n   private HttpTransport httpTransport;\n-  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n-  // a default API client will be used.\n-  private IamCredentialsClient client;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google.\n+  private IamCredentialsClient credentialsClient;\n+  // The Clock to use when generating the expiration timestamp for the returned token.\n+  private Clock clock = Clock.systemUTC();\n \n   public DelegatedUserCredentials(\n-      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+      String serviceAccountEmail,\n+      String userEmail,\n+      List<String> scopes,\n+      IamCredentialsClient credentialsClient,\n+      HttpTransport httpTransport) {\n     super();\n     this.serviceAccountEmail = serviceAccountEmail;\n     this.userEmail = userEmail;\n     this.scopes = scopes;\n-\n-    if (this.scopes == null) {\n-      this.scopes = Collections.emptyList();\n-    }\n-  }\n-\n-  @VisibleForTesting\n-  public void setIamCredentialsClient(IamCredentialsClient client) {\n-    this.client = client;\n+    this.credentialsClient = credentialsClient;\n+    this.httpTransport = httpTransport;\n   }\n \n   @VisibleForTesting\n-  public void setHttpTransport(HttpTransport httpTransport) {\n-    this.httpTransport = httpTransport;\n+  public void setClock(Clock clock) {\n+    this.clock = clock;\n   }\n \n   /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MjMzNA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369762334", "body": "What's the significance of adding this? Isn't this still just a collection of static utilities both before/after this change?", "bodyText": "What's the significance of adding this? Isn't this still just a collection of static utilities both before/after this change?", "bodyHTML": "<p dir=\"auto\">What's the significance of adding this? Isn't this still just a collection of static utilities both before/after this change?</p>", "author": "calbach", "createdAt": "2020-01-22T19:36:50Z", "path": "api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java", "diffHunk": "@@ -7,11 +7,13 @@\n import com.google.auth.oauth2.GoogleCredentials;\n import java.io.IOException;\n import java.util.List;\n+import org.springframework.stereotype.Component;\n \n /**\n  * Handles functionality related to loading service account credentials and generating derived /\n  * impersonated credentials.\n  */\n+@Component", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "changed_code": [{"header": "diff --git a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\nindex 95e5003f5..a3a2b4750 100644\n--- a/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n+++ b/api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java\n", "chunk": "@@ -16,9 +16,6 @@ import org.springframework.stereotype.Component;\n @Component\n public class ServiceAccounts {\n \n-  private static final String SIGN_JWT_URL_FORMAT =\n-      \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/%s:signJwt\";\n-\n   /**\n    * Returns an appropriate set of backend service credentials with the given set of scopes.\n    *\n", "next_change": null}]}, "commits_in_main": [{"oid": "e01fe2ec97cb11ab71e6a673c5ca9b37340c8cc5", "message": "Merge commit", "committedDate": null}, {"oid": "493cf02523762a18af9ae279a57c8041452866e5", "committedDate": "2020-01-30 13:22:45 -0500", "message": "[RW-4277][risk=low] Users can set workspace billing account back to free tier (#3040)"}, {"oid": "fe8b4edaeee7c0a06d5fd647009433849aa72366", "committedDate": "2020-04-08 21:26:14 -0700", "message": "[RW-4573][risk=low] Switch delete-workspaces to use SA creds (#3371)"}, {"oid": "672a601c278de5ce8d2a8261bd6a5fc368cf730b", "committedDate": "2021-10-11 12:25:07 -0700", "message": "[risk=low] Factor out impersonation to common factory (#5735)"}]}, {"oid": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "url": "https://github.com/all-of-us/workbench/commit/fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "message": "PR feedback. Use DI for creds class, fix some Spring config & autowiring madness, use FakeClock in tests.", "committedDate": "2020-01-26T01:41:34Z", "type": "commit"}, {"oid": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "url": "https://github.com/all-of-us/workbench/commit/fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "message": "PR feedback. Use DI for creds class, fix some Spring config & autowiring madness, use FakeClock in tests.", "committedDate": "2020-01-26T01:41:34Z", "type": "forcePushed"}, {"oid": "89bd6c45a8b0ff4ab7f4c78cf36ed64d441723a2", "url": "https://github.com/all-of-us/workbench/commit/89bd6c45a8b0ff4ab7f4c78cf36ed64d441723a2", "message": "Create a ServiceAccountContext within start-local-api.", "committedDate": "2020-01-27T19:36:16Z", "type": "commit"}]}