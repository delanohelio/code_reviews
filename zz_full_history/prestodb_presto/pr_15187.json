{"pr_number": 15187, "pr_title": "Consider predicate columns for encryption", "pr_author": "mayankgarg1990", "pr_createdAt": "2020-09-17T17:18:52Z", "pr_url": "https://github.com/prestodb/presto/pull/15187", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA3MjQyMg==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491072422", "body": "can you remind me again why requested columns is optional?  requested columns being optional and predicate columns not makes the logic here kind of confusing. Is it possible to always provide it?", "bodyText": "can you remind me again why requested columns is optional?  requested columns being optional and predicate columns not makes the logic here kind of confusing. Is it possible to always provide it?", "bodyHTML": "<p dir=\"auto\">can you remind me again why requested columns is optional?  requested columns being optional and predicate columns not makes the logic here kind of confusing. Is it possible to always provide it?</p>", "author": "rschlussel", "createdAt": "2020-09-18T16:49:20Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java", "diffHunk": "@@ -470,6 +481,43 @@ public CounterStat getHighMemorySplitSource()\n         return concat(partitionBatches);\n     }\n \n+    private static Optional<Set<HiveColumnHandle>> mergeRequestedAndPredicateColumns(Optional<Set<HiveColumnHandle>> requestedColumns, Set<HiveColumnHandle> predicateColumns)\n+    {\n+        if (!requestedColumns.isPresent() || predicateColumns.isEmpty()) {", "originalCommit": "87d4e2e8554c8bf5e61bbb410f567a838b6d01ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0NzY4MQ==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491147681", "bodyText": "I am just going with the structure of HiveTableLayoutHandle and in this class - requestedColumns is optional and predicateColumns is not. Given this is where I get the data from, I don't think it is possible for me to always provide requestedColumns", "author": "mayankgarg1990", "createdAt": "2020-09-18T19:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA3MjQyMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMjU1OQ==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491132559", "body": "You can use the groupingBy collector https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-", "bodyText": "You can use the groupingBy collector https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-", "bodyHTML": "<p dir=\"auto\">You can use the groupingBy collector <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-\" rel=\"nofollow\">https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-</a></p>", "author": "rschlussel", "createdAt": "2020-09-18T18:51:34Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java", "diffHunk": "@@ -470,6 +481,43 @@ public CounterStat getHighMemorySplitSource()\n         return concat(partitionBatches);\n     }\n \n+    private static Optional<Set<HiveColumnHandle>> mergeRequestedAndPredicateColumns(Optional<Set<HiveColumnHandle>> requestedColumns, Set<HiveColumnHandle> predicateColumns)\n+    {\n+        if (!requestedColumns.isPresent() || predicateColumns.isEmpty()) {\n+            return requestedColumns;\n+        }\n+\n+        Map<String, Set<HiveColumnHandle>> nameToColumnHandles = new HashMap<>();", "originalCommit": "87d4e2e8554c8bf5e61bbb410f567a838b6d01ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzODQ4NA==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491138484", "body": "why can we short circuit for non-structs?  is it because there will never be any subfields?  I think the shortcircuiting is more confusing.", "bodyText": "why can we short circuit for non-structs?  is it because there will never be any subfields?  I think the shortcircuiting is more confusing.", "bodyHTML": "<p dir=\"auto\">why can we short circuit for non-structs?  is it because there will never be any subfields?  I think the shortcircuiting is more confusing.</p>", "author": "rschlussel", "createdAt": "2020-09-18T19:04:35Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java", "diffHunk": "@@ -470,6 +481,43 @@ public CounterStat getHighMemorySplitSource()\n         return concat(partitionBatches);\n     }\n \n+    private static Optional<Set<HiveColumnHandle>> mergeRequestedAndPredicateColumns(Optional<Set<HiveColumnHandle>> requestedColumns, Set<HiveColumnHandle> predicateColumns)\n+    {\n+        if (!requestedColumns.isPresent() || predicateColumns.isEmpty()) {\n+            return requestedColumns;\n+        }\n+\n+        Map<String, Set<HiveColumnHandle>> nameToColumnHandles = new HashMap<>();\n+        Stream.concat(requestedColumns.get().stream(), predicateColumns.stream())\n+                .filter(column -> column.getColumnType() == REGULAR)\n+                .forEach(column -> nameToColumnHandles.computeIfAbsent(column.getName(), (key) -> new HashSet<>()).add(column));\n+\n+        return Optional.of(nameToColumnHandles.values().stream()\n+                .map(columnHandles -> {\n+                    HiveColumnHandle finalHandle = null;\n+                    for (HiveColumnHandle columnHandle : columnHandles) {\n+                        if (finalHandle == null) {\n+                            finalHandle = columnHandle;\n+                            continue;\n+                        }\n+\n+                        if (finalHandle.getHiveType().getCategory() != STRUCT || finalHandle.getRequiredSubfields().isEmpty()) {", "originalCommit": "87d4e2e8554c8bf5e61bbb410f567a838b6d01ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0ODQxNQ==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491148415", "bodyText": "Yes, because there will never be subfields in NON-structs. Well, there might be key, value stuff for maps, but that doesn't really impact encryption implementation since either the full map/array is encrypted or not.", "author": "mayankgarg1990", "createdAt": "2020-09-18T19:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzODQ4NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0MDkzNQ==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491140935", "body": "Can this whole section be simplified to\r\n```\r\nif (finalHandle == null || finalHandle.getRequiredSubfields.isEmpty() || columnHandle.getRequiredSubfields.isEmpty()) {\r\n   finalHandle = columnHandle;\r\n}\r\nelse {\r\n   finalHandle = (HiveColumnHandle) finalHandle.withRequiredSubfields(ImmutableList.copyOf(ImmutableSet.copyOf(\r\n                                    ImmutableList.<Subfield>builder().addAll(finalHandle.getRequiredSubfields()).addAll(columnHandle.getRequiredSubfields()).build())));\r\n}\r\n```\r\n\r\nAlso, can we do it as a reduce on the stream instead of having a forloop inside the stream? (if we use groupingBy, don't even need to collect to map first)", "bodyText": "Can this whole section be simplified to\nif (finalHandle == null || finalHandle.getRequiredSubfields.isEmpty() || columnHandle.getRequiredSubfields.isEmpty()) {\n   finalHandle = columnHandle;\n}\nelse {\n   finalHandle = (HiveColumnHandle) finalHandle.withRequiredSubfields(ImmutableList.copyOf(ImmutableSet.copyOf(\n                                    ImmutableList.<Subfield>builder().addAll(finalHandle.getRequiredSubfields()).addAll(columnHandle.getRequiredSubfields()).build())));\n}\n\nAlso, can we do it as a reduce on the stream instead of having a forloop inside the stream? (if we use groupingBy, don't even need to collect to map first)", "bodyHTML": "<p dir=\"auto\">Can this whole section be simplified to</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (finalHandle == null || finalHandle.getRequiredSubfields.isEmpty() || columnHandle.getRequiredSubfields.isEmpty()) {\n   finalHandle = columnHandle;\n}\nelse {\n   finalHandle = (HiveColumnHandle) finalHandle.withRequiredSubfields(ImmutableList.copyOf(ImmutableSet.copyOf(\n                                    ImmutableList.&lt;Subfield&gt;builder().addAll(finalHandle.getRequiredSubfields()).addAll(columnHandle.getRequiredSubfields()).build())));\n}\"><pre><code>if (finalHandle == null || finalHandle.getRequiredSubfields.isEmpty() || columnHandle.getRequiredSubfields.isEmpty()) {\n   finalHandle = columnHandle;\n}\nelse {\n   finalHandle = (HiveColumnHandle) finalHandle.withRequiredSubfields(ImmutableList.copyOf(ImmutableSet.copyOf(\n                                    ImmutableList.&lt;Subfield&gt;builder().addAll(finalHandle.getRequiredSubfields()).addAll(columnHandle.getRequiredSubfields()).build())));\n}\n</code></pre></div>\n<p dir=\"auto\">Also, can we do it as a reduce on the stream instead of having a forloop inside the stream? (if we use groupingBy, don't even need to collect to map first)</p>", "author": "rschlussel", "createdAt": "2020-09-18T19:10:13Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java", "diffHunk": "@@ -470,6 +481,43 @@ public CounterStat getHighMemorySplitSource()\n         return concat(partitionBatches);\n     }\n \n+    private static Optional<Set<HiveColumnHandle>> mergeRequestedAndPredicateColumns(Optional<Set<HiveColumnHandle>> requestedColumns, Set<HiveColumnHandle> predicateColumns)\n+    {\n+        if (!requestedColumns.isPresent() || predicateColumns.isEmpty()) {\n+            return requestedColumns;\n+        }\n+\n+        Map<String, Set<HiveColumnHandle>> nameToColumnHandles = new HashMap<>();\n+        Stream.concat(requestedColumns.get().stream(), predicateColumns.stream())\n+                .filter(column -> column.getColumnType() == REGULAR)\n+                .forEach(column -> nameToColumnHandles.computeIfAbsent(column.getName(), (key) -> new HashSet<>()).add(column));\n+\n+        return Optional.of(nameToColumnHandles.values().stream()\n+                .map(columnHandles -> {\n+                    HiveColumnHandle finalHandle = null;\n+                    for (HiveColumnHandle columnHandle : columnHandles) {\n+                        if (finalHandle == null) {", "originalCommit": "87d4e2e8554c8bf5e61bbb410f567a838b6d01ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NzM1Ng==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r491177356", "bodyText": "Thanks for advise on grouping by and reduce - this has made the code a lot simpler now.", "author": "mayankgarg1990", "createdAt": "2020-09-18T20:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0MDkzNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "eec44beab826c865f85bd7167365766c39bd0196", "url": "https://github.com/prestodb/presto/commit/eec44beab826c865f85bd7167365766c39bd0196", "message": "Consider predicate columns for encryption\n\nIn encryption we pass the list of columns that are being read to help with\ngetting the credentials only for those columns and allow for more granular\naccess control.\n\nUptil now, only the columns being requested in the select statement were\nthe only ones being considered. This commit adds support for columns in\nthe predicate as well. We now consider the predicate columns as well.\n\nA special case to callout is `ROW`. Presto currently supports encryption\ngranularity of a subfield, however, it is non-trivial to get the exact\nsubfields being accessed for a `ROW`. This PR puts the whole `ROW` column\nif any subfield is being used in the predicate. This is a limitation for\nnow.", "committedDate": "2020-09-18T20:39:29Z", "type": "forcePushed"}, {"oid": "4f86b23a3e5ec123c9b0a4c4a8932fc5f0c2ecdc", "url": "https://github.com/prestodb/presto/commit/4f86b23a3e5ec123c9b0a4c4a8932fc5f0c2ecdc", "message": "Consider predicate columns for encryption\n\nIn encryption we pass the list of columns that are being read to help with\ngetting the credentials only for those columns and allow for more granular\naccess control.\n\nUptil now, only the columns being requested in the select statement were\nthe only ones being considered. This commit adds support for columns in\nthe predicate as well. We now consider the predicate columns as well.\n\nA special case to callout is `ROW`. Presto currently supports encryption\ngranularity of a subfield, however, it is non-trivial to get the exact\nsubfields being accessed for a `ROW`. This PR puts the whole `ROW` column\nif any subfield is being used in the predicate. This is a limitation for\nnow.", "committedDate": "2020-09-18T20:42:03Z", "type": "commit"}, {"oid": "4f86b23a3e5ec123c9b0a4c4a8932fc5f0c2ecdc", "url": "https://github.com/prestodb/presto/commit/4f86b23a3e5ec123c9b0a4c4a8932fc5f0c2ecdc", "message": "Consider predicate columns for encryption\n\nIn encryption we pass the list of columns that are being read to help with\ngetting the credentials only for those columns and allow for more granular\naccess control.\n\nUptil now, only the columns being requested in the select statement were\nthe only ones being considered. This commit adds support for columns in\nthe predicate as well. We now consider the predicate columns as well.\n\nA special case to callout is `ROW`. Presto currently supports encryption\ngranularity of a subfield, however, it is non-trivial to get the exact\nsubfields being accessed for a `ROW`. This PR puts the whole `ROW` column\nif any subfield is being used in the predicate. This is a limitation for\nnow.", "committedDate": "2020-09-18T20:42:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MTE4OA==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r492841188", "body": "@mayankgarg1990 Is this the right logic? For a `SELECT count(*) FROM t WHERE a > 10` we can have requestedColumns empty and predicateColumns containing \"a\". In this case, don't we need to make sure user has access to \"a\" ?", "bodyText": "@mayankgarg1990 Is this the right logic? For a SELECT count(*) FROM t WHERE a > 10 we can have requestedColumns empty and predicateColumns containing \"a\". In this case, don't we need to make sure user has access to \"a\" ?", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mayankgarg1990/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mayankgarg1990\">@mayankgarg1990</a> Is this the right logic? For a <code>SELECT count(*) FROM t WHERE a &gt; 10</code> we can have requestedColumns empty and predicateColumns containing \"a\". In this case, don't we need to make sure user has access to \"a\" ?</p>", "author": "mbasmanova", "createdAt": "2020-09-22T15:42:10Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java", "diffHunk": "@@ -470,6 +481,37 @@ public CounterStat getHighMemorySplitSource()\n         return concat(partitionBatches);\n     }\n \n+    @VisibleForTesting\n+    static Optional<Set<HiveColumnHandle>> mergeRequestedAndPredicateColumns(Optional<Set<HiveColumnHandle>> requestedColumns, Set<HiveColumnHandle> predicateColumns)\n+    {\n+        if (!requestedColumns.isPresent() || predicateColumns.isEmpty()) {", "originalCommit": "4f86b23a3e5ec123c9b0a4c4a8932fc5f0c2ecdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NDM2Mg==", "url": "https://github.com/prestodb/presto/pull/15187#discussion_r492854362", "bodyText": "In this case - I am checking for requestedColumns.isPresent() and the situation you are talking about will actually be requestedColumns.get().isEmpty().\nSo this check mainly ensures that due to some reason if we don't end up getting the requestedColumns field populated at all, the encryption provider will now try to get the credentials for all columns.", "author": "mayankgarg1990", "createdAt": "2020-09-22T15:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MTE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "90935e84dae12afe44889d7e7e4b4d3fc83445cb", "changed_code": [{"header": "diff --git a/presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java b/presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java\nindex f90f89c98f..e291a80751 100644\n--- a/presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java\n+++ b/presto-hive/src/main/java/com/facebook/presto/hive/HiveSplitManager.java\n", "chunk": "@@ -473,14 +498,226 @@ public class HiveSplitManager\n                     }\n                 }\n \n-                results.add(new HivePartitionMetadata(hivePartition, Optional.of(partition), partitionSchemaDifference.build(), encryptionInformation));\n+                results.add(\n+                        new HivePartitionMetadata(\n+                                hivePartition,\n+                                Optional.of(partition),\n+                                partitionSchemaDifference.build(),\n+                                encryptionInformation));\n+            }\n+            if (unreadablePartitionsSkipped > 0) {\n+                StringBuilder warningMessage = new StringBuilder(format(\"Table '%s' has %s out of %s partitions unreadable: \", tableName, unreadablePartitionsSkipped, partitionBatch.size()));\n+                for (Entry<String, Set<String>> entry : partitionsNotReadable.entrySet()) {\n+                    warningMessage.append(String.join(\", \", entry.getValue())).append(\"... are due to \").append(entry.getKey()).append(\". \");\n+                }\n+                warningCollector.add(new PrestoWarning(PARTITION_NOT_READABLE, warningMessage.toString()));\n             }\n-\n             return results.build();\n         });\n         return concat(partitionBatches);\n     }\n \n+    private Map<String, PartitionSplitInfo> getPartitionSplitInfo(\n+            ConnectorSession session,\n+            SemiTransactionalHiveMetastore metastore,\n+            SchemaTableName tableName,\n+            List<HivePartition> partitionBatch,\n+            Map<String, HiveColumnHandle> predicateColumns,\n+            Optional<Map<Subfield, Domain>> domains)\n+    {\n+        Map<String, Optional<Partition>> partitions = metastore.getPartitionsByNames(\n+                tableName.getSchemaName(),\n+                tableName.getTableName(),\n+                Lists.transform(partitionBatch, HivePartition::getPartitionId));\n+        Map<String, PartitionStatistics> partitionStatistics = ImmutableMap.of();\n+        if (domains.isPresent() && isPartitionStatisticsBasedOptimizationEnabled(session)) {\n+            partitionStatistics = metastore.getPartitionStatistics(\n+                    tableName.getSchemaName(),\n+                    tableName.getTableName(),\n+                    partitionBatch.stream()\n+                            .map(HivePartition::getPartitionId)\n+                            .collect(toImmutableSet()));\n+        }\n+\n+        ImmutableMap.Builder<String, PartitionSplitInfo> partitionSplitInfoBuilder = ImmutableMap.builder();\n+        for (Map.Entry<String, Optional<Partition>> entry : partitions.entrySet()) {\n+            ImmutableSet.Builder<ColumnHandle> redundantColumnDomainsBuilder = ImmutableSet.builder();\n+            if (!entry.getValue().isPresent()) {\n+                throw new PrestoException(HIVE_PARTITION_DROPPED_DURING_QUERY, \"Partition no longer exists: \" + entry.getKey());\n+            }\n+            boolean pruned = false;\n+            if (partitionStatistics.containsKey(entry.getKey())) {\n+                Map<String, HiveColumnStatistics> columnStatistics = partitionStatistics.get(entry.getKey()).getColumnStatistics();\n+                for (Map.Entry<String, HiveColumnHandle> predicateColumnEntry : predicateColumns.entrySet()) {\n+                    if (columnStatistics.containsKey(predicateColumnEntry.getKey())) {\n+                        Optional<ValueSet> columnsStatisticsValueSet = getColumnStatisticsValueSet(columnStatistics.get(predicateColumnEntry.getKey()), predicateColumnEntry.getValue().getHiveType());\n+                        if (columnsStatisticsValueSet.isPresent()) {\n+                            ValueSet columnPredicateValueSet = domains.get().get(new Subfield(predicateColumnEntry.getKey())).getValues();\n+                            if (!columnPredicateValueSet.overlaps(columnsStatisticsValueSet.get())) {\n+                                pruned = true;\n+                                break;\n+                            }\n+                            if (columnPredicateValueSet.contains(columnsStatisticsValueSet.get())) {\n+                                redundantColumnDomainsBuilder.add(predicateColumnEntry.getValue());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            partitionSplitInfoBuilder.put(entry.getKey(), new PartitionSplitInfo(entry.getValue().get(), pruned, redundantColumnDomainsBuilder.build()));\n+        }\n+        return partitionSplitInfoBuilder.build();\n+    }\n+\n+    private Optional<ValueSet> getColumnStatisticsValueSet(HiveColumnStatistics statistics, HiveType hiveType)\n+    {\n+        if (hiveType.getCategory() != PRIMITIVE) {\n+            return Optional.empty();\n+        }\n+\n+        PrimitiveTypeInfo typeInfo = (PrimitiveTypeInfo) hiveType.getTypeInfo();\n+        switch (typeInfo.getPrimitiveCategory()) {\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+                return getIntegerColumnStatisticsValueSet(statistics, getPrimitiveType(typeInfo));\n+            case FLOAT:\n+                return getFloatColumnStatisticsValueSet(statistics, getPrimitiveType(typeInfo));\n+            case DOUBLE:\n+                return getDoubleColumnStatisticsValueSet(statistics, getPrimitiveType(typeInfo));\n+            case DECIMAL:\n+                return getDecimalColumnStatisticsValueSet(statistics, getPrimitiveType(typeInfo));\n+            case DATE:\n+                return getDateColumnStatisticsValueSet(statistics, getPrimitiveType(typeInfo));\n+            default:\n+                return Optional.empty();\n+        }\n+    }\n+\n+    private Optional<ValueSet> getIntegerColumnStatisticsValueSet(HiveColumnStatistics statistics, Type type)\n+    {\n+        if (!statistics.getIntegerStatistics().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        IntegerStatistics hiveColumnStatistics = statistics.getIntegerStatistics().get();\n+        ValueSet result = ValueSet.all(type);\n+        if (hiveColumnStatistics.getMin().isPresent()) {\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.greaterThanOrEqual(type, hiveColumnStatistics.getMin().getAsLong()))));\n+        }\n+        if (hiveColumnStatistics.getMax().isPresent()) {\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.lessThanOrEqual(type, hiveColumnStatistics.getMax().getAsLong()))));\n+        }\n+        return Optional.of(result);\n+    }\n+\n+    private Optional<ValueSet> getFloatColumnStatisticsValueSet(HiveColumnStatistics statistics, Type type)\n+    {\n+        if (!statistics.getDoubleStatistics().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        DoubleStatistics hiveColumnStatistics = statistics.getDoubleStatistics().get();\n+        ValueSet result = ValueSet.all(type);\n+        if (hiveColumnStatistics.getMin().isPresent()) {\n+            result = result.intersect(\n+                    SortedRangeSet.copyOf(\n+                            type,\n+                            ImmutableList.of(Range.greaterThanOrEqual(type, (long) floatToIntBits((float) hiveColumnStatistics.getMin().getAsDouble())))));\n+        }\n+        if (hiveColumnStatistics.getMax().isPresent()) {\n+            result = result.intersect(\n+                    SortedRangeSet.copyOf(\n+                            type,\n+                            ImmutableList.of(Range.lessThanOrEqual(type, (long) floatToIntBits((float) hiveColumnStatistics.getMax().getAsDouble())))));\n+        }\n+        return Optional.of(result);\n+    }\n+\n+    private Optional<ValueSet> getDoubleColumnStatisticsValueSet(HiveColumnStatistics statistics, Type type)\n+    {\n+        if (!statistics.getDoubleStatistics().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        DoubleStatistics hiveColumnStatistics = statistics.getDoubleStatistics().get();\n+        ValueSet result = ValueSet.all(type);\n+        if (hiveColumnStatistics.getMin().isPresent()) {\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.greaterThanOrEqual(type, hiveColumnStatistics.getMin().getAsDouble()))));\n+        }\n+        if (hiveColumnStatistics.getMax().isPresent()) {\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.lessThanOrEqual(type, hiveColumnStatistics.getMax().getAsDouble()))));\n+        }\n+        return Optional.of(result);\n+    }\n+\n+    private Optional<ValueSet> getDecimalColumnStatisticsValueSet(HiveColumnStatistics statistics, Type type)\n+    {\n+        if (!statistics.getDecimalStatistics().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        DecimalStatistics hiveColumnStatistics = statistics.getDecimalStatistics().get();\n+        ValueSet result = ValueSet.all(type);\n+        if (hiveColumnStatistics.getMin().isPresent()) {\n+            Object min = isShortDecimal(type) ? hiveColumnStatistics.getMin().get().longValue() : encodeScaledValue(hiveColumnStatistics.getMin().get());\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.greaterThanOrEqual(type, min))));\n+        }\n+        if (hiveColumnStatistics.getMax().isPresent()) {\n+            Object max = isShortDecimal(type) ? hiveColumnStatistics.getMax().get().longValue() : encodeScaledValue(hiveColumnStatistics.getMax().get());\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.lessThanOrEqual(type, max))));\n+        }\n+        return Optional.of(result);\n+    }\n+\n+    private Optional<ValueSet> getDateColumnStatisticsValueSet(HiveColumnStatistics statistics, Type type)\n+    {\n+        if (!statistics.getDateStatistics().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        DateStatistics hiveColumnStatistics = statistics.getDateStatistics().get();\n+        ValueSet result = ValueSet.all(type);\n+        if (hiveColumnStatistics.getMin().isPresent()) {\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.greaterThanOrEqual(type, hiveColumnStatistics.getMin().get().toEpochDay()))));\n+        }\n+        if (hiveColumnStatistics.getMax().isPresent()) {\n+            result = result.intersect(SortedRangeSet.copyOf(type, ImmutableList.of(Range.lessThanOrEqual(type, hiveColumnStatistics.getMax().get().toEpochDay()))));\n+        }\n+        return Optional.of(result);\n+    }\n+\n+    private static class PartitionSplitInfo\n+    {\n+        private final Partition partition;\n+        private final boolean pruned;\n+        private final Set<ColumnHandle> redundantColumnDomains;\n+\n+        public PartitionSplitInfo(Partition partition, boolean pruned, Set<ColumnHandle> redundantColumnDomains)\n+        {\n+            this.partition = requireNonNull(partition, \"partition is null\");\n+            this.pruned = pruned;\n+            this.redundantColumnDomains = ImmutableSet.copyOf(requireNonNull(redundantColumnDomains, \"redundantColumnDomains is null\"));\n+        }\n+\n+        public Partition getPartition()\n+        {\n+            return partition;\n+        }\n+\n+        public boolean isPruned()\n+        {\n+            return pruned;\n+        }\n+\n+        public Set<ColumnHandle> getRedundantColumnDomains()\n+        {\n+            return redundantColumnDomains;\n+        }\n+    }\n+\n     @VisibleForTesting\n     static Optional<Set<HiveColumnHandle>> mergeRequestedAndPredicateColumns(Optional<Set<HiveColumnHandle>> requestedColumns, Set<HiveColumnHandle> predicateColumns)\n     {\n", "next_change": null}]}}]}