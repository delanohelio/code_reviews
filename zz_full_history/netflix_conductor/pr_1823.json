{"pr_number": 1823, "pr_title": "1816: getNextTask will get wrong task if DO_WHILE task is embed in FORK or DECISION", "pr_author": "alex-fu", "pr_createdAt": "2020-08-06T16:33:42Z", "pr_url": "https://github.com/Netflix/conductor/pull/1823", "merge_commit": "fc533a6be3306335cf6a1f1ba3b322fd480e174c", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxOTM2MQ==", "url": "https://github.com/Netflix/conductor/pull/1823#discussion_r470719361", "body": "@alex-fu Since we are diverging the DECISION block by so many lines of code. We can define a separate switch case for DO_WHILE task. And move common code to one function.", "bodyText": "@alex-fu Since we are diverging the DECISION block by so many lines of code. We can define a separate switch case for DO_WHILE task. And move common code to one function.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/alex-fu/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alex-fu\">@alex-fu</a> Since we are diverging the DECISION block by so many lines of code. We can define a separate switch case for DO_WHILE task. And move common code to one function.</p>", "author": "manan164", "createdAt": "2020-08-14T16:10:41Z", "path": "common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java", "diffHunk": "@@ -569,6 +569,13 @@ public WorkflowTask next(String taskReferenceName, WorkflowTask parent) {\n \t\t\t\t\t\t\treturn nextTask;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (task.has(taskReferenceName)) {\n+\t\t\t\t\t\t\tif (TaskType.DO_WHILE.name().equals(task.getType())) {", "originalCommit": "d4a33fcc451eed883d04ae9ea38fae6634083665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzMTc2NQ==", "url": "https://github.com/Netflix/conductor/pull/1823#discussion_r495431765", "bodyText": "OK, I'll move this common code to a function. But this function should be called from DECISION block and FORK block, not DO_WHILE block(since we don't allow nested DO_WHILE task).", "author": "alex-fu", "createdAt": "2020-09-26T08:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxOTM2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ce62d75e84d8f1fdb7d603d7c98ef0c952789168", "changed_code": [{"header": "diff --git a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\nindex 351a883fc..353a4f2e7 100644\n--- a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n+++ b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n", "chunk": "@@ -569,13 +586,6 @@ public class WorkflowTask {\n \t\t\t\t\t\t\treturn nextTask;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (task.has(taskReferenceName)) {\n-\t\t\t\t\t\t\tif (TaskType.DO_WHILE.name().equals(task.getType())) {\n-\t\t\t\t\t\t\t\t// come here means task is DO_WHILE task and `taskReferenceName` is the last task in\n-\t\t\t\t\t\t\t\t// this DO_WHILE task, because DO_WHILE task need to be executed to decide whether to\n-\t\t\t\t\t\t\t\t// schedule next iteration, so we just return the DO_WHILE task, and then ignore\n-\t\t\t\t\t\t\t\t// generating this task again in deciderService.getNextTask()\n-\t\t\t\t\t\t\t\treturn task;\n-\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "fc533a6be3306335cf6a1f1ba3b322fd480e174c", "changed_code": [{"header": "diff --git a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\nindex 351a883fc..353a4f2e7 100644\n--- a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n+++ b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n", "chunk": "@@ -569,13 +586,6 @@ public class WorkflowTask {\n \t\t\t\t\t\t\treturn nextTask;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (task.has(taskReferenceName)) {\n-\t\t\t\t\t\t\tif (TaskType.DO_WHILE.name().equals(task.getType())) {\n-\t\t\t\t\t\t\t\t// come here means task is DO_WHILE task and `taskReferenceName` is the last task in\n-\t\t\t\t\t\t\t\t// this DO_WHILE task, because DO_WHILE task need to be executed to decide whether to\n-\t\t\t\t\t\t\t\t// schedule next iteration, so we just return the DO_WHILE task, and then ignore\n-\t\t\t\t\t\t\t\t// generating this task again in deciderService.getNextTask()\n-\t\t\t\t\t\t\t\treturn task;\n-\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n", "next_change": {"commit": "c5c56a38a06e26fee9c269bdd900deeadda50b47", "changed_code": [{"header": "diff --git a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\nindex 353a4f2e7..b84b05dd7 100644\n--- a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n+++ b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n", "chunk": "@@ -28,719 +30,713 @@ import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n-import javax.validation.Valid;\n-import javax.validation.constraints.NotEmpty;\n-import javax.validation.constraints.PositiveOrZero;\n \n /**\n- * @author Viren\n- *\n- * This is the task definition definied as part of the {@link WorkflowDef}. The tasks definied in the Workflow definition are saved\n- * as part of {@link WorkflowDef#getTasks}\n+ * This is the task definition definied as part of the {@link WorkflowDef}. The tasks definied in the Workflow\n+ * definition are saved as part of {@link WorkflowDef#getTasks}\n  */\n @ProtoMessage\n public class WorkflowTask {\n \n-\t/**\n-\t * This field is deprecated and will be removed in the next version.\n-\t * Please use {@link TaskType} instead.\n-\t */\n-\t@Deprecated\n-\tpublic enum Type {\n-\t\tSIMPLE, DYNAMIC, FORK_JOIN, FORK_JOIN_DYNAMIC, DECISION, JOIN, SUB_WORKFLOW, EVENT, WAIT, USER_DEFINED;\n-\t\tprivate static Set<String> systemTasks = new HashSet<>();\n-\t\tstatic {\n-\t\t\tsystemTasks.add(Type.SIMPLE.name());\n-\t\t\tsystemTasks.add(Type.DYNAMIC.name());\n-\t\t\tsystemTasks.add(Type.FORK_JOIN.name());\n-\t\t\tsystemTasks.add(Type.FORK_JOIN_DYNAMIC.name());\n-\t\t\tsystemTasks.add(Type.DECISION.name());\n-\t\t\tsystemTasks.add(Type.JOIN.name());\n-\t\t\tsystemTasks.add(Type.SUB_WORKFLOW.name());\n-\t\t\tsystemTasks.add(Type.EVENT.name());\n-\t\t\tsystemTasks.add(Type.WAIT.name());\n-\t\t\t//Do NOT add USER_DEFINED here...\n-\t\t}\n-\t\tpublic static boolean isSystemTask(String name) {\n-\t\t\treturn systemTasks.contains(name);\n-\t\t}\n-\t}\n-\n-\t@ProtoField(id = 1)\n-\t@NotEmpty(message = \"WorkflowTask name cannot be empty or null\")\n-\tprivate String name;\n-\n-\t@ProtoField(id = 2)\n-\t@NotEmpty(message = \"WorkflowTask taskReferenceName name cannot be empty or null\")\n-\tprivate String taskReferenceName;\n-\n-\t@ProtoField(id = 3)\n-\tprivate String description;\n-\n-\t@ProtoField(id = 4)\n-\tprivate Map<String, Object> inputParameters = new HashMap<>();\n-\n-\t@ProtoField(id = 5)\n-\tprivate String type = TaskType.SIMPLE.name();\n-\n-\t@ProtoField(id = 6)\n-\tprivate String dynamicTaskNameParam;\n-\n-\t@ProtoField(id = 7)\n-\tprivate String caseValueParam;\n-\n-\t@ProtoField(id = 8)\n-\tprivate String caseExpression;\n-\n-\t@ProtoField(id = 22)\n-\tprivate String scriptExpression;\n-\n-\t@ProtoMessage(wrapper = true)\n-\tpublic static class WorkflowTaskList {\n-\t\tpublic List<WorkflowTask> getTasks() {\n-\t\t\treturn tasks;\n-\t\t}\n-\n-\t\tpublic void setTasks(List<WorkflowTask> tasks) {\n-\t\t\tthis.tasks = tasks;\n-\t\t}\n-\n-\t\t@ProtoField(id = 1)\n-\t\tprivate List<WorkflowTask> tasks;\n-\t}\n-\n-\t//Populates for the tasks of the decision type\n-\t@ProtoField(id = 9)\n-\tprivate Map<String,@Valid List<@Valid WorkflowTask>> decisionCases = new LinkedHashMap<>();\n-\n-\t@Deprecated\n-\tprivate String dynamicForkJoinTasksParam;\n-\n-\t@ProtoField(id = 10)\n-\tprivate String dynamicForkTasksParam;\n-\n-\t@ProtoField(id = 11)\n-\tprivate String dynamicForkTasksInputParamName;\n-\n-\t@ProtoField(id = 12)\n-\tprivate List<@Valid WorkflowTask> defaultCase = new LinkedList<>();\n-\n-\t@ProtoField(id = 13)\n-\tprivate List<@Valid List<@Valid WorkflowTask>> forkTasks = new LinkedList<>();\n-\n-\t@ProtoField(id = 14)\n+    /**\n+     * This field is deprecated and will be removed in the next version. Please use {@link TaskType} instead.\n+     */\n+    @Deprecated\n+    public enum Type {\n+        SIMPLE, DYNAMIC, FORK_JOIN, FORK_JOIN_DYNAMIC, DECISION, JOIN, SUB_WORKFLOW, EVENT, WAIT, USER_DEFINED;\n+        private static Set<String> systemTasks = new HashSet<>();\n+\n+        static {\n+            systemTasks.add(Type.SIMPLE.name());\n+            systemTasks.add(Type.DYNAMIC.name());\n+            systemTasks.add(Type.FORK_JOIN.name());\n+            systemTasks.add(Type.FORK_JOIN_DYNAMIC.name());\n+            systemTasks.add(Type.DECISION.name());\n+            systemTasks.add(Type.JOIN.name());\n+            systemTasks.add(Type.SUB_WORKFLOW.name());\n+            systemTasks.add(Type.EVENT.name());\n+            systemTasks.add(Type.WAIT.name());\n+            //Do NOT add USER_DEFINED here...\n+        }\n+\n+        public static boolean isSystemTask(String name) {\n+            return systemTasks.contains(name);\n+        }\n+    }\n+\n+    @ProtoField(id = 1)\n+    @NotEmpty(message = \"WorkflowTask name cannot be empty or null\")\n+    private String name;\n+\n+    @ProtoField(id = 2)\n+    @NotEmpty(message = \"WorkflowTask taskReferenceName name cannot be empty or null\")\n+    private String taskReferenceName;\n+\n+    @ProtoField(id = 3)\n+    private String description;\n+\n+    @ProtoField(id = 4)\n+    private Map<String, Object> inputParameters = new HashMap<>();\n+\n+    @ProtoField(id = 5)\n+    private String type = TaskType.SIMPLE.name();\n+\n+    @ProtoField(id = 6)\n+    private String dynamicTaskNameParam;\n+\n+    @ProtoField(id = 7)\n+    private String caseValueParam;\n+\n+    @ProtoField(id = 8)\n+    private String caseExpression;\n+\n+    @ProtoField(id = 22)\n+    private String scriptExpression;\n+\n+    @ProtoMessage(wrapper = true)\n+    public static class WorkflowTaskList {\n+\n+        public List<WorkflowTask> getTasks() {\n+            return tasks;\n+        }\n+\n+        public void setTasks(List<WorkflowTask> tasks) {\n+            this.tasks = tasks;\n+        }\n+\n+        @ProtoField(id = 1)\n+        private List<WorkflowTask> tasks;\n+    }\n+\n+    //Populates for the tasks of the decision type\n+    @ProtoField(id = 9)\n+    private Map<String, @Valid List<@Valid WorkflowTask>> decisionCases = new LinkedHashMap<>();\n+\n+    @Deprecated\n+    private String dynamicForkJoinTasksParam;\n+\n+    @ProtoField(id = 10)\n+    private String dynamicForkTasksParam;\n+\n+    @ProtoField(id = 11)\n+    private String dynamicForkTasksInputParamName;\n+\n+    @ProtoField(id = 12)\n+    private List<@Valid WorkflowTask> defaultCase = new LinkedList<>();\n+\n+    @ProtoField(id = 13)\n+    private List<@Valid List<@Valid WorkflowTask>> forkTasks = new LinkedList<>();\n+\n+    @ProtoField(id = 14)\n     @PositiveOrZero\n-\tprivate int startDelay;\t//No. of seconds (at-least) to wait before starting a task.\n+    private int startDelay;    //No. of seconds (at-least) to wait before starting a task.\n \n-\t@ProtoField(id = 15)\n+    @ProtoField(id = 15)\n     @Valid\n-\tprivate SubWorkflowParams subWorkflowParam;\n-\n-\t@ProtoField(id = 16)\n-\tprivate List<String> joinOn = new LinkedList<>();\n-\n-\t@ProtoField(id = 17)\n-\tprivate String sink;\n-\n-\t@ProtoField(id = 18)\n-\tprivate boolean optional = false;\n-\n-\t@ProtoField(id = 19)\n-\tprivate TaskDef taskDefinition;\n-\n-\t@ProtoField(id = 20)\n-\tprivate Boolean rateLimited;\n-\t\n-\t@ProtoField(id = 21)\n-\tprivate List<String> defaultExclusiveJoinTask = new LinkedList<>();\n-\n-\t@ProtoField(id = 23)\n-\tprivate Boolean asyncComplete = false;\n-\n-\t@ProtoField(id = 24)\n-\tprivate String loopCondition;\n-\n-\t@ProtoField(id = 25)\n-\tprivate List<WorkflowTask> loopOver = new LinkedList<>();\n-\n-\t@ProtoField(id = 26)\n-\tprivate Integer retryCount;\n-\n-\t/**\n-\t * @return the name\n-\t */\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\t/**\n-\t * @param name the name to set\n-\t */\n-\tpublic void setName(String name) {\n-\t\tthis.name = name;\n-\t}\n-\n-\t/**\n-\t * @return the taskReferenceName\n-\t */\n-\tpublic String getTaskReferenceName() {\n-\t\treturn taskReferenceName;\n-\t}\n-\n-\t/**\n-\t * @param taskReferenceName the taskReferenceName to set\n-\t */\n-\tpublic void setTaskReferenceName(String taskReferenceName) {\n-\t\tthis.taskReferenceName = taskReferenceName;\n-\t}\n-\n-\t/**\n-\t * @return the description\n-\t */\n-\tpublic String getDescription() {\n-\t\treturn description;\n-\t}\n-\n-\t/**\n-\t * @param description the description to set\n-\t */\n-\tpublic void setDescription(String description) {\n-\t\tthis.description = description;\n-\t}\n-\n-\t/**\n-\t * @return the inputParameters\n-\t */\n-\tpublic Map<String, Object> getInputParameters() {\n-\t\treturn inputParameters;\n-\t}\n-\n-\t/**\n-\t * @param inputParameters the inputParameters to set\n-\t */\n-\tpublic void setInputParameters(Map<String, Object> inputParameters) {\n-\t\tthis.inputParameters = inputParameters;\n-\t}\n-\t\n-\t/**\n-\t * @return the type\n-\t */\n-\tpublic String getType() {\n-\t\treturn type;\n-\t}\n-\n-\tpublic void setWorkflowTaskType(TaskType type) {\n-\t\tthis.type = type.name();\n-\t}\n-\t\n-\t/**\n-\t * @param type the type to set\n-\t */\n-\tpublic void setType(@NotEmpty(message = \"WorkTask type cannot be null or empty\") String type) {\n-\t\tthis.type = type;\n-\t}\n-\n-\t/**\n-\t * @return the decisionCases\n-\t */\n-\tpublic Map<String, List<WorkflowTask>> getDecisionCases() {\n-\t\treturn decisionCases;\n-\t}\n-\n-\t/**\n-\t * @param decisionCases the decisionCases to set\n-\t */\n-\tpublic void setDecisionCases(Map<String, List<WorkflowTask>> decisionCases) {\n-\t\tthis.decisionCases = decisionCases;\n-\t}\n-\t\n-\t/**\n-\t * @return the defaultCase\n-\t */\n-\tpublic List<WorkflowTask> getDefaultCase() {\n-\t\treturn defaultCase;\n-\t}\n-\n-\t/**\n-\t * @param defaultCase the defaultCase to set\n-\t */\n-\tpublic void setDefaultCase(List<WorkflowTask> defaultCase) {\n-\t\tthis.defaultCase = defaultCase;\n-\t}\n-\n-\t/**\n-\t * @return the forkTasks\n-\t */\n-\tpublic List<List<WorkflowTask>> getForkTasks() {\n-\t\treturn forkTasks;\n-\t}\n-\n-\t/**\n-\t * @param forkTasks the forkTasks to set\n-\t */\n-\tpublic void setForkTasks(List<List<WorkflowTask>> forkTasks) {\n-\t\tthis.forkTasks = forkTasks;\n-\t}\n-\t\n-\t/**\n-\t * @return the startDelay in seconds\n-\t */\n-\tpublic int getStartDelay() {\n-\t\treturn startDelay;\n-\t}\n-\n-\t/**\n-\t * @param startDelay the startDelay to set\n-\t */\n-\tpublic void setStartDelay(int startDelay) {\n-\t\tthis.startDelay = startDelay;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @return the retryCount\n-\t */\n-\tpublic Integer getRetryCount() {\n-\t\treturn retryCount;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @param retryCount the retryCount to set\n-\t */\n-\tpublic void setRetryCount(final Integer retryCount) {\n-\t\tthis.retryCount = retryCount;\n-\t}\n-\n-\t/**\n-\t * @return the dynamicTaskNameParam\n-\t */\n-\tpublic String getDynamicTaskNameParam() {\n-\t\treturn dynamicTaskNameParam;\n-\t}\n-\n-\t/**\n-\t * @param dynamicTaskNameParam the dynamicTaskNameParam to set to be used by DYNAMIC tasks\n-\t * \n-\t */\n-\tpublic void setDynamicTaskNameParam(String dynamicTaskNameParam) {\n-\t\tthis.dynamicTaskNameParam = dynamicTaskNameParam;\n-\t}\n-\n-\t/**\n-\t * @return the caseValueParam\n-\t */\n-\tpublic String getCaseValueParam() {\n-\t\treturn caseValueParam;\n-\t}\n-\n-\t@Deprecated\n-\tpublic String getDynamicForkJoinTasksParam() {\n-\t\treturn dynamicForkJoinTasksParam;\n-\t}\n-\n-\t@Deprecated\n-\tpublic void setDynamicForkJoinTasksParam(String dynamicForkJoinTasksParam) {\n-\t\tthis.dynamicForkJoinTasksParam = dynamicForkJoinTasksParam;\n-\t}\n-\t\n-\tpublic String getDynamicForkTasksParam() {\n-\t\treturn dynamicForkTasksParam;\n-\t}\n-\t\n-\tpublic void setDynamicForkTasksParam(String dynamicForkTasksParam) {\n-\t\tthis.dynamicForkTasksParam = dynamicForkTasksParam;\n-\t}\n-\n-\tpublic String getDynamicForkTasksInputParamName() {\n-\t\treturn dynamicForkTasksInputParamName;\n-\t}\n-\t\n-\tpublic void setDynamicForkTasksInputParamName(String dynamicForkTasksInputParamName) {\n-\t\tthis.dynamicForkTasksInputParamName = dynamicForkTasksInputParamName;\n-\t}\n-\n-\t/**\n-\t * @param caseValueParam the caseValueParam to set\n-\t */\n-\tpublic void setCaseValueParam(String caseValueParam) {\n-\t\tthis.caseValueParam = caseValueParam;\n-\t}\n-\t\n-\t/**\n-\t * \n-\t * @return A javascript expression for decision cases.  The result should be a scalar value that is used to decide the case branches.\n-\t * @see #getDecisionCases()\n-\t */\n-\tpublic String getCaseExpression() {\n-\t\treturn caseExpression;\n-\t}\n-\t\n-\t/**\n-\t * \n-\t * @param caseExpression A javascript expression for decision cases.  The result should be a scalar value that is used to decide the case branches.\n-\t */\n-\tpublic void setCaseExpression(String caseExpression) {\n-\t\tthis.caseExpression = caseExpression;\n-\t}\n-\n-\n-\tpublic String getScriptExpression() {\n-\t\treturn scriptExpression;\n-\t}\n-\n-\tpublic void setScriptExpression(String expression) {\n-\t\tthis.scriptExpression = expression;\n-\t}\n-\n-\t\n-\t/**\n-\t * @return the subWorkflow\n-\t */\n-\tpublic SubWorkflowParams getSubWorkflowParam() {\n-\t\treturn subWorkflowParam;\n-\t}\n-\n-\t/**\n-\t * @param subWorkflow the subWorkflowParam to set\n-\t */\n-\tpublic void setSubWorkflowParam(SubWorkflowParams subWorkflow) {\n-\t\tthis.subWorkflowParam = subWorkflow;\n-\t}\n-\n-\t/**\n-\t * @return the joinOn\n-\t */\n-\tpublic List<String> getJoinOn() {\n-\t\treturn joinOn;\n-\t}\n-\n-\t/**\n-\t * @param joinOn the joinOn to set\n-\t */\n-\tpublic void setJoinOn(List<String> joinOn) {\n-\t\tthis.joinOn = joinOn;\n-\t}\n-\n-\t/**\n-\t * @return the loopCondition\n-\t */\n-\tpublic String getLoopCondition() {\n-\t\treturn loopCondition;\n-\t}\n-\n-\t/**\n-\t * @param loopCondition the expression to set\n-\t */\n-\tpublic void setLoopCondition(String loopCondition) {\n-\t\tthis.loopCondition = loopCondition;\n-\t}\n-\n-\t/**\n-\t * @return the loopOver\n-\t */\n-\tpublic List<WorkflowTask> getLoopOver() {\n-\t\treturn loopOver;\n-\t}\n-\n-\t/**\n-\t * @param loopOver the loopOver to set\n-\t */\n-\tpublic void setLoopOver(List<WorkflowTask> loopOver) {\n-\t\tthis.loopOver = loopOver;\n-\t}\n-\n-\t/**\n-\t * \n-\t * @return Sink value for the EVENT type of task\n-\t */\n-\tpublic String getSink() {\n-\t\treturn sink;\n-\t}\n-\t\n-\t/**\n-\t * \n-\t * @param sink Name of the sink\n-\t */\n-\tpublic void setSink(String sink) {\n-\t\tthis.sink = sink;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @return whether wait for an external event to complete the task, for EVENT and HTTP tasks\n-\t */\n-\tpublic Boolean isAsyncComplete() {\n-\t\treturn asyncComplete;\n-\t}\n-\n-\tpublic void setAsyncComplete(Boolean asyncComplete) {\n-\t\tthis.asyncComplete = asyncComplete;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @return If the task is optional.  When set to true, the workflow execution continues even when the task is in failed status.\n-\t */\n-\tpublic boolean isOptional() {\n-\t\treturn optional;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @return Task definition associated to the Workflow Task\n-\t */\n-\tpublic TaskDef getTaskDefinition() {\n-\t\treturn taskDefinition;\n-\t}\n-\n-\t/**\n-\t * @param taskDefinition Task definition\n-\t */\n-\tpublic void setTaskDefinition(TaskDef taskDefinition) {\n-\t\tthis.taskDefinition = taskDefinition;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @param optional when set to true, the task is marked as optional\n-\t */\n-\tpublic void setOptional(boolean optional) {\n-\t\tthis.optional = optional;\n-\t}\n-\n-\tpublic Boolean getRateLimited() {\n-\t\treturn rateLimited;\n-\t}\n-\n-\tpublic void setRateLimited(Boolean rateLimited) {\n-\t\tthis.rateLimited = rateLimited;\n-\t}\n-\n-\tpublic Boolean isRateLimited() {\n-\t\treturn rateLimited != null && rateLimited;\n-\t}\n-\n-\tpublic List<String> getDefaultExclusiveJoinTask() {\n-\t\treturn defaultExclusiveJoinTask;\n-\t}\n-\n-\tpublic void setDefaultExclusiveJoinTask(List<String> defaultExclusiveJoinTask) {\n-\t\tthis.defaultExclusiveJoinTask = defaultExclusiveJoinTask;\n-\t}\n-\n-\tprivate Collection<List<WorkflowTask>> children() {\n-\t\tCollection<List<WorkflowTask>> workflowTaskLists = new LinkedList<>();\n-\t\tTaskType taskType = TaskType.USER_DEFINED;\n-\t\tif (TaskType.isSystemTask(type)) {\n-\t\t\ttaskType = TaskType.valueOf(type);\n-\t\t}\n-\n-\t\tswitch (taskType) {\n-\t\t\tcase DECISION:\n-\t\t\t\tworkflowTaskLists.addAll(decisionCases.values());\n-\t\t\t\tworkflowTaskLists.add(defaultCase);\n-\t\t\t\tbreak;\n-\t\t\tcase FORK_JOIN:\n-\t\t\t\tworkflowTaskLists.addAll(forkTasks);\n-\t\t\t\tbreak;\n-\t\t\tcase DO_WHILE:\n-\t\t\t\tworkflowTaskLists.add(loopOver);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn workflowTaskLists;\n-\n-\t}\n-\n-\tpublic List<WorkflowTask> collectTasks() {\n-\t\tList<WorkflowTask> tasks = new LinkedList<>();\n-\t\ttasks.add(this);\n-\t\tfor (List<WorkflowTask> workflowTaskList : children()) {\n-\t\t\tfor (WorkflowTask workflowTask : workflowTaskList) {\n-\t\t\t\ttasks.addAll(workflowTask.collectTasks());\n-\t\t\t}\n-\t\t}\n-\t\treturn tasks;\n-\t}\n-\n-\tpublic WorkflowTask next(String taskReferenceName, WorkflowTask parent) {\n-\t\tTaskType taskType = TaskType.USER_DEFINED;\n-\t\tif (TaskType.isSystemTask(type)) {\n-\t\t\ttaskType = TaskType.valueOf(type);\n-\t\t}\n-\n-\t\tswitch (taskType) {\n-\t\t\tcase DO_WHILE:\n-\t\t\tcase DECISION:\n-\t\t\t\tfor (List<WorkflowTask> workflowTasks : children()) {\n-\t\t\t\t\tIterator<WorkflowTask> iterator = workflowTasks.iterator();\n-\t\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\t\tWorkflowTask task = iterator.next();\n-\t\t\t\t\t\tif (task.getTaskReferenceName().equals(taskReferenceName)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tWorkflowTask nextTask = task.next(taskReferenceName, this);\n-\t\t\t\t\t\tif (nextTask != null) {\n-\t\t\t\t\t\t\treturn nextTask;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (task.has(taskReferenceName)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (iterator.hasNext()) {\n-\t\t\t\t\t\treturn iterator.next();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (taskType == TaskType.DO_WHILE && this.has(taskReferenceName)) {\n-\t\t\t\t\t// come here means this is DO_WHILE task and `taskReferenceName` is the last task in\n-\t\t\t\t\t// this DO_WHILE task, because DO_WHILE task need to be executed to decide whether to\n-\t\t\t\t\t// schedule next iteration, so we just return the DO_WHILE task, and then ignore\n-\t\t\t\t\t// generating this task again in deciderService.getNextTask()\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase FORK_JOIN:\n-\t\t\t\tboolean found = false;\n-\t\t\t\tfor (List<WorkflowTask> workflowTasks : children()) {\n-\t\t\t\t\tIterator<WorkflowTask> iterator = workflowTasks.iterator();\n-\t\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\t\tWorkflowTask task = iterator.next();\n-\t\t\t\t\t\tif (task.getTaskReferenceName().equals(taskReferenceName)) {\n-\t\t\t\t\t\t\tfound = true;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tWorkflowTask nextTask = task.next(taskReferenceName, this);\n-\t\t\t\t\t\tif (nextTask != null) {\n-\t\t\t\t\t\t\treturn nextTask;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (task.has(taskReferenceName)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (iterator.hasNext()) {\n-\t\t\t\t\t\treturn iterator.next();\n-\t\t\t\t\t}\n-\t\t\t\t\tif (found && parent != null) {\n-\t\t\t\t\t\treturn parent.next(this.taskReferenceName, parent);        //we need to return join task... -- get my sibling from my parent..\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase DYNAMIC:\n-\t\t\tcase SIMPLE:\n-\t\t\t\treturn null;\n-\t\t\tdefault:\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic boolean has(String taskReferenceName) {\n-\t\tif (this.getTaskReferenceName().equals(taskReferenceName)) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tTaskType taskType = TaskType.USER_DEFINED;\n-\t\tif (TaskType.isSystemTask(type)) {\n-\t\t\ttaskType = TaskType.valueOf(type);\n-\t\t}\n-\n-\t\tswitch (taskType) {\n-\t\t\tcase DECISION:\n-\t\t\tcase DO_WHILE:\n-\t\t\tcase FORK_JOIN:\n-\t\t\t\tfor (List<WorkflowTask> childx : children()) {\n-\t\t\t\t\tfor (WorkflowTask child : childx) {\n-\t\t\t\t\t\tif (child.has(taskReferenceName)) {\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\t\n-\tpublic WorkflowTask get(String taskReferenceName){\n-\n-\t\tif(this.getTaskReferenceName().equals(taskReferenceName)){\n-\t\t\treturn this;\n-\t\t}\n-\t\tfor(List<WorkflowTask> childx : children()){\n-\t\t\tfor(WorkflowTask child : childx){\n-\t\t\t\tWorkflowTask found = child.get(taskReferenceName);\n-\t\t\t\tif(found != null){\n-\t\t\t\t\treturn found;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t\t\n-\t}\n-\t\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn name + \"/\" + taskReferenceName;\n-\t}\n+    private SubWorkflowParams subWorkflowParam;\n+\n+    @ProtoField(id = 16)\n+    private List<String> joinOn = new LinkedList<>();\n+\n+    @ProtoField(id = 17)\n+    private String sink;\n+\n+    @ProtoField(id = 18)\n+    private boolean optional = false;\n+\n+    @ProtoField(id = 19)\n+    private TaskDef taskDefinition;\n+\n+    @ProtoField(id = 20)\n+    private Boolean rateLimited;\n+\n+    @ProtoField(id = 21)\n+    private List<String> defaultExclusiveJoinTask = new LinkedList<>();\n+\n+    @ProtoField(id = 23)\n+    private Boolean asyncComplete = false;\n+\n+    @ProtoField(id = 24)\n+    private String loopCondition;\n+\n+    @ProtoField(id = 25)\n+    private List<WorkflowTask> loopOver = new LinkedList<>();\n+\n+    @ProtoField(id = 26)\n+    private Integer retryCount;\n+\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * @return the taskReferenceName\n+     */\n+    public String getTaskReferenceName() {\n+        return taskReferenceName;\n+    }\n+\n+    /**\n+     * @param taskReferenceName the taskReferenceName to set\n+     */\n+    public void setTaskReferenceName(String taskReferenceName) {\n+        this.taskReferenceName = taskReferenceName;\n+    }\n+\n+    /**\n+     * @return the description\n+     */\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    /**\n+     * @param description the description to set\n+     */\n+    public void setDescription(String description) {\n+        this.description = description;\n+    }\n+\n+    /**\n+     * @return the inputParameters\n+     */\n+    public Map<String, Object> getInputParameters() {\n+        return inputParameters;\n+    }\n+\n+    /**\n+     * @param inputParameters the inputParameters to set\n+     */\n+    public void setInputParameters(Map<String, Object> inputParameters) {\n+        this.inputParameters = inputParameters;\n+    }\n+\n+    /**\n+     * @return the type\n+     */\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public void setWorkflowTaskType(TaskType type) {\n+        this.type = type.name();\n+    }\n+\n+    /**\n+     * @param type the type to set\n+     */\n+    public void setType(@NotEmpty(message = \"WorkTask type cannot be null or empty\") String type) {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * @return the decisionCases\n+     */\n+    public Map<String, List<WorkflowTask>> getDecisionCases() {\n+        return decisionCases;\n+    }\n+\n+    /**\n+     * @param decisionCases the decisionCases to set\n+     */\n+    public void setDecisionCases(Map<String, List<WorkflowTask>> decisionCases) {\n+        this.decisionCases = decisionCases;\n+    }\n+\n+    /**\n+     * @return the defaultCase\n+     */\n+    public List<WorkflowTask> getDefaultCase() {\n+        return defaultCase;\n+    }\n+\n+    /**\n+     * @param defaultCase the defaultCase to set\n+     */\n+    public void setDefaultCase(List<WorkflowTask> defaultCase) {\n+        this.defaultCase = defaultCase;\n+    }\n+\n+    /**\n+     * @return the forkTasks\n+     */\n+    public List<List<WorkflowTask>> getForkTasks() {\n+        return forkTasks;\n+    }\n+\n+    /**\n+     * @param forkTasks the forkTasks to set\n+     */\n+    public void setForkTasks(List<List<WorkflowTask>> forkTasks) {\n+        this.forkTasks = forkTasks;\n+    }\n+\n+    /**\n+     * @return the startDelay in seconds\n+     */\n+    public int getStartDelay() {\n+        return startDelay;\n+    }\n+\n+    /**\n+     * @param startDelay the startDelay to set\n+     */\n+    public void setStartDelay(int startDelay) {\n+        this.startDelay = startDelay;\n+    }\n+\n+    /**\n+     * @return the retryCount\n+     */\n+    public Integer getRetryCount() {\n+        return retryCount;\n+    }\n+\n+    /**\n+     * @param retryCount the retryCount to set\n+     */\n+    public void setRetryCount(final Integer retryCount) {\n+        this.retryCount = retryCount;\n+    }\n+\n+    /**\n+     * @return the dynamicTaskNameParam\n+     */\n+    public String getDynamicTaskNameParam() {\n+        return dynamicTaskNameParam;\n+    }\n+\n+    /**\n+     * @param dynamicTaskNameParam the dynamicTaskNameParam to set to be used by DYNAMIC tasks\n+     */\n+    public void setDynamicTaskNameParam(String dynamicTaskNameParam) {\n+        this.dynamicTaskNameParam = dynamicTaskNameParam;\n+    }\n+\n+    /**\n+     * @return the caseValueParam\n+     */\n+    public String getCaseValueParam() {\n+        return caseValueParam;\n+    }\n+\n+    @Deprecated\n+    public String getDynamicForkJoinTasksParam() {\n+        return dynamicForkJoinTasksParam;\n+    }\n+\n+    @Deprecated\n+    public void setDynamicForkJoinTasksParam(String dynamicForkJoinTasksParam) {\n+        this.dynamicForkJoinTasksParam = dynamicForkJoinTasksParam;\n+    }\n+\n+    public String getDynamicForkTasksParam() {\n+        return dynamicForkTasksParam;\n+    }\n+\n+    public void setDynamicForkTasksParam(String dynamicForkTasksParam) {\n+        this.dynamicForkTasksParam = dynamicForkTasksParam;\n+    }\n+\n+    public String getDynamicForkTasksInputParamName() {\n+        return dynamicForkTasksInputParamName;\n+    }\n+\n+    public void setDynamicForkTasksInputParamName(String dynamicForkTasksInputParamName) {\n+        this.dynamicForkTasksInputParamName = dynamicForkTasksInputParamName;\n+    }\n+\n+    /**\n+     * @param caseValueParam the caseValueParam to set\n+     */\n+    public void setCaseValueParam(String caseValueParam) {\n+        this.caseValueParam = caseValueParam;\n+    }\n+\n+    /**\n+     * @return A javascript expression for decision cases.  The result should be a scalar value that is used to decide\n+     * the case branches.\n+     * @see #getDecisionCases()\n+     */\n+    public String getCaseExpression() {\n+        return caseExpression;\n+    }\n+\n+    /**\n+     * @param caseExpression A javascript expression for decision cases.  The result should be a scalar value that is\n+     *                       used to decide the case branches.\n+     */\n+    public void setCaseExpression(String caseExpression) {\n+        this.caseExpression = caseExpression;\n+    }\n+\n+\n+    public String getScriptExpression() {\n+        return scriptExpression;\n+    }\n+\n+    public void setScriptExpression(String expression) {\n+        this.scriptExpression = expression;\n+    }\n+\n+\n+    /**\n+     * @return the subWorkflow\n+     */\n+    public SubWorkflowParams getSubWorkflowParam() {\n+        return subWorkflowParam;\n+    }\n+\n+    /**\n+     * @param subWorkflow the subWorkflowParam to set\n+     */\n+    public void setSubWorkflowParam(SubWorkflowParams subWorkflow) {\n+        this.subWorkflowParam = subWorkflow;\n+    }\n+\n+    /**\n+     * @return the joinOn\n+     */\n+    public List<String> getJoinOn() {\n+        return joinOn;\n+    }\n+\n+    /**\n+     * @param joinOn the joinOn to set\n+     */\n+    public void setJoinOn(List<String> joinOn) {\n+        this.joinOn = joinOn;\n+    }\n+\n+    /**\n+     * @return the loopCondition\n+     */\n+    public String getLoopCondition() {\n+        return loopCondition;\n+    }\n+\n+    /**\n+     * @param loopCondition the expression to set\n+     */\n+    public void setLoopCondition(String loopCondition) {\n+        this.loopCondition = loopCondition;\n+    }\n+\n+    /**\n+     * @return the loopOver\n+     */\n+    public List<WorkflowTask> getLoopOver() {\n+        return loopOver;\n+    }\n+\n+    /**\n+     * @param loopOver the loopOver to set\n+     */\n+    public void setLoopOver(List<WorkflowTask> loopOver) {\n+        this.loopOver = loopOver;\n+    }\n+\n+    /**\n+     * @return Sink value for the EVENT type of task\n+     */\n+    public String getSink() {\n+        return sink;\n+    }\n+\n+    /**\n+     * @param sink Name of the sink\n+     */\n+    public void setSink(String sink) {\n+        this.sink = sink;\n+    }\n+\n+    /**\n+     * @return whether wait for an external event to complete the task, for EVENT and HTTP tasks\n+     */\n+    public Boolean isAsyncComplete() {\n+        return asyncComplete;\n+    }\n+\n+    public void setAsyncComplete(Boolean asyncComplete) {\n+        this.asyncComplete = asyncComplete;\n+    }\n+\n+    /**\n+     * @return If the task is optional.  When set to true, the workflow execution continues even when the task is in\n+     * failed status.\n+     */\n+    public boolean isOptional() {\n+        return optional;\n+    }\n+\n+    /**\n+     * @return Task definition associated to the Workflow Task\n+     */\n+    public TaskDef getTaskDefinition() {\n+        return taskDefinition;\n+    }\n+\n+    /**\n+     * @param taskDefinition Task definition\n+     */\n+    public void setTaskDefinition(TaskDef taskDefinition) {\n+        this.taskDefinition = taskDefinition;\n+    }\n+\n+    /**\n+     * @param optional when set to true, the task is marked as optional\n+     */\n+    public void setOptional(boolean optional) {\n+        this.optional = optional;\n+    }\n+\n+    public Boolean getRateLimited() {\n+        return rateLimited;\n+    }\n+\n+    public void setRateLimited(Boolean rateLimited) {\n+        this.rateLimited = rateLimited;\n+    }\n+\n+    public Boolean isRateLimited() {\n+        return rateLimited != null && rateLimited;\n+    }\n+\n+    public List<String> getDefaultExclusiveJoinTask() {\n+        return defaultExclusiveJoinTask;\n+    }\n+\n+    public void setDefaultExclusiveJoinTask(List<String> defaultExclusiveJoinTask) {\n+        this.defaultExclusiveJoinTask = defaultExclusiveJoinTask;\n+    }\n+\n+    private Collection<List<WorkflowTask>> children() {\n+        Collection<List<WorkflowTask>> workflowTaskLists = new LinkedList<>();\n+        TaskType taskType = TaskType.USER_DEFINED;\n+        if (TaskType.isSystemTask(type)) {\n+            taskType = TaskType.valueOf(type);\n+        }\n+\n+        switch (taskType) {\n+            case DECISION:\n+                workflowTaskLists.addAll(decisionCases.values());\n+                workflowTaskLists.add(defaultCase);\n+                break;\n+            case FORK_JOIN:\n+                workflowTaskLists.addAll(forkTasks);\n+                break;\n+            case DO_WHILE:\n+                workflowTaskLists.add(loopOver);\n+                break;\n+            default:\n+                break;\n+        }\n+        return workflowTaskLists;\n+\n+    }\n+\n+    public List<WorkflowTask> collectTasks() {\n+        List<WorkflowTask> tasks = new LinkedList<>();\n+        tasks.add(this);\n+        for (List<WorkflowTask> workflowTaskList : children()) {\n+            for (WorkflowTask workflowTask : workflowTaskList) {\n+                tasks.addAll(workflowTask.collectTasks());\n+            }\n+        }\n+        return tasks;\n+    }\n+\n+    public WorkflowTask next(String taskReferenceName, WorkflowTask parent) {\n+        TaskType taskType = TaskType.USER_DEFINED;\n+        if (TaskType.isSystemTask(type)) {\n+            taskType = TaskType.valueOf(type);\n+        }\n+\n+        switch (taskType) {\n+            case DO_WHILE:\n+            case DECISION:\n+                for (List<WorkflowTask> workflowTasks : children()) {\n+                    Iterator<WorkflowTask> iterator = workflowTasks.iterator();\n+                    while (iterator.hasNext()) {\n+                        WorkflowTask task = iterator.next();\n+                        if (task.getTaskReferenceName().equals(taskReferenceName)) {\n+                            break;\n+                        }\n+                        WorkflowTask nextTask = task.next(taskReferenceName, this);\n+                        if (nextTask != null) {\n+                            return nextTask;\n+                        }\n+                        if (task.has(taskReferenceName)) {\n+                            break;\n+                        }\n+                    }\n+                    if (iterator.hasNext()) {\n+                        return iterator.next();\n+                    }\n+                }\n+                if (taskType == TaskType.DO_WHILE && this.has(taskReferenceName)) {\n+                    // come here means this is DO_WHILE task and `taskReferenceName` is the last task in\n+                    // this DO_WHILE task, because DO_WHILE task need to be executed to decide whether to\n+                    // schedule next iteration, so we just return the DO_WHILE task, and then ignore\n+                    // generating this task again in deciderService.getNextTask()\n+                    return this;\n+                }\n+                break;\n+            case FORK_JOIN:\n+                boolean found = false;\n+                for (List<WorkflowTask> workflowTasks : children()) {\n+                    Iterator<WorkflowTask> iterator = workflowTasks.iterator();\n+                    while (iterator.hasNext()) {\n+                        WorkflowTask task = iterator.next();\n+                        if (task.getTaskReferenceName().equals(taskReferenceName)) {\n+                            found = true;\n+                            break;\n+                        }\n+                        WorkflowTask nextTask = task.next(taskReferenceName, this);\n+                        if (nextTask != null) {\n+                            return nextTask;\n+                        }\n+                        if (task.has(taskReferenceName)) {\n+                            break;\n+                        }\n+                    }\n+                    if (iterator.hasNext()) {\n+                        return iterator.next();\n+                    }\n+                    if (found && parent != null) {\n+                        return parent.next(this.taskReferenceName,\n+                            parent);        //we need to return join task... -- get my sibling from my parent..\n+                    }\n+                }\n+                break;\n+            case DYNAMIC:\n+            case SIMPLE:\n+                return null;\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    public boolean has(String taskReferenceName) {\n+        if (this.getTaskReferenceName().equals(taskReferenceName)) {\n+            return true;\n+        }\n+\n+        TaskType taskType = TaskType.USER_DEFINED;\n+        if (TaskType.isSystemTask(type)) {\n+            taskType = TaskType.valueOf(type);\n+        }\n+\n+        switch (taskType) {\n+            case DECISION:\n+            case DO_WHILE:\n+            case FORK_JOIN:\n+                for (List<WorkflowTask> childx : children()) {\n+                    for (WorkflowTask child : childx) {\n+                        if (child.has(taskReferenceName)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+        return false;\n+    }\n+\n+    public WorkflowTask get(String taskReferenceName) {\n+\n+        if (this.getTaskReferenceName().equals(taskReferenceName)) {\n+            return this;\n+        }\n+        for (List<WorkflowTask> childx : children()) {\n+            for (WorkflowTask child : childx) {\n+                WorkflowTask found = child.get(taskReferenceName);\n+                if (found != null) {\n+                    return found;\n+                }\n+            }\n+        }\n+        return null;\n+\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name + \"/\" + taskReferenceName;\n+    }\n \n     @Override\n     public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n         WorkflowTask that = (WorkflowTask) o;\n         return getStartDelay() == that.getStartDelay() &&\n-                isOptional() == that.isOptional() &&\n-                Objects.equals(getName(), that.getName()) &&\n-                Objects.equals(getTaskReferenceName(), that.getTaskReferenceName()) &&\n-                Objects.equals(getDescription(), that.getDescription()) &&\n-                Objects.equals(getInputParameters(), that.getInputParameters()) &&\n-                Objects.equals(getType(), that.getType()) &&\n-                Objects.equals(getDynamicTaskNameParam(), that.getDynamicTaskNameParam()) &&\n-                Objects.equals(getCaseValueParam(), that.getCaseValueParam()) &&\n-                Objects.equals(getCaseExpression(), that.getCaseExpression()) &&\n-                Objects.equals(getDecisionCases(), that.getDecisionCases()) &&\n-                Objects.equals(getDynamicForkJoinTasksParam(), that.getDynamicForkJoinTasksParam()) &&\n-                Objects.equals(getDynamicForkTasksParam(), that.getDynamicForkTasksParam()) &&\n-                Objects.equals(getDynamicForkTasksInputParamName(), that.getDynamicForkTasksInputParamName()) &&\n-                Objects.equals(getDefaultCase(), that.getDefaultCase()) &&\n-                Objects.equals(getForkTasks(), that.getForkTasks()) &&\n-                Objects.equals(getSubWorkflowParam(), that.getSubWorkflowParam()) &&\n-                Objects.equals(getJoinOn(), that.getJoinOn()) &&\n-                Objects.equals(getSink(), that.getSink()) &&\n-\t\t\t\t\t\t\t\tObjects.equals(isAsyncComplete(), that.isAsyncComplete()) &&\n-                Objects.equals(getDefaultExclusiveJoinTask(), that.getDefaultExclusiveJoinTask()) &&\n-\t\t            Objects.equals(getRetryCount(), that.getRetryCount());\n+            isOptional() == that.isOptional() &&\n+            Objects.equals(getName(), that.getName()) &&\n+            Objects.equals(getTaskReferenceName(), that.getTaskReferenceName()) &&\n+            Objects.equals(getDescription(), that.getDescription()) &&\n+            Objects.equals(getInputParameters(), that.getInputParameters()) &&\n+            Objects.equals(getType(), that.getType()) &&\n+            Objects.equals(getDynamicTaskNameParam(), that.getDynamicTaskNameParam()) &&\n+            Objects.equals(getCaseValueParam(), that.getCaseValueParam()) &&\n+            Objects.equals(getCaseExpression(), that.getCaseExpression()) &&\n+            Objects.equals(getDecisionCases(), that.getDecisionCases()) &&\n+            Objects.equals(getDynamicForkJoinTasksParam(), that.getDynamicForkJoinTasksParam()) &&\n+            Objects.equals(getDynamicForkTasksParam(), that.getDynamicForkTasksParam()) &&\n+            Objects.equals(getDynamicForkTasksInputParamName(), that.getDynamicForkTasksInputParamName()) &&\n+            Objects.equals(getDefaultCase(), that.getDefaultCase()) &&\n+            Objects.equals(getForkTasks(), that.getForkTasks()) &&\n+            Objects.equals(getSubWorkflowParam(), that.getSubWorkflowParam()) &&\n+            Objects.equals(getJoinOn(), that.getJoinOn()) &&\n+            Objects.equals(getSink(), that.getSink()) &&\n+            Objects.equals(isAsyncComplete(), that.isAsyncComplete()) &&\n+            Objects.equals(getDefaultExclusiveJoinTask(), that.getDefaultExclusiveJoinTask()) &&\n+            Objects.equals(getRetryCount(), that.getRetryCount());\n     }\n \n     @Override\n     public int hashCode() {\n \n         return Objects.hash(\n-                getName(),\n-                getTaskReferenceName(),\n-                getDescription(),\n-                getInputParameters(),\n-                getType(),\n-                getDynamicTaskNameParam(),\n-                getCaseValueParam(),\n-                getCaseExpression(),\n-                getDecisionCases(),\n-                getDynamicForkJoinTasksParam(),\n-                getDynamicForkTasksParam(),\n-                getDynamicForkTasksInputParamName(),\n-                getDefaultCase(),\n-                getForkTasks(),\n-                getStartDelay(),\n-                getSubWorkflowParam(),\n-                getJoinOn(),\n-                getSink(),\n-                isAsyncComplete(),\n-                isOptional(),\n-                getDefaultExclusiveJoinTask(),\n-                getRetryCount()\n+            getName(),\n+            getTaskReferenceName(),\n+            getDescription(),\n+            getInputParameters(),\n+            getType(),\n+            getDynamicTaskNameParam(),\n+            getCaseValueParam(),\n+            getCaseExpression(),\n+            getDecisionCases(),\n+            getDynamicForkJoinTasksParam(),\n+            getDynamicForkTasksParam(),\n+            getDynamicForkTasksInputParamName(),\n+            getDefaultCase(),\n+            getForkTasks(),\n+            getStartDelay(),\n+            getSubWorkflowParam(),\n+            getJoinOn(),\n+            getSink(),\n+            isAsyncComplete(),\n+            isOptional(),\n+            getDefaultExclusiveJoinTask(),\n+            getRetryCount()\n         );\n     }\n }\n", "next_change": {"commit": "c89e78081d6ff7e80740be35fb2a11e69a1b7a47", "changed_code": [{"header": "diff --git a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\nindex b84b05dd7..e059853c6 100644\n--- a/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n+++ b/common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowTask.java\n", "chunk": "@@ -687,56 +623,62 @@ public class WorkflowTask {\n             return false;\n         }\n         WorkflowTask that = (WorkflowTask) o;\n-        return getStartDelay() == that.getStartDelay() &&\n-            isOptional() == that.isOptional() &&\n-            Objects.equals(getName(), that.getName()) &&\n-            Objects.equals(getTaskReferenceName(), that.getTaskReferenceName()) &&\n-            Objects.equals(getDescription(), that.getDescription()) &&\n-            Objects.equals(getInputParameters(), that.getInputParameters()) &&\n-            Objects.equals(getType(), that.getType()) &&\n-            Objects.equals(getDynamicTaskNameParam(), that.getDynamicTaskNameParam()) &&\n-            Objects.equals(getCaseValueParam(), that.getCaseValueParam()) &&\n-            Objects.equals(getCaseExpression(), that.getCaseExpression()) &&\n-            Objects.equals(getDecisionCases(), that.getDecisionCases()) &&\n-            Objects.equals(getDynamicForkJoinTasksParam(), that.getDynamicForkJoinTasksParam()) &&\n-            Objects.equals(getDynamicForkTasksParam(), that.getDynamicForkTasksParam()) &&\n-            Objects.equals(getDynamicForkTasksInputParamName(), that.getDynamicForkTasksInputParamName()) &&\n-            Objects.equals(getDefaultCase(), that.getDefaultCase()) &&\n-            Objects.equals(getForkTasks(), that.getForkTasks()) &&\n-            Objects.equals(getSubWorkflowParam(), that.getSubWorkflowParam()) &&\n-            Objects.equals(getJoinOn(), that.getJoinOn()) &&\n-            Objects.equals(getSink(), that.getSink()) &&\n-            Objects.equals(isAsyncComplete(), that.isAsyncComplete()) &&\n-            Objects.equals(getDefaultExclusiveJoinTask(), that.getDefaultExclusiveJoinTask()) &&\n-            Objects.equals(getRetryCount(), that.getRetryCount());\n+        return getStartDelay() == that.getStartDelay()\n+                && isOptional() == that.isOptional()\n+                && Objects.equals(getName(), that.getName())\n+                && Objects.equals(getTaskReferenceName(), that.getTaskReferenceName())\n+                && Objects.equals(getDescription(), that.getDescription())\n+                && Objects.equals(getInputParameters(), that.getInputParameters())\n+                && Objects.equals(getType(), that.getType())\n+                && Objects.equals(getDynamicTaskNameParam(), that.getDynamicTaskNameParam())\n+                && Objects.equals(getCaseValueParam(), that.getCaseValueParam())\n+                && Objects.equals(getEvaluatorType(), that.getEvaluatorType())\n+                && Objects.equals(getExpression(), that.getExpression())\n+                && Objects.equals(getCaseExpression(), that.getCaseExpression())\n+                && Objects.equals(getDecisionCases(), that.getDecisionCases())\n+                && Objects.equals(\n+                        getDynamicForkJoinTasksParam(), that.getDynamicForkJoinTasksParam())\n+                && Objects.equals(getDynamicForkTasksParam(), that.getDynamicForkTasksParam())\n+                && Objects.equals(\n+                        getDynamicForkTasksInputParamName(),\n+                        that.getDynamicForkTasksInputParamName())\n+                && Objects.equals(getDefaultCase(), that.getDefaultCase())\n+                && Objects.equals(getForkTasks(), that.getForkTasks())\n+                && Objects.equals(getSubWorkflowParam(), that.getSubWorkflowParam())\n+                && Objects.equals(getJoinOn(), that.getJoinOn())\n+                && Objects.equals(getSink(), that.getSink())\n+                && Objects.equals(isAsyncComplete(), that.isAsyncComplete())\n+                && Objects.equals(getDefaultExclusiveJoinTask(), that.getDefaultExclusiveJoinTask())\n+                && Objects.equals(getRetryCount(), that.getRetryCount());\n     }\n \n     @Override\n     public int hashCode() {\n \n         return Objects.hash(\n-            getName(),\n-            getTaskReferenceName(),\n-            getDescription(),\n-            getInputParameters(),\n-            getType(),\n-            getDynamicTaskNameParam(),\n-            getCaseValueParam(),\n-            getCaseExpression(),\n-            getDecisionCases(),\n-            getDynamicForkJoinTasksParam(),\n-            getDynamicForkTasksParam(),\n-            getDynamicForkTasksInputParamName(),\n-            getDefaultCase(),\n-            getForkTasks(),\n-            getStartDelay(),\n-            getSubWorkflowParam(),\n-            getJoinOn(),\n-            getSink(),\n-            isAsyncComplete(),\n-            isOptional(),\n-            getDefaultExclusiveJoinTask(),\n-            getRetryCount()\n-        );\n+                getName(),\n+                getTaskReferenceName(),\n+                getDescription(),\n+                getInputParameters(),\n+                getType(),\n+                getDynamicTaskNameParam(),\n+                getCaseValueParam(),\n+                getCaseExpression(),\n+                getEvaluatorType(),\n+                getExpression(),\n+                getDecisionCases(),\n+                getDynamicForkJoinTasksParam(),\n+                getDynamicForkTasksParam(),\n+                getDynamicForkTasksInputParamName(),\n+                getDefaultCase(),\n+                getForkTasks(),\n+                getStartDelay(),\n+                getSubWorkflowParam(),\n+                getJoinOn(),\n+                getSink(),\n+                isAsyncComplete(),\n+                isOptional(),\n+                getDefaultExclusiveJoinTask(),\n+                getRetryCount());\n     }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "fc533a6be3306335cf6a1f1ba3b322fd480e174c", "message": "Merge commit", "committedDate": null}, {"oid": "c5c56a38a06e26fee9c269bdd900deeadda50b47", "committedDate": "2020-11-25 16:50:14 -0800", "message": "Switched to Spring Boot. See CHANGELOG.md for a rough log of changes in the branch."}, {"oid": "6784379ade310433a5745ca752bdc3855de260fc", "committedDate": "2021-01-29 13:52:38 -0800", "message": "fix for terminate tasks within a decision branch"}, {"oid": "50844095ecf96e910e5ea11f6bd3fb46d598e4be", "committedDate": "2021-03-24 20:50:25 -0700", "message": "Changes in sub workflow trigger decide on the parent asynchronously (#2125)"}, {"oid": "f6de30d630d259fa01572e621ca37b22b28d03a5", "committedDate": "2021-04-06 15:56:16 -0700", "message": "remove deprecated fields and methods (#2158)"}, {"oid": "fa13e4f64ca20eb0785123eec096c4fc43868f3b", "committedDate": "2021-05-03 15:36:13 -0700", "message": "removed TaskType#isSystemTask in favor SystemTaskRegistry#isSystemTask"}, {"oid": "32d4bb2f80579c7411cac32c168f4003efc983f0", "committedDate": "2021-08-26 00:04:15 -0700", "message": "Extensible evaluator framework. (#2403)"}, {"oid": "080edb6ad31bb9c9745daf101d3c4ec8ff48b1f4", "committedDate": "2021-11-15 16:33:01 -0800", "message": "Fixes #2446 - Move the protogen annotations to local code and make it\u2026 (#2575)"}, {"oid": "c89e78081d6ff7e80740be35fb2a11e69a1b7a47", "committedDate": "2022-01-11 10:09:21 -0800", "message": "Add formatting plugin"}, {"oid": "51a906fe16399661f853617f0f89d422b9ca1d2b", "committedDate": "2022-04-28 10:55:02 -0700", "message": "spotless format"}, {"oid": "ab14727093bf0cec8da4f2995146bda08a78d730", "committedDate": "2022-08-05 13:09:00 -0700", "message": "Jxu/cassandra serde (#3144)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyMDc0OA==", "url": "https://github.com/Netflix/conductor/pull/1823#discussion_r470720748", "body": "Why we are returning an empty list. We are making get next task to return the parent DO_WHILE task let it propagates it further to decider service.", "bodyText": "Why we are returning an empty list. We are making get next task to return the parent DO_WHILE task let it propagates it further to decider service.", "bodyHTML": "<p dir=\"auto\">Why we are returning an empty list. We are making get next task to return the parent DO_WHILE task let it propagates it further to decider service.</p>", "author": "manan164", "createdAt": "2020-08-14T16:13:29Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java", "diffHunk": "@@ -362,6 +363,13 @@ private boolean checkForWorkflowCompletion(final Workflow workflow) throws Termi\n         while (isTaskSkipped(taskToSchedule, workflow)) {\n             taskToSchedule = workflowDef.getNextTask(taskToSchedule.getTaskReferenceName());\n         }\n+        if (taskToSchedule != null && TaskType.DO_WHILE.name().equals(taskToSchedule.getType())) {\n+            // check if already has this DO_WHILE task, ignore it if it already exists\n+            String nextTaskReferenceName = taskToSchedule.getTaskReferenceName();\n+            if (workflow.getTasks().stream().anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n+                return Collections.emptyList();", "originalCommit": "d4a33fcc451eed883d04ae9ea38fae6634083665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQzMjMyMw==", "url": "https://github.com/Netflix/conductor/pull/1823#discussion_r495432323", "bodyText": "Because in this case the parent DO_WHILE task is already exist, so we don't need to generate again. By the way, even though we return the parent DO_WHILE task, deciderService will also exclude it in below line. tasksToBeScheduled already contains this task, and putIfAbsent will not add this task again.\nnextTasks.forEach(nextTask -> tasksToBeScheduled.putIfAbsent(nextTask.getReferenceTaskName(), nextTask));", "author": "alex-fu", "createdAt": "2020-09-26T08:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyMDc0OA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "c5c56a38a06e26fee9c269bdd900deeadda50b47", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\nindex d34c4df79..a2f274ac8 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n", "chunk": "@@ -366,7 +375,8 @@ public class DeciderService {\n         if (taskToSchedule != null && TaskType.DO_WHILE.name().equals(taskToSchedule.getType())) {\n             // check if already has this DO_WHILE task, ignore it if it already exists\n             String nextTaskReferenceName = taskToSchedule.getTaskReferenceName();\n-            if (workflow.getTasks().stream().anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n+            if (workflow.getTasks().stream()\n+                .anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n                 return Collections.emptyList();\n             }\n         }\n", "next_change": {"commit": "5789707afaf68304cae8e51e4f7672db2cbc968f", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\nindex a2f274ac8..2f4dc50b1 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n", "chunk": "@@ -376,7 +393,7 @@ public class DeciderService {\n             // check if already has this DO_WHILE task, ignore it if it already exists\n             String nextTaskReferenceName = taskToSchedule.getTaskReferenceName();\n             if (workflow.getTasks().stream()\n-                .anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n+                    .anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n                 return Collections.emptyList();\n             }\n         }\n", "next_change": {"commit": "65bb754ba379444ece8f7806fdc40750af1fd59f", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\nindex 2f4dc50b1..8beddea4b 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n", "chunk": "@@ -393,7 +399,7 @@ public class DeciderService {\n             // check if already has this DO_WHILE task, ignore it if it already exists\n             String nextTaskReferenceName = taskToSchedule.getTaskReferenceName();\n             if (workflow.getTasks().stream()\n-                    .anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n+                .anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n                 return Collections.emptyList();\n             }\n         }\n", "next_change": {"commit": "c89e78081d6ff7e80740be35fb2a11e69a1b7a47", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\nindex 8beddea4b..44390d832 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java\n", "chunk": "@@ -399,7 +478,11 @@ public class DeciderService {\n             // check if already has this DO_WHILE task, ignore it if it already exists\n             String nextTaskReferenceName = taskToSchedule.getTaskReferenceName();\n             if (workflow.getTasks().stream()\n-                .anyMatch(runningTask -> runningTask.getReferenceTaskName().equals(nextTaskReferenceName))) {\n+                    .anyMatch(\n+                            runningTask ->\n+                                    runningTask\n+                                            .getReferenceTaskName()\n+                                            .equals(nextTaskReferenceName))) {\n                 return Collections.emptyList();\n             }\n         }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "fc533a6be3306335cf6a1f1ba3b322fd480e174c", "message": "Merge commit", "committedDate": null}, {"oid": "c5c56a38a06e26fee9c269bdd900deeadda50b47", "committedDate": "2020-11-25 16:50:14 -0800", "message": "Switched to Spring Boot. See CHANGELOG.md for a rough log of changes in the branch."}, {"oid": "054bcd4cc41e44e7073500d093133fb2f5c6a9fd", "committedDate": "2020-12-04 16:28:50 -0800", "message": "sync to master 954c9a8dfd6a478747c8d95d108ebf1162451bb3"}, {"oid": "bc66dfcfc1b8a8b66dd011aa1877a92c1ca74f9c", "committedDate": "2020-12-29 09:55:31 -0800", "message": "cleanup all properties to follow a namespaced pattern"}, {"oid": "39ce9096762245ce1ba03b67ca6421eb68567d39", "committedDate": "2021-01-04 23:22:17 -0800", "message": "use springboot property conversion"}, {"oid": "6784379ade310433a5745ca752bdc3855de260fc", "committedDate": "2021-01-29 13:52:38 -0800", "message": "fix for terminate tasks within a decision branch"}, {"oid": "b151b9c77ebab08752d9c31433170997bd4bd585", "committedDate": "2021-02-25 10:35:15 -0800", "message": "refactored task processors map"}, {"oid": "5789707afaf68304cae8e51e4f7672db2cbc968f", "committedDate": "2021-03-03 09:56:18 -0800", "message": "fix conditional sync system task with large payload"}, {"oid": "f6de30d630d259fa01572e621ca37b22b28d03a5", "committedDate": "2021-04-06 15:56:16 -0700", "message": "remove deprecated fields and methods (#2158)"}, {"oid": "fe7b7d0f6345ef24861c00362d4314e02de72a6c", "committedDate": "2021-04-12 13:14:56 -0700", "message": "removed SystemTaskType.java"}, {"oid": "609c4227ecf5dd313ec96b43a4f21dcf17eb56bc", "committedDate": "2021-04-12 13:14:56 -0700", "message": "introduced SystemTaskRegistry in place of the registry in WorkflowSystemTask."}, {"oid": "65bb754ba379444ece8f7806fdc40750af1fd59f", "committedDate": "2021-04-15 18:11:02 -0700", "message": "ensure async complete system tasks are not response timed out"}, {"oid": "163f7c494f6abd0ec629bce0eb60e75722bbe7c3", "committedDate": "2021-04-27 10:23:40 -0700", "message": "rename WorkflowPoller -> WorkflowReconciler; update property"}, {"oid": "fa13e4f64ca20eb0785123eec096c4fc43868f3b", "committedDate": "2021-05-03 15:36:13 -0700", "message": "removed TaskType#isSystemTask in favor SystemTaskRegistry#isSystemTask"}, {"oid": "895e398352373a7f648826505abefb7a7fd3f1af", "committedDate": "2021-05-06 13:52:20 -0700", "message": "added check for task limit"}, {"oid": "68e4399020f03e60e62c6ae9e7f03aab9f8225e2", "committedDate": "2021-05-13 13:52:51 -0700", "message": "remove workflow operation from task update"}, {"oid": "1ae474584b1a4572e9ecbd5e47473a42088f8f99", "committedDate": "2021-05-25 13:17:26 -0700", "message": "removed task limit"}, {"oid": "32d4bb2f80579c7411cac32c168f4003efc983f0", "committedDate": "2021-08-26 00:04:15 -0700", "message": "Extensible evaluator framework. (#2403)"}, {"oid": "c89e78081d6ff7e80740be35fb2a11e69a1b7a47", "committedDate": "2022-01-11 10:09:21 -0800", "message": "Add formatting plugin"}, {"oid": "c0513c0dfef46b38ed1bd2c6f2a17f5b1c5a16a6", "committedDate": "2022-01-27 14:05:25 -0800", "message": "Support for Retry with LINEAR_BACKOFF (#2699)"}, {"oid": "cd528e126ed36abedf38ac0eab07e18e1d476dad", "committedDate": "2022-01-31 15:46:34 -0800", "message": "Object model separation (#2702)"}, {"oid": "82a6e3ae37774e493d85787aa68b8b4ca7124299", "committedDate": "2022-02-02 15:30:46 -0800", "message": "use domain models in default queues"}, {"oid": "75fa3eb8d0c613d05e66fccb03c610ea76d1f3f3", "committedDate": "2022-03-14 15:05:07 -0700", "message": "added methods for adding input and output"}, {"oid": "4ed4e1c543342a19c836dfd07bde3a38abee957e", "committedDate": "2022-03-23 21:34:29 -0700", "message": "TaskMapperContext refactoring."}, {"oid": "3a038159bd0940b3f110c68e351db045328e5712", "committedDate": "2022-04-25 14:11:42 -0700", "message": "Allow Overrding of IDGenerator  (#2910)"}, {"oid": "e739c34a810c33ec5acb3fefa8386527c10ab6b6", "committedDate": "2022-04-26 15:03:20 -0700", "message": "remove guava from common module;handle exceptions in sweeper"}, {"oid": "9190e1180e8760c966fecced8ec5e0780f25ec05", "committedDate": "2022-05-16 10:01:24 -0700", "message": "Fix for #1677, inspired from #2881. Loop-over tasks are created in the DoWhile.execute method. The DO_WHILE TaskModel is persisted before the loop-over tasks are created. Therefore, the loop-over tasks will have access the iteration field in DO_WHILE TaskModel."}, {"oid": "144a4de8e32ea09c1d30d783a92e26639b9ff3cd", "committedDate": "2022-05-24 15:44:36 -0700", "message": "Log workflow failures (#3004)"}, {"oid": "ddc1bedbba57abe5f1e806f07eebaac0da6daafe", "committedDate": "2022-07-05 14:53:22 -0700", "message": "Added metrics for ExecutionLockService, DeciderService and WorkflowExecutor#decide"}, {"oid": "2d514690eb7a52ec6140677a1bf083f6f940443d", "committedDate": "2022-08-14 14:33:46 -0700", "message": "Performance improvements in Decider (#3070)"}, {"oid": "060a21769cc7e0671772e2ade62c7dc2b99028a4", "committedDate": "2022-10-10 14:05:57 -0700", "message": "Change TaskType to be string in order to define custom task and taskMappers (#3154)"}]}, {"oid": "73bdde4bec2f3120b22d8b321a1531acced7ac1f", "url": "https://github.com/Netflix/conductor/commit/73bdde4bec2f3120b22d8b321a1531acced7ac1f", "message": "1816: getNextTask will get wrong task if DO_WHILE task is embed in FORK or DECISION", "committedDate": "2020-09-26T08:40:04Z", "type": "forcePushed"}, {"oid": "e80fea4c8b9d22f4b8c9eb32cbe52e798f3dff6c", "url": "https://github.com/Netflix/conductor/commit/e80fea4c8b9d22f4b8c9eb32cbe52e798f3dff6c", "message": "1816: getNextTask will get wrong task if DO_WHILE task is embed in FORK or DECISION", "committedDate": "2020-10-07T16:22:03Z", "type": "commit"}, {"oid": "e80fea4c8b9d22f4b8c9eb32cbe52e798f3dff6c", "url": "https://github.com/Netflix/conductor/commit/e80fea4c8b9d22f4b8c9eb32cbe52e798f3dff6c", "message": "1816: getNextTask will get wrong task if DO_WHILE task is embed in FORK or DECISION", "committedDate": "2020-10-07T16:22:03Z", "type": "forcePushed"}, {"oid": "ce62d75e84d8f1fdb7d603d7c98ef0c952789168", "url": "https://github.com/Netflix/conductor/commit/ce62d75e84d8f1fdb7d603d7c98ef0c952789168", "message": "1816: refactor WorkflowTask.next(); add integration test", "committedDate": "2020-10-08T12:38:14Z", "type": "commit"}, {"oid": "3140193571c51d94de4adacfc4d3ab47ba1fa2a0", "url": "https://github.com/Netflix/conductor/commit/3140193571c51d94de4adacfc4d3ab47ba1fa2a0", "message": "1816: refine getNextTask in WorkflowDef", "committedDate": "2020-10-08T13:49:10Z", "type": "commit"}]}