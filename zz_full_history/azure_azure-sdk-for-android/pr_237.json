{"pr_number": 237, "pr_title": "Support for providing Content URI of the content to be transferred", "pr_author": "anuchandy", "pr_createdAt": "2020-05-19T19:52:32Z", "pr_url": "https://github.com/Azure/azure-sdk-for-android/pull/237", "timeline": [{"oid": "724ce0e8746658af2623039b01de0de1bfd57a3b", "url": "https://github.com/Azure/azure-sdk-for-android/commit/724ce0e8746658af2623039b01de0de1bfd57a3b", "message": "Basic infa to support Content URI", "committedDate": "2020-05-19T19:44:24Z", "type": "commit"}, {"oid": "90d0eefe17236b84212ffba05af7e99cdb138d0d", "url": "https://github.com/Azure/azure-sdk-for-android/commit/90d0eefe17236b84212ffba05af7e99cdb138d0d", "message": "using ContentResolver::query to get the content size.", "committedDate": "2020-05-19T23:05:33Z", "type": "commit"}, {"oid": "285e48ed6a52ed619e74d1b7165d70c96e458610", "url": "https://github.com/Azure/azure-sdk-for-android/commit/285e48ed6a52ed619e74d1b7165d70c96e458610", "message": "Updating sample to use upload API that takes ContentUri.", "committedDate": "2020-05-19T23:06:15Z", "type": "commit"}, {"oid": "c1ae319db3509aa98b20f2dfba2799dfebb58ac4", "url": "https://github.com/Azure/azure-sdk-for-android/commit/c1ae319db3509aa98b20f2dfba2799dfebb58ac4", "message": "Renaming ContentDescription to RedableContent to better indicate the purpose of type, Removing content specific columns from BlockUpload entity instead using the same from BlobUpload entity.", "committedDate": "2020-05-30T18:00:29Z", "type": "commit"}, {"oid": "09a828eb49a0bedc1b1438c1c8153da56464b364", "url": "https://github.com/Azure/azure-sdk-for-android/commit/09a828eb49a0bedc1b1438c1c8153da56464b364", "message": "Fix: Download BlockOffset calculation, Removing unncessary message dispatch in DownloadHandler.", "committedDate": "2020-05-30T18:07:13Z", "type": "commit"}, {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "url": "https://github.com/Azure/azure-sdk-for-android/commit/dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "message": "Adding WritableContent representing the content in device to store the downloaded blob, Updating types to use WritableContent.", "committedDate": "2020-05-30T18:13:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMzc1Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433423756", "body": "```suggestion\r\n     * The URI to the content where the downloaded blob will be stored.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The URI to the content to store the downloaded blob.\n          \n          \n            \n                 * The URI to the content where the downloaded blob will be stored.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">The</span> <span class=\"pl-c1\">URI</span> to the content <span class=\"x x-first x-last\">to store </span>the downloaded blob.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">The</span> <span class=\"pl-c1\">URI</span> to the content <span class=\"x x-first x-last\">where </span>the downloaded blob<span class=\"x x-first x-last\"> will be stored</span>.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T18:51:26Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java", "diffHunk": "@@ -51,10 +50,16 @@\n     public long blobSize;\n \n     /**\n-     * The absolute path to the file to be uploaded as blob.\n+     * The URI to the content to store the downloaded blob.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\nindex 14caf34ce..cbe1ef111 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n", "chunk": "@@ -50,7 +50,7 @@ final class BlobDownloadEntity {\n     public long blobSize;\n \n     /**\n-     * The URI to the content to store the downloaded blob.\n+     * The URI to the content where the downloaded blob will be stored.\n      */\n     @ColumnInfo(name = \"content_uri\")\n     public String contentUri;\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\ndeleted file mode 100644\nindex cbe1ef111..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n+++ /dev/null\n", "chunk": "@@ -1,167 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import androidx.room.ColumnInfo;\n-import androidx.room.Entity;\n-import androidx.room.Ignore;\n-import androidx.room.PrimaryKey;\n-import androidx.room.TypeConverters;\n-\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- *\n- * Represents metadata for a single blob download.\n- *\n- * The Data Access Object type {@link DownloadDao} exposes the DB store and read methods on this model.\n- *\n- * @see TransferDatabase\n- */\n-@Entity(tableName = \"blobdownloads\")\n-final class BlobDownloadEntity {\n-    /**\n-     * A unique key for the blob download metadata.\n-     *\n-     * Also referred as downloadId that users use to identify and manage the download operation.\n-     */\n-    @PrimaryKey(autoGenerate = true)\n-    @ColumnInfo(name = \"key\")\n-    public Long key;\n-\n-    /**\n-     * The name of the Azure Storage Container to download the blob from.\n-     */\n-    @ColumnInfo(name = \"container_name\")\n-    public String containerName;\n-\n-    /**\n-     * The name of the Azure Storage blob to download.\n-     */\n-    @ColumnInfo(name = \"blob_name\")\n-    public String blobName;\n-\n-    /**\n-     * The blob size in bytes.\n-     */\n-    @ColumnInfo(name = \"blob_size\")\n-    public long blobSize;\n-\n-    /**\n-     * The URI to the content where the downloaded blob will be stored.\n-     */\n-    @ColumnInfo(name = \"content_uri\")\n-    public String contentUri;\n-\n-    /**\n-     * Indicate whether android.content.ContentResolver should be used to resolve the contentUri.\n-     */\n-    @ColumnInfo(name = \"use_content_resolver\")\n-    public boolean useContentResolver;\n-\n-    /**\n-     * Identifies the {@link com.azure.android.storage.blob.StorageBlobClient}\n-     * to be used for the file download.\n-     * @see StorageBlobClientMap\n-     */\n-    @ColumnInfo(name = \"storage_blob_client_id\")\n-    public String storageBlobClientId;\n-\n-    /**\n-     * The current state of the blob download operation.\n-     */\n-    @ColumnInfo(name = \"blob_download_state\")\n-    @TypeConverters(ColumnConverter.class)\n-    public volatile BlobTransferState state;\n-\n-    /**\n-     * Indicate the reason for interrupting (stopping) blob download.\n-     */\n-    @ColumnInfo(name = \"transfer_interrupt_state\")\n-    @TypeConverters(ColumnConverter.class)\n-    public TransferInterruptState interruptState;\n-\n-    /**\n-     * Holds the exception indicating the reason for download failure.\n-     *\n-     * This is not persisted.\n-     */\n-    @Ignore\n-    private Throwable downloadError;\n-\n-    /**\n-     * Creates BlobDownloadEntity, this constructor is used by Room library\n-     * when re-hydrating metadata from local store.\n-     */\n-    public BlobDownloadEntity() {}\n-\n-    /**\n-     * Create a new BlobDownloadEntity to persist in local store.\n-     *\n-     * @param storageBlobClientId identifies the blob storage client to be used\n-     * @param containerName The container name.\n-     * @param blobName The blob name.\n-     * @param blobSize The blob size.\n-     * @param content Describes the content where the downloaded blob will be stored.\n-     */\n-    @Ignore\n-    BlobDownloadEntity(String storageBlobClientId,\n-                       String containerName,\n-                       String blobName,\n-                       long blobSize,\n-                       WritableContent content) {\n-        Objects.requireNonNull(storageBlobClientId);\n-        Objects.requireNonNull(containerName);\n-        Objects.requireNonNull(blobName);\n-        Objects.requireNonNull(content);\n-\n-        this.storageBlobClientId = storageBlobClientId;\n-        this.containerName = containerName;\n-        this.blobName = blobName;\n-        this.blobSize = blobSize;\n-        this.contentUri = content.getUri().toString();\n-        this.useContentResolver = content.isUsingContentResolver();\n-        state = BlobTransferState.WAIT_TO_BEGIN;\n-        interruptState = TransferInterruptState.NONE;\n-    }\n-\n-    /**\n-     * Set the download failure error.\n-     *\n-     * @param t The error\n-     */\n-    void setDownloadError(Throwable t) {\n-        downloadError = t;\n-    }\n-\n-    /**\n-     * Get the download failure error.\n-     *\n-     * @return The download failure error or null if there is no error.\n-     */\n-    Throwable getDownloadError() {\n-        return downloadError;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-\n-        builder.append(\" key:\").append(key)\n-            .append(\" containerName:\").append(containerName)\n-            .append(\" blobName:\").append(blobName)\n-            .append(\" blobSize:\" + this.blobSize)\n-            .append(\" contentUri:\" + this.contentUri)\n-            .append(\" useContentResolver:\" + this.useContentResolver)\n-            .append(\" state:\").append(state)\n-            .append(\" interruptState:\").append(interruptState);\n-\n-        if (downloadError != null) {\n-            builder.append(\" downloadError:\").append(downloadError.getMessage());\n-        }\n-\n-        return builder.toString();\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyNDM5MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433424390", "body": "```suggestion\r\n     * @param content Describes the content where the downloaded blob will be stored.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param content describes the content to store the downloaded blob.\n          \n          \n            \n                 * @param content Describes the content where the downloaded blob will be stored.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> content <span class=\"x x-first x-last\">describes</span> the content <span class=\"x x-first x-last\">to store </span>the downloaded blob.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> content <span class=\"pl-smi x x-first x-last\">Describes</span> the content <span class=\"x x-first x-last\">where </span>the downloaded blob<span class=\"x x-first x-last\"> will be stored</span>.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T18:52:43Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java", "diffHunk": "@@ -98,22 +103,26 @@ public BlobDownloadEntity() {}\n      * @param storageBlobClientId identifies the blob storage client to be used\n      * @param containerName The container name.\n      * @param blobName The blob name.\n-     * @param file The local file.\n+     * @param blobSize The blob size.\n+     * @param content describes the content to store the downloaded blob.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\nindex 14caf34ce..cbe1ef111 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n", "chunk": "@@ -104,7 +104,7 @@ final class BlobDownloadEntity {\n      * @param containerName The container name.\n      * @param blobName The blob name.\n      * @param blobSize The blob size.\n-     * @param content describes the content to store the downloaded blob.\n+     * @param content Describes the content where the downloaded blob will be stored.\n      */\n     @Ignore\n     BlobDownloadEntity(String storageBlobClientId,\n", "next_change": {"commit": "ee6b440720171bea25d4a1255aa9c64278583566", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\nindex cbe1ef111..314011c9a 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n", "chunk": "@@ -105,17 +113,20 @@ final class BlobDownloadEntity {\n      * @param blobName The blob name.\n      * @param blobSize The blob size.\n      * @param content Describes the content where the downloaded blob will be stored.\n+     * @param constraints The constraints to be satisfied to run the download operation.\n      */\n     @Ignore\n     BlobDownloadEntity(String storageBlobClientId,\n                        String containerName,\n                        String blobName,\n                        long blobSize,\n-                       WritableContent content) {\n+                       WritableContent content,\n+                       Constraints constraints) {\n         Objects.requireNonNull(storageBlobClientId);\n         Objects.requireNonNull(containerName);\n         Objects.requireNonNull(blobName);\n         Objects.requireNonNull(content);\n+        Objects.requireNonNull(constraints);\n \n         this.storageBlobClientId = storageBlobClientId;\n         this.containerName = containerName;\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\ndeleted file mode 100644\nindex 314011c9a..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java\n+++ /dev/null\n", "chunk": "@@ -1,179 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import androidx.annotation.NonNull;\n-import androidx.room.ColumnInfo;\n-import androidx.room.Embedded;\n-import androidx.room.Entity;\n-import androidx.room.Ignore;\n-import androidx.room.PrimaryKey;\n-import androidx.room.TypeConverters;\n-import androidx.work.Constraints;\n-\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- *\n- * Represents metadata for a single blob download.\n- *\n- * The Data Access Object type {@link DownloadDao} exposes the DB store and read methods on this model.\n- *\n- * @see TransferDatabase\n- */\n-@Entity(tableName = \"blobdownloads\")\n-final class BlobDownloadEntity {\n-    /**\n-     * A unique key for the blob download metadata.\n-     *\n-     * Also referred as downloadId that users use to identify and manage the download operation.\n-     */\n-    @PrimaryKey(autoGenerate = true)\n-    @ColumnInfo(name = \"key\")\n-    public Long key;\n-\n-    /**\n-     * The name of the Azure Storage Container to download the blob from.\n-     */\n-    @ColumnInfo(name = \"container_name\")\n-    public String containerName;\n-\n-    /**\n-     * The name of the Azure Storage blob to download.\n-     */\n-    @ColumnInfo(name = \"blob_name\")\n-    public String blobName;\n-\n-    /**\n-     * The blob size in bytes.\n-     */\n-    @ColumnInfo(name = \"blob_size\")\n-    public long blobSize;\n-\n-    /**\n-     * The URI to the content where the downloaded blob will be stored.\n-     */\n-    @ColumnInfo(name = \"content_uri\")\n-    public String contentUri;\n-\n-    /**\n-     * Indicate whether android.content.ContentResolver should be used to resolve the contentUri.\n-     */\n-    @ColumnInfo(name = \"use_content_resolver\")\n-    public boolean useContentResolver;\n-\n-    /**\n-     * Identifies the {@link com.azure.android.storage.blob.StorageBlobClient}\n-     * to be used for the file download.\n-     * @see StorageBlobClientMap\n-     */\n-    @ColumnInfo(name = \"storage_blob_client_id\")\n-    public String storageBlobClientId;\n-\n-    /**\n-     * The current state of the blob download operation.\n-     */\n-    @ColumnInfo(name = \"blob_download_state\")\n-    @TypeConverters(ColumnConverter.class)\n-    public volatile BlobTransferState state;\n-\n-    /**\n-     * Indicate the reason for interrupting (stopping) blob download.\n-     */\n-    @ColumnInfo(name = \"transfer_interrupt_state\")\n-    @TypeConverters(ColumnConverter.class)\n-    public TransferInterruptState interruptState;\n-    /**\n-     * The constraints to be satisfied to run the download operation.\n-     */\n-    @Embedded\n-    @NonNull\n-    public ConstraintsColumn constraintsColumn = ConstraintsColumn.NONE;\n-    /**\n-     * Holds the exception indicating the reason for download failure.\n-     *\n-     * This is not persisted.\n-     */\n-    @Ignore\n-    private Throwable downloadError;\n-\n-    /**\n-     * Creates BlobDownloadEntity, this constructor is used by Room library\n-     * when re-hydrating metadata from local store.\n-     */\n-    public BlobDownloadEntity() {}\n-\n-    /**\n-     * Create a new BlobDownloadEntity to persist in local store.\n-     *\n-     * @param storageBlobClientId identifies the blob storage client to be used\n-     * @param containerName The container name.\n-     * @param blobName The blob name.\n-     * @param blobSize The blob size.\n-     * @param content Describes the content where the downloaded blob will be stored.\n-     * @param constraints The constraints to be satisfied to run the download operation.\n-     */\n-    @Ignore\n-    BlobDownloadEntity(String storageBlobClientId,\n-                       String containerName,\n-                       String blobName,\n-                       long blobSize,\n-                       WritableContent content,\n-                       Constraints constraints) {\n-        Objects.requireNonNull(storageBlobClientId);\n-        Objects.requireNonNull(containerName);\n-        Objects.requireNonNull(blobName);\n-        Objects.requireNonNull(content);\n-        Objects.requireNonNull(constraints);\n-\n-        this.storageBlobClientId = storageBlobClientId;\n-        this.containerName = containerName;\n-        this.blobName = blobName;\n-        this.blobSize = blobSize;\n-        this.contentUri = content.getUri().toString();\n-        this.useContentResolver = content.isUsingContentResolver();\n-        state = BlobTransferState.WAIT_TO_BEGIN;\n-        interruptState = TransferInterruptState.NONE;\n-        constraintsColumn = ConstraintsColumn.fromConstraints(constraints);\n-    }\n-\n-    /**\n-     * Set the download failure error.\n-     *\n-     * @param t The error\n-     */\n-    void setDownloadError(Throwable t) {\n-        downloadError = t;\n-    }\n-\n-    /**\n-     * Get the download failure error.\n-     *\n-     * @return The download failure error or null if there is no error.\n-     */\n-    Throwable getDownloadError() {\n-        return downloadError;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-\n-        builder.append(\" key:\").append(key)\n-            .append(\" containerName:\").append(containerName)\n-            .append(\" blobName:\").append(blobName)\n-            .append(\" blobSize:\" + this.blobSize)\n-            .append(\" contentUri:\" + this.contentUri)\n-            .append(\" useContentResolver:\" + this.useContentResolver)\n-            .append(\" state:\").append(state)\n-            .append(\" interruptState:\").append(interruptState);\n-\n-        if (downloadError != null) {\n-            builder.append(\" downloadError:\").append(downloadError.getMessage());\n-        }\n-\n-        return builder.toString();\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyODU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433428595", "body": "```suggestion\r\n                        \"' cannot be processed, failed to open the content to write.\", t));\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"' is cannot be processed, failed to open the content to write.\", t));\n          \n          \n            \n                                    \"' cannot be processed, failed to open the content to write.\", t));", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>' <span class=\"x x-first x-last\">is </span>cannot be processed, failed to open the content to write.<span class=\"pl-pds\">\"</span></span>, t));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>' cannot be processed, failed to open the content to write.<span class=\"pl-pds\">\"</span></span>, t));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:01:07Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -168,6 +168,16 @@ private void handleInit() {\n                     .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n                 this.getLooper().quit();\n             } else {\n+                this.content = new WritableContent(appContext,\n+                    Uri.parse(this.blob.contentUri),\n+                    this.blob.useContentResolver);\n+                try {\n+                    this.content.openForWrite(appContext);\n+                } catch (Throwable t) {\n+                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n+                        \"' is cannot be processed, failed to open the content to write.\", t));", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\nindex 5367b50ec..51528ebd3 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n", "chunk": "@@ -175,7 +175,7 @@ final class DownloadHandler extends Handler {\n                     this.content.openForWrite(appContext);\n                 } catch (Throwable t) {\n                     this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                        \"' is cannot be processed, failed to open the content to write.\", t));\n+                        \"' cannot be processed, failed to open the content to write.\", t));\n                     getLooper().quit();\n                 }\n                 this.totalBytesDownloaded = this.db.downloadDao().getDownloadedBytesCount(downloadId);\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\ndeleted file mode 100644\nindex 51528ebd3..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,353 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import android.os.Looper;\n-import android.os.Message;\n-import android.util.Log;\n-import android.util.Pair;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.azure.android.core.http.ServiceCall;\n-import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.models.BlobDownloadAsyncResponse;\n-import com.azure.android.storage.blob.models.BlobRange;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- * <p>\n- * Handler that manages a single blob download.\n- * <p>\n- * Handler is a state machine, {@link DownloadHandlerMessage.Type} represents various stages that the state machine\n- * goes through. Handler reacts to each stage appropriately. Reacting to a stage includes: initialization, starting\n- * async block download operations, handling failure in operations, parking the work if the handler reaches stop state.\n- * <p>\n- * Additionally Handler is responsible for notifying the {@link TransferHandlerListener} on various events. Calls to\n- * this listener methods are serialized, i.e. these methods won't be called concurrently.\n- */\n-final class DownloadHandler extends Handler {\n-    private static final String TAG = DownloadHandler.class.getSimpleName();\n-\n-    private final Context appContext;\n-    private final int blocksDownloadConcurrency;\n-    private final long downloadId;\n-    private final HashMap<String, Pair<BlockDownloadEntity, ServiceCall>> runningBlockDownloads;\n-    private final TransferStopToken transferStopToken;\n-\n-    private TransferHandlerListener transferHandlerListener;\n-    private TransferDatabase db;\n-    private BlobDownloadEntity blob;\n-    private long totalBytesDownloaded;\n-    private BlockDownloadRecordsEnumerator blocksItr;\n-    // The content in the device to store the downloaded blob.\n-    private WritableContent content;\n-    private StorageBlobClient blobClient;\n-\n-    /**\n-     * Creates and initializes a {@link DownloadHandler}.\n-     *\n-     * @param looper     The looper to react on messages describing various blob download stages.\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     */\n-    private DownloadHandler(Looper looper, Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        super(looper);\n-\n-        this.appContext = appContext;\n-        this.blocksDownloadConcurrency = blocksDownloadConcurrency;\n-        this.downloadId = downloadId;\n-        runningBlockDownloads = new HashMap<>(this.blocksDownloadConcurrency);\n-        transferStopToken = new TransferStopToken(DownloadHandlerMessage.createStopMessage(this));\n-    }\n-\n-    /**\n-     * Creates {@link DownloadHandler} for handling a single blob download.\n-     *\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     * @return The DownloadHandler.\n-     */\n-    static DownloadHandler create(@NonNull Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        Objects.requireNonNull(appContext, \"Application Context is null.\");\n-        final HandlerThread handlerThread = new HandlerThread(\"DownloadHandlerThread\");\n-\n-        handlerThread.start();\n-\n-        return new DownloadHandler(handlerThread.getLooper(), appContext, blocksDownloadConcurrency, downloadId);\n-    }\n-\n-    /**\n-     * Begin downloading the blob.\n-     *\n-     * @param transferHandlerListener The listener to send the download events.\n-     * @return The token to stop the download.\n-     */\n-    TransferStopToken beginDownload(TransferHandlerListener transferHandlerListener) {\n-        this.transferHandlerListener =\n-            Objects.requireNonNull(transferHandlerListener, \"transferHandlerListener is null.\");\n-\n-        Log.i(TAG, \"beginDownload(): downloadId: \" + downloadId);\n-\n-        Message message = DownloadHandlerMessage.createInitMessage(this);\n-        message.sendToTarget();\n-\n-        return transferStopToken;\n-    }\n-\n-    @Override\n-    public void handleMessage(@NonNull Message message) {\n-        finalizeIfStopped();\n-\n-        int msgType = DownloadHandlerMessage.getMessageType(message);\n-\n-        switch (msgType) {\n-            case DownloadHandlerMessage.Type.INIT:\n-                Log.v(TAG, \"handleMessage(): received message: INIT\");\n-\n-                handleInit();\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_COMPLETED\");\n-\n-                handleDownloadCompleted(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_FAILED\");\n-\n-                handleDownloadFailed(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.STOP:\n-                Log.v(TAG, \"handleMessage(): received message: STOP\");\n-\n-                finalizeIfStopped();\n-\n-                break;\n-            default:\n-        }\n-    }\n-\n-    /**\n-     * Handles blob download initialization message received by the handler.\n-     * <p>\n-     * This stage acquires the DB, storage client and other resources required through out the life time of the\n-     * Handler. This stage also starts a download operation.\n-     */\n-    private void handleInit() {\n-        this.db = TransferDatabase.get(appContext);\n-        this.blob = db.downloadDao().getBlob(downloadId);\n-\n-        if (this.blob.interruptState == TransferInterruptState.PURGE) {\n-            this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                \"' is already CANCELLED and cannot be RESTARTED or RESUMED.\"));\n-            getLooper().quit();\n-        } else if (this.blob.state == BlobTransferState.COMPLETED) {\n-            this.transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-            this.transferHandlerListener.onComplete();\n-            this.getLooper().quit();\n-        } else {\n-\n-            this.blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(this.blob.storageBlobClientId);\n-            if (this.blobClient == null) {\n-                this.transferHandlerListener\n-                    .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n-                this.getLooper().quit();\n-            } else {\n-                this.content = new WritableContent(appContext,\n-                    Uri.parse(this.blob.contentUri),\n-                    this.blob.useContentResolver);\n-                try {\n-                    this.content.openForWrite(appContext);\n-                } catch (Throwable t) {\n-                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                        \"' cannot be processed, failed to open the content to write.\", t));\n-                    getLooper().quit();\n-                }\n-                this.totalBytesDownloaded = this.db.downloadDao().getDownloadedBytesCount(downloadId);\n-                this.transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-\n-                List<BlockTransferState> skip = new ArrayList<>();\n-                skip.add(BlockTransferState.COMPLETED);\n-                this.blocksItr = new BlockDownloadRecordsEnumerator(db, downloadId, skip);\n-                List<BlockDownloadEntity> blocks = blocksItr.getNext(blocksDownloadConcurrency);\n-\n-                if (blocks.size() != 0) {\n-                    downloadBlocks(blocks);\n-                } else {\n-                    Log.w(TAG, \"All blocks have been downloaded.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the blob download completion message received by the looper.\n-     * <p>\n-     * This stage notifies the completion of blob download to {@link TransferHandlerListener} and terminates the\n-     * handler.\n-     */\n-    private void handleDownloadCompleted(Message message) {\n-        finalizeIfStopped();\n-\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        Pair<BlockDownloadEntity, ServiceCall> pair = runningBlockDownloads.remove(blockId);\n-        BlockDownloadEntity downloadedBlock = pair.first;\n-        totalBytesDownloaded += downloadedBlock.blockSize;\n-        transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-        List<BlockDownloadEntity> blocks = blocksItr.getNext(1);\n-\n-        if (blocks.isEmpty()) {\n-            if (runningBlockDownloads.isEmpty()) {\n-                db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n-\n-                closeContent();\n-\n-                transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-                transferHandlerListener.onComplete();\n-                getLooper().quit();\n-            }\n-        } else {\n-            downloadBlocks(blocks);\n-        }\n-    }\n-\n-    /**\n-     * Handles the blocks download failed message received by the looper.\n-     * <p>\n-     * This stage notifies the failure to {@link TransferHandlerListener} and terminates the handler.\n-     */\n-    private void handleDownloadFailed(Message message) {\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        Pair<BlockDownloadEntity, ServiceCall> failedPair = runningBlockDownloads.remove(blockId);\n-\n-        for (Pair<BlockDownloadEntity, ServiceCall> pair : runningBlockDownloads.values()) {\n-            pair.second.cancel();\n-        }\n-\n-        closeContent();\n-\n-        Throwable downloadError = failedPair.first.getDownloadError();\n-        blob.setDownloadError(downloadError);\n-\n-        transferHandlerListener.onError(downloadError);\n-        getLooper().quit();\n-    }\n-\n-    /**\n-     * Check whether stop token is signalled, if so park the work and quit the looper.\n-     */\n-    private void finalizeIfStopped() {\n-        if (transferStopToken.isStopped()) {\n-            Log.v(TAG, \"finalizeIfStopped(): Stop request received, finalizing\");\n-\n-            for (Pair<BlockDownloadEntity, ServiceCall> pair : runningBlockDownloads.values()) {\n-                pair.second.cancel();\n-            }\n-\n-            closeContent();\n-\n-            TransferInterruptState interruptState = db.downloadDao().getTransferInterruptState(downloadId);\n-\n-            Log.v(TAG, \"finalizeIfStopped: Stop request reason (NONE == Stop requested by SYSTEM): \" + interruptState);\n-\n-            switch (interruptState) {\n-                case NONE:\n-                    transferHandlerListener.onSystemPaused();\n-                    break;\n-                case USER_PAUSED:\n-                    transferHandlerListener.onUserPaused();\n-                    break;\n-                case USER_CANCELLED:\n-                    db.downloadDao().updateDownloadInterruptState(downloadId, TransferInterruptState.PURGE);\n-                    transferHandlerListener.onError(new TransferCancelledException(downloadId));\n-            }\n-\n-            getLooper().quit();\n-        }\n-    }\n-\n-    /**\n-     * Starts the blob download operation.\n-     */\n-    private void downloadBlocks(List<BlockDownloadEntity> blocks) {\n-        for (BlockDownloadEntity block : blocks) {\n-            finalizeIfStopped();\n-\n-            Log.v(TAG, \"downloadBlob(): Downloading block: \" + block.blockId + getThreadName());\n-\n-            ServiceCall call = blobClient.downloadWithHeaders(blob.containerName,\n-                blob.blobName,\n-                null,\n-                null,\n-                new BlobRange(block.blockOffset, block.blockSize),\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                new com.azure.android.core.http.Callback<BlobDownloadAsyncResponse>() {\n-                    @Override\n-                    public void onResponse(BlobDownloadAsyncResponse response) {\n-                        try {\n-                            byte[] blockContent = response.getValue().bytes();\n-                            content.writeBlock(block.blockOffset, blockContent);\n-                        } catch (Throwable t) {\n-                            onFailure(t);\n-                            return;\n-                        }\n-\n-                        Log.v(TAG, \"downloadBlock(): Block downloaded:\" + block.blockId + getThreadName());\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.COMPLETED);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadCompletedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable t) {\n-                        Log.e(TAG, \"downloadFailed(): Block download failed: \" + block.blockId, t);\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.FAILED);\n-                        block.setDownloadError(t);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadFailedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-                });\n-\n-            runningBlockDownloads.put(block.blockId, Pair.create(block, call));\n-        }\n-    }\n-\n-    private void closeContent() {\n-        try {\n-            this.content.close();\n-        } catch (Throwable t) {\n-            Log.i(TAG, \"content::close()\", t);\n-        }\n-    }\n-\n-    // For Debugging, will be removed (TODO: vcolin7)\n-    private static String getThreadName() {\n-        return \" Thread:\" + Thread.currentThread().getName() + \"(\" + Thread.currentThread().getId() + \")\";\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTI0OA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433429248", "body": "Are we not creating a message because we are calling onComplete() and quitting the looper anyways?", "bodyText": "Are we not creating a message because we are calling onComplete() and quitting the looper anyways?", "bodyHTML": "<p dir=\"auto\">Are we not creating a message because we are calling onComplete() and quitting the looper anyways?</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:02:33Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -205,8 +215,7 @@ private void handleDownloadCompleted(Message message) {\n             if (runningBlockDownloads.isEmpty()) {\n                 db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n \n-                Message nextMessage = DownloadHandlerMessage.createBlobDownloadCompletedMessage(DownloadHandler.this);\n-                nextMessage.sendToTarget();\n+                closeContent();", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3ODQxMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433478412", "bodyText": "Depending on when looper really quit - this message either gets ignored because looper quit before processing it OR this message processed again which results in extra DB calls that simply repeat what was already done.", "author": "anuchandy", "createdAt": "2020-06-01T20:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTI0OA=="}], "type": "inlineReview", "revised_code": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\ndeleted file mode 100644\nindex 5367b50ec..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,353 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import android.os.Looper;\n-import android.os.Message;\n-import android.util.Log;\n-import android.util.Pair;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.azure.android.core.http.ServiceCall;\n-import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.models.BlobDownloadAsyncResponse;\n-import com.azure.android.storage.blob.models.BlobRange;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- * <p>\n- * Handler that manages a single blob download.\n- * <p>\n- * Handler is a state machine, {@link DownloadHandlerMessage.Type} represents various stages that the state machine\n- * goes through. Handler reacts to each stage appropriately. Reacting to a stage includes: initialization, starting\n- * async block download operations, handling failure in operations, parking the work if the handler reaches stop state.\n- * <p>\n- * Additionally Handler is responsible for notifying the {@link TransferHandlerListener} on various events. Calls to\n- * this listener methods are serialized, i.e. these methods won't be called concurrently.\n- */\n-final class DownloadHandler extends Handler {\n-    private static final String TAG = DownloadHandler.class.getSimpleName();\n-\n-    private final Context appContext;\n-    private final int blocksDownloadConcurrency;\n-    private final long downloadId;\n-    private final HashMap<String, Pair<BlockDownloadEntity, ServiceCall>> runningBlockDownloads;\n-    private final TransferStopToken transferStopToken;\n-\n-    private TransferHandlerListener transferHandlerListener;\n-    private TransferDatabase db;\n-    private BlobDownloadEntity blob;\n-    private long totalBytesDownloaded;\n-    private BlockDownloadRecordsEnumerator blocksItr;\n-    // The content in the device to store the downloaded blob.\n-    private WritableContent content;\n-    private StorageBlobClient blobClient;\n-\n-    /**\n-     * Creates and initializes a {@link DownloadHandler}.\n-     *\n-     * @param looper     The looper to react on messages describing various blob download stages.\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     */\n-    private DownloadHandler(Looper looper, Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        super(looper);\n-\n-        this.appContext = appContext;\n-        this.blocksDownloadConcurrency = blocksDownloadConcurrency;\n-        this.downloadId = downloadId;\n-        runningBlockDownloads = new HashMap<>(this.blocksDownloadConcurrency);\n-        transferStopToken = new TransferStopToken(DownloadHandlerMessage.createStopMessage(this));\n-    }\n-\n-    /**\n-     * Creates {@link DownloadHandler} for handling a single blob download.\n-     *\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     * @return The DownloadHandler.\n-     */\n-    static DownloadHandler create(@NonNull Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        Objects.requireNonNull(appContext, \"Application Context is null.\");\n-        final HandlerThread handlerThread = new HandlerThread(\"DownloadHandlerThread\");\n-\n-        handlerThread.start();\n-\n-        return new DownloadHandler(handlerThread.getLooper(), appContext, blocksDownloadConcurrency, downloadId);\n-    }\n-\n-    /**\n-     * Begin downloading the blob.\n-     *\n-     * @param transferHandlerListener The listener to send the download events.\n-     * @return The token to stop the download.\n-     */\n-    TransferStopToken beginDownload(TransferHandlerListener transferHandlerListener) {\n-        this.transferHandlerListener =\n-            Objects.requireNonNull(transferHandlerListener, \"transferHandlerListener is null.\");\n-\n-        Log.i(TAG, \"beginDownload(): downloadId: \" + downloadId);\n-\n-        Message message = DownloadHandlerMessage.createInitMessage(this);\n-        message.sendToTarget();\n-\n-        return transferStopToken;\n-    }\n-\n-    @Override\n-    public void handleMessage(@NonNull Message message) {\n-        finalizeIfStopped();\n-\n-        int msgType = DownloadHandlerMessage.getMessageType(message);\n-\n-        switch (msgType) {\n-            case DownloadHandlerMessage.Type.INIT:\n-                Log.v(TAG, \"handleMessage(): received message: INIT\");\n-\n-                handleInit();\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_COMPLETED\");\n-\n-                handleDownloadCompleted(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_FAILED\");\n-\n-                handleDownloadFailed(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.STOP:\n-                Log.v(TAG, \"handleMessage(): received message: STOP\");\n-\n-                finalizeIfStopped();\n-\n-                break;\n-            default:\n-        }\n-    }\n-\n-    /**\n-     * Handles blob download initialization message received by the handler.\n-     * <p>\n-     * This stage acquires the DB, storage client and other resources required through out the life time of the\n-     * Handler. This stage also starts a download operation.\n-     */\n-    private void handleInit() {\n-        this.db = TransferDatabase.get(appContext);\n-        this.blob = db.downloadDao().getBlob(downloadId);\n-\n-        if (this.blob.interruptState == TransferInterruptState.PURGE) {\n-            this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                \"' is already CANCELLED and cannot be RESTARTED or RESUMED.\"));\n-            getLooper().quit();\n-        } else if (this.blob.state == BlobTransferState.COMPLETED) {\n-            this.transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-            this.transferHandlerListener.onComplete();\n-            this.getLooper().quit();\n-        } else {\n-\n-            this.blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(this.blob.storageBlobClientId);\n-            if (this.blobClient == null) {\n-                this.transferHandlerListener\n-                    .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n-                this.getLooper().quit();\n-            } else {\n-                this.content = new WritableContent(appContext,\n-                    Uri.parse(this.blob.contentUri),\n-                    this.blob.useContentResolver);\n-                try {\n-                    this.content.openForWrite(appContext);\n-                } catch (Throwable t) {\n-                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                        \"' is cannot be processed, failed to open the content to write.\", t));\n-                    getLooper().quit();\n-                }\n-                this.totalBytesDownloaded = this.db.downloadDao().getDownloadedBytesCount(downloadId);\n-                this.transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-\n-                List<BlockTransferState> skip = new ArrayList<>();\n-                skip.add(BlockTransferState.COMPLETED);\n-                this.blocksItr = new BlockDownloadRecordsEnumerator(db, downloadId, skip);\n-                List<BlockDownloadEntity> blocks = blocksItr.getNext(blocksDownloadConcurrency);\n-\n-                if (blocks.size() != 0) {\n-                    downloadBlocks(blocks);\n-                } else {\n-                    Log.w(TAG, \"All blocks have been downloaded.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the blob download completion message received by the looper.\n-     * <p>\n-     * This stage notifies the completion of blob download to {@link TransferHandlerListener} and terminates the\n-     * handler.\n-     */\n-    private void handleDownloadCompleted(Message message) {\n-        finalizeIfStopped();\n-\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        Pair<BlockDownloadEntity, ServiceCall> pair = runningBlockDownloads.remove(blockId);\n-        BlockDownloadEntity downloadedBlock = pair.first;\n-        totalBytesDownloaded += downloadedBlock.blockSize;\n-        transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-        List<BlockDownloadEntity> blocks = blocksItr.getNext(1);\n-\n-        if (blocks.isEmpty()) {\n-            if (runningBlockDownloads.isEmpty()) {\n-                db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n-\n-                closeContent();\n-\n-                transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-                transferHandlerListener.onComplete();\n-                getLooper().quit();\n-            }\n-        } else {\n-            downloadBlocks(blocks);\n-        }\n-    }\n-\n-    /**\n-     * Handles the blocks download failed message received by the looper.\n-     * <p>\n-     * This stage notifies the failure to {@link TransferHandlerListener} and terminates the handler.\n-     */\n-    private void handleDownloadFailed(Message message) {\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        Pair<BlockDownloadEntity, ServiceCall> failedPair = runningBlockDownloads.remove(blockId);\n-\n-        for (Pair<BlockDownloadEntity, ServiceCall> pair : runningBlockDownloads.values()) {\n-            pair.second.cancel();\n-        }\n-\n-        closeContent();\n-\n-        Throwable downloadError = failedPair.first.getDownloadError();\n-        blob.setDownloadError(downloadError);\n-\n-        transferHandlerListener.onError(downloadError);\n-        getLooper().quit();\n-    }\n-\n-    /**\n-     * Check whether stop token is signalled, if so park the work and quit the looper.\n-     */\n-    private void finalizeIfStopped() {\n-        if (transferStopToken.isStopped()) {\n-            Log.v(TAG, \"finalizeIfStopped(): Stop request received, finalizing\");\n-\n-            for (Pair<BlockDownloadEntity, ServiceCall> pair : runningBlockDownloads.values()) {\n-                pair.second.cancel();\n-            }\n-\n-            closeContent();\n-\n-            TransferInterruptState interruptState = db.downloadDao().getTransferInterruptState(downloadId);\n-\n-            Log.v(TAG, \"finalizeIfStopped: Stop request reason (NONE == Stop requested by SYSTEM): \" + interruptState);\n-\n-            switch (interruptState) {\n-                case NONE:\n-                    transferHandlerListener.onSystemPaused();\n-                    break;\n-                case USER_PAUSED:\n-                    transferHandlerListener.onUserPaused();\n-                    break;\n-                case USER_CANCELLED:\n-                    db.downloadDao().updateDownloadInterruptState(downloadId, TransferInterruptState.PURGE);\n-                    transferHandlerListener.onError(new TransferCancelledException(downloadId));\n-            }\n-\n-            getLooper().quit();\n-        }\n-    }\n-\n-    /**\n-     * Starts the blob download operation.\n-     */\n-    private void downloadBlocks(List<BlockDownloadEntity> blocks) {\n-        for (BlockDownloadEntity block : blocks) {\n-            finalizeIfStopped();\n-\n-            Log.v(TAG, \"downloadBlob(): Downloading block: \" + block.blockId + getThreadName());\n-\n-            ServiceCall call = blobClient.downloadWithHeaders(blob.containerName,\n-                blob.blobName,\n-                null,\n-                null,\n-                new BlobRange(block.blockOffset, block.blockSize),\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                new com.azure.android.core.http.Callback<BlobDownloadAsyncResponse>() {\n-                    @Override\n-                    public void onResponse(BlobDownloadAsyncResponse response) {\n-                        try {\n-                            byte[] blockContent = response.getValue().bytes();\n-                            content.writeBlock(block.blockOffset, blockContent);\n-                        } catch (Throwable t) {\n-                            onFailure(t);\n-                            return;\n-                        }\n-\n-                        Log.v(TAG, \"downloadBlock(): Block downloaded:\" + block.blockId + getThreadName());\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.COMPLETED);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadCompletedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable t) {\n-                        Log.e(TAG, \"downloadFailed(): Block download failed: \" + block.blockId, t);\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.FAILED);\n-                        block.setDownloadError(t);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadFailedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-                });\n-\n-            runningBlockDownloads.put(block.blockId, Pair.create(block, call));\n-        }\n-    }\n-\n-    private void closeContent() {\n-        try {\n-            this.content.close();\n-        } catch (Throwable t) {\n-            Log.i(TAG, \"content::close()\", t);\n-        }\n-    }\n-\n-    // For Debugging, will be removed (TODO: vcolin7)\n-    private static String getThreadName() {\n-        return \" Thread:\" + Thread.currentThread().getName() + \"(\" + Thread.currentThread().getId() + \")\";\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433429777", "body": "Same as above.", "bodyText": "Same as above.", "bodyHTML": "<p dir=\"auto\">Same as above.</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:03:39Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -230,13 +239,11 @@ private void handleDownloadFailed(Message message) {\n             pair.second.cancel();\n         }\n \n-        Throwable downloadError = failedPair.first.getDownloadError();\n+        closeContent();\n \n+        Throwable downloadError = failedPair.first.getDownloadError();\n         blob.setDownloadError(downloadError);\n \n-        Message nextMessage = DownloadHandlerMessage.createBlobDownloadFailedMessage(DownloadHandler.this);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4NTMzMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433485333", "bodyText": "yes, reason for this is same as I explained above.", "author": "anuchandy", "createdAt": "2020-06-01T20:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "213c93409759e10c597eef72b1fea28a3c6f8270", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\nindex 5367b50ec..f5119c7d5 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n", "chunk": "@@ -233,15 +233,13 @@ final class DownloadHandler extends Handler {\n      */\n     private void handleDownloadFailed(Message message) {\n         String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        Pair<BlockDownloadEntity, ServiceCall> failedPair = runningBlockDownloads.remove(blockId);\n+        BlockDownloadEntity failedBlock = runningBlockDownloads.remove(blockId);\n \n-        for (Pair<BlockDownloadEntity, ServiceCall> pair : runningBlockDownloads.values()) {\n-            pair.second.cancel();\n-        }\n+        this.cancellationToken.cancel();\n \n         closeContent();\n \n-        Throwable downloadError = failedPair.first.getDownloadError();\n+        Throwable downloadError = failedBlock.getDownloadError();\n         blob.setDownloadError(downloadError);\n \n         transferHandlerListener.onError(downloadError);\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\ndeleted file mode 100644\nindex f5119c7d5..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,350 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import android.os.Looper;\n-import android.os.Message;\n-import android.util.Log;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.azure.android.core.util.CancellationToken;\n-import com.azure.android.storage.blob.StorageBlobAsyncClient;\n-import com.azure.android.storage.blob.models.BlobDownloadResponse;\n-import com.azure.android.storage.blob.models.BlobRange;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- * <p>\n- * Handler that manages a single blob download.\n- * <p>\n- * Handler is a state machine, {@link DownloadHandlerMessage.Type} represents various stages that the state machine\n- * goes through. Handler reacts to each stage appropriately. Reacting to a stage includes: initialization, starting\n- * async block download operations, handling failure in operations, parking the work if the handler reaches stop state.\n- * <p>\n- * Additionally Handler is responsible for notifying the {@link TransferHandlerListener} on various events. Calls to\n- * this listener methods are serialized, i.e. these methods won't be called concurrently.\n- */\n-final class DownloadHandler extends Handler {\n-    private static final String TAG = DownloadHandler.class.getSimpleName();\n-\n-    private final Context appContext;\n-    private final int blocksDownloadConcurrency;\n-    private final long downloadId;\n-    private final HashMap<String, BlockDownloadEntity> runningBlockDownloads;\n-    private final TransferStopToken transferStopToken;\n-    private final CancellationToken cancellationToken;\n-\n-    private TransferHandlerListener transferHandlerListener;\n-    private TransferDatabase db;\n-    private BlobDownloadEntity blob;\n-    private long totalBytesDownloaded;\n-    private BlockDownloadRecordsEnumerator blocksItr;\n-    // The content in the device to store the downloaded blob.\n-    private WritableContent content;\n-    private StorageBlobAsyncClient blobClient;\n-\n-    /**\n-     * Creates and initializes a {@link DownloadHandler}.\n-     *\n-     * @param looper     The looper to react on messages describing various blob download stages.\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     */\n-    private DownloadHandler(Looper looper, Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        super(looper);\n-\n-        this.appContext = appContext;\n-        this.blocksDownloadConcurrency = blocksDownloadConcurrency;\n-        this.downloadId = downloadId;\n-        runningBlockDownloads = new HashMap<>(this.blocksDownloadConcurrency);\n-        transferStopToken = new TransferStopToken(DownloadHandlerMessage.createStopMessage(this));\n-        this.cancellationToken = CancellationToken.create();\n-    }\n-\n-    /**\n-     * Creates {@link DownloadHandler} for handling a single blob download.\n-     *\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     * @return The DownloadHandler.\n-     */\n-    static DownloadHandler create(@NonNull Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        Objects.requireNonNull(appContext, \"Application Context is null.\");\n-        final HandlerThread handlerThread = new HandlerThread(\"DownloadHandlerThread\");\n-\n-        handlerThread.start();\n-\n-        return new DownloadHandler(handlerThread.getLooper(), appContext, blocksDownloadConcurrency, downloadId);\n-    }\n-\n-    /**\n-     * Begin downloading the blob.\n-     *\n-     * @param transferHandlerListener The listener to send the download events.\n-     * @return The token to stop the download.\n-     */\n-    TransferStopToken beginDownload(TransferHandlerListener transferHandlerListener) {\n-        this.transferHandlerListener =\n-            Objects.requireNonNull(transferHandlerListener, \"transferHandlerListener is null.\");\n-\n-        Log.i(TAG, \"beginDownload(): downloadId: \" + downloadId);\n-\n-        Message message = DownloadHandlerMessage.createInitMessage(this);\n-        message.sendToTarget();\n-\n-        return transferStopToken;\n-    }\n-\n-    @Override\n-    public void handleMessage(@NonNull Message message) {\n-        finalizeIfStopped();\n-\n-        int msgType = DownloadHandlerMessage.getMessageType(message);\n-\n-        switch (msgType) {\n-            case DownloadHandlerMessage.Type.INIT:\n-                Log.v(TAG, \"handleMessage(): received message: INIT\");\n-\n-                handleInit();\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_COMPLETED\");\n-\n-                handleDownloadCompleted(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_FAILED\");\n-\n-                handleDownloadFailed(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.STOP:\n-                Log.v(TAG, \"handleMessage(): received message: STOP\");\n-\n-                finalizeIfStopped();\n-\n-                break;\n-            default:\n-        }\n-    }\n-\n-    /**\n-     * Handles blob download initialization message received by the handler.\n-     * <p>\n-     * This stage acquires the DB, storage client and other resources required through out the life time of the\n-     * Handler. This stage also starts a download operation.\n-     */\n-    private void handleInit() {\n-        this.db = TransferDatabase.getInstance(appContext);\n-        this.blob = db.downloadDao().getBlob(downloadId);\n-\n-        if (this.blob.interruptState == TransferInterruptState.PURGE) {\n-            this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                \"' is already CANCELLED and cannot be RESTARTED or RESUMED.\"));\n-            getLooper().quit();\n-        } else if (this.blob.state == BlobTransferState.COMPLETED) {\n-            this.transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-            this.transferHandlerListener.onComplete();\n-            this.getLooper().quit();\n-        } else {\n-\n-            this.blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(this.blob.storageBlobClientId);\n-            if (this.blobClient == null) {\n-                this.transferHandlerListener\n-                    .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n-                this.getLooper().quit();\n-            } else {\n-                this.content = new WritableContent(appContext,\n-                    Uri.parse(this.blob.contentUri),\n-                    this.blob.useContentResolver);\n-                try {\n-                    this.content.openForWrite(appContext);\n-                } catch (Throwable t) {\n-                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                        \"' cannot be processed, failed to open the content to write.\", t));\n-                    getLooper().quit();\n-                }\n-                this.totalBytesDownloaded = this.db.downloadDao().getDownloadedBytesCount(downloadId);\n-                this.transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-\n-                List<BlockTransferState> skip = new ArrayList<>();\n-                skip.add(BlockTransferState.COMPLETED);\n-                this.blocksItr = new BlockDownloadRecordsEnumerator(db, downloadId, skip);\n-                List<BlockDownloadEntity> blocks = blocksItr.getNext(blocksDownloadConcurrency);\n-\n-                if (blocks.size() != 0) {\n-                    downloadBlocks(blocks);\n-                } else {\n-                    Log.w(TAG, \"All blocks have been downloaded.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the blob download completion message received by the looper.\n-     * <p>\n-     * This stage notifies the completion of blob download to {@link TransferHandlerListener} and terminates the\n-     * handler.\n-     */\n-    private void handleDownloadCompleted(Message message) {\n-        finalizeIfStopped();\n-\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockDownloadEntity downloadedBlock = runningBlockDownloads.remove(blockId);\n-        totalBytesDownloaded += downloadedBlock.blockSize;\n-        transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-        List<BlockDownloadEntity> blocks = blocksItr.getNext(1);\n-\n-        if (blocks.isEmpty()) {\n-            if (runningBlockDownloads.isEmpty()) {\n-                db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n-\n-                closeContent();\n-\n-                transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-                transferHandlerListener.onComplete();\n-                getLooper().quit();\n-            }\n-        } else {\n-            downloadBlocks(blocks);\n-        }\n-    }\n-\n-    /**\n-     * Handles the blocks download failed message received by the looper.\n-     * <p>\n-     * This stage notifies the failure to {@link TransferHandlerListener} and terminates the handler.\n-     */\n-    private void handleDownloadFailed(Message message) {\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockDownloadEntity failedBlock = runningBlockDownloads.remove(blockId);\n-\n-        this.cancellationToken.cancel();\n-\n-        closeContent();\n-\n-        Throwable downloadError = failedBlock.getDownloadError();\n-        blob.setDownloadError(downloadError);\n-\n-        transferHandlerListener.onError(downloadError);\n-        getLooper().quit();\n-    }\n-\n-    /**\n-     * Check whether stop token is signalled, if so park the work and quit the looper.\n-     */\n-    private void finalizeIfStopped() {\n-        if (transferStopToken.isStopped()) {\n-            Log.v(TAG, \"finalizeIfStopped(): Stop request received, finalizing\");\n-\n-            this.cancellationToken.cancel();\n-\n-            closeContent();\n-\n-            TransferInterruptState interruptState = db.downloadDao().getTransferInterruptState(downloadId);\n-\n-            Log.v(TAG, \"finalizeIfStopped: Stop request reason (NONE == Stop requested by SYSTEM): \" + interruptState);\n-\n-            switch (interruptState) {\n-                case NONE:\n-                    transferHandlerListener.onSystemPaused();\n-                    break;\n-                case USER_PAUSED:\n-                    transferHandlerListener.onUserPaused();\n-                    break;\n-                case USER_CANCELLED:\n-                    db.downloadDao().updateDownloadInterruptState(downloadId, TransferInterruptState.PURGE);\n-                    transferHandlerListener.onError(new TransferCancelledException(downloadId));\n-            }\n-\n-            getLooper().quit();\n-        }\n-    }\n-\n-    /**\n-     * Starts the blob download operation.\n-     */\n-    private void downloadBlocks(List<BlockDownloadEntity> blocks) {\n-        for (BlockDownloadEntity block : blocks) {\n-            finalizeIfStopped();\n-\n-            Log.v(TAG, \"downloadBlob(): Downloading block: \" + block.blockId + getThreadName());\n-\n-            blobClient.rawDownloadWithRestResponse(blob.containerName,\n-                blob.blobName,\n-                null,\n-                null,\n-                new BlobRange(block.blockOffset, block.blockSize),\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                this.cancellationToken,\n-                new com.azure.android.core.http.Callback<BlobDownloadResponse>() {\n-                    @Override\n-                    public void onResponse(BlobDownloadResponse response) {\n-                        try {\n-                            byte[] blockContent = response.getValue().bytes();\n-                            content.writeBlock(block.blockOffset, blockContent);\n-                        } catch (Throwable t) {\n-                            onFailure(t);\n-                            return;\n-                        }\n-\n-                        Log.v(TAG, \"downloadBlock(): Block downloaded:\" + block.blockId + getThreadName());\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.COMPLETED);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadCompletedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable t) {\n-                        Log.e(TAG, \"downloadFailed(): Block download failed: \" + block.blockId, t);\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.FAILED);\n-                        block.setDownloadError(t);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadFailedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-                });\n-\n-            runningBlockDownloads.put(block.blockId, block);\n-        }\n-    }\n-\n-    private void closeContent() {\n-        try {\n-            this.content.close();\n-        } catch (Throwable t) {\n-            Log.i(TAG, \"content::close()\", t);\n-        }\n-    }\n-\n-    // For Debugging, will be removed (TODO: vcolin7)\n-    private static String getThreadName() {\n-        return \" Thread:\" + Thread.currentThread().getName() + \"(\" + Thread.currentThread().getId() + \")\";\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433431179", "body": "What are the possible consequences of not being able to close a content instance?", "bodyText": "What are the possible consequences of not being able to close a content instance?", "bodyHTML": "<p dir=\"auto\">What are the possible consequences of not being able to close a content instance?</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:06:30Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -330,6 +338,14 @@ public void onFailure(Throwable t) {\n         }\n     }\n \n+    private void closeContent() {", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4MDg1MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433480850", "bodyText": "it is a  wrapper over file so consequence will be the same as if the app doesn't close a file descriptor (or HTTP connection). But we are careful enough to close it when the work manager asks us to do the cleanup by calling onStop.", "author": "anuchandy", "createdAt": "2020-06-01T20:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "213c93409759e10c597eef72b1fea28a3c6f8270", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\nindex 5367b50ec..f5119c7d5 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n", "chunk": "@@ -334,7 +331,7 @@ final class DownloadHandler extends Handler {\n                     }\n                 });\n \n-            runningBlockDownloads.put(block.blockId, Pair.create(block, call));\n+            runningBlockDownloads.put(block.blockId, block);\n         }\n     }\n \n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\ndeleted file mode 100644\nindex f5119c7d5..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,350 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import android.os.Looper;\n-import android.os.Message;\n-import android.util.Log;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.azure.android.core.util.CancellationToken;\n-import com.azure.android.storage.blob.StorageBlobAsyncClient;\n-import com.azure.android.storage.blob.models.BlobDownloadResponse;\n-import com.azure.android.storage.blob.models.BlobRange;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- * <p>\n- * Handler that manages a single blob download.\n- * <p>\n- * Handler is a state machine, {@link DownloadHandlerMessage.Type} represents various stages that the state machine\n- * goes through. Handler reacts to each stage appropriately. Reacting to a stage includes: initialization, starting\n- * async block download operations, handling failure in operations, parking the work if the handler reaches stop state.\n- * <p>\n- * Additionally Handler is responsible for notifying the {@link TransferHandlerListener} on various events. Calls to\n- * this listener methods are serialized, i.e. these methods won't be called concurrently.\n- */\n-final class DownloadHandler extends Handler {\n-    private static final String TAG = DownloadHandler.class.getSimpleName();\n-\n-    private final Context appContext;\n-    private final int blocksDownloadConcurrency;\n-    private final long downloadId;\n-    private final HashMap<String, BlockDownloadEntity> runningBlockDownloads;\n-    private final TransferStopToken transferStopToken;\n-    private final CancellationToken cancellationToken;\n-\n-    private TransferHandlerListener transferHandlerListener;\n-    private TransferDatabase db;\n-    private BlobDownloadEntity blob;\n-    private long totalBytesDownloaded;\n-    private BlockDownloadRecordsEnumerator blocksItr;\n-    // The content in the device to store the downloaded blob.\n-    private WritableContent content;\n-    private StorageBlobAsyncClient blobClient;\n-\n-    /**\n-     * Creates and initializes a {@link DownloadHandler}.\n-     *\n-     * @param looper     The looper to react on messages describing various blob download stages.\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     */\n-    private DownloadHandler(Looper looper, Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        super(looper);\n-\n-        this.appContext = appContext;\n-        this.blocksDownloadConcurrency = blocksDownloadConcurrency;\n-        this.downloadId = downloadId;\n-        runningBlockDownloads = new HashMap<>(this.blocksDownloadConcurrency);\n-        transferStopToken = new TransferStopToken(DownloadHandlerMessage.createStopMessage(this));\n-        this.cancellationToken = CancellationToken.create();\n-    }\n-\n-    /**\n-     * Creates {@link DownloadHandler} for handling a single blob download.\n-     *\n-     * @param appContext The context.\n-     * @param downloadId The identifier to a {@link BlobDownloadEntity} in the local store, describing the blob to be\n-     *                   downloaded.\n-     * @return The DownloadHandler.\n-     */\n-    static DownloadHandler create(@NonNull Context appContext, int blocksDownloadConcurrency, long downloadId) {\n-        Objects.requireNonNull(appContext, \"Application Context is null.\");\n-        final HandlerThread handlerThread = new HandlerThread(\"DownloadHandlerThread\");\n-\n-        handlerThread.start();\n-\n-        return new DownloadHandler(handlerThread.getLooper(), appContext, blocksDownloadConcurrency, downloadId);\n-    }\n-\n-    /**\n-     * Begin downloading the blob.\n-     *\n-     * @param transferHandlerListener The listener to send the download events.\n-     * @return The token to stop the download.\n-     */\n-    TransferStopToken beginDownload(TransferHandlerListener transferHandlerListener) {\n-        this.transferHandlerListener =\n-            Objects.requireNonNull(transferHandlerListener, \"transferHandlerListener is null.\");\n-\n-        Log.i(TAG, \"beginDownload(): downloadId: \" + downloadId);\n-\n-        Message message = DownloadHandlerMessage.createInitMessage(this);\n-        message.sendToTarget();\n-\n-        return transferStopToken;\n-    }\n-\n-    @Override\n-    public void handleMessage(@NonNull Message message) {\n-        finalizeIfStopped();\n-\n-        int msgType = DownloadHandlerMessage.getMessageType(message);\n-\n-        switch (msgType) {\n-            case DownloadHandlerMessage.Type.INIT:\n-                Log.v(TAG, \"handleMessage(): received message: INIT\");\n-\n-                handleInit();\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_COMPLETED\");\n-\n-                handleDownloadCompleted(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.DOWNLOAD_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: DOWNLOAD_FAILED\");\n-\n-                handleDownloadFailed(message);\n-\n-                break;\n-            case DownloadHandlerMessage.Type.STOP:\n-                Log.v(TAG, \"handleMessage(): received message: STOP\");\n-\n-                finalizeIfStopped();\n-\n-                break;\n-            default:\n-        }\n-    }\n-\n-    /**\n-     * Handles blob download initialization message received by the handler.\n-     * <p>\n-     * This stage acquires the DB, storage client and other resources required through out the life time of the\n-     * Handler. This stage also starts a download operation.\n-     */\n-    private void handleInit() {\n-        this.db = TransferDatabase.getInstance(appContext);\n-        this.blob = db.downloadDao().getBlob(downloadId);\n-\n-        if (this.blob.interruptState == TransferInterruptState.PURGE) {\n-            this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                \"' is already CANCELLED and cannot be RESTARTED or RESUMED.\"));\n-            getLooper().quit();\n-        } else if (this.blob.state == BlobTransferState.COMPLETED) {\n-            this.transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-            this.transferHandlerListener.onComplete();\n-            this.getLooper().quit();\n-        } else {\n-\n-            this.blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(this.blob.storageBlobClientId);\n-            if (this.blobClient == null) {\n-                this.transferHandlerListener\n-                    .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n-                this.getLooper().quit();\n-            } else {\n-                this.content = new WritableContent(appContext,\n-                    Uri.parse(this.blob.contentUri),\n-                    this.blob.useContentResolver);\n-                try {\n-                    this.content.openForWrite(appContext);\n-                } catch (Throwable t) {\n-                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n-                        \"' cannot be processed, failed to open the content to write.\", t));\n-                    getLooper().quit();\n-                }\n-                this.totalBytesDownloaded = this.db.downloadDao().getDownloadedBytesCount(downloadId);\n-                this.transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-\n-                List<BlockTransferState> skip = new ArrayList<>();\n-                skip.add(BlockTransferState.COMPLETED);\n-                this.blocksItr = new BlockDownloadRecordsEnumerator(db, downloadId, skip);\n-                List<BlockDownloadEntity> blocks = blocksItr.getNext(blocksDownloadConcurrency);\n-\n-                if (blocks.size() != 0) {\n-                    downloadBlocks(blocks);\n-                } else {\n-                    Log.w(TAG, \"All blocks have been downloaded.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the blob download completion message received by the looper.\n-     * <p>\n-     * This stage notifies the completion of blob download to {@link TransferHandlerListener} and terminates the\n-     * handler.\n-     */\n-    private void handleDownloadCompleted(Message message) {\n-        finalizeIfStopped();\n-\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockDownloadEntity downloadedBlock = runningBlockDownloads.remove(blockId);\n-        totalBytesDownloaded += downloadedBlock.blockSize;\n-        transferHandlerListener.onTransferProgress(blob.blobSize, totalBytesDownloaded);\n-        List<BlockDownloadEntity> blocks = blocksItr.getNext(1);\n-\n-        if (blocks.isEmpty()) {\n-            if (runningBlockDownloads.isEmpty()) {\n-                db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n-\n-                closeContent();\n-\n-                transferHandlerListener.onTransferProgress(blob.blobSize, blob.blobSize);\n-                transferHandlerListener.onComplete();\n-                getLooper().quit();\n-            }\n-        } else {\n-            downloadBlocks(blocks);\n-        }\n-    }\n-\n-    /**\n-     * Handles the blocks download failed message received by the looper.\n-     * <p>\n-     * This stage notifies the failure to {@link TransferHandlerListener} and terminates the handler.\n-     */\n-    private void handleDownloadFailed(Message message) {\n-        String blockId = DownloadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockDownloadEntity failedBlock = runningBlockDownloads.remove(blockId);\n-\n-        this.cancellationToken.cancel();\n-\n-        closeContent();\n-\n-        Throwable downloadError = failedBlock.getDownloadError();\n-        blob.setDownloadError(downloadError);\n-\n-        transferHandlerListener.onError(downloadError);\n-        getLooper().quit();\n-    }\n-\n-    /**\n-     * Check whether stop token is signalled, if so park the work and quit the looper.\n-     */\n-    private void finalizeIfStopped() {\n-        if (transferStopToken.isStopped()) {\n-            Log.v(TAG, \"finalizeIfStopped(): Stop request received, finalizing\");\n-\n-            this.cancellationToken.cancel();\n-\n-            closeContent();\n-\n-            TransferInterruptState interruptState = db.downloadDao().getTransferInterruptState(downloadId);\n-\n-            Log.v(TAG, \"finalizeIfStopped: Stop request reason (NONE == Stop requested by SYSTEM): \" + interruptState);\n-\n-            switch (interruptState) {\n-                case NONE:\n-                    transferHandlerListener.onSystemPaused();\n-                    break;\n-                case USER_PAUSED:\n-                    transferHandlerListener.onUserPaused();\n-                    break;\n-                case USER_CANCELLED:\n-                    db.downloadDao().updateDownloadInterruptState(downloadId, TransferInterruptState.PURGE);\n-                    transferHandlerListener.onError(new TransferCancelledException(downloadId));\n-            }\n-\n-            getLooper().quit();\n-        }\n-    }\n-\n-    /**\n-     * Starts the blob download operation.\n-     */\n-    private void downloadBlocks(List<BlockDownloadEntity> blocks) {\n-        for (BlockDownloadEntity block : blocks) {\n-            finalizeIfStopped();\n-\n-            Log.v(TAG, \"downloadBlob(): Downloading block: \" + block.blockId + getThreadName());\n-\n-            blobClient.rawDownloadWithRestResponse(blob.containerName,\n-                blob.blobName,\n-                null,\n-                null,\n-                new BlobRange(block.blockOffset, block.blockSize),\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                this.cancellationToken,\n-                new com.azure.android.core.http.Callback<BlobDownloadResponse>() {\n-                    @Override\n-                    public void onResponse(BlobDownloadResponse response) {\n-                        try {\n-                            byte[] blockContent = response.getValue().bytes();\n-                            content.writeBlock(block.blockOffset, blockContent);\n-                        } catch (Throwable t) {\n-                            onFailure(t);\n-                            return;\n-                        }\n-\n-                        Log.v(TAG, \"downloadBlock(): Block downloaded:\" + block.blockId + getThreadName());\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.COMPLETED);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadCompletedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable t) {\n-                        Log.e(TAG, \"downloadFailed(): Block download failed: \" + block.blockId, t);\n-\n-                        db.downloadDao().updateBlockState(blob.key, BlockTransferState.FAILED);\n-                        block.setDownloadError(t);\n-\n-                        Message nextMessage =\n-                            DownloadHandlerMessage.createBlockDownloadFailedMessage(DownloadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-                });\n-\n-            runningBlockDownloads.put(block.blockId, block);\n-        }\n-    }\n-\n-    private void closeContent() {\n-        try {\n-            this.content.close();\n-        } catch (Throwable t) {\n-            Log.i(TAG, \"content::close()\", t);\n-        }\n-    }\n-\n-    // For Debugging, will be removed (TODO: vcolin7)\n-    private static String getThreadName() {\n-        return \" Thread:\" + Thread.currentThread().getName() + \"(\" + Thread.currentThread().getId() + \")\";\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTQxNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433431414", "body": "```suggestion\r\n     * Upload the content of a file.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Upload content of a file.\n          \n          \n            \n                 * Upload the content of a file.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Upload</span> content of a file.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Upload</span> <span class=\"x x-first x-last\">the </span>content of a file.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:06:57Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -73,7 +74,7 @@ private TransferClient(Context context,\n     }\n \n     /**\n-     * Upload a file.\n+     * Upload content of a file.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 8f13481ed..7c9443020 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -74,7 +74,7 @@ public class TransferClient {\n     }\n \n     /**\n-     * Upload content of a file.\n+     * Upload the content of a file.\n      *\n      * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n      * @param containerName the container to upload the file to\n", "next_change": {"commit": "1d7f20437e061255e017de37aad4c6f3ec829001", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 7c9443020..237383fb2 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -76,11 +76,11 @@ public class TransferClient {\n     /**\n      * Upload the content of a file.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n+     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName The name of the target blob holding uploaded file.\n+     * @param file The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n", "next_change": {"commit": "ee6b440720171bea25d4a1255aa9c64278583566", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 237383fb2..4722a1adf 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -19,106 +16,86 @@ import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.ListenableWorker;\n-import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n \n-import java.io.File;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n \n /**\n  * A type that exposes blob transfer APIs.\n  */\n-public class TransferClient {\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS = new StorageBlobClientMap();\n+public final class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n-    // the application context.\n-    private final Context context;\n-    // the constraints to meet to run the transfers.\n-    private final Constraints constraints;\n     // the executor for internal book keeping.\n     private SerialExecutor serialTaskExecutor;\n     // reference to the database holding transfer entities.\n     private final TransferDatabase db;\n+    // reference to the androidx work manager.\n+    private final WorkManager workManager;\n     // track the active (not collected by GC) Transfers.\n-    private final static TransferIdInfoLiveDataCache TRANSFER_ID_INFO_CACHE = new TransferIdInfoLiveDataCache();\n+    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n+    // The singleton TransferClient.\n+    private static TransferClient INSTANCE = null;\n+    // An object to synchronize the creation of the singleton TransferClient.\n+    private static final Object INIT_LOCK = new Object();\n+    // the static shared map of StorageBlobClient instances for transfers, with package\n+    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n+    // and used by Upload|Download handlers.\n+    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n \n-    /**\n-     * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n-     * for transfers.\n-     *\n-     * @param context The context.\n-     * @param constraints The constraints to meet to run transfers.\n-     * @param serialTaskExecutor The executor for all internal book keeping purposes.\n-     * @param storageBlobClients The blob storage clients for transfers.\n-     */\n-    private TransferClient(Context context,\n-                           Constraints constraints,\n-                           SerialExecutor serialTaskExecutor,\n-                           Map<String, StorageBlobClient> storageBlobClients) {\n-        this.context = context;\n-        this.constraints = constraints;\n-        this.serialTaskExecutor = serialTaskExecutor;\n-        this.db = TransferDatabase.get(context);\n-        STORAGE_BLOB_CLIENTS.putAll(storageBlobClients);\n+    static {\n+        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n     }\n \n     /**\n-     * Upload the content of a file.\n+     * Retrieves the singleton instance of {@link TransferClient}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param file The local file to upload.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param context A {@link Context} for on-demand initialization.\n+     * @return The singleton instance of {@link TransferClient}.\n+     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n      */\n-    public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n-        // UI_Thread\n-        return upload(storageBlobClientId, containerName, blobName,\n-            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n+        synchronized (INIT_LOCK) {\n+            if (INSTANCE == null) {\n+                INSTANCE = new TransferClient(context.getApplicationContext());\n+            }\n+            return INSTANCE;\n+        }\n     }\n \n     /**\n-     * Upload content identified by a given Uri.\n+     * Create an instance of {@link TransferClient}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param contentUri URI to the Content to upload, the contentUri is resolved using\n-     *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param applicationContext The application {@link Context} for on-demand initialization.\n      */\n-    public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n-        // UI_Thread\n-        return upload(storageBlobClientId, containerName, blobName,\n-            new ReadableContent(this.context, contentUri, true));\n+    @SuppressLint(\"RestrictedApi\")\n+    private TransferClient(Context applicationContext) {\n+        this.db = TransferDatabase.getInstance(applicationContext);\n+        this.workManager = WorkManager.getInstance(applicationContext);\n+        try {\n+            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n+            //\n+            // Try to re-use the existing taskExecutor shared by WorkManager.\n+            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n+            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n+        } catch (Exception ignored) {\n+            // Create our own small ThreadPoolExecutor if we can't.\n+            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n+        }\n     }\n \n     /**\n      * Upload the content described by the given {@link ReadableContent}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param readableContent Describes the Content to read and upload.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param uploadRequest Describes the upload request.\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    private LiveData<TransferInfo> upload(String storageBlobClientId,\n-                                          String containerName,\n-                                          String blobName,\n-                                          ReadableContent readableContent) {\n-        // UI_Thread\n+    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n+        final ReadableContent readableContent = uploadRequest.getReadableContent();\n         final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n         try {\n             // Take permission immediately in the UI_Thread (granting may require UI interaction).\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\ndeleted file mode 100644\nindex 4722a1adf..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.util.Log;\n-\n-import androidx.annotation.MainThread;\n-import androidx.annotation.NonNull;\n-import androidx.lifecycle.LiveData;\n-import androidx.lifecycle.MutableLiveData;\n-import androidx.lifecycle.Transformations;\n-import androidx.work.Constraints;\n-import androidx.work.Data;\n-import androidx.work.ExistingWorkPolicy;\n-import androidx.work.ListenableWorker;\n-import androidx.work.OneTimeWorkRequest;\n-import androidx.work.WorkManager;\n-import androidx.work.impl.WorkManagerImpl;\n-\n-import com.azure.android.storage.blob.StorageBlobClient;\n-\n-import java.util.List;\n-import java.util.concurrent.Executors;\n-\n-/**\n- * A type that exposes blob transfer APIs.\n- */\n-public final class TransferClient {\n-    private static final String TAG = TransferClient.class.getSimpleName();\n-    // the executor for internal book keeping.\n-    private SerialExecutor serialTaskExecutor;\n-    // reference to the database holding transfer entities.\n-    private final TransferDatabase db;\n-    // reference to the androidx work manager.\n-    private final WorkManager workManager;\n-    // track the active (not collected by GC) Transfers.\n-    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n-    // The singleton TransferClient.\n-    private static TransferClient INSTANCE = null;\n-    // An object to synchronize the creation of the singleton TransferClient.\n-    private static final Object INIT_LOCK = new Object();\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n-\n-    static {\n-        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n-    }\n-\n-    /**\n-     * Retrieves the singleton instance of {@link TransferClient}.\n-     *\n-     * @param context A {@link Context} for on-demand initialization.\n-     * @return The singleton instance of {@link TransferClient}.\n-     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n-     */\n-    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n-        synchronized (INIT_LOCK) {\n-            if (INSTANCE == null) {\n-                INSTANCE = new TransferClient(context.getApplicationContext());\n-            }\n-            return INSTANCE;\n-        }\n-    }\n-\n-    /**\n-     * Create an instance of {@link TransferClient}.\n-     *\n-     * @param applicationContext The application {@link Context} for on-demand initialization.\n-     */\n-    @SuppressLint(\"RestrictedApi\")\n-    private TransferClient(Context applicationContext) {\n-        this.db = TransferDatabase.getInstance(applicationContext);\n-        this.workManager = WorkManager.getInstance(applicationContext);\n-        try {\n-            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n-            //\n-            // Try to re-use the existing taskExecutor shared by WorkManager.\n-            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n-            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n-        } catch (Exception ignored) {\n-            // Create our own small ThreadPoolExecutor if we can't.\n-            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n-        }\n-    }\n-\n-    /**\n-     * Upload the content described by the given {@link ReadableContent}.\n-     *\n-     * @param uploadRequest Describes the upload request.\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n-     */\n-    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n-        final ReadableContent readableContent = uploadRequest.getReadableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            readableContent.takePersistableReadPermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(uploadRequest.getStorageClientId())) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadRequest.getStorageClientId()));\n-                    return;\n-                }\n-                BlobUploadEntity blob = new BlobUploadEntity(uploadRequest.getStorageClientId(),\n-                    uploadRequest.getContainerName(),\n-                    uploadRequest.getBlobName(),\n-                    readableContent,\n-                    uploadRequest.getConstraints());\n-                List<BlockUploadEntity> blocks\n-                    = BlockUploadEntity.createBlockEntities(readableContent.getLength(), Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.uploadDao().createUploadRecord(blob, blocks);\n-                Log.v(TAG, \"upload(): upload record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(UploadWorker.class)\n-                    .setConstraints(uploadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + transferId);\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        uploadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Throwable e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param downloadRequest Describes the download request.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n-        final WritableContent writableContent = downloadRequest.getWritableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            writableContent.takePersistableWritePermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                StorageBlobClient blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(downloadRequest.getStorageClientId());\n-                if (blobClient == null) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            downloadRequest.getStorageClientId()));\n-                    return;\n-                }\n-\n-                long blobSize = blobClient.getBlobProperties(downloadRequest.getContainerName(), downloadRequest.getBlobName()).getContentLength();\n-                BlobDownloadEntity blob = new BlobDownloadEntity(downloadRequest.getStorageClientId(),\n-                    downloadRequest.getContainerName(),\n-                    downloadRequest.getBlobName(),\n-                    blobSize,\n-                    writableContent,\n-                    downloadRequest.getConstraints());\n-                List<BlockDownloadEntity> blocks\n-                    = BlockDownloadEntity.createBlockEntities(blobSize, Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.downloadDao().createDownloadRecord(blob, blocks);\n-\n-                Log.v(TAG, \"download(): Download record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest downloadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(DownloadWorker.class)\n-                    .setConstraints(downloadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"download(): enqueuing DownloadWorker: \" + transferId);\n-\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        downloadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Pause a transfer identified by the given transfer id. The pause operation\n-     * is a best-effort, and a transfer that is already executing may continue to\n-     * transfer.\n-     *\n-     * Upon successful scheduling of the pause, any observer observing on\n-     * the {@link LiveData} for this transfer receives a {@link TransferInfo}\n-     * event with state {@link TransferInfo.State#USER_PAUSED}.\n-     *\n-     * @param transferId The transfer id identifies the transfer to pause.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void pause(long transferId) {\n-        // UI_Thread\n-        final TransferIdInfoLiveData.TransferFlags transferFlags = transferIdInfoCache.getTransferFlags(transferId);\n-\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    }\n-\n-                    if (transferFlags != null) {\n-                        transferFlags.setUserPaused();\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule pause for the transfer:\" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Resume a paused transfer.\n-     *\n-     * @param transferId The transfer id identifies the transfer to resume.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n-     */\n-    public LiveData<TransferInfo> resume(long transferId) {\n-        // UI_Thread\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final ResumeCheck resumeCheck = checkResumeable(transferId, transferOpResultLiveData);\n-\n-                if (resumeCheck.canResume) {\n-                    final OneTimeWorkRequest workRequest;\n-                    String blobTransferIdKey, logMessage;\n-                    Class<? extends ListenableWorker> workerClass;\n-\n-                    if (resumeCheck.isUpload) {\n-                        blobTransferIdKey = UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY;\n-                        logMessage = \"Upload::resume() Enqueuing UploadWorker: \" + transferId;\n-                        workerClass = UploadWorker.class;\n-                    } else { // Download\n-                        blobTransferIdKey = DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY;\n-                        logMessage = \"Download::resume() Enqueuing DownloadWorker: \" + transferId;\n-                        workerClass = DownloadWorker.class;\n-                    }\n-\n-                    Data inputData = new Data.Builder()\n-                        .putLong(blobTransferIdKey, transferId)\n-                        .build();\n-                    workRequest = new OneTimeWorkRequest\n-                        .Builder(workerClass)\n-                        .setConstraints(resumeCheck.constraints)\n-                        .setInputData(inputData)\n-                        .build();\n-\n-                    Log.v(TAG, logMessage);\n-\n-                    // resume() will resubmit the work to WorkManager with the policy as KEEP.\n-                    // With this policy, if the work is already running, then this resume() call is NO-OP,\n-                    // we return the LiveData to the caller that streams the TransferInfo events of\n-                    // the already running work.\n-                    workManager\n-                        .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                            ExistingWorkPolicy.KEEP,\n-                            workRequest)\n-                        .enqueue();\n-                    transferOpResultLiveData\n-                        .postValue(TransferOperationResult.id(TransferOperationResult.Operation.RESUME, transferId));\n-                }\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.RESUME, e));\n-            }\n-        });\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, true);\n-    }\n-\n-    /**\n-     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n-     * that is already executing may continue to transfer.\n-     *\n-     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n-     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n-     *\n-     * @param transferId The transfer ID identifies the transfer to cancel.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void cancel(long transferId) {\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule cancellation for transfer with ID: \" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get unique name for a transfer work.\n-     *\n-     * @param transferId The transfer id.\n-     * @return The name for the transfer work.\n-     */\n-    static String toTransferUniqueWorkName(long transferId) {\n-        return \"azure_transfer_\" + transferId;\n-    }\n-\n-    /**\n-     * Subscribe to a TransferOperationResult LiveData and transform that to TransferInfo LiveData.\n-     *\n-     * This method caches or uses cached {@link LiveData} to stream {@link TransferInfo}.\n-     * If provided TransferOperationResult LiveData emits an error, then cache won't be used.\n-     *\n-     * @param transferOpResultLiveData The LiveData to channel transfer operation initiation result\n-     * @param isResume True if the transfer id emitted by the transferOpResultLiveData LiveData\n-     *   identifies a transfer to be resumed, false for a new upload or download transfer.\n-     * @return The TransferInfo LiveData.\n-     */\n-    @MainThread\n-    private LiveData<TransferInfo> toCachedTransferInfoLiveData(LiveData<TransferOperationResult> transferOpResultLiveData,\n-                                                                boolean isResume) {\n-        // UI_Thread\n-        return Transformations.switchMap(transferOpResultLiveData, transferOpResult -> {\n-            if (transferOpResult.isError()) {\n-                final TransferIdInfoLiveData.Result result = TransferIdInfoLiveData.create(workManager);\n-                final TransferIdInfoLiveData.LiveDataPair pair = result.getLiveDataPair();\n-                pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                return pair.getTransferInfoLiveData();\n-            } else {\n-                if (isResume) {\n-                    // If the application process already has a cached LiveData pair for the same transfer,\n-                    // then use it, otherwise create, cache, and use.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.getOrCreate(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                } else {\n-                    // For a new upload or download transfer, create a transfer LiveData pair\n-                    // (TransferOperationResult, TransferInfo) cache entry and use them.\n-                    // Any future resume operation on the same transfer will use this pair\n-                    // as long as:\n-                    //     1. both upload or download transfer, and the corresponding resume happens\n-                    //        in the same application process\n-                    //     2. and the cache entry is not GC-ed.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.create(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be resumed.\n-     *\n-     * @param transferId Identifies the transfer to check for resume eligibility.\n-     * @param transferOpResultLiveData The LiveData to post the error if the transfer cannot be resumed.\n-     * @return Result of check.\n-     */\n-    private ResumeCheck checkResumeable(long transferId,\n-                                        MutableLiveData<TransferOperationResult> transferOpResultLiveData) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-        String storageBlobClientId = null;\n-        Constraints constraints = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-            storageBlobClientId = uploadBlob.storageBlobClientId;\n-            constraints = uploadBlob.constraintsColumn.toConstraints();\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-                storageBlobClientId = downloadBlob.storageBlobClientId;\n-                constraints = downloadBlob.constraintsColumn.toConstraints();\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            transferOpResultLiveData.postValue(TransferOperationResult.notFoundError(transferId));\n-\n-            return new ResumeCheck(false, false, constraints);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInFailedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInCompletedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(storageBlobClientId)) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadBlob.storageBlobClientId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            }\n-\n-            return new ResumeCheck(true, true, constraints);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkResumeable(long, MutableLiveData)}} **/\n-    private static final class ResumeCheck {\n-        // Flag indicating whether transfer can be resumed.\n-        final boolean canResume;\n-        // If the transfer can be resumed then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-        // The constraints to be satisfied to resume the transfer.\n-        final Constraints constraints;\n-\n-        ResumeCheck(boolean canResume, boolean isUpload, Constraints constraints) {\n-            this.canResume = canResume;\n-            this.isUpload = isUpload;\n-            this.constraints = constraints;\n-        }\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be stopped (paused/cancelled).\n-     *\n-     * @param transferId Identifies the transfer to check for stopping eligibility.\n-     * @return Result of check.\n-     */\n-    private StopCheck checkStoppable(long transferId) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            return new StopCheck(false, false);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                return new StopCheck(false, true);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                return new StopCheck(false, true);\n-            }\n-\n-            return new StopCheck(true, true);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkStoppable(long)}} **/\n-    private static final class StopCheck {\n-        // Flag indicating whether transfer can be paused or cancelled.\n-        private final boolean canStop;\n-        // If the transfer can be paused or cancelled then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-\n-        private StopCheck(boolean canStop, boolean isUpload) {\n-            this.canStop = canStop;\n-            this.isUpload = isUpload;\n-        }\n-    }\n-\n-    private static final class Constants {\n-        static final int KB = 1024;\n-        static final int MB = 1024 * KB;\n-        static final int DEFAULT_BLOCK_SIZE = 10 * Constants.MB;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMjA3Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433432076", "body": "```suggestion\r\n     * @param contentUri URI to the Content to upload, the contentUri is resolved using\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri uri to the Content to upload, the contentUri is resolved using\n          \n          \n            \n                 * @param contentUri URI to the Content to upload, the contentUri is resolved using", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri <span class=\"x x-first x-last\">uri</span> to the <span class=\"pl-smi\">Content</span> to upload, the contentUri is resolved using</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri <span class=\"pl-c1 x x-first x-last\">URI</span> to the <span class=\"pl-smi\">Content</span> to upload, the contentUri is resolved using</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:08:12Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -83,7 +84,50 @@ private TransferClient(Context context,\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n+        return upload(storageBlobClientId, containerName, blobName,\n+            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Upload content identified by a given Uri.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param contentUri uri to the Content to upload, the contentUri is resolved using", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 8f13481ed..7c9443020 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -94,9 +94,9 @@ public class TransferClient {\n      * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n      * @param containerName the container to upload the file to\n      * @param blobName the name of the target blob holding uploaded file\n-     * @param contentUri uri to the Content to upload, the contentUri is resolved using\n+     * @param contentUri URI to the Content to upload, the contentUri is resolved using\n      *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://\n+     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'\n      * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n", "next_change": {"commit": "1d7f20437e061255e017de37aad4c6f3ec829001", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 7c9443020..237383fb2 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -91,13 +91,13 @@ public class TransferClient {\n     /**\n      * Upload content identified by a given Uri.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n+     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName The name of the target blob holding uploaded file.\n      * @param contentUri URI to the Content to upload, the contentUri is resolved using\n      *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n+     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n         // UI_Thread\n", "next_change": {"commit": "ee6b440720171bea25d4a1255aa9c64278583566", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 237383fb2..4722a1adf 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -19,106 +16,86 @@ import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.ListenableWorker;\n-import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n \n-import java.io.File;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n \n /**\n  * A type that exposes blob transfer APIs.\n  */\n-public class TransferClient {\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS = new StorageBlobClientMap();\n+public final class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n-    // the application context.\n-    private final Context context;\n-    // the constraints to meet to run the transfers.\n-    private final Constraints constraints;\n     // the executor for internal book keeping.\n     private SerialExecutor serialTaskExecutor;\n     // reference to the database holding transfer entities.\n     private final TransferDatabase db;\n+    // reference to the androidx work manager.\n+    private final WorkManager workManager;\n     // track the active (not collected by GC) Transfers.\n-    private final static TransferIdInfoLiveDataCache TRANSFER_ID_INFO_CACHE = new TransferIdInfoLiveDataCache();\n+    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n+    // The singleton TransferClient.\n+    private static TransferClient INSTANCE = null;\n+    // An object to synchronize the creation of the singleton TransferClient.\n+    private static final Object INIT_LOCK = new Object();\n+    // the static shared map of StorageBlobClient instances for transfers, with package\n+    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n+    // and used by Upload|Download handlers.\n+    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n \n-    /**\n-     * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n-     * for transfers.\n-     *\n-     * @param context The context.\n-     * @param constraints The constraints to meet to run transfers.\n-     * @param serialTaskExecutor The executor for all internal book keeping purposes.\n-     * @param storageBlobClients The blob storage clients for transfers.\n-     */\n-    private TransferClient(Context context,\n-                           Constraints constraints,\n-                           SerialExecutor serialTaskExecutor,\n-                           Map<String, StorageBlobClient> storageBlobClients) {\n-        this.context = context;\n-        this.constraints = constraints;\n-        this.serialTaskExecutor = serialTaskExecutor;\n-        this.db = TransferDatabase.get(context);\n-        STORAGE_BLOB_CLIENTS.putAll(storageBlobClients);\n+    static {\n+        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n     }\n \n     /**\n-     * Upload the content of a file.\n+     * Retrieves the singleton instance of {@link TransferClient}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param file The local file to upload.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param context A {@link Context} for on-demand initialization.\n+     * @return The singleton instance of {@link TransferClient}.\n+     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n      */\n-    public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n-        // UI_Thread\n-        return upload(storageBlobClientId, containerName, blobName,\n-            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n+        synchronized (INIT_LOCK) {\n+            if (INSTANCE == null) {\n+                INSTANCE = new TransferClient(context.getApplicationContext());\n+            }\n+            return INSTANCE;\n+        }\n     }\n \n     /**\n-     * Upload content identified by a given Uri.\n+     * Create an instance of {@link TransferClient}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param contentUri URI to the Content to upload, the contentUri is resolved using\n-     *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param applicationContext The application {@link Context} for on-demand initialization.\n      */\n-    public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n-        // UI_Thread\n-        return upload(storageBlobClientId, containerName, blobName,\n-            new ReadableContent(this.context, contentUri, true));\n+    @SuppressLint(\"RestrictedApi\")\n+    private TransferClient(Context applicationContext) {\n+        this.db = TransferDatabase.getInstance(applicationContext);\n+        this.workManager = WorkManager.getInstance(applicationContext);\n+        try {\n+            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n+            //\n+            // Try to re-use the existing taskExecutor shared by WorkManager.\n+            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n+            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n+        } catch (Exception ignored) {\n+            // Create our own small ThreadPoolExecutor if we can't.\n+            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n+        }\n     }\n \n     /**\n      * Upload the content described by the given {@link ReadableContent}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param readableContent Describes the Content to read and upload.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param uploadRequest Describes the upload request.\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    private LiveData<TransferInfo> upload(String storageBlobClientId,\n-                                          String containerName,\n-                                          String blobName,\n-                                          ReadableContent readableContent) {\n-        // UI_Thread\n+    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n+        final ReadableContent readableContent = uploadRequest.getReadableContent();\n         final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n         try {\n             // Take permission immediately in the UI_Thread (granting may require UI interaction).\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\ndeleted file mode 100644\nindex 4722a1adf..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.util.Log;\n-\n-import androidx.annotation.MainThread;\n-import androidx.annotation.NonNull;\n-import androidx.lifecycle.LiveData;\n-import androidx.lifecycle.MutableLiveData;\n-import androidx.lifecycle.Transformations;\n-import androidx.work.Constraints;\n-import androidx.work.Data;\n-import androidx.work.ExistingWorkPolicy;\n-import androidx.work.ListenableWorker;\n-import androidx.work.OneTimeWorkRequest;\n-import androidx.work.WorkManager;\n-import androidx.work.impl.WorkManagerImpl;\n-\n-import com.azure.android.storage.blob.StorageBlobClient;\n-\n-import java.util.List;\n-import java.util.concurrent.Executors;\n-\n-/**\n- * A type that exposes blob transfer APIs.\n- */\n-public final class TransferClient {\n-    private static final String TAG = TransferClient.class.getSimpleName();\n-    // the executor for internal book keeping.\n-    private SerialExecutor serialTaskExecutor;\n-    // reference to the database holding transfer entities.\n-    private final TransferDatabase db;\n-    // reference to the androidx work manager.\n-    private final WorkManager workManager;\n-    // track the active (not collected by GC) Transfers.\n-    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n-    // The singleton TransferClient.\n-    private static TransferClient INSTANCE = null;\n-    // An object to synchronize the creation of the singleton TransferClient.\n-    private static final Object INIT_LOCK = new Object();\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n-\n-    static {\n-        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n-    }\n-\n-    /**\n-     * Retrieves the singleton instance of {@link TransferClient}.\n-     *\n-     * @param context A {@link Context} for on-demand initialization.\n-     * @return The singleton instance of {@link TransferClient}.\n-     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n-     */\n-    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n-        synchronized (INIT_LOCK) {\n-            if (INSTANCE == null) {\n-                INSTANCE = new TransferClient(context.getApplicationContext());\n-            }\n-            return INSTANCE;\n-        }\n-    }\n-\n-    /**\n-     * Create an instance of {@link TransferClient}.\n-     *\n-     * @param applicationContext The application {@link Context} for on-demand initialization.\n-     */\n-    @SuppressLint(\"RestrictedApi\")\n-    private TransferClient(Context applicationContext) {\n-        this.db = TransferDatabase.getInstance(applicationContext);\n-        this.workManager = WorkManager.getInstance(applicationContext);\n-        try {\n-            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n-            //\n-            // Try to re-use the existing taskExecutor shared by WorkManager.\n-            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n-            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n-        } catch (Exception ignored) {\n-            // Create our own small ThreadPoolExecutor if we can't.\n-            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n-        }\n-    }\n-\n-    /**\n-     * Upload the content described by the given {@link ReadableContent}.\n-     *\n-     * @param uploadRequest Describes the upload request.\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n-     */\n-    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n-        final ReadableContent readableContent = uploadRequest.getReadableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            readableContent.takePersistableReadPermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(uploadRequest.getStorageClientId())) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadRequest.getStorageClientId()));\n-                    return;\n-                }\n-                BlobUploadEntity blob = new BlobUploadEntity(uploadRequest.getStorageClientId(),\n-                    uploadRequest.getContainerName(),\n-                    uploadRequest.getBlobName(),\n-                    readableContent,\n-                    uploadRequest.getConstraints());\n-                List<BlockUploadEntity> blocks\n-                    = BlockUploadEntity.createBlockEntities(readableContent.getLength(), Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.uploadDao().createUploadRecord(blob, blocks);\n-                Log.v(TAG, \"upload(): upload record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(UploadWorker.class)\n-                    .setConstraints(uploadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + transferId);\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        uploadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Throwable e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param downloadRequest Describes the download request.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n-        final WritableContent writableContent = downloadRequest.getWritableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            writableContent.takePersistableWritePermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                StorageBlobClient blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(downloadRequest.getStorageClientId());\n-                if (blobClient == null) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            downloadRequest.getStorageClientId()));\n-                    return;\n-                }\n-\n-                long blobSize = blobClient.getBlobProperties(downloadRequest.getContainerName(), downloadRequest.getBlobName()).getContentLength();\n-                BlobDownloadEntity blob = new BlobDownloadEntity(downloadRequest.getStorageClientId(),\n-                    downloadRequest.getContainerName(),\n-                    downloadRequest.getBlobName(),\n-                    blobSize,\n-                    writableContent,\n-                    downloadRequest.getConstraints());\n-                List<BlockDownloadEntity> blocks\n-                    = BlockDownloadEntity.createBlockEntities(blobSize, Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.downloadDao().createDownloadRecord(blob, blocks);\n-\n-                Log.v(TAG, \"download(): Download record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest downloadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(DownloadWorker.class)\n-                    .setConstraints(downloadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"download(): enqueuing DownloadWorker: \" + transferId);\n-\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        downloadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Pause a transfer identified by the given transfer id. The pause operation\n-     * is a best-effort, and a transfer that is already executing may continue to\n-     * transfer.\n-     *\n-     * Upon successful scheduling of the pause, any observer observing on\n-     * the {@link LiveData} for this transfer receives a {@link TransferInfo}\n-     * event with state {@link TransferInfo.State#USER_PAUSED}.\n-     *\n-     * @param transferId The transfer id identifies the transfer to pause.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void pause(long transferId) {\n-        // UI_Thread\n-        final TransferIdInfoLiveData.TransferFlags transferFlags = transferIdInfoCache.getTransferFlags(transferId);\n-\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    }\n-\n-                    if (transferFlags != null) {\n-                        transferFlags.setUserPaused();\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule pause for the transfer:\" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Resume a paused transfer.\n-     *\n-     * @param transferId The transfer id identifies the transfer to resume.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n-     */\n-    public LiveData<TransferInfo> resume(long transferId) {\n-        // UI_Thread\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final ResumeCheck resumeCheck = checkResumeable(transferId, transferOpResultLiveData);\n-\n-                if (resumeCheck.canResume) {\n-                    final OneTimeWorkRequest workRequest;\n-                    String blobTransferIdKey, logMessage;\n-                    Class<? extends ListenableWorker> workerClass;\n-\n-                    if (resumeCheck.isUpload) {\n-                        blobTransferIdKey = UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY;\n-                        logMessage = \"Upload::resume() Enqueuing UploadWorker: \" + transferId;\n-                        workerClass = UploadWorker.class;\n-                    } else { // Download\n-                        blobTransferIdKey = DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY;\n-                        logMessage = \"Download::resume() Enqueuing DownloadWorker: \" + transferId;\n-                        workerClass = DownloadWorker.class;\n-                    }\n-\n-                    Data inputData = new Data.Builder()\n-                        .putLong(blobTransferIdKey, transferId)\n-                        .build();\n-                    workRequest = new OneTimeWorkRequest\n-                        .Builder(workerClass)\n-                        .setConstraints(resumeCheck.constraints)\n-                        .setInputData(inputData)\n-                        .build();\n-\n-                    Log.v(TAG, logMessage);\n-\n-                    // resume() will resubmit the work to WorkManager with the policy as KEEP.\n-                    // With this policy, if the work is already running, then this resume() call is NO-OP,\n-                    // we return the LiveData to the caller that streams the TransferInfo events of\n-                    // the already running work.\n-                    workManager\n-                        .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                            ExistingWorkPolicy.KEEP,\n-                            workRequest)\n-                        .enqueue();\n-                    transferOpResultLiveData\n-                        .postValue(TransferOperationResult.id(TransferOperationResult.Operation.RESUME, transferId));\n-                }\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.RESUME, e));\n-            }\n-        });\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, true);\n-    }\n-\n-    /**\n-     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n-     * that is already executing may continue to transfer.\n-     *\n-     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n-     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n-     *\n-     * @param transferId The transfer ID identifies the transfer to cancel.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void cancel(long transferId) {\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule cancellation for transfer with ID: \" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get unique name for a transfer work.\n-     *\n-     * @param transferId The transfer id.\n-     * @return The name for the transfer work.\n-     */\n-    static String toTransferUniqueWorkName(long transferId) {\n-        return \"azure_transfer_\" + transferId;\n-    }\n-\n-    /**\n-     * Subscribe to a TransferOperationResult LiveData and transform that to TransferInfo LiveData.\n-     *\n-     * This method caches or uses cached {@link LiveData} to stream {@link TransferInfo}.\n-     * If provided TransferOperationResult LiveData emits an error, then cache won't be used.\n-     *\n-     * @param transferOpResultLiveData The LiveData to channel transfer operation initiation result\n-     * @param isResume True if the transfer id emitted by the transferOpResultLiveData LiveData\n-     *   identifies a transfer to be resumed, false for a new upload or download transfer.\n-     * @return The TransferInfo LiveData.\n-     */\n-    @MainThread\n-    private LiveData<TransferInfo> toCachedTransferInfoLiveData(LiveData<TransferOperationResult> transferOpResultLiveData,\n-                                                                boolean isResume) {\n-        // UI_Thread\n-        return Transformations.switchMap(transferOpResultLiveData, transferOpResult -> {\n-            if (transferOpResult.isError()) {\n-                final TransferIdInfoLiveData.Result result = TransferIdInfoLiveData.create(workManager);\n-                final TransferIdInfoLiveData.LiveDataPair pair = result.getLiveDataPair();\n-                pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                return pair.getTransferInfoLiveData();\n-            } else {\n-                if (isResume) {\n-                    // If the application process already has a cached LiveData pair for the same transfer,\n-                    // then use it, otherwise create, cache, and use.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.getOrCreate(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                } else {\n-                    // For a new upload or download transfer, create a transfer LiveData pair\n-                    // (TransferOperationResult, TransferInfo) cache entry and use them.\n-                    // Any future resume operation on the same transfer will use this pair\n-                    // as long as:\n-                    //     1. both upload or download transfer, and the corresponding resume happens\n-                    //        in the same application process\n-                    //     2. and the cache entry is not GC-ed.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.create(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be resumed.\n-     *\n-     * @param transferId Identifies the transfer to check for resume eligibility.\n-     * @param transferOpResultLiveData The LiveData to post the error if the transfer cannot be resumed.\n-     * @return Result of check.\n-     */\n-    private ResumeCheck checkResumeable(long transferId,\n-                                        MutableLiveData<TransferOperationResult> transferOpResultLiveData) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-        String storageBlobClientId = null;\n-        Constraints constraints = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-            storageBlobClientId = uploadBlob.storageBlobClientId;\n-            constraints = uploadBlob.constraintsColumn.toConstraints();\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-                storageBlobClientId = downloadBlob.storageBlobClientId;\n-                constraints = downloadBlob.constraintsColumn.toConstraints();\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            transferOpResultLiveData.postValue(TransferOperationResult.notFoundError(transferId));\n-\n-            return new ResumeCheck(false, false, constraints);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInFailedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInCompletedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(storageBlobClientId)) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadBlob.storageBlobClientId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            }\n-\n-            return new ResumeCheck(true, true, constraints);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkResumeable(long, MutableLiveData)}} **/\n-    private static final class ResumeCheck {\n-        // Flag indicating whether transfer can be resumed.\n-        final boolean canResume;\n-        // If the transfer can be resumed then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-        // The constraints to be satisfied to resume the transfer.\n-        final Constraints constraints;\n-\n-        ResumeCheck(boolean canResume, boolean isUpload, Constraints constraints) {\n-            this.canResume = canResume;\n-            this.isUpload = isUpload;\n-            this.constraints = constraints;\n-        }\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be stopped (paused/cancelled).\n-     *\n-     * @param transferId Identifies the transfer to check for stopping eligibility.\n-     * @return Result of check.\n-     */\n-    private StopCheck checkStoppable(long transferId) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            return new StopCheck(false, false);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                return new StopCheck(false, true);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                return new StopCheck(false, true);\n-            }\n-\n-            return new StopCheck(true, true);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkStoppable(long)}} **/\n-    private static final class StopCheck {\n-        // Flag indicating whether transfer can be paused or cancelled.\n-        private final boolean canStop;\n-        // If the transfer can be paused or cancelled then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-\n-        private StopCheck(boolean canStop, boolean isUpload) {\n-            this.canStop = canStop;\n-            this.isUpload = isUpload;\n-        }\n-    }\n-\n-    private static final class Constants {\n-        static final int KB = 1024;\n-        static final int MB = 1024 * KB;\n-        static final int DEFAULT_BLOCK_SIZE = 10 * Constants.MB;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMjM3MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433432371", "body": "```suggestion\r\n     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://\n          \n          \n            \n                 *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>   with mode as <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>r<span class=\"pl-pds\">\"</span></span><span class=\"pl-c1\">.</span> <span class=\"pl-smi\">The</span> supported <span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">URI</span> schemes are<span class=\"x x-first x-last\"> </span>content<span class=\"pl-k\">:</span><span class=\"pl-c\"><span class=\"pl-c\">//</span><span class=\"x x-first x-last\"> </span>file:// and android.resource://</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>   with mode as <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>r<span class=\"pl-pds\">\"</span></span><span class=\"pl-c1\">.</span> <span class=\"pl-smi\">The</span> supported <span class=\"pl-c1\">URI</span> schemes are<span class=\"pl-k x x-first\">:</span><span class=\"x\"> </span><span class=\"pl-s\"><span class=\"pl-pds x x-last\">'</span>content://<span class=\"pl-pds x x-first\">'</span></span><span class=\"x\">, </span><span class=\"pl-s\"><span class=\"pl-pds x x-last\">'</span>file://<span class=\"pl-pds x x-first x-last\">'</span></span> and <span class=\"pl-s\"><span class=\"pl-pds x x-first x-last\">'</span>android.resource://<span class=\"pl-pds x x-first x-last\">'</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:08:47Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -83,7 +84,50 @@ private TransferClient(Context context,\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n+        return upload(storageBlobClientId, containerName, blobName,\n+            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Upload content identified by a given Uri.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param contentUri uri to the Content to upload, the contentUri is resolved using\n+     *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n+     *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 8f13481ed..7c9443020 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -94,9 +94,9 @@ public class TransferClient {\n      * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n      * @param containerName the container to upload the file to\n      * @param blobName the name of the target blob holding uploaded file\n-     * @param contentUri uri to the Content to upload, the contentUri is resolved using\n+     * @param contentUri URI to the Content to upload, the contentUri is resolved using\n      *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://\n+     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'\n      * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n", "next_change": {"commit": "1d7f20437e061255e017de37aad4c6f3ec829001", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 7c9443020..237383fb2 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -91,13 +91,13 @@ public class TransferClient {\n     /**\n      * Upload content identified by a given Uri.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n+     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName The name of the target blob holding uploaded file.\n      * @param contentUri URI to the Content to upload, the contentUri is resolved using\n      *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n+     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n         // UI_Thread\n", "next_change": {"commit": "ee6b440720171bea25d4a1255aa9c64278583566", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 237383fb2..4722a1adf 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -19,106 +16,86 @@ import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.ListenableWorker;\n-import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n \n-import java.io.File;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n \n /**\n  * A type that exposes blob transfer APIs.\n  */\n-public class TransferClient {\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS = new StorageBlobClientMap();\n+public final class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n-    // the application context.\n-    private final Context context;\n-    // the constraints to meet to run the transfers.\n-    private final Constraints constraints;\n     // the executor for internal book keeping.\n     private SerialExecutor serialTaskExecutor;\n     // reference to the database holding transfer entities.\n     private final TransferDatabase db;\n+    // reference to the androidx work manager.\n+    private final WorkManager workManager;\n     // track the active (not collected by GC) Transfers.\n-    private final static TransferIdInfoLiveDataCache TRANSFER_ID_INFO_CACHE = new TransferIdInfoLiveDataCache();\n+    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n+    // The singleton TransferClient.\n+    private static TransferClient INSTANCE = null;\n+    // An object to synchronize the creation of the singleton TransferClient.\n+    private static final Object INIT_LOCK = new Object();\n+    // the static shared map of StorageBlobClient instances for transfers, with package\n+    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n+    // and used by Upload|Download handlers.\n+    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n \n-    /**\n-     * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n-     * for transfers.\n-     *\n-     * @param context The context.\n-     * @param constraints The constraints to meet to run transfers.\n-     * @param serialTaskExecutor The executor for all internal book keeping purposes.\n-     * @param storageBlobClients The blob storage clients for transfers.\n-     */\n-    private TransferClient(Context context,\n-                           Constraints constraints,\n-                           SerialExecutor serialTaskExecutor,\n-                           Map<String, StorageBlobClient> storageBlobClients) {\n-        this.context = context;\n-        this.constraints = constraints;\n-        this.serialTaskExecutor = serialTaskExecutor;\n-        this.db = TransferDatabase.get(context);\n-        STORAGE_BLOB_CLIENTS.putAll(storageBlobClients);\n+    static {\n+        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n     }\n \n     /**\n-     * Upload the content of a file.\n+     * Retrieves the singleton instance of {@link TransferClient}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param file The local file to upload.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param context A {@link Context} for on-demand initialization.\n+     * @return The singleton instance of {@link TransferClient}.\n+     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n      */\n-    public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n-        // UI_Thread\n-        return upload(storageBlobClientId, containerName, blobName,\n-            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n+        synchronized (INIT_LOCK) {\n+            if (INSTANCE == null) {\n+                INSTANCE = new TransferClient(context.getApplicationContext());\n+            }\n+            return INSTANCE;\n+        }\n     }\n \n     /**\n-     * Upload content identified by a given Uri.\n+     * Create an instance of {@link TransferClient}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param contentUri URI to the Content to upload, the contentUri is resolved using\n-     *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n-     *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param applicationContext The application {@link Context} for on-demand initialization.\n      */\n-    public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n-        // UI_Thread\n-        return upload(storageBlobClientId, containerName, blobName,\n-            new ReadableContent(this.context, contentUri, true));\n+    @SuppressLint(\"RestrictedApi\")\n+    private TransferClient(Context applicationContext) {\n+        this.db = TransferDatabase.getInstance(applicationContext);\n+        this.workManager = WorkManager.getInstance(applicationContext);\n+        try {\n+            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n+            //\n+            // Try to re-use the existing taskExecutor shared by WorkManager.\n+            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n+            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n+        } catch (Exception ignored) {\n+            // Create our own small ThreadPoolExecutor if we can't.\n+            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n+        }\n     }\n \n     /**\n      * Upload the content described by the given {@link ReadableContent}.\n      *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the upload.\n-     * @param containerName The container to upload the file to.\n-     * @param blobName The name of the target blob holding uploaded file.\n-     * @param readableContent Describes the Content to read and upload.\n-     * @return A LiveData that streams {@link TransferInfo} describing current state of the transfer.\n+     * @param uploadRequest Describes the upload request.\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    private LiveData<TransferInfo> upload(String storageBlobClientId,\n-                                          String containerName,\n-                                          String blobName,\n-                                          ReadableContent readableContent) {\n-        // UI_Thread\n+    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n+        final ReadableContent readableContent = uploadRequest.getReadableContent();\n         final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n         try {\n             // Take permission immediately in the UI_Thread (granting may require UI interaction).\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\ndeleted file mode 100644\nindex 4722a1adf..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.util.Log;\n-\n-import androidx.annotation.MainThread;\n-import androidx.annotation.NonNull;\n-import androidx.lifecycle.LiveData;\n-import androidx.lifecycle.MutableLiveData;\n-import androidx.lifecycle.Transformations;\n-import androidx.work.Constraints;\n-import androidx.work.Data;\n-import androidx.work.ExistingWorkPolicy;\n-import androidx.work.ListenableWorker;\n-import androidx.work.OneTimeWorkRequest;\n-import androidx.work.WorkManager;\n-import androidx.work.impl.WorkManagerImpl;\n-\n-import com.azure.android.storage.blob.StorageBlobClient;\n-\n-import java.util.List;\n-import java.util.concurrent.Executors;\n-\n-/**\n- * A type that exposes blob transfer APIs.\n- */\n-public final class TransferClient {\n-    private static final String TAG = TransferClient.class.getSimpleName();\n-    // the executor for internal book keeping.\n-    private SerialExecutor serialTaskExecutor;\n-    // reference to the database holding transfer entities.\n-    private final TransferDatabase db;\n-    // reference to the androidx work manager.\n-    private final WorkManager workManager;\n-    // track the active (not collected by GC) Transfers.\n-    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n-    // The singleton TransferClient.\n-    private static TransferClient INSTANCE = null;\n-    // An object to synchronize the creation of the singleton TransferClient.\n-    private static final Object INIT_LOCK = new Object();\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n-\n-    static {\n-        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n-    }\n-\n-    /**\n-     * Retrieves the singleton instance of {@link TransferClient}.\n-     *\n-     * @param context A {@link Context} for on-demand initialization.\n-     * @return The singleton instance of {@link TransferClient}.\n-     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n-     */\n-    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n-        synchronized (INIT_LOCK) {\n-            if (INSTANCE == null) {\n-                INSTANCE = new TransferClient(context.getApplicationContext());\n-            }\n-            return INSTANCE;\n-        }\n-    }\n-\n-    /**\n-     * Create an instance of {@link TransferClient}.\n-     *\n-     * @param applicationContext The application {@link Context} for on-demand initialization.\n-     */\n-    @SuppressLint(\"RestrictedApi\")\n-    private TransferClient(Context applicationContext) {\n-        this.db = TransferDatabase.getInstance(applicationContext);\n-        this.workManager = WorkManager.getInstance(applicationContext);\n-        try {\n-            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n-            //\n-            // Try to re-use the existing taskExecutor shared by WorkManager.\n-            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n-            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n-        } catch (Exception ignored) {\n-            // Create our own small ThreadPoolExecutor if we can't.\n-            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n-        }\n-    }\n-\n-    /**\n-     * Upload the content described by the given {@link ReadableContent}.\n-     *\n-     * @param uploadRequest Describes the upload request.\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n-     */\n-    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n-        final ReadableContent readableContent = uploadRequest.getReadableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            readableContent.takePersistableReadPermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(uploadRequest.getStorageClientId())) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadRequest.getStorageClientId()));\n-                    return;\n-                }\n-                BlobUploadEntity blob = new BlobUploadEntity(uploadRequest.getStorageClientId(),\n-                    uploadRequest.getContainerName(),\n-                    uploadRequest.getBlobName(),\n-                    readableContent,\n-                    uploadRequest.getConstraints());\n-                List<BlockUploadEntity> blocks\n-                    = BlockUploadEntity.createBlockEntities(readableContent.getLength(), Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.uploadDao().createUploadRecord(blob, blocks);\n-                Log.v(TAG, \"upload(): upload record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(UploadWorker.class)\n-                    .setConstraints(uploadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + transferId);\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        uploadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Throwable e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param downloadRequest Describes the download request.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n-        final WritableContent writableContent = downloadRequest.getWritableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            writableContent.takePersistableWritePermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                StorageBlobClient blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(downloadRequest.getStorageClientId());\n-                if (blobClient == null) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            downloadRequest.getStorageClientId()));\n-                    return;\n-                }\n-\n-                long blobSize = blobClient.getBlobProperties(downloadRequest.getContainerName(), downloadRequest.getBlobName()).getContentLength();\n-                BlobDownloadEntity blob = new BlobDownloadEntity(downloadRequest.getStorageClientId(),\n-                    downloadRequest.getContainerName(),\n-                    downloadRequest.getBlobName(),\n-                    blobSize,\n-                    writableContent,\n-                    downloadRequest.getConstraints());\n-                List<BlockDownloadEntity> blocks\n-                    = BlockDownloadEntity.createBlockEntities(blobSize, Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.downloadDao().createDownloadRecord(blob, blocks);\n-\n-                Log.v(TAG, \"download(): Download record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest downloadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(DownloadWorker.class)\n-                    .setConstraints(downloadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"download(): enqueuing DownloadWorker: \" + transferId);\n-\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        downloadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Pause a transfer identified by the given transfer id. The pause operation\n-     * is a best-effort, and a transfer that is already executing may continue to\n-     * transfer.\n-     *\n-     * Upon successful scheduling of the pause, any observer observing on\n-     * the {@link LiveData} for this transfer receives a {@link TransferInfo}\n-     * event with state {@link TransferInfo.State#USER_PAUSED}.\n-     *\n-     * @param transferId The transfer id identifies the transfer to pause.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void pause(long transferId) {\n-        // UI_Thread\n-        final TransferIdInfoLiveData.TransferFlags transferFlags = transferIdInfoCache.getTransferFlags(transferId);\n-\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    }\n-\n-                    if (transferFlags != null) {\n-                        transferFlags.setUserPaused();\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule pause for the transfer:\" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Resume a paused transfer.\n-     *\n-     * @param transferId The transfer id identifies the transfer to resume.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n-     */\n-    public LiveData<TransferInfo> resume(long transferId) {\n-        // UI_Thread\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final ResumeCheck resumeCheck = checkResumeable(transferId, transferOpResultLiveData);\n-\n-                if (resumeCheck.canResume) {\n-                    final OneTimeWorkRequest workRequest;\n-                    String blobTransferIdKey, logMessage;\n-                    Class<? extends ListenableWorker> workerClass;\n-\n-                    if (resumeCheck.isUpload) {\n-                        blobTransferIdKey = UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY;\n-                        logMessage = \"Upload::resume() Enqueuing UploadWorker: \" + transferId;\n-                        workerClass = UploadWorker.class;\n-                    } else { // Download\n-                        blobTransferIdKey = DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY;\n-                        logMessage = \"Download::resume() Enqueuing DownloadWorker: \" + transferId;\n-                        workerClass = DownloadWorker.class;\n-                    }\n-\n-                    Data inputData = new Data.Builder()\n-                        .putLong(blobTransferIdKey, transferId)\n-                        .build();\n-                    workRequest = new OneTimeWorkRequest\n-                        .Builder(workerClass)\n-                        .setConstraints(resumeCheck.constraints)\n-                        .setInputData(inputData)\n-                        .build();\n-\n-                    Log.v(TAG, logMessage);\n-\n-                    // resume() will resubmit the work to WorkManager with the policy as KEEP.\n-                    // With this policy, if the work is already running, then this resume() call is NO-OP,\n-                    // we return the LiveData to the caller that streams the TransferInfo events of\n-                    // the already running work.\n-                    workManager\n-                        .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                            ExistingWorkPolicy.KEEP,\n-                            workRequest)\n-                        .enqueue();\n-                    transferOpResultLiveData\n-                        .postValue(TransferOperationResult.id(TransferOperationResult.Operation.RESUME, transferId));\n-                }\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.RESUME, e));\n-            }\n-        });\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, true);\n-    }\n-\n-    /**\n-     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n-     * that is already executing may continue to transfer.\n-     *\n-     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n-     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n-     *\n-     * @param transferId The transfer ID identifies the transfer to cancel.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void cancel(long transferId) {\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule cancellation for transfer with ID: \" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get unique name for a transfer work.\n-     *\n-     * @param transferId The transfer id.\n-     * @return The name for the transfer work.\n-     */\n-    static String toTransferUniqueWorkName(long transferId) {\n-        return \"azure_transfer_\" + transferId;\n-    }\n-\n-    /**\n-     * Subscribe to a TransferOperationResult LiveData and transform that to TransferInfo LiveData.\n-     *\n-     * This method caches or uses cached {@link LiveData} to stream {@link TransferInfo}.\n-     * If provided TransferOperationResult LiveData emits an error, then cache won't be used.\n-     *\n-     * @param transferOpResultLiveData The LiveData to channel transfer operation initiation result\n-     * @param isResume True if the transfer id emitted by the transferOpResultLiveData LiveData\n-     *   identifies a transfer to be resumed, false for a new upload or download transfer.\n-     * @return The TransferInfo LiveData.\n-     */\n-    @MainThread\n-    private LiveData<TransferInfo> toCachedTransferInfoLiveData(LiveData<TransferOperationResult> transferOpResultLiveData,\n-                                                                boolean isResume) {\n-        // UI_Thread\n-        return Transformations.switchMap(transferOpResultLiveData, transferOpResult -> {\n-            if (transferOpResult.isError()) {\n-                final TransferIdInfoLiveData.Result result = TransferIdInfoLiveData.create(workManager);\n-                final TransferIdInfoLiveData.LiveDataPair pair = result.getLiveDataPair();\n-                pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                return pair.getTransferInfoLiveData();\n-            } else {\n-                if (isResume) {\n-                    // If the application process already has a cached LiveData pair for the same transfer,\n-                    // then use it, otherwise create, cache, and use.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.getOrCreate(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                } else {\n-                    // For a new upload or download transfer, create a transfer LiveData pair\n-                    // (TransferOperationResult, TransferInfo) cache entry and use them.\n-                    // Any future resume operation on the same transfer will use this pair\n-                    // as long as:\n-                    //     1. both upload or download transfer, and the corresponding resume happens\n-                    //        in the same application process\n-                    //     2. and the cache entry is not GC-ed.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.create(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be resumed.\n-     *\n-     * @param transferId Identifies the transfer to check for resume eligibility.\n-     * @param transferOpResultLiveData The LiveData to post the error if the transfer cannot be resumed.\n-     * @return Result of check.\n-     */\n-    private ResumeCheck checkResumeable(long transferId,\n-                                        MutableLiveData<TransferOperationResult> transferOpResultLiveData) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-        String storageBlobClientId = null;\n-        Constraints constraints = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-            storageBlobClientId = uploadBlob.storageBlobClientId;\n-            constraints = uploadBlob.constraintsColumn.toConstraints();\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-                storageBlobClientId = downloadBlob.storageBlobClientId;\n-                constraints = downloadBlob.constraintsColumn.toConstraints();\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            transferOpResultLiveData.postValue(TransferOperationResult.notFoundError(transferId));\n-\n-            return new ResumeCheck(false, false, constraints);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInFailedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInCompletedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(storageBlobClientId)) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadBlob.storageBlobClientId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            }\n-\n-            return new ResumeCheck(true, true, constraints);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkResumeable(long, MutableLiveData)}} **/\n-    private static final class ResumeCheck {\n-        // Flag indicating whether transfer can be resumed.\n-        final boolean canResume;\n-        // If the transfer can be resumed then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-        // The constraints to be satisfied to resume the transfer.\n-        final Constraints constraints;\n-\n-        ResumeCheck(boolean canResume, boolean isUpload, Constraints constraints) {\n-            this.canResume = canResume;\n-            this.isUpload = isUpload;\n-            this.constraints = constraints;\n-        }\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be stopped (paused/cancelled).\n-     *\n-     * @param transferId Identifies the transfer to check for stopping eligibility.\n-     * @return Result of check.\n-     */\n-    private StopCheck checkStoppable(long transferId) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            return new StopCheck(false, false);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                return new StopCheck(false, true);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                return new StopCheck(false, true);\n-            }\n-\n-            return new StopCheck(true, true);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkStoppable(long)}} **/\n-    private static final class StopCheck {\n-        // Flag indicating whether transfer can be paused or cancelled.\n-        private final boolean canStop;\n-        // If the transfer can be paused or cancelled then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-\n-        private StopCheck(boolean canStop, boolean isUpload) {\n-            this.canStop = canStop;\n-            this.isUpload = isUpload;\n-        }\n-    }\n-\n-    private static final class Constants {\n-        static final int KB = 1024;\n-        static final int MB = 1024 * KB;\n-        static final int DEFAULT_BLOCK_SIZE = 10 * Constants.MB;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMzY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433433672", "body": "```suggestion\r\n     * @param contentUri The URI to the local content where the downloaded blob will be stored.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri The uri to the local content to write the downloaded blob\n          \n          \n            \n                 * @param contentUri The URI to the local content where the downloaded blob will be stored.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri <span class=\"pl-smi\">The</span> <span class=\"x x-first x-last\">uri</span> to the local content <span class=\"x x-first x-last\">to write </span>the downloaded blob</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri <span class=\"pl-smi\">The</span> <span class=\"pl-c1 x x-first x-last\">URI</span> to the local content <span class=\"x x-first x-last\">where </span>the downloaded blob<span class=\"x x-first x-last\"> will be stored.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:11:34Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -135,9 +182,51 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param containerName The container to download the blob from.\n+     * @param blobName The name of the target blob to download.\n+     * @param contentUri The uri to the local content to write the downloaded blob", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 8f13481ed..7c9443020 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -194,14 +194,14 @@ public class TransferClient {\n      * @param storageBlobClientId the identifier of the blob storage client to use for the download\n      * @param containerName The container to download the blob from.\n      * @param blobName The name of the target blob to download.\n-     * @param contentUri The uri to the local content to write the downloaded blob\n+     * @param contentUri The URI to the local content where the downloaded blob will be stored.\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n         return download(storageBlobClientId,\n             containerName,\n             blobName,\n-            new WritableContent(this.context, contentUri, false));\n+            new WritableContent(this.context, contentUri, true));\n     }\n \n     /**\n", "next_change": {"commit": "1d7f20437e061255e017de37aad4c6f3ec829001", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 7c9443020..237383fb2 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -207,13 +207,13 @@ public class TransferClient {\n     /**\n      * Download a blob.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param storageBlobClientId The identifier of the blob storage client to use for the download\n      * @param containerName The container to download the blob from.\n      * @param blobName The name of the target blob to download.\n-     * @param writableContent describes the Content in the device to store the downloaded blob.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     * @param writableContent Describes the Content in the device to store the downloaded blob.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n-    public LiveData<TransferInfo> download(String storageBlobClientId,\n+    private LiveData<TransferInfo> download(String storageBlobClientId,\n                                            String containerName,\n                                            String blobName,\n                                            WritableContent writableContent) {\n", "next_change": {"commit": "ee6b440720171bea25d4a1255aa9c64278583566", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 237383fb2..4722a1adf 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -168,56 +145,17 @@ public class TransferClient {\n                     .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n             }\n         });\n-        // UI_Thread\n         return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n     }\n \n     /**\n      * Download a blob.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n-     * @param containerName The container to download the blob from.\n-     * @param blobName The name of the target blob to download.\n-     * @param file The local file to download to.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n-        return download(storageBlobClientId,\n-            containerName,\n-            blobName,\n-            new WritableContent(this.context, Uri.fromFile(file), false));\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n-     * @param containerName The container to download the blob from.\n-     * @param blobName The name of the target blob to download.\n-     * @param contentUri The URI to the local content where the downloaded blob will be stored.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     * @param downloadRequest Describes the download request.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n-    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n-        return download(storageBlobClientId,\n-            containerName,\n-            blobName,\n-            new WritableContent(this.context, contentUri, true));\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the download\n-     * @param containerName The container to download the blob from.\n-     * @param blobName The name of the target blob to download.\n-     * @param writableContent Describes the Content in the device to store the downloaded blob.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    private LiveData<TransferInfo> download(String storageBlobClientId,\n-                                           String containerName,\n-                                           String blobName,\n-                                           WritableContent writableContent) {\n-        // UI_Thread\n+    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n+        final WritableContent writableContent = downloadRequest.getWritableContent();\n         final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n         try {\n             // Take permission immediately in the UI_Thread (granting may require UI interaction).\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\ndeleted file mode 100644\nindex 4722a1adf..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.util.Log;\n-\n-import androidx.annotation.MainThread;\n-import androidx.annotation.NonNull;\n-import androidx.lifecycle.LiveData;\n-import androidx.lifecycle.MutableLiveData;\n-import androidx.lifecycle.Transformations;\n-import androidx.work.Constraints;\n-import androidx.work.Data;\n-import androidx.work.ExistingWorkPolicy;\n-import androidx.work.ListenableWorker;\n-import androidx.work.OneTimeWorkRequest;\n-import androidx.work.WorkManager;\n-import androidx.work.impl.WorkManagerImpl;\n-\n-import com.azure.android.storage.blob.StorageBlobClient;\n-\n-import java.util.List;\n-import java.util.concurrent.Executors;\n-\n-/**\n- * A type that exposes blob transfer APIs.\n- */\n-public final class TransferClient {\n-    private static final String TAG = TransferClient.class.getSimpleName();\n-    // the executor for internal book keeping.\n-    private SerialExecutor serialTaskExecutor;\n-    // reference to the database holding transfer entities.\n-    private final TransferDatabase db;\n-    // reference to the androidx work manager.\n-    private final WorkManager workManager;\n-    // track the active (not collected by GC) Transfers.\n-    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n-    // The singleton TransferClient.\n-    private static TransferClient INSTANCE = null;\n-    // An object to synchronize the creation of the singleton TransferClient.\n-    private static final Object INIT_LOCK = new Object();\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n-\n-    static {\n-        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n-    }\n-\n-    /**\n-     * Retrieves the singleton instance of {@link TransferClient}.\n-     *\n-     * @param context A {@link Context} for on-demand initialization.\n-     * @return The singleton instance of {@link TransferClient}.\n-     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n-     */\n-    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n-        synchronized (INIT_LOCK) {\n-            if (INSTANCE == null) {\n-                INSTANCE = new TransferClient(context.getApplicationContext());\n-            }\n-            return INSTANCE;\n-        }\n-    }\n-\n-    /**\n-     * Create an instance of {@link TransferClient}.\n-     *\n-     * @param applicationContext The application {@link Context} for on-demand initialization.\n-     */\n-    @SuppressLint(\"RestrictedApi\")\n-    private TransferClient(Context applicationContext) {\n-        this.db = TransferDatabase.getInstance(applicationContext);\n-        this.workManager = WorkManager.getInstance(applicationContext);\n-        try {\n-            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n-            //\n-            // Try to re-use the existing taskExecutor shared by WorkManager.\n-            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n-            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n-        } catch (Exception ignored) {\n-            // Create our own small ThreadPoolExecutor if we can't.\n-            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n-        }\n-    }\n-\n-    /**\n-     * Upload the content described by the given {@link ReadableContent}.\n-     *\n-     * @param uploadRequest Describes the upload request.\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n-     */\n-    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n-        final ReadableContent readableContent = uploadRequest.getReadableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            readableContent.takePersistableReadPermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(uploadRequest.getStorageClientId())) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadRequest.getStorageClientId()));\n-                    return;\n-                }\n-                BlobUploadEntity blob = new BlobUploadEntity(uploadRequest.getStorageClientId(),\n-                    uploadRequest.getContainerName(),\n-                    uploadRequest.getBlobName(),\n-                    readableContent,\n-                    uploadRequest.getConstraints());\n-                List<BlockUploadEntity> blocks\n-                    = BlockUploadEntity.createBlockEntities(readableContent.getLength(), Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.uploadDao().createUploadRecord(blob, blocks);\n-                Log.v(TAG, \"upload(): upload record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(UploadWorker.class)\n-                    .setConstraints(uploadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + transferId);\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        uploadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Throwable e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param downloadRequest Describes the download request.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n-        final WritableContent writableContent = downloadRequest.getWritableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            writableContent.takePersistableWritePermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                StorageBlobClient blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(downloadRequest.getStorageClientId());\n-                if (blobClient == null) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            downloadRequest.getStorageClientId()));\n-                    return;\n-                }\n-\n-                long blobSize = blobClient.getBlobProperties(downloadRequest.getContainerName(), downloadRequest.getBlobName()).getContentLength();\n-                BlobDownloadEntity blob = new BlobDownloadEntity(downloadRequest.getStorageClientId(),\n-                    downloadRequest.getContainerName(),\n-                    downloadRequest.getBlobName(),\n-                    blobSize,\n-                    writableContent,\n-                    downloadRequest.getConstraints());\n-                List<BlockDownloadEntity> blocks\n-                    = BlockDownloadEntity.createBlockEntities(blobSize, Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.downloadDao().createDownloadRecord(blob, blocks);\n-\n-                Log.v(TAG, \"download(): Download record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest downloadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(DownloadWorker.class)\n-                    .setConstraints(downloadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"download(): enqueuing DownloadWorker: \" + transferId);\n-\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        downloadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Pause a transfer identified by the given transfer id. The pause operation\n-     * is a best-effort, and a transfer that is already executing may continue to\n-     * transfer.\n-     *\n-     * Upon successful scheduling of the pause, any observer observing on\n-     * the {@link LiveData} for this transfer receives a {@link TransferInfo}\n-     * event with state {@link TransferInfo.State#USER_PAUSED}.\n-     *\n-     * @param transferId The transfer id identifies the transfer to pause.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void pause(long transferId) {\n-        // UI_Thread\n-        final TransferIdInfoLiveData.TransferFlags transferFlags = transferIdInfoCache.getTransferFlags(transferId);\n-\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    }\n-\n-                    if (transferFlags != null) {\n-                        transferFlags.setUserPaused();\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule pause for the transfer:\" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Resume a paused transfer.\n-     *\n-     * @param transferId The transfer id identifies the transfer to resume.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n-     */\n-    public LiveData<TransferInfo> resume(long transferId) {\n-        // UI_Thread\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final ResumeCheck resumeCheck = checkResumeable(transferId, transferOpResultLiveData);\n-\n-                if (resumeCheck.canResume) {\n-                    final OneTimeWorkRequest workRequest;\n-                    String blobTransferIdKey, logMessage;\n-                    Class<? extends ListenableWorker> workerClass;\n-\n-                    if (resumeCheck.isUpload) {\n-                        blobTransferIdKey = UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY;\n-                        logMessage = \"Upload::resume() Enqueuing UploadWorker: \" + transferId;\n-                        workerClass = UploadWorker.class;\n-                    } else { // Download\n-                        blobTransferIdKey = DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY;\n-                        logMessage = \"Download::resume() Enqueuing DownloadWorker: \" + transferId;\n-                        workerClass = DownloadWorker.class;\n-                    }\n-\n-                    Data inputData = new Data.Builder()\n-                        .putLong(blobTransferIdKey, transferId)\n-                        .build();\n-                    workRequest = new OneTimeWorkRequest\n-                        .Builder(workerClass)\n-                        .setConstraints(resumeCheck.constraints)\n-                        .setInputData(inputData)\n-                        .build();\n-\n-                    Log.v(TAG, logMessage);\n-\n-                    // resume() will resubmit the work to WorkManager with the policy as KEEP.\n-                    // With this policy, if the work is already running, then this resume() call is NO-OP,\n-                    // we return the LiveData to the caller that streams the TransferInfo events of\n-                    // the already running work.\n-                    workManager\n-                        .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                            ExistingWorkPolicy.KEEP,\n-                            workRequest)\n-                        .enqueue();\n-                    transferOpResultLiveData\n-                        .postValue(TransferOperationResult.id(TransferOperationResult.Operation.RESUME, transferId));\n-                }\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.RESUME, e));\n-            }\n-        });\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, true);\n-    }\n-\n-    /**\n-     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n-     * that is already executing may continue to transfer.\n-     *\n-     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n-     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n-     *\n-     * @param transferId The transfer ID identifies the transfer to cancel.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void cancel(long transferId) {\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule cancellation for transfer with ID: \" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get unique name for a transfer work.\n-     *\n-     * @param transferId The transfer id.\n-     * @return The name for the transfer work.\n-     */\n-    static String toTransferUniqueWorkName(long transferId) {\n-        return \"azure_transfer_\" + transferId;\n-    }\n-\n-    /**\n-     * Subscribe to a TransferOperationResult LiveData and transform that to TransferInfo LiveData.\n-     *\n-     * This method caches or uses cached {@link LiveData} to stream {@link TransferInfo}.\n-     * If provided TransferOperationResult LiveData emits an error, then cache won't be used.\n-     *\n-     * @param transferOpResultLiveData The LiveData to channel transfer operation initiation result\n-     * @param isResume True if the transfer id emitted by the transferOpResultLiveData LiveData\n-     *   identifies a transfer to be resumed, false for a new upload or download transfer.\n-     * @return The TransferInfo LiveData.\n-     */\n-    @MainThread\n-    private LiveData<TransferInfo> toCachedTransferInfoLiveData(LiveData<TransferOperationResult> transferOpResultLiveData,\n-                                                                boolean isResume) {\n-        // UI_Thread\n-        return Transformations.switchMap(transferOpResultLiveData, transferOpResult -> {\n-            if (transferOpResult.isError()) {\n-                final TransferIdInfoLiveData.Result result = TransferIdInfoLiveData.create(workManager);\n-                final TransferIdInfoLiveData.LiveDataPair pair = result.getLiveDataPair();\n-                pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                return pair.getTransferInfoLiveData();\n-            } else {\n-                if (isResume) {\n-                    // If the application process already has a cached LiveData pair for the same transfer,\n-                    // then use it, otherwise create, cache, and use.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.getOrCreate(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                } else {\n-                    // For a new upload or download transfer, create a transfer LiveData pair\n-                    // (TransferOperationResult, TransferInfo) cache entry and use them.\n-                    // Any future resume operation on the same transfer will use this pair\n-                    // as long as:\n-                    //     1. both upload or download transfer, and the corresponding resume happens\n-                    //        in the same application process\n-                    //     2. and the cache entry is not GC-ed.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.create(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be resumed.\n-     *\n-     * @param transferId Identifies the transfer to check for resume eligibility.\n-     * @param transferOpResultLiveData The LiveData to post the error if the transfer cannot be resumed.\n-     * @return Result of check.\n-     */\n-    private ResumeCheck checkResumeable(long transferId,\n-                                        MutableLiveData<TransferOperationResult> transferOpResultLiveData) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-        String storageBlobClientId = null;\n-        Constraints constraints = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-            storageBlobClientId = uploadBlob.storageBlobClientId;\n-            constraints = uploadBlob.constraintsColumn.toConstraints();\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-                storageBlobClientId = downloadBlob.storageBlobClientId;\n-                constraints = downloadBlob.constraintsColumn.toConstraints();\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            transferOpResultLiveData.postValue(TransferOperationResult.notFoundError(transferId));\n-\n-            return new ResumeCheck(false, false, constraints);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInFailedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInCompletedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(storageBlobClientId)) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadBlob.storageBlobClientId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            }\n-\n-            return new ResumeCheck(true, true, constraints);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkResumeable(long, MutableLiveData)}} **/\n-    private static final class ResumeCheck {\n-        // Flag indicating whether transfer can be resumed.\n-        final boolean canResume;\n-        // If the transfer can be resumed then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-        // The constraints to be satisfied to resume the transfer.\n-        final Constraints constraints;\n-\n-        ResumeCheck(boolean canResume, boolean isUpload, Constraints constraints) {\n-            this.canResume = canResume;\n-            this.isUpload = isUpload;\n-            this.constraints = constraints;\n-        }\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be stopped (paused/cancelled).\n-     *\n-     * @param transferId Identifies the transfer to check for stopping eligibility.\n-     * @return Result of check.\n-     */\n-    private StopCheck checkStoppable(long transferId) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            return new StopCheck(false, false);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                return new StopCheck(false, true);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                return new StopCheck(false, true);\n-            }\n-\n-            return new StopCheck(true, true);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkStoppable(long)}} **/\n-    private static final class StopCheck {\n-        // Flag indicating whether transfer can be paused or cancelled.\n-        private final boolean canStop;\n-        // If the transfer can be paused or cancelled then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-\n-        private StopCheck(boolean canStop, boolean isUpload) {\n-            this.canStop = canStop;\n-            this.isUpload = isUpload;\n-        }\n-    }\n-\n-    private static final class Constants {\n-        static final int KB = 1024;\n-        static final int MB = 1024 * KB;\n-        static final int DEFAULT_BLOCK_SIZE = 10 * Constants.MB;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433438522", "body": "What is the difference with the upload() URI overload where the useContentResolver value is set to true? Are we setting it to false here because the content would not yet exist in storage when this is called?", "bodyText": "What is the difference with the upload() URI overload where the useContentResolver value is set to true? Are we setting it to false here because the content would not yet exist in storage when this is called?", "bodyHTML": "<p dir=\"auto\">What is the difference with the upload() URI overload where the useContentResolver value is set to true? Are we setting it to false here because the content would not yet exist in storage when this is called?</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:21:37Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -135,9 +182,51 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param containerName The container to download the blob from.\n+     * @param blobName The name of the target blob to download.\n+     * @param contentUri The uri to the local content to write the downloaded blob\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, contentUri, false));", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4MzQ0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433483444", "bodyText": "if useContentResolver is false, it means the user-provided already resolved File object hence it is ok to use the raw path. If useContentResolver is true then it means the user provided a contentUri which we treat as an opaque handle and we don't look into the raw path.", "author": "anuchandy", "createdAt": "2020-06-01T20:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMjU4Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433522587", "bodyText": "How probable do you think it is that we get an unresolved URI for download?", "author": "vcolin7", "createdAt": "2020-06-01T22:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzMzAyNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433533024", "bodyText": "How probably do you think it is that we get an \"unresolved URI\" for download?\nBy \"unresolved URI\" do you mean a URI that always needed to go through ContentResolver? If so I think recommendation is - we should always use ContentResolver when user explicitly provide URI. For example, if we take Android official DownloadManager source code, it always uses ContentResolver and never touches the raw-path.", "author": "anuchandy", "createdAt": "2020-06-01T22:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzMzc3MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433533770", "bodyText": "I missed the source code ref to DownloadManager. Here it is: https://android.googlesource.com/platform/packages/providers/DownloadProvider/+/refs/heads/master/src/com/android/providers/downloads/DownloadThread.java#559", "author": "anuchandy", "createdAt": "2020-06-01T23:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzOTEyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433539127", "bodyText": "If the question is opposite - i.e., what are the chances that user can provide a File object which somehow requires ContentResolver, then may be if a user wants he can make up one, but I don't know what he is trying to achieve :(\nI think our rules are simple:\n\nIf the user provides a File object, we expect the library can directly read/write to the path it points to. (i.e the first/existing impl of download)\nIf the user provides a Uri object, then the user assumes the library uses Content resolution guidelines. Just like any other android API's that take Uri.", "author": "anuchandy", "createdAt": "2020-06-01T23:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NDkyMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433574923", "bodyText": "Sounds good to me. Based on that, shouldn't this particular overload (using contentUri) pass true to WritableContent?", "author": "vcolin7", "createdAt": "2020-06-02T01:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Njg3MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433576870", "bodyText": "ah. I see, yes it should be true,thanks for catching \ud83d\udc4d", "author": "anuchandy", "createdAt": "2020-06-02T01:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 8f13481ed..7c9443020 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -194,14 +194,14 @@ public class TransferClient {\n      * @param storageBlobClientId the identifier of the blob storage client to use for the download\n      * @param containerName The container to download the blob from.\n      * @param blobName The name of the target blob to download.\n-     * @param contentUri The uri to the local content to write the downloaded blob\n+     * @param contentUri The URI to the local content where the downloaded blob will be stored.\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n         return download(storageBlobClientId,\n             containerName,\n             blobName,\n-            new WritableContent(this.context, contentUri, false));\n+            new WritableContent(this.context, contentUri, true));\n     }\n \n     /**\n", "next_change": {"commit": "1d7f20437e061255e017de37aad4c6f3ec829001", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 7c9443020..237383fb2 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -207,13 +207,13 @@ public class TransferClient {\n     /**\n      * Download a blob.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param storageBlobClientId The identifier of the blob storage client to use for the download\n      * @param containerName The container to download the blob from.\n      * @param blobName The name of the target blob to download.\n-     * @param writableContent describes the Content in the device to store the downloaded blob.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     * @param writableContent Describes the Content in the device to store the downloaded blob.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n-    public LiveData<TransferInfo> download(String storageBlobClientId,\n+    private LiveData<TransferInfo> download(String storageBlobClientId,\n                                            String containerName,\n                                            String blobName,\n                                            WritableContent writableContent) {\n", "next_change": {"commit": "ee6b440720171bea25d4a1255aa9c64278583566", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\nindex 237383fb2..4722a1adf 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n", "chunk": "@@ -168,56 +145,17 @@ public class TransferClient {\n                     .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n             }\n         });\n-        // UI_Thread\n         return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n     }\n \n     /**\n      * Download a blob.\n      *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n-     * @param containerName The container to download the blob from.\n-     * @param blobName The name of the target blob to download.\n-     * @param file The local file to download to.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n-        return download(storageBlobClientId,\n-            containerName,\n-            blobName,\n-            new WritableContent(this.context, Uri.fromFile(file), false));\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n-     * @param containerName The container to download the blob from.\n-     * @param blobName The name of the target blob to download.\n-     * @param contentUri The URI to the local content where the downloaded blob will be stored.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     * @param downloadRequest Describes the download request.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n-    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n-        return download(storageBlobClientId,\n-            containerName,\n-            blobName,\n-            new WritableContent(this.context, contentUri, true));\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param storageBlobClientId The identifier of the blob storage client to use for the download\n-     * @param containerName The container to download the blob from.\n-     * @param blobName The name of the target blob to download.\n-     * @param writableContent Describes the Content in the device to store the downloaded blob.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    private LiveData<TransferInfo> download(String storageBlobClientId,\n-                                           String containerName,\n-                                           String blobName,\n-                                           WritableContent writableContent) {\n-        // UI_Thread\n+    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n+        final WritableContent writableContent = downloadRequest.getWritableContent();\n         final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n         try {\n             // Take permission immediately in the UI_Thread (granting may require UI interaction).\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\ndeleted file mode 100644\nindex 4722a1adf..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.util.Log;\n-\n-import androidx.annotation.MainThread;\n-import androidx.annotation.NonNull;\n-import androidx.lifecycle.LiveData;\n-import androidx.lifecycle.MutableLiveData;\n-import androidx.lifecycle.Transformations;\n-import androidx.work.Constraints;\n-import androidx.work.Data;\n-import androidx.work.ExistingWorkPolicy;\n-import androidx.work.ListenableWorker;\n-import androidx.work.OneTimeWorkRequest;\n-import androidx.work.WorkManager;\n-import androidx.work.impl.WorkManagerImpl;\n-\n-import com.azure.android.storage.blob.StorageBlobClient;\n-\n-import java.util.List;\n-import java.util.concurrent.Executors;\n-\n-/**\n- * A type that exposes blob transfer APIs.\n- */\n-public final class TransferClient {\n-    private static final String TAG = TransferClient.class.getSimpleName();\n-    // the executor for internal book keeping.\n-    private SerialExecutor serialTaskExecutor;\n-    // reference to the database holding transfer entities.\n-    private final TransferDatabase db;\n-    // reference to the androidx work manager.\n-    private final WorkManager workManager;\n-    // track the active (not collected by GC) Transfers.\n-    private final TransferIdInfoLiveDataCache transferIdInfoCache = new TransferIdInfoLiveDataCache();\n-    // The singleton TransferClient.\n-    private static TransferClient INSTANCE = null;\n-    // An object to synchronize the creation of the singleton TransferClient.\n-    private static final Object INIT_LOCK = new Object();\n-    // the static shared map of StorageBlobClient instances for transfers, with package\n-    // scoped access. StorageBlobClient instances are added from TransferClient.Builder\n-    // and used by Upload|Download handlers.\n-    static final StorageBlobClientMap STORAGE_BLOB_CLIENTS;\n-\n-    static {\n-        STORAGE_BLOB_CLIENTS = StorageBlobClientMap.getInstance();\n-    }\n-\n-    /**\n-     * Retrieves the singleton instance of {@link TransferClient}.\n-     *\n-     * @param context A {@link Context} for on-demand initialization.\n-     * @return The singleton instance of {@link TransferClient}.\n-     * @throws IllegalStateException If underlying Database or {@link WorkManager} is not initialized properly.\n-     */\n-    public static @NonNull TransferClient getInstance(@NonNull Context context) throws IllegalStateException {\n-        synchronized (INIT_LOCK) {\n-            if (INSTANCE == null) {\n-                INSTANCE = new TransferClient(context.getApplicationContext());\n-            }\n-            return INSTANCE;\n-        }\n-    }\n-\n-    /**\n-     * Create an instance of {@link TransferClient}.\n-     *\n-     * @param applicationContext The application {@link Context} for on-demand initialization.\n-     */\n-    @SuppressLint(\"RestrictedApi\")\n-    private TransferClient(Context applicationContext) {\n-        this.db = TransferDatabase.getInstance(applicationContext);\n-        this.workManager = WorkManager.getInstance(applicationContext);\n-        try {\n-            // Reference: https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043\n-            //\n-            // Try to re-use the existing taskExecutor shared by WorkManager.\n-            WorkManagerImpl wmImpl = (WorkManagerImpl)this.workManager;\n-            this.serialTaskExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n-        } catch (Exception ignored) {\n-            // Create our own small ThreadPoolExecutor if we can't.\n-            this.serialTaskExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n-        }\n-    }\n-\n-    /**\n-     * Upload the content described by the given {@link ReadableContent}.\n-     *\n-     * @param uploadRequest Describes the upload request.\n-     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n-     */\n-    public LiveData<TransferInfo> upload(UploadRequest uploadRequest) {\n-        final ReadableContent readableContent = uploadRequest.getReadableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            readableContent.takePersistableReadPermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(uploadRequest.getStorageClientId())) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadRequest.getStorageClientId()));\n-                    return;\n-                }\n-                BlobUploadEntity blob = new BlobUploadEntity(uploadRequest.getStorageClientId(),\n-                    uploadRequest.getContainerName(),\n-                    uploadRequest.getBlobName(),\n-                    readableContent,\n-                    uploadRequest.getConstraints());\n-                List<BlockUploadEntity> blocks\n-                    = BlockUploadEntity.createBlockEntities(readableContent.getLength(), Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.uploadDao().createUploadRecord(blob, blocks);\n-                Log.v(TAG, \"upload(): upload record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(UploadWorker.class)\n-                    .setConstraints(uploadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + transferId);\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        uploadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Throwable e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Download a blob.\n-     *\n-     * @param downloadRequest Describes the download request.\n-     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n-     */\n-    public LiveData<TransferInfo> download(DownloadRequest downloadRequest) {\n-        final WritableContent writableContent = downloadRequest.getWritableContent();\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        try {\n-            // Take permission immediately in the UI_Thread (granting may require UI interaction).\n-            writableContent.takePersistableWritePermission();\n-        } catch (Throwable e) {\n-            transferOpResultLiveData\n-                .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-        }\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                StorageBlobClient blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(downloadRequest.getStorageClientId());\n-                if (blobClient == null) {\n-                    transferOpResultLiveData.postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            downloadRequest.getStorageClientId()));\n-                    return;\n-                }\n-\n-                long blobSize = blobClient.getBlobProperties(downloadRequest.getContainerName(), downloadRequest.getBlobName()).getContentLength();\n-                BlobDownloadEntity blob = new BlobDownloadEntity(downloadRequest.getStorageClientId(),\n-                    downloadRequest.getContainerName(),\n-                    downloadRequest.getBlobName(),\n-                    blobSize,\n-                    writableContent,\n-                    downloadRequest.getConstraints());\n-                List<BlockDownloadEntity> blocks\n-                    = BlockDownloadEntity.createBlockEntities(blobSize, Constants.DEFAULT_BLOCK_SIZE);\n-                long transferId = db.downloadDao().createDownloadRecord(blob, blocks);\n-\n-                Log.v(TAG, \"download(): Download record created: \" + transferId);\n-\n-                Data inputData = new Data.Builder()\n-                    .putLong(DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY, transferId)\n-                    .build();\n-                OneTimeWorkRequest downloadWorkRequest = new OneTimeWorkRequest\n-                    .Builder(DownloadWorker.class)\n-                    .setConstraints(downloadRequest.getConstraints())\n-                    .setInputData(inputData)\n-                    .build();\n-\n-                Log.v(TAG, \"download(): enqueuing DownloadWorker: \" + transferId);\n-\n-                workManager\n-                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                        ExistingWorkPolicy.KEEP,\n-                        downloadWorkRequest)\n-                    .enqueue();\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.id(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, transferId));\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.UPLOAD_DOWNLOAD, e));\n-            }\n-        });\n-\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, false);\n-    }\n-\n-    /**\n-     * Pause a transfer identified by the given transfer id. The pause operation\n-     * is a best-effort, and a transfer that is already executing may continue to\n-     * transfer.\n-     *\n-     * Upon successful scheduling of the pause, any observer observing on\n-     * the {@link LiveData} for this transfer receives a {@link TransferInfo}\n-     * event with state {@link TransferInfo.State#USER_PAUSED}.\n-     *\n-     * @param transferId The transfer id identifies the transfer to pause.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void pause(long transferId) {\n-        // UI_Thread\n-        final TransferIdInfoLiveData.TransferFlags transferFlags = transferIdInfoCache.getTransferFlags(transferId);\n-\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_PAUSED);\n-                    }\n-\n-                    if (transferFlags != null) {\n-                        transferFlags.setUserPaused();\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule pause for the transfer:\" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Resume a paused transfer.\n-     *\n-     * @param transferId The transfer id identifies the transfer to resume.\n-     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n-     */\n-    public LiveData<TransferInfo> resume(long transferId) {\n-        // UI_Thread\n-        final MutableLiveData<TransferOperationResult> transferOpResultLiveData = new MutableLiveData<>();\n-        this.serialTaskExecutor.execute(() -> {\n-            // BG_Thread\n-            try {\n-                final ResumeCheck resumeCheck = checkResumeable(transferId, transferOpResultLiveData);\n-\n-                if (resumeCheck.canResume) {\n-                    final OneTimeWorkRequest workRequest;\n-                    String blobTransferIdKey, logMessage;\n-                    Class<? extends ListenableWorker> workerClass;\n-\n-                    if (resumeCheck.isUpload) {\n-                        blobTransferIdKey = UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY;\n-                        logMessage = \"Upload::resume() Enqueuing UploadWorker: \" + transferId;\n-                        workerClass = UploadWorker.class;\n-                    } else { // Download\n-                        blobTransferIdKey = DownloadWorker.Constants.INPUT_BLOB_DOWNLOAD_ID_KEY;\n-                        logMessage = \"Download::resume() Enqueuing DownloadWorker: \" + transferId;\n-                        workerClass = DownloadWorker.class;\n-                    }\n-\n-                    Data inputData = new Data.Builder()\n-                        .putLong(blobTransferIdKey, transferId)\n-                        .build();\n-                    workRequest = new OneTimeWorkRequest\n-                        .Builder(workerClass)\n-                        .setConstraints(resumeCheck.constraints)\n-                        .setInputData(inputData)\n-                        .build();\n-\n-                    Log.v(TAG, logMessage);\n-\n-                    // resume() will resubmit the work to WorkManager with the policy as KEEP.\n-                    // With this policy, if the work is already running, then this resume() call is NO-OP,\n-                    // we return the LiveData to the caller that streams the TransferInfo events of\n-                    // the already running work.\n-                    workManager\n-                        .beginUniqueWork(toTransferUniqueWorkName(transferId),\n-                            ExistingWorkPolicy.KEEP,\n-                            workRequest)\n-                        .enqueue();\n-                    transferOpResultLiveData\n-                        .postValue(TransferOperationResult.id(TransferOperationResult.Operation.RESUME, transferId));\n-                }\n-            } catch (Exception e) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult.error(TransferOperationResult.Operation.RESUME, e));\n-            }\n-        });\n-        // UI_Thread\n-        return toCachedTransferInfoLiveData(transferOpResultLiveData, true);\n-    }\n-\n-    /**\n-     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n-     * that is already executing may continue to transfer.\n-     *\n-     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n-     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n-     *\n-     * @param transferId The transfer ID identifies the transfer to cancel.\n-     */\n-    // P2: Currently no return value, evaluate any possible return value later.\n-    public void cancel(long transferId) {\n-        this.serialTaskExecutor.execute(() -> {\n-            try {\n-                final StopCheck stopCheck = checkStoppable(transferId);\n-\n-                if (stopCheck.canStop) {\n-                    if (stopCheck.isUpload) {\n-                        db.uploadDao().updateUploadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    } else {\n-                        db.downloadDao().updateDownloadInterruptState(transferId, TransferInterruptState.USER_CANCELLED);\n-                    }\n-\n-                    workManager\n-                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n-                }\n-            } catch (Exception e) {\n-                Log.e(TAG, \"Unable to schedule cancellation for transfer with ID: \" + transferId, e);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get unique name for a transfer work.\n-     *\n-     * @param transferId The transfer id.\n-     * @return The name for the transfer work.\n-     */\n-    static String toTransferUniqueWorkName(long transferId) {\n-        return \"azure_transfer_\" + transferId;\n-    }\n-\n-    /**\n-     * Subscribe to a TransferOperationResult LiveData and transform that to TransferInfo LiveData.\n-     *\n-     * This method caches or uses cached {@link LiveData} to stream {@link TransferInfo}.\n-     * If provided TransferOperationResult LiveData emits an error, then cache won't be used.\n-     *\n-     * @param transferOpResultLiveData The LiveData to channel transfer operation initiation result\n-     * @param isResume True if the transfer id emitted by the transferOpResultLiveData LiveData\n-     *   identifies a transfer to be resumed, false for a new upload or download transfer.\n-     * @return The TransferInfo LiveData.\n-     */\n-    @MainThread\n-    private LiveData<TransferInfo> toCachedTransferInfoLiveData(LiveData<TransferOperationResult> transferOpResultLiveData,\n-                                                                boolean isResume) {\n-        // UI_Thread\n-        return Transformations.switchMap(transferOpResultLiveData, transferOpResult -> {\n-            if (transferOpResult.isError()) {\n-                final TransferIdInfoLiveData.Result result = TransferIdInfoLiveData.create(workManager);\n-                final TransferIdInfoLiveData.LiveDataPair pair = result.getLiveDataPair();\n-                pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                return pair.getTransferInfoLiveData();\n-            } else {\n-                if (isResume) {\n-                    // If the application process already has a cached LiveData pair for the same transfer,\n-                    // then use it, otherwise create, cache, and use.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.getOrCreate(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                } else {\n-                    // For a new upload or download transfer, create a transfer LiveData pair\n-                    // (TransferOperationResult, TransferInfo) cache entry and use them.\n-                    // Any future resume operation on the same transfer will use this pair\n-                    // as long as:\n-                    //     1. both upload or download transfer, and the corresponding resume happens\n-                    //        in the same application process\n-                    //     2. and the cache entry is not GC-ed.\n-                    final TransferIdInfoLiveData.LiveDataPair pair\n-                        = transferIdInfoCache.create(transferOpResult.getId(), workManager);\n-                    pair.getTransferOpResultLiveData().setValue(transferOpResult);\n-                    return pair.getTransferInfoLiveData();\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be resumed.\n-     *\n-     * @param transferId Identifies the transfer to check for resume eligibility.\n-     * @param transferOpResultLiveData The LiveData to post the error if the transfer cannot be resumed.\n-     * @return Result of check.\n-     */\n-    private ResumeCheck checkResumeable(long transferId,\n-                                        MutableLiveData<TransferOperationResult> transferOpResultLiveData) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-        String storageBlobClientId = null;\n-        Constraints constraints = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-            storageBlobClientId = uploadBlob.storageBlobClientId;\n-            constraints = uploadBlob.constraintsColumn.toConstraints();\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-                storageBlobClientId = downloadBlob.storageBlobClientId;\n-                constraints = downloadBlob.constraintsColumn.toConstraints();\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            transferOpResultLiveData.postValue(TransferOperationResult.notFoundError(transferId));\n-\n-            return new ResumeCheck(false, false, constraints);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInFailedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                transferOpResultLiveData.postValue(TransferOperationResult.alreadyInCompletedStateError(transferId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            } else if (!TransferClient.STORAGE_BLOB_CLIENTS.contains(storageBlobClientId)) {\n-                transferOpResultLiveData\n-                    .postValue(TransferOperationResult\n-                        .unresolvedStorageClientIdError(TransferOperationResult.Operation.UPLOAD_DOWNLOAD,\n-                            uploadBlob.storageBlobClientId));\n-\n-                return new ResumeCheck(false, true, constraints);\n-            }\n-\n-            return new ResumeCheck(true, true, constraints);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkResumeable(long, MutableLiveData)}} **/\n-    private static final class ResumeCheck {\n-        // Flag indicating whether transfer can be resumed.\n-        final boolean canResume;\n-        // If the transfer can be resumed then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-        // The constraints to be satisfied to resume the transfer.\n-        final Constraints constraints;\n-\n-        ResumeCheck(boolean canResume, boolean isUpload, Constraints constraints) {\n-            this.canResume = canResume;\n-            this.isUpload = isUpload;\n-            this.constraints = constraints;\n-        }\n-    }\n-\n-    /**\n-     * Do pre-validations to see a transfer can be stopped (paused/cancelled).\n-     *\n-     * @param transferId Identifies the transfer to check for stopping eligibility.\n-     * @return Result of check.\n-     */\n-    private StopCheck checkStoppable(long transferId) {\n-        // Check for transfer record\n-        BlobUploadEntity uploadBlob = db.uploadDao().getBlob(transferId);\n-        BlobTransferState blobTransferState = null;\n-\n-        if (uploadBlob != null) {\n-            blobTransferState = uploadBlob.state;\n-        } else {\n-            BlobDownloadEntity downloadBlob = db.downloadDao().getBlob(transferId);\n-\n-            if (downloadBlob != null) {\n-                blobTransferState = downloadBlob.state;\n-            }\n-        }\n-\n-        if (blobTransferState == null) {\n-            // No upload or download transfer found.\n-            return new StopCheck(false, false);\n-        } else {\n-            if (blobTransferState == BlobTransferState.FAILED) {\n-                return new StopCheck(false, true);\n-            } else if (blobTransferState == BlobTransferState.COMPLETED) {\n-                return new StopCheck(false, true);\n-            }\n-\n-            return new StopCheck(true, true);\n-        }\n-    }\n-\n-    /** Result of {@link this#checkStoppable(long)}} **/\n-    private static final class StopCheck {\n-        // Flag indicating whether transfer can be paused or cancelled.\n-        private final boolean canStop;\n-        // If the transfer can be paused or cancelled then this flag indicates the transfer type (upload|download).\n-        final boolean isUpload;\n-\n-        private StopCheck(boolean canStop, boolean isUpload) {\n-            this.canStop = canStop;\n-            this.isUpload = isUpload;\n-        }\n-    }\n-\n-    private static final class Constants {\n-        static final int KB = 1024;\n-        static final int MB = 1024 * KB;\n-        static final int DEFAULT_BLOCK_SIZE = 10 * Constants.MB;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzOTkwOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433439909", "body": "```suggestion\r\n                Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);\n          \n          \n            \n                            Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-smi\">Log</span><span class=\"pl-k\">.</span>e(<span class=\"pl-c1\">TAG</span>,  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>stageBlocks(): failure in reading content<span class=\"x x-first x-last\">:</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> block<span class=\"pl-k\">.</span>blockId <span class=\"pl-k\">+</span> threadName(), t);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-smi\">Log</span><span class=\"pl-k\">.</span>e(<span class=\"pl-c1\">TAG</span>,  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>stageBlocks(): failure in reading content<span class=\"x x-first x-last\">. Block id: </span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> block<span class=\"pl-k\">.</span>blockId<span class=\"x x-first\"> </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-s\"><span class=\"pl-pds x\">\"</span><span class=\"x\">. Thread name: </span><span class=\"pl-pds x x-last\">\"</span></span> <span class=\"pl-k\">+</span> threadName(), t);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:24:37Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java", "diffHunk": "@@ -277,10 +283,23 @@ private void stageBlocks(List<BlockUploadEntity> blocks) {\n         for (BlockUploadEntity block : blocks) {\n             this.finalizeIfStopped();\n             Log.v(TAG, \"stageBlocks(): Uploading block:\" + block.blockId + threadName());\n+            byte [] blockContent;\n+            try {\n+                blockContent = content.readBlock(block.blockOffset, block.blockSize);\n+            } catch (Throwable t) {\n+                Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MDY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433440683", "bodyText": "Making this a little easier to read. Although I would understand if you felt like explicitly talking about thread name and block id is not desired.", "author": "vcolin7", "createdAt": "2020-06-01T19:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzOTkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\nindex 6775e0eb3..60060aa4f 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n", "chunk": "@@ -287,7 +287,7 @@ final class UploadHandler extends Handler {\n             try {\n                 blockContent = content.readBlock(block.blockOffset, block.blockSize);\n             } catch (Throwable t) {\n-                Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);\n+                Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);\n                 db.uploadDao().updateBlockState(block.key, BlockTransferState.FAILED);\n                 block.setStagingError(t);\n                 Message nextMessage = UploadHandlerMessage\n", "next_change": {"commit": "213c93409759e10c597eef72b1fea28a3c6f8270", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\nindex 60060aa4f..29a243a4b 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n", "chunk": "@@ -296,13 +293,20 @@ final class UploadHandler extends Handler {\n                 return;\n             }\n \n-            ServiceCall call = this.blobClient.stageBlock(this.blob.containerName,\n+            this.blobClient.stageBlockWithRestResponse(this.blob.containerName,\n                 this.blob.blobName,\n                 block.blockId,\n                 blockContent,\n-                null, new com.azure.android.core.http.Callback<Void>() {\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                this.cancellationToken,\n+                new com.azure.android.core.http.Callback<BlockBlobsStageBlockResponse>() {\n                     @Override\n-                    public void onResponse(Void response) {\n+                    public void onResponse(BlockBlobsStageBlockResponse response) {\n                         Log.v(TAG, \"stageBlocks(): Block uploaded:\" + block.blockId + threadName());\n                         db.uploadDao().updateBlockState(block.key, BlockTransferState.COMPLETED);\n                         Message nextMessage = UploadHandlerMessage\n", "next_change": {"commit": "8c7babc862d9b9a81d57d98b31ae5e09702dbacf", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\nindex 29a243a4b..8f7f098e0 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n", "chunk": "@@ -304,9 +308,9 @@ final class UploadHandler extends Handler {\n                 null,\n                 null,\n                 this.cancellationToken,\n-                new com.azure.android.core.http.Callback<BlockBlobsStageBlockResponse>() {\n+                new CallbackWithHeader<Void, BlockBlobStageBlockHeaders>() {\n                     @Override\n-                    public void onResponse(BlockBlobsStageBlockResponse response) {\n+                    public void onSuccess(Void result, BlockBlobStageBlockHeaders header, Response response) {\n                         Log.v(TAG, \"stageBlocks(): Block uploaded:\" + block.blockId + threadName());\n                         db.uploadDao().updateBlockState(block.key, BlockTransferState.COMPLETED);\n                         Message nextMessage = UploadHandlerMessage\n", "next_change": {"commit": "0ef4de95021f90c07c3e888cd740592cf7e924c4", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\nindex 8f7f098e0..4e8316fb6 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n", "chunk": "@@ -306,7 +306,6 @@ final class UploadHandler extends Handler {\n                 null,\n                 null,\n                 null,\n-                null,\n                 this.cancellationToken,\n                 new CallbackWithHeader<Void, BlockBlobStageBlockHeaders>() {\n                     @Override\n", "next_change": {"commit": "b7a2567cf6f0dda2941a806aeb48081e4458dfc2", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\nindex 4e8316fb6..d5bf2aea2 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n", "chunk": "@@ -303,6 +303,7 @@ final class UploadHandler extends Handler {\n                 blockContent,\n                 null,\n                 null,\n+                this.blob.computeMd5,\n                 null,\n                 null,\n                 null,\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\ndeleted file mode 100644\nindex d5bf2aea2..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,383 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import android.os.Looper;\n-import android.os.Message;\n-import android.util.Log;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.azure.android.core.http.CallbackWithHeader;\n-import com.azure.android.core.util.CancellationToken;\n-import com.azure.android.storage.blob.StorageBlobAsyncClient;\n-import com.azure.android.storage.blob.models.BlockBlobCommitBlockListHeaders;\n-import com.azure.android.storage.blob.models.BlockBlobItem;\n-import com.azure.android.storage.blob.models.BlockBlobStageBlockHeaders;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import okhttp3.Response;\n-\n-/**\n- * Package private.\n- *\n- * Handler that manages a single file upload.\n- *\n- * Handler is a state machine, {@link UploadHandlerMessage.Type} represents various stages\n- * that the state machine goes through. Handler react to each stage appropriately.\n- * Reacting to stage includes - initialization, starting async block upload operations and\n- * blocks commit operation, handling failure in operations, parking the work if the handler\n- * reaches stop state.\n- *\n- * Additionally Handler is responsible for notifying {@link TransferHandlerListener} on various events.\n- * Calls to this listener methods are serialized, i.e. these methods won't be called concurrently.\n- */\n-final class UploadHandler extends Handler {\n-    private static final String TAG = UploadHandler.class.getSimpleName();\n-\n-    private final Context appContext;\n-    private final int blocksUploadConcurrency;\n-    private final long uploadId;\n-    private final HashMap<String, BlockUploadEntity> runningBlockUploads;\n-    private final TransferStopToken transferStopToken;\n-    private final CancellationToken cancellationToken;\n-\n-    private TransferHandlerListener transferHandlerListener;\n-    private TransferDatabase db;\n-    private BlobUploadEntity blob;\n-    private long totalBytesUploaded;\n-    private BlockUploadRecordsEnumerator blocksItr;\n-    //  The content in the device representing the data to be read and uploaded.\n-    private ReadableContent content;\n-    private StorageBlobAsyncClient blobClient;\n-\n-    /**\n-     * Create and initializes {@link UploadHandler}.\n-     *\n-     * @param looper the looper to react on messages describing various file upload stages\n-     * @param appContext the context\n-     * @param blocksUploadConcurrency the number of blocks to be uploaded in parallel\n-     * @param uploadId the identifier to a {@link BlobUploadEntity} in the local store, describing\n-     *     the file to be uploaded\n-     */\n-    private UploadHandler(Looper looper, Context appContext, int blocksUploadConcurrency, long uploadId) {\n-        super(looper);\n-        this.appContext = appContext;\n-        this.blocksUploadConcurrency = blocksUploadConcurrency;\n-        this.uploadId = uploadId;\n-        this.runningBlockUploads = new HashMap<>(this.blocksUploadConcurrency);\n-        this.transferStopToken = new TransferStopToken(UploadHandlerMessage.createStopMessage(this));\n-        this.cancellationToken = CancellationToken.create();\n-    }\n-\n-    /**\n-     * Creates {@link UploadHandler} for handling a single file upload.\n-     *\n-     * @param appContext the context\n-     * @param blocksUploadConcurrency the number of blocks to be uploaded in parallel\n-     * @param uploadId the identifier to a {@link BlobUploadEntity} in the local store, describing the\n-     *     file to be uploaded\n-     * @return the UploadHandler\n-     */\n-    static UploadHandler create(@NonNull Context appContext, int blocksUploadConcurrency, long uploadId) {\n-        Objects.requireNonNull(appContext, \"Application Context is null.\");\n-        final HandlerThread handlerThread = new HandlerThread(\"UploadHandlerThread\");\n-        handlerThread.start();\n-        return new UploadHandler(handlerThread.getLooper(), appContext, blocksUploadConcurrency, uploadId);\n-    }\n-\n-    /**\n-     * Begin uploading the file.\n-     *\n-     * @param transferHandlerListener the listener to send the upload events\n-     * @return the token to stop the upload\n-     */\n-    TransferStopToken beginUpload(TransferHandlerListener transferHandlerListener) {\n-        this.transferHandlerListener =\n-            Objects.requireNonNull(transferHandlerListener, \"transferHandlerListener is null.\");\n-        Log.i(TAG, \"beginUpload(): uploadId:\" + this.uploadId);\n-        Message message = UploadHandlerMessage.createInitMessage(this);\n-        message.sendToTarget();\n-        return this.transferStopToken;\n-    }\n-\n-    @Override\n-    public void handleMessage(Message msg) {\n-        this.finalizeIfStopped();\n-        int msgType = UploadHandlerMessage.getMessageType(msg);\n-        switch (msgType) {\n-            case UploadHandlerMessage.Type.INIT:\n-                Log.v(TAG, \"handleMessage(): received message: INIT\");\n-                this.handleInit();\n-                break;\n-            case UploadHandlerMessage.Type.STAGING_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: STAGING_COMPLETED\");\n-                this.handleStagingCompleted(msg);\n-                break;\n-            case UploadHandlerMessage.Type.STAGING_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: STAGING_FAILED\");\n-                this.handleStagingFailed(msg);\n-                break;\n-            case UploadHandlerMessage.Type.COMMIT_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: COMMIT_COMPLETED\");\n-                this.handleCommitCompleted();\n-                break;\n-            case UploadHandlerMessage.Type.COMMIT_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: COMMIT_FAILED\");\n-                this.handleCommitFailed();\n-                break;\n-            case UploadHandlerMessage.Type.STOP:\n-                Log.v(TAG, \"handleMessage(): received message: STOP\");\n-                this.finalizeIfStopped();\n-                break;\n-            default:\n-        }\n-    }\n-\n-    /**\n-     * Handles file upload initialization message received by the handler.\n-     *\n-     * This stage acquires the db, storage client and other resources required through out\n-     * the life time of the Handler. This stage also starts a set of block upload async operations,\n-     * with the number of async operations equal to the configured blocksUploadConcurrency.\n-     */\n-    private void handleInit() {\n-        this.db = TransferDatabase.getInstance(this.appContext);\n-        this.blob = this.db.uploadDao().getBlob(uploadId);\n-        if (this.blob.interruptState == TransferInterruptState.PURGE) {\n-            this.transferHandlerListener.onError(new RuntimeException(\"Upload Operation with id '\"\n-                + this.uploadId + \"' is already CANCELLED and cannot be RESTARTED or RESUMED.\"));\n-            this.getLooper().quit();\n-        } else if (this.blob.state == BlobTransferState.COMPLETED) {\n-            this.transferHandlerListener.onTransferProgress(blob.contentSize, blob.contentSize);\n-            this.transferHandlerListener.onComplete();\n-            this.getLooper().quit();\n-        } else {\n-            this.blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(this.blob.storageBlobClientId);\n-            if (this.blobClient == null) {\n-                this.transferHandlerListener\n-                    .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n-                this.getLooper().quit();\n-            } else {\n-                this.content = new ReadableContent(appContext,\n-                    Uri.parse(this.blob.contentUri),\n-                    this.blob.useContentResolver);\n-                this.totalBytesUploaded = this.db.uploadDao().getUploadedBytesCount(this.uploadId);\n-                this.transferHandlerListener.onTransferProgress(blob.contentSize, totalBytesUploaded);\n-                List<BlockTransferState> skip = new ArrayList();\n-                skip.add(BlockTransferState.COMPLETED);\n-                this.blocksItr = new BlockUploadRecordsEnumerator(this.db, this.uploadId, skip);\n-                List<BlockUploadEntity> blocks = this.blocksItr.getNext(this.blocksUploadConcurrency);\n-                if (blocks.size() == 0) {\n-                    this.commitBlocks();\n-                } else {\n-                    this.stageBlocks(blocks);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the block staging (upload) completion message received by the looper.\n-     * Such a completion message indicate that a single block is successfully uploaded.\n-     *\n-     * This stage notifies the progress to {@link TransferHandlerListener}. If there are more\n-     * blocks to be uploaded then it starts next block upload async operation, if there are no\n-     * more blocks to upload then it start a blocks commit async operation.\n-     *\n-     * @param message the message describing the block that completed staging\n-     */\n-    private void handleStagingCompleted(Message message) {\n-        this.finalizeIfStopped();\n-        String blockId = UploadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockUploadEntity blockStaged = this.runningBlockUploads.remove(blockId);\n-        this.totalBytesUploaded += blockStaged.blockSize;\n-        this.transferHandlerListener.onTransferProgress(this.blob.contentSize, this.totalBytesUploaded);\n-        List<BlockUploadEntity> blocks = blocksItr.getNext(1);\n-        if (blocks.isEmpty()) {\n-            if (runningBlockUploads.isEmpty()) {\n-                this.commitBlocks();\n-            }\n-        } else {\n-            this.stageBlocks(blocks);\n-        }\n-    }\n-\n-    /**\n-     * Handles the block staging (upload) failed message received by the looper.\n-     *\n-     * This stage cancel any running calls, notifies the failure to {@link TransferHandlerListener}\n-     * and terminates the handler.\n-     *\n-     * @param message the message describing the block that failed to stage\n-     */\n-    private void handleStagingFailed(Message message) {\n-        String blockId = UploadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockUploadEntity failedBlock = this.runningBlockUploads.remove(blockId);\n-        this.transferHandlerListener.onError(failedBlock.getStagingError());\n-        this.getLooper().quit();\n-    }\n-\n-    /**\n-     * Handles the blocks commit completion message received by the looper.\n-     *\n-     * This stage notifies the completion of file upload to {@link TransferHandlerListener}\n-     * and terminates the handler.\n-     */\n-    private void handleCommitCompleted() {\n-        this.transferHandlerListener.onTransferProgress(this.blob.contentSize, this.blob.contentSize);\n-        this.transferHandlerListener.onComplete();\n-        this.getLooper().quit();\n-    }\n-\n-    /**\n-     * Handles the blocks commit failed message received by the looper.\n-     *\n-     * This stage notifies the failure to {@link TransferHandlerListener} and terminates\n-     * the handler.\n-     */\n-    private void handleCommitFailed() {\n-        this.transferHandlerListener.onError(this.blob.getCommitError());\n-        this.getLooper().quit();\n-    }\n-\n-    /**\n-     * Check whether stop token is signalled, if so park the work and quit the looper.\n-     */\n-    private void finalizeIfStopped() {\n-        if (this.transferStopToken.isStopped()) {\n-            Log.v(TAG, \"finalizeIfStopped(): Stop request received, finalizing\");\n-            this.cancellationToken.cancel();\n-            TransferInterruptState interruptState = this.db.uploadDao().getTransferInterruptState(this.uploadId);\n-            Log.v(TAG, \"finalizeIfStopped: Stop request reason (NONE == Stop requested by SYSTEM): \" + interruptState);\n-            switch (interruptState) {\n-                case NONE:\n-                    this.transferHandlerListener.onSystemPaused();\n-                    break;\n-                case USER_PAUSED:\n-                    this.transferHandlerListener.onUserPaused();\n-                    break;\n-                case USER_CANCELLED:\n-                    this.db.uploadDao().updateUploadInterruptState(this.uploadId, TransferInterruptState.PURGE);\n-                    this.transferHandlerListener.onError(new TransferCancelledException(this.uploadId));\n-            }\n-            this.getLooper().quit();\n-        }\n-    }\n-\n-    /**\n-     * Starts the block upload async operations.\n-     *\n-     * @param blocks the blocks to be staged (uploaded).\n-     */\n-    private void stageBlocks(List<BlockUploadEntity> blocks) {\n-        for (BlockUploadEntity block : blocks) {\n-            this.finalizeIfStopped();\n-\n-            Log.v(TAG, \"stageBlocks(): Uploading block:\" + block.blockId + threadName());\n-            byte [] blockContent;\n-            try {\n-                blockContent = content.readBlock(block.blockOffset, block.blockSize);\n-            } catch (Throwable t) {\n-                Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);\n-                db.uploadDao().updateBlockState(block.key, BlockTransferState.FAILED);\n-                block.setStagingError(t);\n-                Message nextMessage = UploadHandlerMessage\n-                    .createStagingFailedMessage(UploadHandler.this, block.blockId);\n-                nextMessage.sendToTarget();\n-                return;\n-            }\n-\n-            this.blobClient.stageBlock(this.blob.containerName,\n-                this.blob.blobName,\n-                block.blockId,\n-                blockContent,\n-                null,\n-                null,\n-                this.blob.computeMd5,\n-                null,\n-                null,\n-                null,\n-                this.cancellationToken,\n-                new CallbackWithHeader<Void, BlockBlobStageBlockHeaders>() {\n-                    @Override\n-                    public void onSuccess(Void result, BlockBlobStageBlockHeaders header, Response response) {\n-                        Log.v(TAG, \"stageBlocks(): Block uploaded:\" + block.blockId + threadName());\n-                        db.uploadDao().updateBlockState(block.key, BlockTransferState.COMPLETED);\n-                        Message nextMessage = UploadHandlerMessage\n-                            .createStagingCompletedMessage(UploadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable throwable, Response response) {\n-                        Log.e(TAG,  \"stageBlocks(): Block upload failed:\" + block.blockId + threadName(), throwable);\n-                        db.uploadDao().updateBlockState(block.key, BlockTransferState.FAILED);\n-                        block.setStagingError(throwable);\n-                        Message nextMessage = UploadHandlerMessage\n-                            .createStagingFailedMessage(UploadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-                });\n-            this.runningBlockUploads.put(block.blockId, block);\n-        }\n-    }\n-\n-    /**\n-     * Starts the blocks commit async operation.\n-     */\n-    private void commitBlocks() {\n-        this.finalizeIfStopped();\n-\n-        Log.v(TAG, \"commitBlocks(): All blocks uploaded, committing them.\" + threadName());\n-\n-        List<String> blockIds = this.db.uploadDao().getBlockIds(this.uploadId);\n-\n-        this.blobClient.commitBlockList(blob.containerName,\n-            blob.blobName,\n-            blockIds,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            this.cancellationToken,\n-            new CallbackWithHeader<BlockBlobItem, BlockBlobCommitBlockListHeaders>() {\n-                @Override\n-                public void onSuccess(BlockBlobItem result, BlockBlobCommitBlockListHeaders header, Response response) {\n-                    Log.v(TAG, \"commitBlocks(): Blocks committed.\" + threadName());\n-                    db.uploadDao().updateBlobState(uploadId, BlobTransferState.COMPLETED);\n-                    Message nextMessage = UploadHandlerMessage\n-                        .createCommitCompletedMessage(UploadHandler.this);\n-                    nextMessage.sendToTarget();\n-                }\n-\n-                @Override\n-                public void onFailure(Throwable throwable, Response response) {\n-                    Log.e(TAG,  \"commitBlocks(): Blocks commit failed.\" + threadName(), throwable);\n-                    db.uploadDao().updateBlobState(uploadId, BlobTransferState.FAILED);\n-                    blob.setCommitError(throwable);\n-                    Message nextMessage = UploadHandlerMessage\n-                        .createCommitFailedMessage(UploadHandler.this);\n-                    nextMessage.sendToTarget();\n-                }\n-            });\n-    }\n-\n-    // For Debugging, will be removed (TODO: anuchan)\n-    private static String threadName() {\n-        return \" Thread:\" + Thread.currentThread().getName() + \"(\" + Thread.currentThread().getId() + \")\";\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\nindex 29a243a4b..8f7f098e0 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n", "chunk": "@@ -315,10 +319,10 @@ final class UploadHandler extends Handler {\n                     }\n \n                     @Override\n-                    public void onFailure(Throwable t) {\n-                        Log.e(TAG,  \"stageBlocks(): Block upload failed:\" + block.blockId + threadName(), t);\n+                    public void onFailure(Throwable throwable, Response response) {\n+                        Log.e(TAG,  \"stageBlocks(): Block upload failed:\" + block.blockId + threadName(), throwable);\n                         db.uploadDao().updateBlockState(block.key, BlockTransferState.FAILED);\n-                        block.setStagingError(t);\n+                        block.setStagingError(throwable);\n                         Message nextMessage = UploadHandlerMessage\n                             .createStagingFailedMessage(UploadHandler.this, block.blockId);\n                         nextMessage.sendToTarget();\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\ndeleted file mode 100644\nindex 8f7f098e0..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,384 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import android.os.Looper;\n-import android.os.Message;\n-import android.util.Log;\n-\n-import androidx.annotation.NonNull;\n-\n-import com.azure.android.core.http.CallbackWithHeader;\n-import com.azure.android.core.util.CancellationToken;\n-import com.azure.android.storage.blob.StorageBlobAsyncClient;\n-import com.azure.android.storage.blob.models.BlockBlobCommitBlockListHeaders;\n-import com.azure.android.storage.blob.models.BlockBlobItem;\n-import com.azure.android.storage.blob.models.BlockBlobStageBlockHeaders;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import okhttp3.Response;\n-\n-/**\n- * Package private.\n- *\n- * Handler that manages a single file upload.\n- *\n- * Handler is a state machine, {@link UploadHandlerMessage.Type} represents various stages\n- * that the state machine goes through. Handler react to each stage appropriately.\n- * Reacting to stage includes - initialization, starting async block upload operations and\n- * blocks commit operation, handling failure in operations, parking the work if the handler\n- * reaches stop state.\n- *\n- * Additionally Handler is responsible for notifying {@link TransferHandlerListener} on various events.\n- * Calls to this listener methods are serialized, i.e. these methods won't be called concurrently.\n- */\n-final class UploadHandler extends Handler {\n-    private static final String TAG = UploadHandler.class.getSimpleName();\n-\n-    private final Context appContext;\n-    private final int blocksUploadConcurrency;\n-    private final long uploadId;\n-    private final HashMap<String, BlockUploadEntity> runningBlockUploads;\n-    private final TransferStopToken transferStopToken;\n-    private final CancellationToken cancellationToken;\n-\n-    private TransferHandlerListener transferHandlerListener;\n-    private TransferDatabase db;\n-    private BlobUploadEntity blob;\n-    private long totalBytesUploaded;\n-    private BlockUploadRecordsEnumerator blocksItr;\n-    //  The content in the device representing the data to be read and uploaded.\n-    private ReadableContent content;\n-    private StorageBlobAsyncClient blobClient;\n-\n-    /**\n-     * Create and initializes {@link UploadHandler}.\n-     *\n-     * @param looper the looper to react on messages describing various file upload stages\n-     * @param appContext the context\n-     * @param blocksUploadConcurrency the number of blocks to be uploaded in parallel\n-     * @param uploadId the identifier to a {@link BlobUploadEntity} in the local store, describing\n-     *     the file to be uploaded\n-     */\n-    private UploadHandler(Looper looper, Context appContext, int blocksUploadConcurrency, long uploadId) {\n-        super(looper);\n-        this.appContext = appContext;\n-        this.blocksUploadConcurrency = blocksUploadConcurrency;\n-        this.uploadId = uploadId;\n-        this.runningBlockUploads = new HashMap<>(this.blocksUploadConcurrency);\n-        this.transferStopToken = new TransferStopToken(UploadHandlerMessage.createStopMessage(this));\n-        this.cancellationToken = CancellationToken.create();\n-    }\n-\n-    /**\n-     * Creates {@link UploadHandler} for handling a single file upload.\n-     *\n-     * @param appContext the context\n-     * @param blocksUploadConcurrency the number of blocks to be uploaded in parallel\n-     * @param uploadId the identifier to a {@link BlobUploadEntity} in the local store, describing the\n-     *     file to be uploaded\n-     * @return the UploadHandler\n-     */\n-    static UploadHandler create(@NonNull Context appContext, int blocksUploadConcurrency, long uploadId) {\n-        Objects.requireNonNull(appContext, \"Application Context is null.\");\n-        final HandlerThread handlerThread = new HandlerThread(\"UploadHandlerThread\");\n-        handlerThread.start();\n-        return new UploadHandler(handlerThread.getLooper(), appContext, blocksUploadConcurrency, uploadId);\n-    }\n-\n-    /**\n-     * Begin uploading the file.\n-     *\n-     * @param transferHandlerListener the listener to send the upload events\n-     * @return the token to stop the upload\n-     */\n-    TransferStopToken beginUpload(TransferHandlerListener transferHandlerListener) {\n-        this.transferHandlerListener =\n-            Objects.requireNonNull(transferHandlerListener, \"transferHandlerListener is null.\");\n-        Log.i(TAG, \"beginUpload(): uploadId:\" + this.uploadId);\n-        Message message = UploadHandlerMessage.createInitMessage(this);\n-        message.sendToTarget();\n-        return this.transferStopToken;\n-    }\n-\n-    @Override\n-    public void handleMessage(Message msg) {\n-        this.finalizeIfStopped();\n-        int msgType = UploadHandlerMessage.getMessageType(msg);\n-        switch (msgType) {\n-            case UploadHandlerMessage.Type.INIT:\n-                Log.v(TAG, \"handleMessage(): received message: INIT\");\n-                this.handleInit();\n-                break;\n-            case UploadHandlerMessage.Type.STAGING_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: STAGING_COMPLETED\");\n-                this.handleStagingCompleted(msg);\n-                break;\n-            case UploadHandlerMessage.Type.STAGING_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: STAGING_FAILED\");\n-                this.handleStagingFailed(msg);\n-                break;\n-            case UploadHandlerMessage.Type.COMMIT_COMPLETED:\n-                Log.v(TAG, \"handleMessage(): received message: COMMIT_COMPLETED\");\n-                this.handleCommitCompleted();\n-                break;\n-            case UploadHandlerMessage.Type.COMMIT_FAILED:\n-                Log.v(TAG, \"handleMessage(): received message: COMMIT_FAILED\");\n-                this.handleCommitFailed();\n-                break;\n-            case UploadHandlerMessage.Type.STOP:\n-                Log.v(TAG, \"handleMessage(): received message: STOP\");\n-                this.finalizeIfStopped();\n-                break;\n-            default:\n-        }\n-    }\n-\n-    /**\n-     * Handles file upload initialization message received by the handler.\n-     *\n-     * This stage acquires the db, storage client and other resources required through out\n-     * the life time of the Handler. This stage also starts a set of block upload async operations,\n-     * with the number of async operations equal to the configured blocksUploadConcurrency.\n-     */\n-    private void handleInit() {\n-        this.db = TransferDatabase.getInstance(this.appContext);\n-        this.blob = this.db.uploadDao().getBlob(uploadId);\n-        if (this.blob.interruptState == TransferInterruptState.PURGE) {\n-            this.transferHandlerListener.onError(new RuntimeException(\"Upload Operation with id '\"\n-                + this.uploadId + \"' is already CANCELLED and cannot be RESTARTED or RESUMED.\"));\n-            this.getLooper().quit();\n-        } else if (this.blob.state == BlobTransferState.COMPLETED) {\n-            this.transferHandlerListener.onTransferProgress(blob.contentSize, blob.contentSize);\n-            this.transferHandlerListener.onComplete();\n-            this.getLooper().quit();\n-        } else {\n-            this.blobClient = TransferClient.STORAGE_BLOB_CLIENTS.get(this.blob.storageBlobClientId);\n-            if (this.blobClient == null) {\n-                this.transferHandlerListener\n-                    .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n-                this.getLooper().quit();\n-            } else {\n-                this.content = new ReadableContent(appContext,\n-                    Uri.parse(this.blob.contentUri),\n-                    this.blob.useContentResolver);\n-                this.totalBytesUploaded = this.db.uploadDao().getUploadedBytesCount(this.uploadId);\n-                this.transferHandlerListener.onTransferProgress(blob.contentSize, totalBytesUploaded);\n-                List<BlockTransferState> skip = new ArrayList();\n-                skip.add(BlockTransferState.COMPLETED);\n-                this.blocksItr = new BlockUploadRecordsEnumerator(this.db, this.uploadId, skip);\n-                List<BlockUploadEntity> blocks = this.blocksItr.getNext(this.blocksUploadConcurrency);\n-                if (blocks.size() == 0) {\n-                    this.commitBlocks();\n-                } else {\n-                    this.stageBlocks(blocks);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the block staging (upload) completion message received by the looper.\n-     * Such a completion message indicate that a single block is successfully uploaded.\n-     *\n-     * This stage notifies the progress to {@link TransferHandlerListener}. If there are more\n-     * blocks to be uploaded then it starts next block upload async operation, if there are no\n-     * more blocks to upload then it start a blocks commit async operation.\n-     *\n-     * @param message the message describing the block that completed staging\n-     */\n-    private void handleStagingCompleted(Message message) {\n-        this.finalizeIfStopped();\n-        String blockId = UploadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockUploadEntity blockStaged = this.runningBlockUploads.remove(blockId);\n-        this.totalBytesUploaded += blockStaged.blockSize;\n-        this.transferHandlerListener.onTransferProgress(this.blob.contentSize, this.totalBytesUploaded);\n-        List<BlockUploadEntity> blocks = blocksItr.getNext(1);\n-        if (blocks.isEmpty()) {\n-            if (runningBlockUploads.isEmpty()) {\n-                this.commitBlocks();\n-            }\n-        } else {\n-            this.stageBlocks(blocks);\n-        }\n-    }\n-\n-    /**\n-     * Handles the block staging (upload) failed message received by the looper.\n-     *\n-     * This stage cancel any running calls, notifies the failure to {@link TransferHandlerListener}\n-     * and terminates the handler.\n-     *\n-     * @param message the message describing the block that failed to stage\n-     */\n-    private void handleStagingFailed(Message message) {\n-        String blockId = UploadHandlerMessage.getBlockIdFromMessage(message);\n-        BlockUploadEntity failedBlock = this.runningBlockUploads.remove(blockId);\n-        this.transferHandlerListener.onError(failedBlock.getStagingError());\n-        this.getLooper().quit();\n-    }\n-\n-    /**\n-     * Handles the blocks commit completion message received by the looper.\n-     *\n-     * This stage notifies the completion of file upload to {@link TransferHandlerListener}\n-     * and terminates the handler.\n-     */\n-    private void handleCommitCompleted() {\n-        this.transferHandlerListener.onTransferProgress(this.blob.contentSize, this.blob.contentSize);\n-        this.transferHandlerListener.onComplete();\n-        this.getLooper().quit();\n-    }\n-\n-    /**\n-     * Handles the blocks commit failed message received by the looper.\n-     *\n-     * This stage notifies the failure to {@link TransferHandlerListener} and terminates\n-     * the handler.\n-     */\n-    private void handleCommitFailed() {\n-        this.transferHandlerListener.onError(this.blob.getCommitError());\n-        this.getLooper().quit();\n-    }\n-\n-    /**\n-     * Check whether stop token is signalled, if so park the work and quit the looper.\n-     */\n-    private void finalizeIfStopped() {\n-        if (this.transferStopToken.isStopped()) {\n-            Log.v(TAG, \"finalizeIfStopped(): Stop request received, finalizing\");\n-            this.cancellationToken.cancel();\n-            TransferInterruptState interruptState = this.db.uploadDao().getTransferInterruptState(this.uploadId);\n-            Log.v(TAG, \"finalizeIfStopped: Stop request reason (NONE == Stop requested by SYSTEM): \" + interruptState);\n-            switch (interruptState) {\n-                case NONE:\n-                    this.transferHandlerListener.onSystemPaused();\n-                    break;\n-                case USER_PAUSED:\n-                    this.transferHandlerListener.onUserPaused();\n-                    break;\n-                case USER_CANCELLED:\n-                    this.db.uploadDao().updateUploadInterruptState(this.uploadId, TransferInterruptState.PURGE);\n-                    this.transferHandlerListener.onError(new TransferCancelledException(this.uploadId));\n-            }\n-            this.getLooper().quit();\n-        }\n-    }\n-\n-    /**\n-     * Starts the block upload async operations.\n-     *\n-     * @param blocks the blocks to be staged (uploaded).\n-     */\n-    private void stageBlocks(List<BlockUploadEntity> blocks) {\n-        for (BlockUploadEntity block : blocks) {\n-            this.finalizeIfStopped();\n-\n-            Log.v(TAG, \"stageBlocks(): Uploading block:\" + block.blockId + threadName());\n-            byte [] blockContent;\n-            try {\n-                blockContent = content.readBlock(block.blockOffset, block.blockSize);\n-            } catch (Throwable t) {\n-                Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);\n-                db.uploadDao().updateBlockState(block.key, BlockTransferState.FAILED);\n-                block.setStagingError(t);\n-                Message nextMessage = UploadHandlerMessage\n-                    .createStagingFailedMessage(UploadHandler.this, block.blockId);\n-                nextMessage.sendToTarget();\n-                return;\n-            }\n-\n-            this.blobClient.stageBlock(this.blob.containerName,\n-                this.blob.blobName,\n-                block.blockId,\n-                blockContent,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                this.cancellationToken,\n-                new CallbackWithHeader<Void, BlockBlobStageBlockHeaders>() {\n-                    @Override\n-                    public void onSuccess(Void result, BlockBlobStageBlockHeaders header, Response response) {\n-                        Log.v(TAG, \"stageBlocks(): Block uploaded:\" + block.blockId + threadName());\n-                        db.uploadDao().updateBlockState(block.key, BlockTransferState.COMPLETED);\n-                        Message nextMessage = UploadHandlerMessage\n-                            .createStagingCompletedMessage(UploadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable throwable, Response response) {\n-                        Log.e(TAG,  \"stageBlocks(): Block upload failed:\" + block.blockId + threadName(), throwable);\n-                        db.uploadDao().updateBlockState(block.key, BlockTransferState.FAILED);\n-                        block.setStagingError(throwable);\n-                        Message nextMessage = UploadHandlerMessage\n-                            .createStagingFailedMessage(UploadHandler.this, block.blockId);\n-                        nextMessage.sendToTarget();\n-                    }\n-                });\n-            this.runningBlockUploads.put(block.blockId, block);\n-        }\n-    }\n-\n-    /**\n-     * Starts the blocks commit async operation.\n-     */\n-    private void commitBlocks() {\n-        this.finalizeIfStopped();\n-\n-        Log.v(TAG, \"commitBlocks(): All blocks uploaded, committing them.\" + threadName());\n-\n-        List<String> blockIds = this.db.uploadDao().getBlockIds(this.uploadId);\n-\n-        this.blobClient.commitBlockList(blob.containerName,\n-            blob.blobName,\n-            blockIds,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            null,\n-            this.cancellationToken,\n-            new CallbackWithHeader<BlockBlobItem, BlockBlobCommitBlockListHeaders>() {\n-                @Override\n-                public void onSuccess(BlockBlobItem result, BlockBlobCommitBlockListHeaders header, Response response) {\n-                    Log.v(TAG, \"commitBlocks(): Blocks committed.\" + threadName());\n-                    db.uploadDao().updateBlobState(uploadId, BlobTransferState.COMPLETED);\n-                    Message nextMessage = UploadHandlerMessage\n-                        .createCommitCompletedMessage(UploadHandler.this);\n-                    nextMessage.sendToTarget();\n-                }\n-\n-                @Override\n-                public void onFailure(Throwable throwable, Response response) {\n-                    Log.e(TAG,  \"commitBlocks(): Blocks commit failed.\" + threadName(), throwable);\n-                    db.uploadDao().updateBlobState(uploadId, BlobTransferState.FAILED);\n-                    blob.setCommitError(throwable);\n-                    Message nextMessage = UploadHandlerMessage\n-                        .createCommitFailedMessage(UploadHandler.this);\n-                    nextMessage.sendToTarget();\n-                }\n-            });\n-    }\n-\n-    // For Debugging, will be removed (TODO: anuchan)\n-    private static String threadName() {\n-        return \" Thread:\" + Thread.currentThread().getName() + \"(\" + Thread.currentThread().getId() + \")\";\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MzUzMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433443532", "body": "I feel weird reading `isUse` at the beginning although I understand it's based on a convention for boolean values. Would it be ok to rename this to `isUsingContentResolver` instead?", "bodyText": "I feel weird reading isUse at the beginning although I understand it's based on a convention for boolean values. Would it be ok to rename this to isUsingContentResolver instead?", "bodyHTML": "<p dir=\"auto\">I feel weird reading <code>isUse</code> at the beginning although I understand it's based on a convention for boolean values. Would it be ok to rename this to <code>isUsingContentResolver</code> instead?</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:31:04Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4OTc1OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433489759", "bodyText": "Something I struggled when naming this property :) .. isUsingContentResolver is fine with me.", "author": "anuchandy", "createdAt": "2020-06-01T21:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MzUzMg=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -56,7 +55,7 @@ final class ReadableContent {\n      *\n      * @return true if resolving content URI requires content resolver.\n      */\n-    boolean isUseContentResolver() {\n+    boolean isUsingContentResolver() {\n         return this.useContentResolver;\n     }\n \n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433444189", "body": "This could return 0 if the file does not exist. We might want to consider that for when we decide to throw. [Source](https://docs.oracle.com/javase/7/docs/api/java/io/File.html#length()).", "bodyText": "This could return 0 if the file does not exist. We might want to consider that for when we decide to throw. Source.", "bodyHTML": "<p dir=\"auto\">This could return 0 if the file does not exist. We might want to consider that for when we decide to throw. <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/File.html#length()\" rel=\"nofollow\">Source</a>.</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:32:32Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NTI5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433575291", "bodyText": "@anuchandy Although, you really can't tell if a returning 0 means there is no file, so we would probably need to make another check there.", "author": "vcolin7", "createdAt": "2020-06-02T01:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NzI1OA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433577258", "bodyText": "actually I changed the logic and this is taken care of in the last commit", "author": "anuchandy", "createdAt": "2020-06-02T01:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -78,24 +77,29 @@ final class ReadableContent {\n      * Get the total size of the content in bytes.\n      *\n      * @return the content size in bytes\n-     * @throws Throwable if retrieval of content length fails\n+     * @throws FileNotFoundException if the content does not exists\n+     * @throws UnsupportedOperationException if content length is unknown\n+     * @throws IOException if there is a failure when closing the content opened to fetch the length\n      */\n-    long getLength() throws Throwable {\n-        final long contentLength;\n+    long getLength() throws IOException, UnsupportedOperationException {\n         if (this.useContentResolver) {\n-            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n-            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n-            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n-            cursor.moveToFirst();\n-            contentLength = cursor.getLong(sizeIndex);\n+            final long contentLength;\n+            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                contentLength = descriptor.getLength();\n+            }\n+            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n+                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n+            }\n+            return contentLength;\n         } else {\n-            File file = new File(contentUri.getPath());\n-            contentLength = file.length();\n-        }\n-        if (contentLength == -1) {\n-            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+            final File file = new File(contentUri.getPath());\n+            if (!file.exists() || !file.isFile()) {\n+                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n+            }\n+            return file.length();\n         }\n-        return contentLength;\n     }\n \n     /**\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTYyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433445627", "body": "Any reason you preferred to use Throwable here instead of a specific exception? I feel like using the latter would be more descriptive.", "bodyText": "Any reason you preferred to use Throwable here instead of a specific exception? I feel like using the latter would be more descriptive.", "bodyHTML": "<p dir=\"auto\">Any reason you preferred to use Throwable here instead of a specific exception? I feel like using the latter would be more descriptive.</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:35:35Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5MjU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433492562", "bodyText": "good catch, I thought I got rid of Throwables :), will switch to something meaning full.", "author": "anuchandy", "createdAt": "2020-06-01T21:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -78,24 +77,29 @@ final class ReadableContent {\n      * Get the total size of the content in bytes.\n      *\n      * @return the content size in bytes\n-     * @throws Throwable if retrieval of content length fails\n+     * @throws FileNotFoundException if the content does not exists\n+     * @throws UnsupportedOperationException if content length is unknown\n+     * @throws IOException if there is a failure when closing the content opened to fetch the length\n      */\n-    long getLength() throws Throwable {\n-        final long contentLength;\n+    long getLength() throws IOException, UnsupportedOperationException {\n         if (this.useContentResolver) {\n-            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n-            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n-            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n-            cursor.moveToFirst();\n-            contentLength = cursor.getLong(sizeIndex);\n+            final long contentLength;\n+            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                contentLength = descriptor.getLength();\n+            }\n+            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n+                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n+            }\n+            return contentLength;\n         } else {\n-            File file = new File(contentUri.getPath());\n-            contentLength = file.length();\n-        }\n-        if (contentLength == -1) {\n-            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+            final File file = new File(contentUri.getPath());\n+            if (!file.exists() || !file.isFile()) {\n+                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n+            }\n+            return file.length();\n         }\n-        return contentLength;\n     }\n \n     /**\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTk4MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433445980", "body": "```suggestion\r\n     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n          \n          \n            \n                 * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"x x-first x-last\">block </span>of bytes in the range [blockOffset, blockOffset <span class=\"pl-k\">+</span> blockSize]</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"x x-first x-last\">an array </span>of bytes<span class=\"x x-first x-last\"> taken from the content</span> in the range [blockOffset, blockOffset <span class=\"pl-k\">+</span> blockSize]</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:36:17Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -78,24 +77,29 @@ final class ReadableContent {\n      * Get the total size of the content in bytes.\n      *\n      * @return the content size in bytes\n-     * @throws Throwable if retrieval of content length fails\n+     * @throws FileNotFoundException if the content does not exists\n+     * @throws UnsupportedOperationException if content length is unknown\n+     * @throws IOException if there is a failure when closing the content opened to fetch the length\n      */\n-    long getLength() throws Throwable {\n-        final long contentLength;\n+    long getLength() throws IOException, UnsupportedOperationException {\n         if (this.useContentResolver) {\n-            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n-            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n-            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n-            cursor.moveToFirst();\n-            contentLength = cursor.getLong(sizeIndex);\n+            final long contentLength;\n+            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                contentLength = descriptor.getLength();\n+            }\n+            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n+                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n+            }\n+            return contentLength;\n         } else {\n-            File file = new File(contentUri.getPath());\n-            contentLength = file.length();\n-        }\n-        if (contentLength == -1) {\n-            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+            final File file = new File(contentUri.getPath());\n+            if (!file.exists() || !file.isFile()) {\n+                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n+            }\n+            return file.length();\n         }\n-        return contentLength;\n     }\n \n     /**\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}, {"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -103,7 +107,8 @@ final class ReadableContent {\n      *\n      * @param blockOffset the start offset of the block\n      * @param blockSize the size of the block\n-     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n+     * @throws FileNotFoundException if the content does not exists\n      * @throws IOException the IO error when attempting to read\n      * @throws IllegalStateException if read permission is not granted or revoked\n      */\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Mjk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433452971", "body": "A little nitpick: maybe we can modify a little this to avoid code duplication? To be honest this is not really a big deal.\r\n```suggestion\r\n        FileInputStream fileInputStream;\r\n        \r\n        if (this.useContentResolver) {\r\n            this.checkPersistableReadGranted();\r\n            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\r\n            // so that providers that returns subsection of file gets supported.\r\n            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\r\n            try (AssetFileDescriptor descriptor\r\n                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\r\n                fileInputStream = descriptor.createInputStream();\r\n            }\r\n        } else {\r\n            File file = new File(this.contentUri.getPath());\r\n            fileInputStream = new FileInputStream(file);\r\n        }\r\n        \r\n        try {\r\n            seek(fileInputStream, blockOffset);\r\n            byte [] blockContent = new byte[blockSize];\r\n            read(fileInputStream, blockContent);\r\n            return blockContent;\r\n        } finally {\r\n            fileInputStream.close();\r\n        }\r\n    }\r\n```", "bodyText": "A little nitpick: maybe we can modify a little this to avoid code duplication? To be honest this is not really a big deal.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this.useContentResolver) {\n          \n          \n            \n                        this.checkPersistableReadGranted();\n          \n          \n            \n                        // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n          \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        try (AssetFileDescriptor descriptor\n          \n          \n            \n                                 = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n          \n          \n            \n                            try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n          \n          \n            \n                                seek(fileInputStream, blockOffset);\n          \n          \n            \n                                byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                                read(fileInputStream, blockContent);\n          \n          \n            \n                                return blockContent;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        File file = new File(this.contentUri.getPath());\n          \n          \n            \n                        try (FileInputStream fileInputStream = new FileInputStream(file)) {\n          \n          \n            \n                            seek(fileInputStream, blockOffset);\n          \n          \n            \n                            byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                            read(fileInputStream, blockContent);\n          \n          \n            \n                            return blockContent;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    FileInputStream fileInputStream;\n          \n          \n            \n                    \n          \n          \n            \n                    if (this.useContentResolver) {\n          \n          \n            \n                        this.checkPersistableReadGranted();\n          \n          \n            \n                        // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n          \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        try (AssetFileDescriptor descriptor\n          \n          \n            \n                                 = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n          \n          \n            \n                            fileInputStream = descriptor.createInputStream();\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        File file = new File(this.contentUri.getPath());\n          \n          \n            \n                        fileInputStream = new FileInputStream(file);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    try {\n          \n          \n            \n                        seek(fileInputStream, blockOffset);\n          \n          \n            \n                        byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                        read(fileInputStream, blockContent);\n          \n          \n            \n                        return blockContent;\n          \n          \n            \n                    } finally {\n          \n          \n            \n                        fileInputStream.close();\n          \n          \n            \n                    }\n          \n          \n            \n                }", "bodyHTML": "<p dir=\"auto\">A little nitpick: maybe we can modify a little this to avoid code duplication? To be honest this is not really a big deal.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"139\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>useContentResolver) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"140\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>checkPersistableReadGranted();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"141\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"142\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> so that providers that returns subsection of file gets supported.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"143\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"144\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">AssetFileDescriptor</span> descriptor</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"145\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                     <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>context<span class=\"pl-k\">.</span>getContentResolver()<span class=\"pl-k\">.</span>openAssetFileDescriptor(<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>contentUri, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>r<span class=\"pl-pds\">\"</span></span>)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"146\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">FileInputStream</span> fileInputStream <span class=\"pl-k\">=</span> descriptor<span class=\"pl-k\">.</span>createInputStream()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"147\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    seek(fileInputStream, blockOffset);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"148\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">byte</span> [] blockContent <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[blockSize];</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"149\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    read(fileInputStream, blockContent);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"150\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">return</span> blockContent;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"151\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"152\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"153\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"154\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">File</span> file <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">File</span>(<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>contentUri<span class=\"pl-k\">.</span>getPath());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"155\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">FileInputStream</span> fileInputStream <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">FileInputStream</span>(file)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"156\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                seek(fileInputStream, blockOffset);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"157\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-k\">byte</span> [] blockContent <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[blockSize];</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"158\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                read(fileInputStream, blockContent);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"159\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-k\">return</span> blockContent;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"160\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"161\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"162\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"139\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">FileInputStream</span> fileInputStream;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"140\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"141\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>useContentResolver) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"142\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>checkPersistableReadGranted();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"143\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"144\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> so that providers that returns subsection of file gets supported.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"145\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"146\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">AssetFileDescriptor</span> descriptor</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"147\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                     <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>context<span class=\"pl-k\">.</span>getContentResolver()<span class=\"pl-k\">.</span>openAssetFileDescriptor(<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>contentUri, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>r<span class=\"pl-pds\">\"</span></span>)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"148\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                fileInputStream <span class=\"pl-k\">=</span> descriptor<span class=\"pl-k\">.</span>createInputStream();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"149\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"150\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"151\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-smi\">File</span> file <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">File</span>(<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>contentUri<span class=\"pl-k\">.</span>getPath());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"152\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            fileInputStream <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">FileInputStream</span>(file);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"153\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"154\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"155\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">try</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"156\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            seek(fileInputStream, blockOffset);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"157\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">byte</span> [] blockContent <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[blockSize];</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"158\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            read(fileInputStream, blockContent);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"159\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span> blockContent;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"160\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        } <span class=\"pl-k\">finally</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"161\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            fileInputStream<span class=\"pl-k\">.</span>close();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"162\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"163\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:50:42Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NjUxMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433496512", "bodyText": "yes, thanks for double-checking, I know we duplicate ~5 lines but I prefer the original one due to readability.", "author": "anuchandy", "createdAt": "2020-06-01T21:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Mjk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 93f998377..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,203 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.database.Cursor;\n-import android.net.Uri;\n-import android.provider.OpenableColumns;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the content URI identifying the content\n-     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUseContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws Throwable if retrieval of content length fails\n-     */\n-    long getLength() throws Throwable {\n-        final long contentLength;\n-        if (this.useContentResolver) {\n-            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n-            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n-            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n-            cursor.moveToFirst();\n-            contentLength = cursor.getLong(sizeIndex);\n-        } else {\n-            File file = new File(contentUri.getPath());\n-            contentLength = file.length();\n-        }\n-        if (contentLength == -1) {\n-            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n-        }\n-        return contentLength;\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that returns subsection of file gets supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the seek position\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int skipped = 0;\n-        while(skipped < seekTo) {\n-            long m = stream.skip(seekTo - skipped);\n-            if (m < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (m == 0) {\n-                if (stream.read() == -1) {\n-                    return;\n-                } else {\n-                    skipped++;\n-                }\n-            } else {\n-                skipped += m;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1MzQ0Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433453447", "body": "```suggestion\r\n     * @param seekTo the stream position to seek\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param seekTo the seek position\n          \n          \n            \n                 * @param seekTo the stream position to seek", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> seekTo the <span class=\"x x-first x-last\">seek</span> position</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> seekTo the <span class=\"x x-first x-last\">stream</span> position<span class=\"x x-first x-last\"> to seek</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:51:44Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -158,30 +163,34 @@ final class ReadableContent {\n      * Seek the stream read cursor to the given position.\n      *\n      * @param stream the stream\n-     * @param seekTo the seek position\n+     * @param seekTo the stream position to seek\n      * @throws IOException if seek fails\n      */\n     private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int skipped = 0;\n-        while(skipped < seekTo) {\n-            long m = stream.skip(seekTo - skipped);\n-            if (m < 0) {\n+        int totalBytesSkipped = 0;\n+        while(totalBytesSkipped < seekTo) {\n+            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n+            if (bytesSkipped < 0) {\n                 throw new IOException(\"FileInputStream::seek returned negative value.\");\n             }\n-            if (m == 0) {\n+            if (bytesSkipped == 0) {\n+                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n+                // Read one byte to see it's due to EOF.\n                 if (stream.read() == -1) {\n+                    // EOF hence return.\n                     return;\n                 } else {\n-                    skipped++;\n+                    // not EOF but stream::read returned a byte.\n+                    totalBytesSkipped++;\n                 }\n             } else {\n-                skipped += m;\n+                totalBytesSkipped += bytesSkipped;\n             }\n         }\n     }\n \n     /**\n-     * Read the stream content into a buffer starting from stream's read cursor position.\n+     * Read the stream content into a buffer starting from the stream's read cursor position.\n      *\n      * @param stream the file stream\n      * @param buffer the output buffer\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433454701", "body": "What does `m` stand for?", "bodyText": "What does m stand for?", "bodyHTML": "<p dir=\"auto\">What does <code>m</code> stand for?</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:54:22Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NDU2Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433494567", "bodyText": "its number of bytes skipped, I'll change the variable name to be more readable.", "author": "anuchandy", "createdAt": "2020-06-01T21:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTkyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433521927", "bodyText": "Thanks!", "author": "vcolin7", "createdAt": "2020-06-01T22:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -158,30 +163,34 @@ final class ReadableContent {\n      * Seek the stream read cursor to the given position.\n      *\n      * @param stream the stream\n-     * @param seekTo the seek position\n+     * @param seekTo the stream position to seek\n      * @throws IOException if seek fails\n      */\n     private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int skipped = 0;\n-        while(skipped < seekTo) {\n-            long m = stream.skip(seekTo - skipped);\n-            if (m < 0) {\n+        int totalBytesSkipped = 0;\n+        while(totalBytesSkipped < seekTo) {\n+            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n+            if (bytesSkipped < 0) {\n                 throw new IOException(\"FileInputStream::seek returned negative value.\");\n             }\n-            if (m == 0) {\n+            if (bytesSkipped == 0) {\n+                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n+                // Read one byte to see it's due to EOF.\n                 if (stream.read() == -1) {\n+                    // EOF hence return.\n                     return;\n                 } else {\n-                    skipped++;\n+                    // not EOF but stream::read returned a byte.\n+                    totalBytesSkipped++;\n                 }\n             } else {\n-                skipped += m;\n+                totalBytesSkipped += bytesSkipped;\n             }\n         }\n     }\n \n     /**\n-     * Read the stream content into a buffer starting from stream's read cursor position.\n+     * Read the stream content into a buffer starting from the stream's read cursor position.\n      *\n      * @param stream the file stream\n      * @param buffer the output buffer\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433454875", "body": "```suggestion\r\n     * Read the stream content into a buffer starting from the stream's read cursor position.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Read the stream content into a buffer starting from stream's read cursor position.\n          \n          \n            \n                 * Read the stream content into a buffer starting from the stream's read cursor position.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Read</span> the stream content into a buffer starting from stream<span class=\"pl-s\"><span class=\"pl-pds\">'</span>s read cursor position.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Read</span> the stream content into a buffer starting from <span class=\"x x-first x-last\">the </span>stream<span class=\"pl-s\"><span class=\"pl-pds\">'</span>s read cursor position.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:54:45Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);\n+            if (m < 0) {\n+                throw new IOException(\"FileInputStream::seek returned negative value.\");\n+            }\n+            if (m == 0) {\n+                if (stream.read() == -1) {\n+                    return;\n+                } else {\n+                    skipped++;\n+                }\n+            } else {\n+                skipped += m;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the stream content into a buffer starting from stream's read cursor position.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -158,30 +163,34 @@ final class ReadableContent {\n      * Seek the stream read cursor to the given position.\n      *\n      * @param stream the stream\n-     * @param seekTo the seek position\n+     * @param seekTo the stream position to seek\n      * @throws IOException if seek fails\n      */\n     private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int skipped = 0;\n-        while(skipped < seekTo) {\n-            long m = stream.skip(seekTo - skipped);\n-            if (m < 0) {\n+        int totalBytesSkipped = 0;\n+        while(totalBytesSkipped < seekTo) {\n+            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n+            if (bytesSkipped < 0) {\n                 throw new IOException(\"FileInputStream::seek returned negative value.\");\n             }\n-            if (m == 0) {\n+            if (bytesSkipped == 0) {\n+                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n+                // Read one byte to see it's due to EOF.\n                 if (stream.read() == -1) {\n+                    // EOF hence return.\n                     return;\n                 } else {\n-                    skipped++;\n+                    // not EOF but stream::read returned a byte.\n+                    totalBytesSkipped++;\n                 }\n             } else {\n-                skipped += m;\n+                totalBytesSkipped += bytesSkipped;\n             }\n         }\n     }\n \n     /**\n-     * Read the stream content into a buffer starting from stream's read cursor position.\n+     * Read the stream content into a buffer starting from the stream's read cursor position.\n      *\n      * @param stream the file stream\n      * @param buffer the output buffer\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NTA0MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433455040", "body": "Same as above.", "bodyText": "Same as above.", "bodyHTML": "<p dir=\"auto\">Same as above.</p>", "author": "vcolin7", "createdAt": "2020-06-01T19:55:03Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);\n+            if (m < 0) {\n+                throw new IOException(\"FileInputStream::seek returned negative value.\");\n+            }\n+            if (m == 0) {\n+                if (stream.read() == -1) {\n+                    return;\n+                } else {\n+                    skipped++;\n+                }\n+            } else {\n+                skipped += m;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the stream content into a buffer starting from stream's read cursor position.\n+     *\n+     * @param stream the file stream\n+     * @param buffer the output buffer\n+     * @return the number of bytes read\n+     * @throws IOException if read fails\n+     */\n+    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n+        int bytesToRead = buffer.length;\n+        int bytesRead = 0;\n+        while (bytesRead < bytesToRead) {\n+            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 93f998377..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,203 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.database.Cursor;\n-import android.net.Uri;\n-import android.provider.OpenableColumns;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the content URI identifying the content\n-     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUseContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws Throwable if retrieval of content length fails\n-     */\n-    long getLength() throws Throwable {\n-        final long contentLength;\n-        if (this.useContentResolver) {\n-            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n-            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n-            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n-            cursor.moveToFirst();\n-            contentLength = cursor.getLong(sizeIndex);\n-        } else {\n-            File file = new File(contentUri.getPath());\n-            contentLength = file.length();\n-        }\n-        if (contentLength == -1) {\n-            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n-        }\n-        return contentLength;\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that returns subsection of file gets supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the seek position\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int skipped = 0;\n-        while(skipped < seekTo) {\n-            long m = stream.skip(seekTo - skipped);\n-            if (m < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (m == 0) {\n-                if (stream.read() == -1) {\n-                    return;\n-                } else {\n-                    skipped++;\n-                }\n-            } else {\n-                skipped += m;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjM5NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433456394", "body": "```suggestion\r\n     * The URI to the content to be uploaded as a blob.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The URI to the content to be uploaded as blob.\n          \n          \n            \n                 * The URI to the content to be uploaded as a blob.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">The</span> <span class=\"pl-c1\">URI</span> to the content to be uploaded as blob.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">The</span> <span class=\"pl-c1\">URI</span> to the content to be uploaded as <span class=\"x x-first x-last\">a </span>blob.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T19:57:41Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java", "diffHunk": "@@ -32,15 +31,20 @@\n     @ColumnInfo(name = \"key\")\n     public Long key;\n     /**\n-     * The absolute path to the file to be uploaded as blob.\n+     * The URI to the content to be uploaded as blob.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java\nindex 4c6af619d..a9dbce8f1 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java\n", "chunk": "@@ -31,7 +31,7 @@ final class BlobUploadEntity {\n     @ColumnInfo(name = \"key\")\n     public Long key;\n     /**\n-     * The URI to the content to be uploaded as blob.\n+     * The URI to the content to be uploaded as a blob.\n      */\n     @ColumnInfo(name = \"content_uri\")\n     public String contentUri;\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java\ndeleted file mode 100644\nindex a9dbce8f1..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java\n+++ /dev/null\n", "chunk": "@@ -1,155 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import androidx.room.ColumnInfo;\n-import androidx.room.Entity;\n-import androidx.room.Ignore;\n-import androidx.room.PrimaryKey;\n-import androidx.room.TypeConverters;\n-\n-import java.util.Objects;\n-\n-/**\n- * Package private.\n- *\n- * Represents blob upload metadata for a single file upload.\n- *\n- * The Data Access Object type {@link UploadDao} exposes DB store and read methods on this model.\n- *\n- * @see TransferDatabase\n- */\n-@Entity(tableName = \"blobuploads\")\n-final class BlobUploadEntity {\n-    /**\n-     * A unique key for the blob upload metadata.\n-     *\n-     * Also referred as uploadId that users use to identify and manage the upload operation.\n-     */\n-    @PrimaryKey(autoGenerate = true)\n-    @ColumnInfo(name = \"key\")\n-    public Long key;\n-    /**\n-     * The URI to the content to be uploaded as a blob.\n-     */\n-    @ColumnInfo(name = \"content_uri\")\n-    public String contentUri;\n-    /**\n-     * The content size in bytes (i.e. the total size of the blob once uploaded).\n-     */\n-    @ColumnInfo(name = \"content_size\")\n-    public long contentSize;\n-    /**\n-     * Indicate whether android.content.ContentResolver should be used to resolve the contentUri.\n-     */\n-    @ColumnInfo(name = \"use_content_resolver\")\n-    public boolean useContentResolver;\n-    /**\n-     * Identifies the {@link com.azure.android.storage.blob.StorageBlobClient}\n-     * to be used for the file upload.\n-     * @see StorageBlobClientMap\n-     */\n-    @ColumnInfo(name = \"storage_blob_client_id\")\n-    public String storageBlobClientId;\n-    /**\n-     * The name of the Azure Storage Container to upload the file to.\n-     */\n-    @ColumnInfo(name = \"container_name\")\n-    public String containerName;\n-    /**\n-     * The name of the Azure Storage blob holding uploaded file.\n-     */\n-    @ColumnInfo(name = \"blob_name\")\n-    public String blobName;\n-    /**\n-     * The current state of the blob upload operation.\n-     */\n-    @ColumnInfo(name = \"blob_upload_state\")\n-    @TypeConverters(ColumnConverter.class)\n-    public volatile BlobTransferState state;\n-    /**\n-     * Indicate the reason for interrupting (stopping) blob upload.\n-     */\n-    @ColumnInfo(name = \"transfer_interrupt_state\")\n-    @TypeConverters(ColumnConverter.class)\n-    public TransferInterruptState interruptState;\n-    /**\n-     * holds the exception indicating the reason for commit (the last\n-     * stage of upload) failure.\n-     *\n-     * This is not persisted\n-     */\n-    @Ignore\n-    private Throwable commitError;\n-\n-    /**\n-     * Creates BlobUploadEntity, this constructor is used by Room library\n-     * when re-hydrating metadata from local store.\n-     */\n-    public BlobUploadEntity() {}\n-\n-    /**\n-     * Create a new BlobUploadEntity to persist in local store.\n-     *\n-     * @param storageBlobClientId identifies the blob storage client to be used\n-     * @param containerName the container name\n-     * @param blobName the blob name\n-     * @param content describes the content to be read while uploading\n-     */\n-    @Ignore\n-    BlobUploadEntity(String storageBlobClientId,\n-                     String containerName,\n-                     String blobName,\n-                     ReadableContent content) throws Throwable {\n-        Objects.requireNonNull(storageBlobClientId);\n-        Objects.requireNonNull(containerName);\n-        Objects.requireNonNull(blobName);\n-        Objects.requireNonNull(content);\n-\n-        this.contentUri = content.getUri().toString();\n-        this.contentSize = content.getLength();\n-        this.useContentResolver = content.isUsingContentResolver();\n-\n-        this.storageBlobClientId = storageBlobClientId;\n-        this.containerName = containerName;\n-        this.blobName = blobName;\n-        this.state = BlobTransferState.WAIT_TO_BEGIN;\n-        this.interruptState = TransferInterruptState.NONE;\n-    }\n-\n-    /**\n-     * Set the commit (the last stage of upload) failure error.\n-     *\n-     * @param t the error\n-     */\n-    void setCommitError(Throwable t) {\n-        this.commitError = t;\n-    }\n-\n-    /**\n-     * Get the commit failure error.\n-     *\n-     * @return the commit failure error or null if there is no error\n-     */\n-    Throwable getCommitError() {\n-        return this.commitError;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-        builder.append(\" key:\" + this.key);\n-        builder.append(\" contentUri:\" + this.contentUri);\n-        builder.append(\" contentSize:\" + this.contentSize);\n-        builder.append(\" useContentResolver:\" + this.useContentResolver);\n-        builder.append(\" containerName:\" + this.containerName);\n-        builder.append(\" blobName:\" + this.blobName);\n-        builder.append(\" state:\" + this.state);\n-        builder.append(\" interruptState:\" + this.interruptState);\n-        if (this.commitError != null) {\n-            builder.append(\" commitError:\" + this.commitError.getMessage());\n-        }\n-        return builder.toString();\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Nzc1MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433457751", "body": "```suggestion\r\n     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return true if resolving content URI requires content resolver.\n          \n          \n            \n                 * @return true if resolving content URI requires {@link android.content.ContentResolver}.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"pl-c1\">true</span> <span class=\"pl-k\">if</span> resolving content <span class=\"pl-c1\">URI</span> requires <span class=\"x x-first x-last\">content resolver</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@return</span> <span class=\"pl-c1\">true</span> <span class=\"pl-k\">if</span> resolving content <span class=\"pl-c1\">URI</span> requires <span class=\"x x-first\">{</span><span class=\"pl-k x\">@link</span><span class=\"x\"> </span><span class=\"pl-smi\"><span class=\"x\">android.content</span><span class=\"pl-k x\">.</span><span class=\"x\">ContentResolver</span></span><span class=\"x x-last\">}</span><span class=\"pl-c1\">.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:00:23Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -59,9 +59,9 @@ final class WritableContent {\n     /**\n      * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n      *\n-     * @return true if resolving content URI requires content resolver.\n+     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n      */\n-    boolean isUseContentResolver() {\n+    boolean isUsingContentResolver() {\n         return this.useContentResolver;\n     }\n \n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1OTMxMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433459311", "body": "```suggestion\r\n     * @throws IOException if not possible to open underlying content resource in write mode\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IOException if fails to open underlying content resource in write mode\n          \n          \n            \n                 * @throws IOException if not possible to open underlying content resource in write mode", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@throws</span> <span class=\"pl-smi\">IOException</span> <span class=\"pl-k\">if</span> <span class=\"x x-first x-last\">fails</span> to open underlying content resource in write mode</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@throws</span> <span class=\"pl-smi\">IOException</span> <span class=\"pl-k\">if</span> <span class=\"x x-first x-last\">not possible</span> to open underlying content resource in write mode</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:03:50Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -82,7 +82,7 @@ final class WritableContent {\n     /**\n      * Open the content for writing.\n      *\n-     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IOException if not possible to open underlying content resource in write mode\n      * @throws IllegalStateException if write permission to the content is not granted/revoked or\n      *     the channel was already opened and disposed\n      */\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MDA5Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433460097", "body": "See comment above about the naming of this method on `ReadableContent`.", "bodyText": "See comment above about the naming of this method on ReadableContent.", "bodyHTML": "<p dir=\"auto\">See comment above about the naming of this method on <code>ReadableContent</code>.</p>", "author": "vcolin7", "createdAt": "2020-06-01T20:05:25Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5Njk0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433496944", "bodyText": "I guess you mean isUsingContentResolver, will change it, thanks!", "author": "anuchandy", "createdAt": "2020-06-01T21:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MDA5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -59,9 +59,9 @@ final class WritableContent {\n     /**\n      * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n      *\n-     * @return true if resolving content URI requires content resolver.\n+     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n      */\n-    boolean isUseContentResolver() {\n+    boolean isUsingContentResolver() {\n         return this.useContentResolver;\n     }\n \n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MzAyNg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433463026", "body": "Do we want to capitalize Content wherever its mentioned to make the distinction between ReadableContent/WritableContent and the word \"content\" in the general sense?", "bodyText": "Do we want to capitalize Content wherever its mentioned to make the distinction between ReadableContent/WritableContent and the word \"content\" in the general sense?", "bodyHTML": "<p dir=\"auto\">Do we want to capitalize Content wherever its mentioned to make the distinction between ReadableContent/WritableContent and the word \"content\" in the general sense?</p>", "author": "vcolin7", "createdAt": "2020-06-01T20:11:37Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri\n+     * @throws IllegalStateException if permission is not granted\n+     */\n+    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n+        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n+        boolean grantedWrite = false;\n+        for (UriPermission permission : permissions) {\n+            if (permission.isWritePermission()) {\n+                grantedWrite = true;\n+                break;\n+            }\n+        }\n+\n+        if (!grantedWrite) {\n+            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+        }\n+    }\n+\n+    /**\n+     * A Channel to write to a Content identified by a ContentUri.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5OTgwNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433499804", "bodyText": "\"content\" is a general android term so it should be fine to use it in comments as \"content\", this specific code comment, maybe I should change from \"Content\" to \"content\".", "author": "anuchandy", "createdAt": "2020-06-01T21:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MzAyNg=="}], "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -175,7 +175,7 @@ final class WritableContent {\n     }\n \n     /**\n-     * A Channel to write to a Content identified by a ContentUri.\n+     * A Channel to write to a content identified by a ContentUri.\n      */\n     private static class WriteToContentChannel implements Closeable {\n         private final Context context;\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NDAyMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433464021", "body": "```suggestion\r\n         * @param context the context to resolve the content URI\r\n         * @param contentUri the URI of the content to write to using this Channel.\r\n         *\r\n         * @throws IOException if failed to open the underlying content resource in write mode\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param context the context to resolve the content uri\n          \n          \n            \n                     * @param contentUri the uri of the content to write to using this Channel.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws IOException if fails to open underlying content resource in write mode\n          \n          \n            \n                     * @param context the context to resolve the content URI\n          \n          \n            \n                     * @param contentUri the URI of the content to write to using this Channel.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws IOException if failed to open the underlying content resource in write mode", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> context the context to resolve the content <span class=\"x x-first x-last\">uri</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the <span class=\"x x-first x-last\">uri</span> of the content to write to using <span class=\"pl-c1\">this</span> <span class=\"pl-smi\">Channel</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@throws</span> <span class=\"pl-smi\">IOException</span> <span class=\"pl-k\">if</span> <span class=\"x x-first x-last\">fails</span> to open underlying content resource in write mode</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> context the context to resolve the content <span class=\"pl-c1 x x-first x-last\">URI</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the <span class=\"pl-c1 x x-first x-last\">URI</span> of the content to write to using <span class=\"pl-c1\">this</span> <span class=\"pl-smi\">Channel</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@throws</span> <span class=\"pl-smi\">IOException</span> <span class=\"pl-k\">if</span> <span class=\"x x-first x-last\">failed</span> to open<span class=\"x x-first x-last\"> the</span> underlying content resource in write mode</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:13:43Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri\n+     * @throws IllegalStateException if permission is not granted\n+     */\n+    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n+        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n+        boolean grantedWrite = false;\n+        for (UriPermission permission : permissions) {\n+            if (permission.isWritePermission()) {\n+                grantedWrite = true;\n+                break;\n+            }\n+        }\n+\n+        if (!grantedWrite) {\n+            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+        }\n+    }\n+\n+    /**\n+     * A Channel to write to a Content identified by a ContentUri.\n+     */\n+    private static class WriteToContentChannel implements Closeable {\n+        private final Context context;\n+        private final Uri contentUri;\n+        private final ParcelFileDescriptor parcelFileDescriptor;\n+        private final FileOutputStream fileOutputStream;\n+        private final FileChannel fileChannel;\n+        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+        /**\n+         * Creates WriteToContentChannel to write to the Content identified by the given ContentUri.\n+         *\n+         * @param context the context to resolve the content uri\n+         * @param contentUri the uri of the content to write to using this Channel.\n+         *\n+         * @throws IOException if fails to open underlying content resource in write mode", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -186,12 +186,12 @@ final class WritableContent {\n         private final AtomicBoolean isClosed = new AtomicBoolean(false);\n \n         /**\n-         * Creates WriteToContentChannel to write to the Content identified by the given ContentUri.\n+         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n          *\n-         * @param context the context to resolve the content uri\n-         * @param contentUri the uri of the content to write to using this Channel.\n+         * @param context the context to resolve the content URI\n+         * @param contentUri the URI of the content to write to using this Channel.\n          *\n-         * @throws IOException if fails to open underlying content resource in write mode\n+         * @throws IOException if failed to open the underlying content resource in write mode\n          * @throws IllegalStateException if write permission to the content is not granted or revoked\n          */\n         static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NTY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433465683", "body": "```suggestion\r\n     * Check if persistable write permission is granted on the content.\r\n     *\r\n     * @param context the context to access {@link android.content.ContentResolver}\r\n     * @param contentUri the content URI\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Check a persistable write permission is granted on the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param context the context to access content resolver\n          \n          \n            \n                 * @param contentUri the content uri\n          \n          \n            \n                 * Check if persistable write permission is granted on the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param context the context to access {@link android.content.ContentResolver}\n          \n          \n            \n                 * @param contentUri the content URI", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Check</span> <span class=\"x x-first x-last\">a</span> persistable write permission is granted on the content.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> context the context to access <span class=\"x x-first x-last\">content resolver</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the content <span class=\"x x-first x-last\">uri</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Check</span> <span class=\"pl-k x x-first x-last\">if</span> persistable write permission is granted on the content.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> context the context to access <span class=\"x x-first\">{</span><span class=\"pl-k x\">@link</span><span class=\"x\"> </span><span class=\"pl-smi\"><span class=\"x\">android.content</span><span class=\"pl-k x\">.</span><span class=\"x\">ContentResolver</span></span><span class=\"x x-last\">}</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the content <span class=\"pl-c1 x x-first x-last\">URI</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:17:14Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -153,10 +153,10 @@ final class WritableContent {\n     }\n \n     /**\n-     * Check a persistable write permission is granted on the content.\n+     * Check if persistable write permission is granted on the content.\n      *\n-     * @param context the context to access content resolver\n-     * @param contentUri the content uri\n+     * @param context the context to access {@link android.content.ContentResolver}\n+     * @param contentUri the content URI\n      * @throws IllegalStateException if permission is not granted\n      */\n     private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjE3Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466172", "body": "```suggestion\r\n     * Close the content.\r\n     *\r\n     * @throws IOException if the close operation fails\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * close the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @throws IOException if close operation fails\n          \n          \n            \n                 * Close the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @throws IOException if the close operation fails", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">close</span> the content.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@throws</span> <span class=\"pl-smi\">IOException</span> <span class=\"pl-k\">if</span> close operation fails</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first x-last\">Close</span> the content.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@throws</span> <span class=\"pl-smi\">IOException</span> <span class=\"pl-k\">if</span> <span class=\"x x-first x-last\">the </span>close operation fails</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:18:10Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -138,9 +138,9 @@ final class WritableContent {\n     }\n \n     /**\n-     * close the content.\n+     * Close the content.\n      *\n-     * @throws IOException if close operation fails\n+     * @throws IOException if the close operation fails\n      */\n     void close() throws IOException {\n         if (this.useContentResolver) {\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjY3NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466674", "body": "```suggestion\r\n     * @param contentUri the URI identifying the content\r\n     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri the content URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n          \n          \n            \n                 * @param contentUri the URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the <span class=\"x x-first x-last\">content </span><span class=\"pl-c1\">URI</span> identifying the content</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> useContentResolver <span class=\"x x-first x-last\">indicate</span> whether to use {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">android.content<span class=\"pl-k\">.</span>ContentResolver</span>} to resolve</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the <span class=\"pl-c1\">URI</span> identifying the content</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> useContentResolver <span class=\"x x-first x-last\">indicates</span> whether to use {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">android.content<span class=\"pl-k\">.</span>ContentResolver</span>} to resolve</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:19:08Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\nindex f6145444f..eea46af68 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n", "chunk": "@@ -37,8 +37,8 @@ final class WritableContent {\n      * Create WritableContent describing a content in the device on which data can be written.\n      *\n      * @param context the context\n-     * @param contentUri the content URI identifying the content\n-     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     * @param contentUri the URI identifying the content\n+     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n      *                           the content URI\n      */\n     WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\ndeleted file mode 100644\nindex eea46af68..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,253 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.net.Uri;\n-import android.os.ParcelFileDescriptor;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.Closeable;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device to which data can be written.\n- */\n-final class WritableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-    // Channel to write to the content if ContentResolver is required to resolve the content,\n-    // i.e. when useContentResolver == true\n-    private WriteToContentChannel contentChannel;\n-\n-    /**\n-     * Create WritableContent describing a content in the device on which data can be written.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires {@link android.content.ContentResolver}.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable write permission on the content.\n-     *\n-     * @throws IllegalStateException if write permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableWritePermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n-            checkPersistableWriteGranted(this.context, this.contentUri);\n-        }\n-    }\n-\n-    /**\n-     * Open the content for writing.\n-     *\n-     * @throws IOException if not possible to open underlying content resource in write mode\n-     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n-     *     the channel was already opened and disposed\n-     */\n-    void openForWrite(Context context) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel == null) {\n-                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n-                } else if (this.contentChannel.isClosed()) {\n-                    throw new IllegalStateException(\"A closed content Channel cannot be opened.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write a block of bytes to the content.\n-     *\n-     * @param blockOffset the start offset to write the block to\n-     * @param block the block of bytes to write\n-     *\n-     * @throws IOException the IO error when attempting to write\n-     * @throws IllegalStateException if write permission is not granted or revoked\n-     */\n-    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            if (this.contentChannel == null) {\n-                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n-            }\n-            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n-            // and the raw-path must not be used.\n-            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n-            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n-            //\n-            // So to write to content, instead of RandomAccessFile we will use FileChannel, specifically\n-            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n-            // Operations in FileChannel instance are concurrent safe.\n-            // https://developer.android.com/reference/java/nio/channels/FileChannel\n-            //\n-            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n-            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n-            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n-            // FileChannel instance.\n-            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n-            //\n-            this.contentChannel.writeBlock(blockOffset, block);\n-        } else {\n-            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n-                randomAccessFile.seek(blockOffset);\n-                randomAccessFile.write(block);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Close the content.\n-     *\n-     * @throws IOException if the close operation fails\n-     */\n-    void close() throws IOException {\n-        if (this.useContentResolver) {\n-            synchronized (this) {\n-                if (this.contentChannel != null) {\n-                    this.contentChannel.close();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if persistable write permission is granted on the content.\n-     *\n-     * @param context the context to access {@link android.content.ContentResolver}\n-     * @param contentUri the content URI\n-     * @throws IllegalStateException if permission is not granted\n-     */\n-    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n-        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n-        boolean grantedWrite = false;\n-        for (UriPermission permission : permissions) {\n-            if (permission.isWritePermission()) {\n-                grantedWrite = true;\n-                break;\n-            }\n-        }\n-\n-        if (!grantedWrite) {\n-            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-        }\n-    }\n-\n-    /**\n-     * A Channel to write to a content identified by a ContentUri.\n-     */\n-    private static class WriteToContentChannel implements Closeable {\n-        private final Context context;\n-        private final Uri contentUri;\n-        private final ParcelFileDescriptor parcelFileDescriptor;\n-        private final FileOutputStream fileOutputStream;\n-        private final FileChannel fileChannel;\n-        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-        /**\n-         * Creates WriteToContentChannel to write to the content identified by the given ContentUri.\n-         *\n-         * @param context the context to resolve the content URI\n-         * @param contentUri the URI of the content to write to using this Channel.\n-         *\n-         * @throws IOException if failed to open the underlying content resource in write mode\n-         * @throws IllegalStateException if write permission to the content is not granted or revoked\n-         */\n-        static WriteToContentChannel create(Context context, Uri contentUri) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(context, contentUri);\n-            return new WriteToContentChannel(context, contentUri);\n-        }\n-\n-        /**\n-         * Write a block of bytes to the Channel.\n-         *\n-         * @param blockOffset the start offset in the content to write the block\n-         * @param block the block of bytes to write\n-         * @throws IOException if write fails\n-         * @throws IllegalStateException if write permission is not granted or revoked\n-         */\n-        void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n-            WritableContent.checkPersistableWriteGranted(this.context, this.contentUri);\n-            this.fileChannel.write(ByteBuffer.wrap(block), blockOffset);\n-        }\n-\n-        /**\n-         * @return true if the Channel is closed\n-         */\n-        boolean isClosed() {\n-            return this.isClosed.get();\n-        }\n-\n-        /**\n-         * Close the Channel.\n-         *\n-         * @throws IOException if close fails\n-         */\n-        @Override\n-        public void close() throws IOException {\n-            if (this.isClosed.getAndSet(true)) {\n-                if (this.parcelFileDescriptor != null) {\n-                    this.parcelFileDescriptor.close();\n-                }\n-                if (this.fileOutputStream != null) {\n-                    this.fileOutputStream.close();\n-                }\n-                if (this.fileChannel != null) {\n-                    this.fileChannel.close();\n-                }\n-            }\n-        }\n-\n-        private WriteToContentChannel(Context context, Uri contentUri) throws IOException {\n-            this.context = context;\n-            this.contentUri = contentUri;\n-            this.parcelFileDescriptor = context.getContentResolver().openFileDescriptor(this.contentUri, \"w\");\n-            if (this.parcelFileDescriptor == null) {\n-                throw new IOException(\"FileDescriptor for the content '\" + this.contentUri + \"' cannot be opened.\");\n-            }\n-            this.fileOutputStream = new FileOutputStream(this.parcelFileDescriptor.getFileDescriptor());\n-            this.fileChannel = this.fileOutputStream.getChannel();\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Njk3Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466976", "body": "```suggestion\r\n            // so that providers that return subsections of a file are supported.\r\n            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        // so that providers that return subsections of a file are supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> so that providers that <span class=\"x x-first x-last\">returns subsection</span> of file <span class=\"x x-first x-last\">gets</span> supported.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> so that providers that <span class=\"x x-first x-last\">return subsections</span> of <span class=\"x x-first x-last\">a </span>file <span class=\"x x-first x-last\">are</span> supported.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-c\"><span class=\"pl-c\">//</span> The \"r\" (read) mode is used so that the content providers that don't support write can also <span class=\"x x-first x-last\">be </span>consumed.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:19:45Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -111,8 +116,8 @@ final class ReadableContent {\n         if (this.useContentResolver) {\n             this.checkPersistableReadGranted();\n             // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that returns subsection of file gets supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            // so that providers that return subsections of a file are supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n             try (AssetFileDescriptor descriptor\n                      = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n                 try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NzE4Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433467187", "body": "```suggestion\r\n     * @param contentUri the URI identifying the content\r\n     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri the content URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n          \n          \n            \n                 * @param contentUri the URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the <span class=\"x x-first x-last\">content </span><span class=\"pl-c1\">URI</span> identifying the content</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> useContentResolver <span class=\"x x-first x-last\">indicate</span> whether to use {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">android.content<span class=\"pl-k\">.</span>ContentResolver</span>} to resolve</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> contentUri the <span class=\"pl-c1\">URI</span> identifying the content</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> useContentResolver <span class=\"x x-first x-last\">indicates</span> whether to use {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">android.content<span class=\"pl-k\">.</span>ContentResolver</span>} to resolve</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vcolin7", "createdAt": "2020-06-01T20:20:12Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "daa09584f64a0dcf84d686529274c98419b42952", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\nindex 93f998377..8b18a5751 100644\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n", "chunk": "@@ -32,8 +31,8 @@ final class ReadableContent {\n      * Create ReadableContent representing a content in the device from which data can be read.\n      *\n      * @param context the context\n-     * @param contentUri the content URI identifying the content\n-     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     * @param contentUri the URI identifying the content\n+     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n      *                           the content URI\n      */\n     ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n", "next_change": {"commit": "927088035fe49832bd9f9c35bcd3a920e9148b8c", "changed_code": [{"header": "diff --git a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java b/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\ndeleted file mode 100644\nindex 8b18a5751..000000000\n--- a/sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java\n+++ /dev/null\n", "chunk": "@@ -1,212 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.android.storage.blob.transfer;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.UriPermission;\n-import android.content.res.AssetFileDescriptor;\n-import android.net.Uri;\n-\n-import androidx.annotation.MainThread;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.List;\n-\n-/**\n- * Package private.\n- *\n- * A type that describes a content in the device from which data can be read.\n- */\n-final class ReadableContent {\n-    private final Context context;\n-    private final Uri contentUri;\n-    private final boolean useContentResolver;\n-\n-    /**\n-     * Create ReadableContent representing a content in the device from which data can be read.\n-     *\n-     * @param context the context\n-     * @param contentUri the URI identifying the content\n-     * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve\n-     *                           the content URI\n-     */\n-    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n-        this.context = context;\n-        this.contentUri = contentUri;\n-        this.useContentResolver = useContentResolver;\n-    }\n-\n-    /**\n-     * Get the {@link Uri} to the content.\n-     *\n-     * @return the content URI\n-     */\n-    Uri getUri() {\n-        return this.contentUri;\n-    }\n-\n-    /**\n-     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n-     *\n-     * @return true if resolving content URI requires content resolver.\n-     */\n-    boolean isUsingContentResolver() {\n-        return this.useContentResolver;\n-    }\n-\n-    /**\n-     * Attempt to take persistable read permission on the content.\n-     *\n-     * @throws IllegalStateException if read permission is not granted\n-     */\n-    @MainThread\n-    void takePersistableReadPermission() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.context.getContentResolver()\n-                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            checkPersistableReadGranted();\n-        }\n-    }\n-\n-    /**\n-     * Get the total size of the content in bytes.\n-     *\n-     * @return the content size in bytes\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws UnsupportedOperationException if content length is unknown\n-     * @throws IOException if there is a failure when closing the content opened to fetch the length\n-     */\n-    long getLength() throws IOException, UnsupportedOperationException {\n-        if (this.useContentResolver) {\n-            final long contentLength;\n-            // Note: openAssetFileDescriptor throws FileNotFoundException if content not exists.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                contentLength = descriptor.getLength();\n-            }\n-            if (contentLength == AssetFileDescriptor.UNKNOWN_LENGTH) {\n-                throw new UnsupportedOperationException(\"The size of the content '\" + contentUri + \"' is unknown.\");\n-            }\n-            return contentLength;\n-        } else {\n-            final File file = new File(contentUri.getPath());\n-            if (!file.exists() || !file.isFile()) {\n-                throw new FileNotFoundException(\"File resource does not exist: \" + contentUri.getPath());\n-            }\n-            return file.length();\n-        }\n-    }\n-\n-    /**\n-     * Read a block of bytes from the content.\n-     *\n-     * @param blockOffset the start offset of the block\n-     * @param blockSize the size of the block\n-     * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]\n-     * @throws FileNotFoundException if the content does not exists\n-     * @throws IOException the IO error when attempting to read\n-     * @throws IllegalStateException if read permission is not granted or revoked\n-     */\n-    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n-        if (this.useContentResolver) {\n-            this.checkPersistableReadGranted();\n-            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n-            // so that providers that return subsections of a file are supported.\n-            // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.\n-            try (AssetFileDescriptor descriptor\n-                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n-                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n-                    seek(fileInputStream, blockOffset);\n-                    byte [] blockContent = new byte[blockSize];\n-                    read(fileInputStream, blockContent);\n-                    return blockContent;\n-                }\n-            }\n-        } else {\n-            File file = new File(this.contentUri.getPath());\n-            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n-                seek(fileInputStream, blockOffset);\n-                byte [] blockContent = new byte[blockSize];\n-                read(fileInputStream, blockContent);\n-                return blockContent;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check a persistable read permission is granted on the content.\n-     *\n-     * @throws Throwable if permission is not granted\n-     */\n-    private void checkPersistableReadGranted() throws IllegalStateException {\n-        if (this.useContentResolver) {\n-            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n-            boolean grantedRead = false;\n-            for (UriPermission permission : permissions) {\n-                if (permission.isReadPermission()) {\n-                    grantedRead = true;\n-                    break;\n-                }\n-            }\n-            if (!grantedRead) {\n-                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Seek the stream read cursor to the given position.\n-     *\n-     * @param stream the stream\n-     * @param seekTo the stream position to seek\n-     * @throws IOException if seek fails\n-     */\n-    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n-        int totalBytesSkipped = 0;\n-        while(totalBytesSkipped < seekTo) {\n-            final long bytesSkipped = stream.skip(seekTo - totalBytesSkipped);\n-            if (bytesSkipped < 0) {\n-                throw new IOException(\"FileInputStream::seek returned negative value.\");\n-            }\n-            if (bytesSkipped == 0) {\n-                // 0 can be returned from Stream::skip if EOF reached OR unable to skip at the moment.\n-                // Read one byte to see it's due to EOF.\n-                if (stream.read() == -1) {\n-                    // EOF hence return.\n-                    return;\n-                } else {\n-                    // not EOF but stream::read returned a byte.\n-                    totalBytesSkipped++;\n-                }\n-            } else {\n-                totalBytesSkipped += bytesSkipped;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Read the stream content into a buffer starting from the stream's read cursor position.\n-     *\n-     * @param stream the file stream\n-     * @param buffer the output buffer\n-     * @return the number of bytes read\n-     * @throws IOException if read fails\n-     */\n-    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n-        int bytesToRead = buffer.length;\n-        int bytesRead = 0;\n-        while (bytesRead < bytesToRead) {\n-            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);\n-            if (m == -1) {\n-                break;\n-            }\n-            bytesRead += m;\n-        }\n-        return bytesRead;\n-    }\n-}\n", "next_change": null}]}}]}}, {"oid": "710f50b854de3eef4dab2e9637c0703de587be6b", "url": "https://github.com/Azure/azure-sdk-for-android/commit/710f50b854de3eef4dab2e9637c0703de587be6b", "message": "Cleaning up javadoc\n\nCo-authored-by: vcolin7 <vicolina@microsoft.com>", "committedDate": "2020-06-01T22:06:47Z", "type": "commit"}, {"oid": "d1d43844d8519f29a09c8cb127be02607210d632", "url": "https://github.com/Azure/azure-sdk-for-android/commit/d1d43844d8519f29a09c8cb127be02607210d632", "message": "More stable ReadableContent::getLength implementation, rename isUseContentResolver to isUsingContentResolver.", "committedDate": "2020-06-02T01:39:15Z", "type": "commit"}, {"oid": "2d974b2f0779e2cd0c5741dcc4505201f956262f", "url": "https://github.com/Azure/azure-sdk-for-android/commit/2d974b2f0779e2cd0c5741dcc4505201f956262f", "message": "Really passing useContentResolver:true for download(Uri), comment update Content to content", "committedDate": "2020-06-02T01:58:29Z", "type": "commit"}]}