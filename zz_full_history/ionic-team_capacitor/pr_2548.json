{"pr_number": 2548, "pr_title": "feat(android): added configurable icon color for local notifications", "pr_author": "andysousa", "pr_createdAt": "2020-03-10T15:07:43Z", "pr_url": "https://github.com/ionic-team/capacitor/pull/2548", "timeline": [{"oid": "b1ec8cbf28bc23aa3a3f05d468f8668d399f65e9", "url": "https://github.com/ionic-team/capacitor/commit/b1ec8cbf28bc23aa3a3f05d468f8668d399f65e9", "message": "added configurable icon color for android local notifications", "committedDate": "2020-03-10T15:01:31Z", "type": "commit"}, {"oid": "627cf9718877b925d048d75cb743c5b6260f52c3", "url": "https://github.com/ionic-team/capacitor/commit/627cf9718877b925d048d75cb743c5b6260f52c3", "message": "updated the api documentation for webpage", "committedDate": "2020-03-10T18:06:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1NDIxMw==", "url": "https://github.com/ionic-team/capacitor/pull/2548#discussion_r393254213", "body": "this crash if the color is not valid, put it inside a try catch (check other plugins like Browser or Statusbar)", "bodyText": "this crash if the color is not valid, put it inside a try catch (check other plugins like Browser or Statusbar)", "bodyHTML": "<p dir=\"auto\">this crash if the color is not valid, put it inside a try catch (check other plugins like Browser or Statusbar)</p>", "author": "jcesarmobile", "createdAt": "2020-03-16T19:10:43Z", "path": "android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java", "diffHunk": "@@ -174,6 +175,12 @@ private void buildNotification(NotificationManagerCompat notificationManager, Lo\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n+\n+    String iconColor = localNotification.getIconColor();\n+    if (iconColor != null) {\n+      mBuilder.setColor(Color.parseColor(iconColor));", "originalCommit": "627cf9718877b925d048d75cb743c5b6260f52c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59d02ab95b3aeff7076f012828b35703a9015a10", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 92b1a8e5..a4fd2b3d 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -175,12 +178,6 @@ public class LocalNotificationManager {\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n-\n-    String iconColor = localNotification.getIconColor();\n-    if (iconColor != null) {\n-      mBuilder.setColor(Color.parseColor(iconColor));\n-    }\n-\n     createActionIntents(localNotification, mBuilder);\n     // notificationId is a unique int for each localNotification that you must define\n     Notification buildNotification = mBuilder.build();\n", "next_change": {"commit": "448e7b7a46858b3d8f963123549e0bcf03493805", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex a4fd2b3d..2bb048f9 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -174,6 +174,12 @@ public class LocalNotificationManager {\n       mBuilder.setGroup(group);\n     }\n \n+    // make sure scheduled time is shown instead of display time\n+    if (localNotification.isScheduled()) {\n+      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n+        .setShowWhen(true);\n+    }\n+\n     mBuilder.setVisibility(Notification.VISIBILITY_PRIVATE);\n     mBuilder.setOnlyAlertOnce(true);\n \n", "next_change": {"commit": "62b11fdc3c865747350ae7bbb0f1f3d129f0bfd6", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 2bb048f9..b7be3161 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -180,7 +180,7 @@ public class LocalNotificationManager {\n         .setShowWhen(true);\n     }\n \n-    mBuilder.setVisibility(Notification.VISIBILITY_PRIVATE);\n+    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n", "next_change": {"commit": "0bfa0bfeb7607e987b1a497bc8f5e0b64e9ca17d", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex b7be3161..202de9d8 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -184,6 +185,17 @@ public class LocalNotificationManager {\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n+\n+    String iconColor = localNotification.getIconColor();\n+    if (iconColor != null) {\n+      try {\n+        mBuilder.setColor(Color.parseColor(iconColor));\n+      } catch (IllegalArgumentException ex) {\n+        call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        return;\n+      }\n+    }\n+\n     createActionIntents(localNotification, mBuilder);\n     // notificationId is a unique int for each localNotification that you must define\n     Notification buildNotification = mBuilder.build();\n", "next_change": {"commit": "2a39a7d044d67096d555f09c22dde183b2f9b264", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 202de9d8..c0675465 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -168,30 +191,36 @@ public class LocalNotificationManager {\n               \"com.android.systemui\", soundUri,\n               Intent.FLAG_GRANT_READ_URI_PERMISSION);\n       mBuilder.setSound(soundUri);\n+      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+    } else {\n+      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n     }\n \n+\n     String group = localNotification.getGroup();\n     if (group != null) {\n       mBuilder.setGroup(group);\n     }\n \n     // make sure scheduled time is shown instead of display time\n-    if (localNotification.isScheduled()) {\n+    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n       mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n-        .setShowWhen(true);\n+              .setShowWhen(true);\n     }\n \n     mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n     mBuilder.setOnlyAlertOnce(true);\n \n-    mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n+    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n \n-    String iconColor = localNotification.getIconColor();\n+    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n     if (iconColor != null) {\n       try {\n         mBuilder.setColor(Color.parseColor(iconColor));\n       } catch (IllegalArgumentException ex) {\n-        call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        if(call != null) {\n+            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        }\n         return;\n       }\n     }\n", "next_change": {"commit": "e0ed9c90947c8e4bcd1f7b42f21c79d1e6bb50f3", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex c0675465..1336bea1 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -27,394 +25,399 @@ import com.getcapacitor.Logger;\n import com.getcapacitor.PluginCall;\n import com.getcapacitor.android.R;\n import com.getcapacitor.plugin.util.AssetUtil;\n-\n+import java.util.Date;\n+import java.util.List;\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import java.util.Date;\n-import java.util.List;\n-\n-\n /**\n  * Contains implementations for all notification actions\n  */\n public class LocalNotificationManager {\n-\n-  private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-  private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  // Action constants\n-  public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-  public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-  public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-  public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-  public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-  public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-  private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-  private Context context;\n-  private Activity activity;\n-  private NotificationStorage storage;\n-  private CapConfig config;\n-\n-  public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-    storage = notificationStorage;\n-    this.activity = activity;\n-    this.context = context;\n-    this.config = config;\n-  }\n-\n-  /**\n-   * Method extecuted when notification is launched by user from the notification bar.\n-   */\n-  public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-    Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-    int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-    if (notificationId == Integer.MIN_VALUE) {\n-      Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-      return null;\n+    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n+    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    // Action constants\n+    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n+    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n+    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n+    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n+    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n+\n+    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n+    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n+\n+    private Context context;\n+    private Activity activity;\n+    private NotificationStorage storage;\n+    private CapConfig config;\n+\n+    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n+        storage = notificationStorage;\n+        this.activity = activity;\n+        this.context = context;\n+        this.config = config;\n     }\n-    boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-    if (isRemovable) {\n-      notificationStorage.deleteNotification(Integer.toString(notificationId));\n-    }\n-    JSObject dataJson = new JSObject();\n \n-    Bundle results = RemoteInput.getResultsFromIntent(data);\n-    if (results != null) {\n-      CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-      dataJson.put(\"inputValue\", input.toString());\n-    }\n-    String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-    dismissVisibleNotification(notificationId);\n-\n-    dataJson.put(\"actionId\", menuAction);\n-    JSONObject request = null;\n-    try {\n-      String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-      if (notificationJsonString != null) {\n-        request = new JSObject(notificationJsonString);\n-      }\n-    } catch (JSONException e) {\n-    }\n-    dataJson.put(\"notification\", request);\n-    return dataJson;\n-  }\n-\n-  /**\n-   * Create notification channel\n-   */\n-  public void createNotificationChannel() {\n-    // Create the NotificationChannel, but only on API 26+ because\n-    // the NotificationChannel class is new and not in the support library\n-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-      CharSequence name = \"Default\";\n-      String description = \"Default\";\n-      int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-      NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-      channel.setDescription(description);\n-      AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-              .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-              .setUsage(AudioAttributes.USAGE_ALARM).build();\n-      Uri soundUri = this.getDefaultSoundUrl(context);\n-      if (soundUri != null) {\n-        channel.setSound(soundUri, audioAttributes);\n-      }\n-      // Register the channel with the system; you can't change the importance\n-      // or other notification behaviors after this\n-      android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-      notificationManager.createNotificationChannel(channel);\n-    }\n-  }\n-\n-  @Nullable\n-  public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-    JSONArray ids = new JSONArray();\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-    boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-    if (!notificationsEnabled) {\n-      if(call != null){\n-        call.error(\"Notifications not enabled on this device\");\n-      }\n-      return null;\n+    /**\n+     * Method extecuted when notification is launched by user from the notification bar.\n+     */\n+    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n+        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n+        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n+        if (notificationId == Integer.MIN_VALUE) {\n+            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n+            return null;\n+        }\n+        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n+        if (isRemovable) {\n+            notificationStorage.deleteNotification(Integer.toString(notificationId));\n+        }\n+        JSObject dataJson = new JSObject();\n+\n+        Bundle results = RemoteInput.getResultsFromIntent(data);\n+        if (results != null) {\n+            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n+            dataJson.put(\"inputValue\", input.toString());\n+        }\n+        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n+\n+        dismissVisibleNotification(notificationId);\n+\n+        dataJson.put(\"actionId\", menuAction);\n+        JSONObject request = null;\n+        try {\n+            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n+            if (notificationJsonString != null) {\n+                request = new JSObject(notificationJsonString);\n+            }\n+        } catch (JSONException e) {}\n+        dataJson.put(\"notification\", request);\n+        return dataJson;\n     }\n-    for (LocalNotification localNotification : localNotifications) {\n-      Integer id = localNotification.getId();\n-      if (localNotification.getId() == null) {\n-        if(call != null) {\n-          call.error(\"LocalNotification missing identifier\");\n+\n+    /**\n+     * Create notification channel\n+     */\n+    public void createNotificationChannel() {\n+        // Create the NotificationChannel, but only on API 26+ because\n+        // the NotificationChannel class is new and not in the support library\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            CharSequence name = \"Default\";\n+            String description = \"Default\";\n+            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n+            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n+            channel.setDescription(description);\n+            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n+                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n+                .setUsage(AudioAttributes.USAGE_ALARM)\n+                .build();\n+            Uri soundUri = this.getDefaultSoundUrl(context);\n+            if (soundUri != null) {\n+                channel.setSound(soundUri, audioAttributes);\n+            }\n+            // Register the channel with the system; you can't change the importance\n+            // or other notification behaviors after this\n+            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n+            notificationManager.createNotificationChannel(channel);\n         }\n-        return null;\n-      }\n-      dismissVisibleNotification(id);\n-      cancelTimerForNotification(id);\n-      buildNotification(notificationManager, localNotification, call);\n-      ids.put(id);\n     }\n-    return ids;\n-  }\n-\n-  // TODO Progressbar support\n-  // TODO System categories (DO_NOT_DISTURB etc.)\n-  // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-  // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-  // TODO use NotificationCompat.MessagingStyle for latest API\n-  // TODO expandable notification NotificationCompat.MessagingStyle\n-  // TODO media style notification support NotificationCompat.MediaStyle\n-  // TODO custom small/large icons\n-  private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-    String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-    if (localNotification.getChannelId() != null) {\n-      channelId = localNotification.getChannelId();\n+\n+    @Nullable\n+    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n+        JSONArray ids = new JSONArray();\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+\n+        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n+        if (!notificationsEnabled) {\n+            if (call != null) {\n+                call.error(\"Notifications not enabled on this device\");\n+            }\n+            return null;\n+        }\n+        for (LocalNotification localNotification : localNotifications) {\n+            Integer id = localNotification.getId();\n+            if (localNotification.getId() == null) {\n+                if (call != null) {\n+                    call.error(\"LocalNotification missing identifier\");\n+                }\n+                return null;\n+            }\n+            dismissVisibleNotification(id);\n+            cancelTimerForNotification(id);\n+            buildNotification(notificationManager, localNotification, call);\n+            ids.put(id);\n+        }\n+        return ids;\n     }\n-    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n+\n+    // TODO Progressbar support\n+    // TODO System categories (DO_NOT_DISTURB etc.)\n+    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n+    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n+    // TODO use NotificationCompat.MessagingStyle for latest API\n+    // TODO expandable notification NotificationCompat.MessagingStyle\n+    // TODO media style notification support NotificationCompat.MediaStyle\n+    // TODO custom small/large icons\n+    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n+        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n+        if (localNotification.getChannelId() != null) {\n+            channelId = localNotification.getChannelId();\n+        }\n+        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n             .setContentTitle(localNotification.getTitle())\n             .setContentText(localNotification.getBody())\n-            .setAutoCancel(true)\n-            .setOngoing(false)\n+            .setAutoCancel(localNotification.isAutoCancel())\n+            .setOngoing(localNotification.isOngoing())\n             .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n             .setGroupSummary(localNotification.isGroupSummary());\n \n+        // support multiline text\n+        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n+\n+        String sound = localNotification.getSound(context, getDefaultSound(context));\n+        if (sound != null) {\n+            Uri soundUri = Uri.parse(sound);\n+            // Grant permission to use sound\n+            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            mBuilder.setSound(soundUri);\n+            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+        } else {\n+            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        }\n \n-    // support multiline text\n-    mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-    String sound = localNotification.getSound(context, getDefaultSound(context));\n-    if (sound != null) {\n-      Uri soundUri = Uri.parse(sound);\n-      // Grant permission to use sound\n-      context.grantUriPermission(\n-              \"com.android.systemui\", soundUri,\n-              Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-      mBuilder.setSound(soundUri);\n-      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-    } else {\n-      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        String group = localNotification.getGroup();\n+        if (group != null) {\n+            mBuilder.setGroup(group);\n+        }\n+\n+        // make sure scheduled time is shown instead of display time\n+        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n+            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n+        }\n+\n+        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n+        mBuilder.setOnlyAlertOnce(true);\n+\n+        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+\n+        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n+        if (iconColor != null) {\n+            try {\n+                mBuilder.setColor(Color.parseColor(iconColor));\n+            } catch (IllegalArgumentException ex) {\n+                if (call != null) {\n+                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+                }\n+                return;\n+            }\n+        }\n+\n+        createActionIntents(localNotification, mBuilder);\n+        // notificationId is a unique int for each localNotification that you must define\n+        Notification buildNotification = mBuilder.build();\n+        if (localNotification.isScheduled()) {\n+            triggerScheduledNotification(buildNotification, localNotification);\n+        } else {\n+            notificationManager.notify(localNotification.getId(), buildNotification);\n+        }\n     }\n \n+    // Create intents for open/dissmis actions\n+    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n+        // Open intent\n+        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n+\n+        PendingIntent pendingIntent = PendingIntent.getActivity(\n+            context,\n+            localNotification.getId(),\n+            intent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+        mBuilder.setContentIntent(pendingIntent);\n+\n+        // Build action types\n+        String actionTypeId = localNotification.getActionTypeId();\n+        if (actionTypeId != null) {\n+            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n+            for (NotificationAction notificationAction : actionGroup) {\n+                // TODO Add custom icons to actions\n+                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n+                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n+                    context,\n+                    localNotification.getId() + notificationAction.getId().hashCode(),\n+                    actionIntent,\n+                    PendingIntent.FLAG_CANCEL_CURRENT\n+                );\n+                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n+                    R.drawable.ic_transparent,\n+                    notificationAction.getTitle(),\n+                    actionPendingIntent\n+                );\n+                if (notificationAction.isInput()) {\n+                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n+                    actionBuilder.addRemoteInput(remoteInput);\n+                }\n+                mBuilder.addAction(actionBuilder.build());\n+            }\n+        }\n \n-    String group = localNotification.getGroup();\n-    if (group != null) {\n-      mBuilder.setGroup(group);\n+        // Dismiss intent\n+        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n+        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n+        mBuilder.setDeleteIntent(deleteIntent);\n     }\n \n-    // make sure scheduled time is shown instead of display time\n-    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n-              .setShowWhen(true);\n+    @NonNull\n+    private Intent buildIntent(LocalNotification localNotification, String action) {\n+        Intent intent;\n+        if (activity != null) {\n+            intent = new Intent(context, activity.getClass());\n+        } else {\n+            String packageName = context.getPackageName();\n+            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n+        }\n+        intent.setAction(Intent.ACTION_MAIN);\n+        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n+        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        intent.putExtra(ACTION_INTENT_KEY, action);\n+        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        return intent;\n     }\n \n-    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-    mBuilder.setOnlyAlertOnce(true);\n+    /**\n+     * Build a notification trigger, such as triggering each N seconds, or\n+     * on a certain date \"shape\" (such as every first of the month)\n+     */\n+    // TODO support different AlarmManager.RTC modes depending on priority\n+    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n+        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+        LocalNotificationSchedule schedule = request.getSchedule();\n+        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n+        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n+        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n+        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n+            context,\n+            request.getId(),\n+            notificationIntent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+\n+        // Schedule at specific time (with repeating support)\n+        Date at = schedule.getAt();\n+        if (at != null) {\n+            if (at.getTime() < new Date().getTime()) {\n+                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n+                return;\n+            }\n+            if (schedule.isRepeating()) {\n+                long interval = at.getTime() - new Date().getTime();\n+                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n+            } else {\n+                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n+            }\n+            return;\n+        }\n \n-    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+        // Schedule at specific intervals\n+        String every = schedule.getEvery();\n+        if (every != null) {\n+            Long everyInterval = schedule.getEveryInterval();\n+            if (everyInterval != null) {\n+                long startTime = new Date().getTime() + everyInterval;\n+                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n+            }\n+            return;\n+        }\n \n-    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-    if (iconColor != null) {\n-      try {\n-        mBuilder.setColor(Color.parseColor(iconColor));\n-      } catch (IllegalArgumentException ex) {\n-        if(call != null) {\n-            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        // Cron like scheduler\n+        DateMatch on = schedule.getOn();\n+        if (on != null) {\n+            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n+            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+            alarmManager.setExact(AlarmManager.RTC, on.nextTrigger(new Date()), pendingIntent);\n         }\n-        return;\n-      }\n     }\n \n-    createActionIntents(localNotification, mBuilder);\n-    // notificationId is a unique int for each localNotification that you must define\n-    Notification buildNotification = mBuilder.build();\n-    if (localNotification.isScheduled()) {\n-      triggerScheduledNotification(buildNotification, localNotification);\n-    } else {\n-      notificationManager.notify(localNotification.getId(), buildNotification);\n-    }\n-  }\n-\n-  // Create intents for open/dissmis actions\n-  private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-    // Open intent\n-    Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-    PendingIntent pendingIntent = PendingIntent.getActivity(context, localNotification.getId(), intent, PendingIntent.FLAG_CANCEL_CURRENT);\n-    mBuilder.setContentIntent(pendingIntent);\n-\n-    // Build action types\n-    String actionTypeId = localNotification.getActionTypeId();\n-    if (actionTypeId != null) {\n-      NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-      for (int i = 0; i < actionGroup.length; i++) {\n-        NotificationAction notificationAction = actionGroup[i];\n-        // TODO Add custom icons to actions\n-        Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-        PendingIntent actionPendingIntent = PendingIntent.getActivity(context, localNotification.getId() + notificationAction.getId().hashCode(), actionIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(R.drawable.ic_transparent, notificationAction.getTitle(), actionPendingIntent);\n-        if (notificationAction.isInput()) {\n-          RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY)\n-                  .setLabel(notificationAction.getTitle())\n-                  .build();\n-          actionBuilder.addRemoteInput(remoteInput);\n+    public void cancel(PluginCall call) {\n+        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n+        if (notificationsToCancel != null) {\n+            for (Integer id : notificationsToCancel) {\n+                dismissVisibleNotification(id);\n+                cancelTimerForNotification(id);\n+                storage.deleteNotification(Integer.toString(id));\n+            }\n         }\n-        mBuilder.addAction(actionBuilder.build());\n-      }\n+        call.success();\n     }\n \n-    // Dismiss intent\n-    Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-    dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-    dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    PendingIntent deleteIntent = PendingIntent.getBroadcast(\n-            context, localNotification.getId(), dissmissIntent, 0);\n-    mBuilder.setDeleteIntent(deleteIntent);\n-  }\n-\n-  @NonNull\n-  private Intent buildIntent(LocalNotification localNotification, String action) {\n-    Intent intent;\n-    if (activity != null) {\n-      intent = new Intent(context, activity.getClass());\n-    } else {\n-      String packageName = context.getPackageName();\n-      intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-    }\n-    intent.setAction(Intent.ACTION_MAIN);\n-    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-    intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    intent.putExtra(ACTION_INTENT_KEY, action);\n-    intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    return intent;\n-  }\n-\n-  /**\n-   * Build a notification trigger, such as triggering each N seconds, or\n-   * on a certain date \"shape\" (such as every first of the month)\n-   */\n-  // TODO support different AlarmManager.RTC modes depending on priority\n-  private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-    LocalNotificationSchedule schedule = request.getSchedule();\n-    Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-    notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-    notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-\n-    // Schedule at specific time (with repeating support)\n-    Date at = schedule.getAt();\n-    if (at != null) {\n-      if (at.getTime() < new Date().getTime()) {\n-        Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-        return;\n-      }\n-      if (schedule.isRepeating()) {\n-        long interval = at.getTime() - new Date().getTime();\n-        alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-      } else {\n-        alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-      }\n-      return;\n+    private void cancelTimerForNotification(Integer notificationId) {\n+        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n+        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n+        if (pi != null) {\n+            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+            alarmManager.cancel(pi);\n+        }\n     }\n \n-    // Schedule at specific intervals\n-    String every = schedule.getEvery();\n-    if (every != null) {\n-      Long everyInterval = schedule.getEveryInterval();\n-      if (everyInterval != null) {\n-        long startTime = new Date().getTime() + everyInterval;\n-        alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-      }\n-      return;\n+    private void dismissVisibleNotification(int notificationId) {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n+        notificationManager.cancel(notificationId);\n     }\n \n-    // Cron like scheduler\n-    DateMatch on = schedule.getOn();\n-    if (on != null) {\n-      notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-      pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-      alarmManager.setExact(AlarmManager.RTC, on.nextTrigger(new Date()), pendingIntent);\n-    }\n-  }\n-\n-  public void cancel(PluginCall call) {\n-    List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-    if (notificationsToCancel != null) {\n-      for (Integer id : notificationsToCancel) {\n-        dismissVisibleNotification(id);\n-        cancelTimerForNotification(id);\n-        storage.deleteNotification(Integer.toString(id));\n-      }\n-    }\n-    call.success();\n-  }\n-\n-  private void cancelTimerForNotification(Integer notificationId) {\n-    Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-    PendingIntent pi = PendingIntent.getBroadcast(\n-            context, notificationId, intent, 0);\n-    if (pi != null) {\n-      AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-      alarmManager.cancel(pi);\n+    public boolean areNotificationsEnabled() {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+        return notificationManager.areNotificationsEnabled();\n     }\n-  }\n-\n-  private void dismissVisibleNotification(int notificationId) {\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-    notificationManager.cancel(notificationId);\n-  }\n-\n-  public boolean areNotificationsEnabled(){\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-    return notificationManager.areNotificationsEnabled();\n-  }\n-\n-  public Uri getDefaultSoundUrl(Context context){\n-    int soundId = this.getDefaultSound(context);\n-    if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+\n+    public Uri getDefaultSoundUrl(Context context) {\n+        int soundId = this.getDefaultSound(context);\n+        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n \n-  private int getDefaultSound(Context context){\n-    if(defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n+    private int getDefaultSound(Context context) {\n+        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-    soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n+        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n \n-    if(soundConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        if (soundConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        }\n+\n+        defaultSoundID = resId;\n+        return resId;\n     }\n \n-    defaultSoundID = resId;\n-    return resId;\n-  }\n+    private int getDefaultSmallIcon(Context context) {\n+        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n \n-  private int getDefaultSmallIcon(Context context){\n-    if(defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n+        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-    smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n+        if (smallIconConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n+        }\n \n-    if(smallIconConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-    }\n+        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            resId = android.R.drawable.ic_dialog_info;\n+        }\n \n-    if(resId == AssetUtil.RESOURCE_ID_ZERO_VALUE){\n-      resId = android.R.drawable.ic_dialog_info;\n+        defaultSmallIconID = resId;\n+        return resId;\n     }\n-\n-    defaultSmallIconID = resId;\n-    return resId;\n-  }\n }\n", "next_change": {"commit": "15af432094bb83fb78919db134a2cb0d8eda305d", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 1336bea1..1f55d0ec 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -25,399 +27,398 @@ import com.getcapacitor.Logger;\n import com.getcapacitor.PluginCall;\n import com.getcapacitor.android.R;\n import com.getcapacitor.plugin.util.AssetUtil;\n-import java.util.Date;\n-import java.util.List;\n+\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+\n+\n /**\n  * Contains implementations for all notification actions\n  */\n public class LocalNotificationManager {\n-    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    // Action constants\n-    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-    private Context context;\n-    private Activity activity;\n-    private NotificationStorage storage;\n-    private CapConfig config;\n-\n-    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-        storage = notificationStorage;\n-        this.activity = activity;\n-        this.context = context;\n-        this.config = config;\n-    }\n-\n-    /**\n-     * Method extecuted when notification is launched by user from the notification bar.\n-     */\n-    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-        if (notificationId == Integer.MIN_VALUE) {\n-            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-            return null;\n-        }\n-        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-        if (isRemovable) {\n-            notificationStorage.deleteNotification(Integer.toString(notificationId));\n-        }\n-        JSObject dataJson = new JSObject();\n \n-        Bundle results = RemoteInput.getResultsFromIntent(data);\n-        if (results != null) {\n-            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-            dataJson.put(\"inputValue\", input.toString());\n-        }\n-        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-        dismissVisibleNotification(notificationId);\n-\n-        dataJson.put(\"actionId\", menuAction);\n-        JSONObject request = null;\n-        try {\n-            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-            if (notificationJsonString != null) {\n-                request = new JSObject(notificationJsonString);\n-            }\n-        } catch (JSONException e) {}\n-        dataJson.put(\"notification\", request);\n-        return dataJson;\n+  private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n+  private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+  private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+  // Action constants\n+  public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n+  public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n+  public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n+  public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n+  public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n+\n+  public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n+  private static final String DEFAULT_PRESS_ACTION = \"tap\";\n+\n+  private Context context;\n+  private Activity activity;\n+  private NotificationStorage storage;\n+  private CapConfig config;\n+\n+  public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n+    storage = notificationStorage;\n+    this.activity = activity;\n+    this.context = context;\n+    this.config = config;\n+  }\n+\n+  /**\n+   * Method extecuted when notification is launched by user from the notification bar.\n+   */\n+  public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n+    Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n+    int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n+    if (notificationId == Integer.MIN_VALUE) {\n+      Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n+      return null;\n     }\n-\n-    /**\n-     * Create notification channel\n-     */\n-    public void createNotificationChannel() {\n-        // Create the NotificationChannel, but only on API 26+ because\n-        // the NotificationChannel class is new and not in the support library\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-            CharSequence name = \"Default\";\n-            String description = \"Default\";\n-            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-            channel.setDescription(description);\n-            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-                .setUsage(AudioAttributes.USAGE_ALARM)\n-                .build();\n-            Uri soundUri = this.getDefaultSoundUrl(context);\n-            if (soundUri != null) {\n-                channel.setSound(soundUri, audioAttributes);\n-            }\n-            // Register the channel with the system; you can't change the importance\n-            // or other notification behaviors after this\n-            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-            notificationManager.createNotificationChannel(channel);\n-        }\n+    boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n+    if (isRemovable) {\n+      notificationStorage.deleteNotification(Integer.toString(notificationId));\n     }\n+    JSObject dataJson = new JSObject();\n \n-    @Nullable\n-    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-        JSONArray ids = new JSONArray();\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-        if (!notificationsEnabled) {\n-            if (call != null) {\n-                call.error(\"Notifications not enabled on this device\");\n-            }\n-            return null;\n-        }\n-        for (LocalNotification localNotification : localNotifications) {\n-            Integer id = localNotification.getId();\n-            if (localNotification.getId() == null) {\n-                if (call != null) {\n-                    call.error(\"LocalNotification missing identifier\");\n-                }\n-                return null;\n-            }\n-            dismissVisibleNotification(id);\n-            cancelTimerForNotification(id);\n-            buildNotification(notificationManager, localNotification, call);\n-            ids.put(id);\n-        }\n-        return ids;\n+    Bundle results = RemoteInput.getResultsFromIntent(data);\n+    if (results != null) {\n+      CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n+      dataJson.put(\"inputValue\", input.toString());\n     }\n-\n-    // TODO Progressbar support\n-    // TODO System categories (DO_NOT_DISTURB etc.)\n-    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-    // TODO use NotificationCompat.MessagingStyle for latest API\n-    // TODO expandable notification NotificationCompat.MessagingStyle\n-    // TODO media style notification support NotificationCompat.MediaStyle\n-    // TODO custom small/large icons\n-    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-        if (localNotification.getChannelId() != null) {\n-            channelId = localNotification.getChannelId();\n+    String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n+\n+    dismissVisibleNotification(notificationId);\n+\n+    dataJson.put(\"actionId\", menuAction);\n+    JSONObject request = null;\n+    try {\n+      String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n+      if (notificationJsonString != null) {\n+        request = new JSObject(notificationJsonString);\n+      }\n+    } catch (JSONException e) {\n+    }\n+    dataJson.put(\"notification\", request);\n+    return dataJson;\n+  }\n+\n+  /**\n+   * Create notification channel\n+   */\n+  public void createNotificationChannel() {\n+    // Create the NotificationChannel, but only on API 26+ because\n+    // the NotificationChannel class is new and not in the support library\n+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+      CharSequence name = \"Default\";\n+      String description = \"Default\";\n+      int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n+      NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n+      channel.setDescription(description);\n+      AudioAttributes audioAttributes = new AudioAttributes.Builder()\n+              .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n+              .setUsage(AudioAttributes.USAGE_ALARM).build();\n+      Uri soundUri = this.getDefaultSoundUrl(context);\n+      if (soundUri != null) {\n+        channel.setSound(soundUri, audioAttributes);\n+      }\n+      // Register the channel with the system; you can't change the importance\n+      // or other notification behaviors after this\n+      android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n+      notificationManager.createNotificationChannel(channel);\n+    }\n+  }\n+\n+  @Nullable\n+  public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n+    JSONArray ids = new JSONArray();\n+    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+\n+    boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n+    if (!notificationsEnabled) {\n+      if(call != null){\n+        call.error(\"Notifications not enabled on this device\");\n+      }\n+      return null;\n+    }\n+    for (LocalNotification localNotification : localNotifications) {\n+      Integer id = localNotification.getId();\n+      if (localNotification.getId() == null) {\n+        if(call != null) {\n+          call.error(\"LocalNotification missing identifier\");\n         }\n-        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n+        return null;\n+      }\n+      dismissVisibleNotification(id);\n+      cancelTimerForNotification(id);\n+      buildNotification(notificationManager, localNotification, call);\n+      ids.put(id);\n+    }\n+    return ids;\n+  }\n+\n+  // TODO Progressbar support\n+  // TODO System categories (DO_NOT_DISTURB etc.)\n+  // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n+  // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n+  // TODO use NotificationCompat.MessagingStyle for latest API\n+  // TODO expandable notification NotificationCompat.MessagingStyle\n+  // TODO media style notification support NotificationCompat.MediaStyle\n+  // TODO custom small/large icons\n+  private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n+    String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n+    if (localNotification.getChannelId() != null) {\n+      channelId = localNotification.getChannelId();\n+    }\n+    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n             .setContentTitle(localNotification.getTitle())\n             .setContentText(localNotification.getBody())\n-            .setAutoCancel(localNotification.isAutoCancel())\n-            .setOngoing(localNotification.isOngoing())\n+            .setAutoCancel( localNotification.isAutoCancel( ) )\n+            .setOngoing( localNotification.isOngoing( ) )\n             .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n             .setGroupSummary(localNotification.isGroupSummary());\n \n-        // support multiline text\n-        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-        String sound = localNotification.getSound(context, getDefaultSound(context));\n-        if (sound != null) {\n-            Uri soundUri = Uri.parse(sound);\n-            // Grant permission to use sound\n-            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            mBuilder.setSound(soundUri);\n-            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-        } else {\n-            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n-        }\n \n-        String group = localNotification.getGroup();\n-        if (group != null) {\n-            mBuilder.setGroup(group);\n-        }\n-\n-        // make sure scheduled time is shown instead of display time\n-        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n-        }\n-\n-        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-        mBuilder.setOnlyAlertOnce(true);\n-\n-        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n-\n-        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-        if (iconColor != null) {\n-            try {\n-                mBuilder.setColor(Color.parseColor(iconColor));\n-            } catch (IllegalArgumentException ex) {\n-                if (call != null) {\n-                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n-                }\n-                return;\n-            }\n-        }\n-\n-        createActionIntents(localNotification, mBuilder);\n-        // notificationId is a unique int for each localNotification that you must define\n-        Notification buildNotification = mBuilder.build();\n-        if (localNotification.isScheduled()) {\n-            triggerScheduledNotification(buildNotification, localNotification);\n-        } else {\n-            notificationManager.notify(localNotification.getId(), buildNotification);\n-        }\n+    // support multiline text\n+    mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n+\n+    String sound = localNotification.getSound(context, getDefaultSound(context));\n+    if (sound != null) {\n+      Uri soundUri = Uri.parse(sound);\n+      // Grant permission to use sound\n+      context.grantUriPermission(\n+              \"com.android.systemui\", soundUri,\n+              Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+      mBuilder.setSound(soundUri);\n+      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+    } else {\n+      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n     }\n \n-    // Create intents for open/dissmis actions\n-    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-        // Open intent\n-        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-        PendingIntent pendingIntent = PendingIntent.getActivity(\n-            context,\n-            localNotification.getId(),\n-            intent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-        mBuilder.setContentIntent(pendingIntent);\n-\n-        // Build action types\n-        String actionTypeId = localNotification.getActionTypeId();\n-        if (actionTypeId != null) {\n-            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-            for (NotificationAction notificationAction : actionGroup) {\n-                // TODO Add custom icons to actions\n-                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n-                    context,\n-                    localNotification.getId() + notificationAction.getId().hashCode(),\n-                    actionIntent,\n-                    PendingIntent.FLAG_CANCEL_CURRENT\n-                );\n-                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n-                    R.drawable.ic_transparent,\n-                    notificationAction.getTitle(),\n-                    actionPendingIntent\n-                );\n-                if (notificationAction.isInput()) {\n-                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n-                    actionBuilder.addRemoteInput(remoteInput);\n-                }\n-                mBuilder.addAction(actionBuilder.build());\n-            }\n-        }\n \n-        // Dismiss intent\n-        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n-        mBuilder.setDeleteIntent(deleteIntent);\n+    String group = localNotification.getGroup();\n+    if (group != null) {\n+      mBuilder.setGroup(group);\n     }\n \n-    @NonNull\n-    private Intent buildIntent(LocalNotification localNotification, String action) {\n-        Intent intent;\n-        if (activity != null) {\n-            intent = new Intent(context, activity.getClass());\n-        } else {\n-            String packageName = context.getPackageName();\n-            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-        }\n-        intent.setAction(Intent.ACTION_MAIN);\n-        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        intent.putExtra(ACTION_INTENT_KEY, action);\n-        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        return intent;\n+    // make sure scheduled time is shown instead of display time\n+    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n+      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n+              .setShowWhen(true);\n     }\n \n-    /**\n-     * Build a notification trigger, such as triggering each N seconds, or\n-     * on a certain date \"shape\" (such as every first of the month)\n-     */\n-    // TODO support different AlarmManager.RTC modes depending on priority\n-    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-        LocalNotificationSchedule schedule = request.getSchedule();\n-        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n-            context,\n-            request.getId(),\n-            notificationIntent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-\n-        // Schedule at specific time (with repeating support)\n-        Date at = schedule.getAt();\n-        if (at != null) {\n-            if (at.getTime() < new Date().getTime()) {\n-                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-                return;\n-            }\n-            if (schedule.isRepeating()) {\n-                long interval = at.getTime() - new Date().getTime();\n-                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-            } else {\n-                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-            }\n-            return;\n-        }\n+    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n+    mBuilder.setOnlyAlertOnce(true);\n \n-        // Schedule at specific intervals\n-        String every = schedule.getEvery();\n-        if (every != null) {\n-            Long everyInterval = schedule.getEveryInterval();\n-            if (everyInterval != null) {\n-                long startTime = new Date().getTime() + everyInterval;\n-                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-            }\n-            return;\n-        }\n+    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n \n-        // Cron like scheduler\n-        DateMatch on = schedule.getOn();\n-        if (on != null) {\n-            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-            alarmManager.setExact(AlarmManager.RTC, on.nextTrigger(new Date()), pendingIntent);\n+    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n+    if (iconColor != null) {\n+      try {\n+        mBuilder.setColor(Color.parseColor(iconColor));\n+      } catch (IllegalArgumentException ex) {\n+        if(call != null) {\n+            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n         }\n+        return;\n+      }\n     }\n \n-    public void cancel(PluginCall call) {\n-        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-        if (notificationsToCancel != null) {\n-            for (Integer id : notificationsToCancel) {\n-                dismissVisibleNotification(id);\n-                cancelTimerForNotification(id);\n-                storage.deleteNotification(Integer.toString(id));\n-            }\n-        }\n-        call.success();\n+    createActionIntents(localNotification, mBuilder);\n+    // notificationId is a unique int for each localNotification that you must define\n+    Notification buildNotification = mBuilder.build();\n+    if (localNotification.isScheduled()) {\n+      triggerScheduledNotification(buildNotification, localNotification);\n+    } else {\n+      notificationManager.notify(localNotification.getId(), buildNotification);\n     }\n-\n-    private void cancelTimerForNotification(Integer notificationId) {\n-        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n-        if (pi != null) {\n-            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-            alarmManager.cancel(pi);\n+  }\n+\n+  // Create intents for open/dissmis actions\n+  private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n+    // Open intent\n+    Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n+\n+    PendingIntent pendingIntent = PendingIntent.getActivity(context, localNotification.getId(), intent, PendingIntent.FLAG_CANCEL_CURRENT);\n+    mBuilder.setContentIntent(pendingIntent);\n+\n+    // Build action types\n+    String actionTypeId = localNotification.getActionTypeId();\n+    if (actionTypeId != null) {\n+      NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n+      for (int i = 0; i < actionGroup.length; i++) {\n+        NotificationAction notificationAction = actionGroup[i];\n+        // TODO Add custom icons to actions\n+        Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n+        PendingIntent actionPendingIntent = PendingIntent.getActivity(context, localNotification.getId() + notificationAction.getId().hashCode(), actionIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(R.drawable.ic_transparent, notificationAction.getTitle(), actionPendingIntent);\n+        if (notificationAction.isInput()) {\n+          RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY)\n+                  .setLabel(notificationAction.getTitle())\n+                  .build();\n+          actionBuilder.addRemoteInput(remoteInput);\n         }\n+        mBuilder.addAction(actionBuilder.build());\n+      }\n     }\n \n-    private void dismissVisibleNotification(int notificationId) {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-        notificationManager.cancel(notificationId);\n+    // Dismiss intent\n+    Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n+    dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+    dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+    dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n+    LocalNotificationSchedule schedule = localNotification.getSchedule();\n+    dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+    PendingIntent deleteIntent = PendingIntent.getBroadcast(\n+            context, localNotification.getId(), dissmissIntent, 0);\n+    mBuilder.setDeleteIntent(deleteIntent);\n+  }\n+\n+  @NonNull\n+  private Intent buildIntent(LocalNotification localNotification, String action) {\n+    Intent intent;\n+    if (activity != null) {\n+      intent = new Intent(context, activity.getClass());\n+    } else {\n+      String packageName = context.getPackageName();\n+      intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n     }\n-\n-    public boolean areNotificationsEnabled() {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-        return notificationManager.areNotificationsEnabled();\n+    intent.setAction(Intent.ACTION_MAIN);\n+    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n+    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+    intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+    intent.putExtra(ACTION_INTENT_KEY, action);\n+    intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n+    LocalNotificationSchedule schedule = localNotification.getSchedule();\n+    intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+    return intent;\n+  }\n+\n+  /**\n+   * Build a notification trigger, such as triggering each N seconds, or\n+   * on a certain date \"shape\" (such as every first of the month)\n+   */\n+  // TODO support different AlarmManager.RTC modes depending on priority\n+  private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n+    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+    LocalNotificationSchedule schedule = request.getSchedule();\n+    Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n+    notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n+    notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n+    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+\n+    // Schedule at specific time (with repeating support)\n+    Date at = schedule.getAt();\n+    if (at != null) {\n+      if (at.getTime() < new Date().getTime()) {\n+        Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n+        return;\n+      }\n+      if (schedule.isRepeating()) {\n+        long interval = at.getTime() - new Date().getTime();\n+        alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n+      } else {\n+        alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n+      }\n+      return;\n     }\n \n-    public Uri getDefaultSoundUrl(Context context) {\n-        int soundId = this.getDefaultSound(context);\n-        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n-        }\n-        return null;\n+    // Schedule at specific intervals\n+    String every = schedule.getEvery();\n+    if (every != null) {\n+      Long everyInterval = schedule.getEveryInterval();\n+      if (everyInterval != null) {\n+        long startTime = new Date().getTime() + everyInterval;\n+        alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n+      }\n+      return;\n     }\n \n-    private int getDefaultSound(Context context) {\n-        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n+    // Cron like scheduler\n+    DateMatch on = schedule.getOn();\n+    if (on != null) {\n+      long trigger = on.nextTrigger(new Date());\n+      notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n+      pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+      alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n+      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n+      Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n+    }\n+  }\n+\n+  public void cancel(PluginCall call) {\n+    List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n+    if (notificationsToCancel != null) {\n+      for (Integer id : notificationsToCancel) {\n+        dismissVisibleNotification(id);\n+        cancelTimerForNotification(id);\n+        storage.deleteNotification(Integer.toString(id));\n+      }\n+    }\n+    call.success();\n+  }\n+\n+  private void cancelTimerForNotification(Integer notificationId) {\n+    Intent intent = new Intent(context, TimedNotificationPublisher.class);\n+    PendingIntent pi = PendingIntent.getBroadcast(\n+            context, notificationId, intent, 0);\n+    if (pi != null) {\n+      AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+      alarmManager.cancel(pi);\n+    }\n+  }\n+\n+  private void dismissVisibleNotification(int notificationId) {\n+    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n+    notificationManager.cancel(notificationId);\n+  }\n+\n+  public boolean areNotificationsEnabled(){\n+    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+    return notificationManager.areNotificationsEnabled();\n+  }\n+\n+  public Uri getDefaultSoundUrl(Context context){\n+    int soundId = this.getDefaultSound(context);\n+    if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+    }\n+    return null;\n+  }\n \n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n+  private int getDefaultSound(Context context){\n+    if(defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n \n-        if (soundConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n-        }\n+    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n+    soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n \n-        defaultSoundID = resId;\n-        return resId;\n+    if(soundConfigResourceName != null){\n+      resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n     }\n \n-    private int getDefaultSmallIcon(Context context) {\n-        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n+    defaultSoundID = resId;\n+    return resId;\n+  }\n \n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n+  private int getDefaultSmallIcon(Context context){\n+    if(defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n \n-        if (smallIconConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-        }\n+    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n+    smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n \n-        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            resId = android.R.drawable.ic_dialog_info;\n-        }\n+    if(smallIconConfigResourceName != null){\n+      resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n+    }\n \n-        defaultSmallIconID = resId;\n-        return resId;\n+    if(resId == AssetUtil.RESOURCE_ID_ZERO_VALUE){\n+      resId = android.R.drawable.ic_dialog_info;\n     }\n+\n+    defaultSmallIconID = resId;\n+    return resId;\n+  }\n }\n", "next_change": {"commit": "2201ba099b5f1362529a45d7e114761f5bf4f9bb", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 1f55d0ec..2e9b347d 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -13,412 +13,414 @@ import android.media.AudioAttributes;\n import android.net.Uri;\n import android.os.Build;\n import android.os.Bundle;\n-\n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n import androidx.core.app.NotificationCompat;\n import androidx.core.app.NotificationManagerCompat;\n import androidx.core.app.RemoteInput;\n-\n import com.getcapacitor.CapConfig;\n-import com.getcapacitor.Config;\n import com.getcapacitor.JSObject;\n import com.getcapacitor.Logger;\n import com.getcapacitor.PluginCall;\n import com.getcapacitor.android.R;\n import com.getcapacitor.plugin.util.AssetUtil;\n-\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n-\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.List;\n-\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n \n /**\n  * Contains implementations for all notification actions\n  */\n public class LocalNotificationManager {\n-\n-  private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-  private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  // Action constants\n-  public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-  public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-  public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-  public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-  public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-  public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-  private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-  private Context context;\n-  private Activity activity;\n-  private NotificationStorage storage;\n-  private CapConfig config;\n-\n-  public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-    storage = notificationStorage;\n-    this.activity = activity;\n-    this.context = context;\n-    this.config = config;\n-  }\n-\n-  /**\n-   * Method extecuted when notification is launched by user from the notification bar.\n-   */\n-  public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-    Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-    int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-    if (notificationId == Integer.MIN_VALUE) {\n-      Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-      return null;\n-    }\n-    boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-    if (isRemovable) {\n-      notificationStorage.deleteNotification(Integer.toString(notificationId));\n+    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n+    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    // Action constants\n+    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n+    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n+    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n+    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n+    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n+\n+    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n+    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n+\n+    private Context context;\n+    private Activity activity;\n+    private NotificationStorage storage;\n+    private CapConfig config;\n+\n+    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n+        storage = notificationStorage;\n+        this.activity = activity;\n+        this.context = context;\n+        this.config = config;\n     }\n-    JSObject dataJson = new JSObject();\n \n-    Bundle results = RemoteInput.getResultsFromIntent(data);\n-    if (results != null) {\n-      CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-      dataJson.put(\"inputValue\", input.toString());\n-    }\n-    String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-    dismissVisibleNotification(notificationId);\n-\n-    dataJson.put(\"actionId\", menuAction);\n-    JSONObject request = null;\n-    try {\n-      String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-      if (notificationJsonString != null) {\n-        request = new JSObject(notificationJsonString);\n-      }\n-    } catch (JSONException e) {\n-    }\n-    dataJson.put(\"notification\", request);\n-    return dataJson;\n-  }\n-\n-  /**\n-   * Create notification channel\n-   */\n-  public void createNotificationChannel() {\n-    // Create the NotificationChannel, but only on API 26+ because\n-    // the NotificationChannel class is new and not in the support library\n-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-      CharSequence name = \"Default\";\n-      String description = \"Default\";\n-      int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-      NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-      channel.setDescription(description);\n-      AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-              .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-              .setUsage(AudioAttributes.USAGE_ALARM).build();\n-      Uri soundUri = this.getDefaultSoundUrl(context);\n-      if (soundUri != null) {\n-        channel.setSound(soundUri, audioAttributes);\n-      }\n-      // Register the channel with the system; you can't change the importance\n-      // or other notification behaviors after this\n-      android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-      notificationManager.createNotificationChannel(channel);\n-    }\n-  }\n-\n-  @Nullable\n-  public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-    JSONArray ids = new JSONArray();\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-    boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-    if (!notificationsEnabled) {\n-      if(call != null){\n-        call.error(\"Notifications not enabled on this device\");\n-      }\n-      return null;\n+    /**\n+     * Method extecuted when notification is launched by user from the notification bar.\n+     */\n+    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n+        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n+        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n+        if (notificationId == Integer.MIN_VALUE) {\n+            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n+            return null;\n+        }\n+        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n+        if (isRemovable) {\n+            notificationStorage.deleteNotification(Integer.toString(notificationId));\n+        }\n+        JSObject dataJson = new JSObject();\n+\n+        Bundle results = RemoteInput.getResultsFromIntent(data);\n+        if (results != null) {\n+            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n+            dataJson.put(\"inputValue\", input.toString());\n+        }\n+        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n+\n+        dismissVisibleNotification(notificationId);\n+\n+        dataJson.put(\"actionId\", menuAction);\n+        JSONObject request = null;\n+        try {\n+            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n+            if (notificationJsonString != null) {\n+                request = new JSObject(notificationJsonString);\n+            }\n+        } catch (JSONException e) {}\n+        dataJson.put(\"notification\", request);\n+        return dataJson;\n     }\n-    for (LocalNotification localNotification : localNotifications) {\n-      Integer id = localNotification.getId();\n-      if (localNotification.getId() == null) {\n-        if(call != null) {\n-          call.error(\"LocalNotification missing identifier\");\n+\n+    /**\n+     * Create notification channel\n+     */\n+    public void createNotificationChannel() {\n+        // Create the NotificationChannel, but only on API 26+ because\n+        // the NotificationChannel class is new and not in the support library\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            CharSequence name = \"Default\";\n+            String description = \"Default\";\n+            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n+            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n+            channel.setDescription(description);\n+            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n+                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n+                .setUsage(AudioAttributes.USAGE_ALARM)\n+                .build();\n+            Uri soundUri = this.getDefaultSoundUrl(context);\n+            if (soundUri != null) {\n+                channel.setSound(soundUri, audioAttributes);\n+            }\n+            // Register the channel with the system; you can't change the importance\n+            // or other notification behaviors after this\n+            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n+            notificationManager.createNotificationChannel(channel);\n         }\n-        return null;\n-      }\n-      dismissVisibleNotification(id);\n-      cancelTimerForNotification(id);\n-      buildNotification(notificationManager, localNotification, call);\n-      ids.put(id);\n     }\n-    return ids;\n-  }\n-\n-  // TODO Progressbar support\n-  // TODO System categories (DO_NOT_DISTURB etc.)\n-  // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-  // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-  // TODO use NotificationCompat.MessagingStyle for latest API\n-  // TODO expandable notification NotificationCompat.MessagingStyle\n-  // TODO media style notification support NotificationCompat.MediaStyle\n-  // TODO custom small/large icons\n-  private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-    String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-    if (localNotification.getChannelId() != null) {\n-      channelId = localNotification.getChannelId();\n+\n+    @Nullable\n+    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n+        JSONArray ids = new JSONArray();\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+\n+        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n+        if (!notificationsEnabled) {\n+            if (call != null) {\n+                call.error(\"Notifications not enabled on this device\");\n+            }\n+            return null;\n+        }\n+        for (LocalNotification localNotification : localNotifications) {\n+            Integer id = localNotification.getId();\n+            if (localNotification.getId() == null) {\n+                if (call != null) {\n+                    call.error(\"LocalNotification missing identifier\");\n+                }\n+                return null;\n+            }\n+            dismissVisibleNotification(id);\n+            cancelTimerForNotification(id);\n+            buildNotification(notificationManager, localNotification, call);\n+            ids.put(id);\n+        }\n+        return ids;\n     }\n-    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n+\n+    // TODO Progressbar support\n+    // TODO System categories (DO_NOT_DISTURB etc.)\n+    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n+    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n+    // TODO use NotificationCompat.MessagingStyle for latest API\n+    // TODO expandable notification NotificationCompat.MessagingStyle\n+    // TODO media style notification support NotificationCompat.MediaStyle\n+    // TODO custom small/large icons\n+    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n+        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n+        if (localNotification.getChannelId() != null) {\n+            channelId = localNotification.getChannelId();\n+        }\n+        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n             .setContentTitle(localNotification.getTitle())\n             .setContentText(localNotification.getBody())\n-            .setAutoCancel( localNotification.isAutoCancel( ) )\n-            .setOngoing( localNotification.isOngoing( ) )\n+            .setAutoCancel(localNotification.isAutoCancel())\n+            .setOngoing(localNotification.isOngoing())\n             .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n             .setGroupSummary(localNotification.isGroupSummary());\n \n+        // support multiline text\n+        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n+\n+        String sound = localNotification.getSound(context, getDefaultSound(context));\n+        if (sound != null) {\n+            Uri soundUri = Uri.parse(sound);\n+            // Grant permission to use sound\n+            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            mBuilder.setSound(soundUri);\n+            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+        } else {\n+            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        }\n+\n+        String group = localNotification.getGroup();\n+        if (group != null) {\n+            mBuilder.setGroup(group);\n+        }\n+\n+        // make sure scheduled time is shown instead of display time\n+        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n+            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n+        }\n+\n+        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n+        mBuilder.setOnlyAlertOnce(true);\n+\n+        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+\n+        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n+        if (iconColor != null) {\n+            try {\n+                mBuilder.setColor(Color.parseColor(iconColor));\n+            } catch (IllegalArgumentException ex) {\n+                if (call != null) {\n+                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+                }\n+                return;\n+            }\n+        }\n \n-    // support multiline text\n-    mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-    String sound = localNotification.getSound(context, getDefaultSound(context));\n-    if (sound != null) {\n-      Uri soundUri = Uri.parse(sound);\n-      // Grant permission to use sound\n-      context.grantUriPermission(\n-              \"com.android.systemui\", soundUri,\n-              Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-      mBuilder.setSound(soundUri);\n-      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-    } else {\n-      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        createActionIntents(localNotification, mBuilder);\n+        // notificationId is a unique int for each localNotification that you must define\n+        Notification buildNotification = mBuilder.build();\n+        if (localNotification.isScheduled()) {\n+            triggerScheduledNotification(buildNotification, localNotification);\n+        } else {\n+            notificationManager.notify(localNotification.getId(), buildNotification);\n+        }\n     }\n \n+    // Create intents for open/dissmis actions\n+    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n+        // Open intent\n+        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n+\n+        PendingIntent pendingIntent = PendingIntent.getActivity(\n+            context,\n+            localNotification.getId(),\n+            intent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+        mBuilder.setContentIntent(pendingIntent);\n+\n+        // Build action types\n+        String actionTypeId = localNotification.getActionTypeId();\n+        if (actionTypeId != null) {\n+            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n+            for (NotificationAction notificationAction : actionGroup) {\n+                // TODO Add custom icons to actions\n+                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n+                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n+                    context,\n+                    localNotification.getId() + notificationAction.getId().hashCode(),\n+                    actionIntent,\n+                    PendingIntent.FLAG_CANCEL_CURRENT\n+                );\n+                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n+                    R.drawable.ic_transparent,\n+                    notificationAction.getTitle(),\n+                    actionPendingIntent\n+                );\n+                if (notificationAction.isInput()) {\n+                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n+                    actionBuilder.addRemoteInput(remoteInput);\n+                }\n+                mBuilder.addAction(actionBuilder.build());\n+            }\n+        }\n \n-    String group = localNotification.getGroup();\n-    if (group != null) {\n-      mBuilder.setGroup(group);\n+        // Dismiss intent\n+        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n+        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n+        mBuilder.setDeleteIntent(deleteIntent);\n     }\n \n-    // make sure scheduled time is shown instead of display time\n-    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n-              .setShowWhen(true);\n+    @NonNull\n+    private Intent buildIntent(LocalNotification localNotification, String action) {\n+        Intent intent;\n+        if (activity != null) {\n+            intent = new Intent(context, activity.getClass());\n+        } else {\n+            String packageName = context.getPackageName();\n+            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n+        }\n+        intent.setAction(Intent.ACTION_MAIN);\n+        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n+        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        intent.putExtra(ACTION_INTENT_KEY, action);\n+        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        return intent;\n     }\n \n-    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-    mBuilder.setOnlyAlertOnce(true);\n+    /**\n+     * Build a notification trigger, such as triggering each N seconds, or\n+     * on a certain date \"shape\" (such as every first of the month)\n+     */\n+    // TODO support different AlarmManager.RTC modes depending on priority\n+    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n+        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+        LocalNotificationSchedule schedule = request.getSchedule();\n+        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n+        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n+        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n+        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n+            context,\n+            request.getId(),\n+            notificationIntent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+\n+        // Schedule at specific time (with repeating support)\n+        Date at = schedule.getAt();\n+        if (at != null) {\n+            if (at.getTime() < new Date().getTime()) {\n+                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n+                return;\n+            }\n+            if (schedule.isRepeating()) {\n+                long interval = at.getTime() - new Date().getTime();\n+                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n+            } else {\n+                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n+            }\n+            return;\n+        }\n \n-    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+        // Schedule at specific intervals\n+        String every = schedule.getEvery();\n+        if (every != null) {\n+            Long everyInterval = schedule.getEveryInterval();\n+            if (everyInterval != null) {\n+                long startTime = new Date().getTime() + everyInterval;\n+                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n+            }\n+            return;\n+        }\n \n-    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-    if (iconColor != null) {\n-      try {\n-        mBuilder.setColor(Color.parseColor(iconColor));\n-      } catch (IllegalArgumentException ex) {\n-        if(call != null) {\n-            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        // Cron like scheduler\n+        DateMatch on = schedule.getOn();\n+        if (on != null) {\n+            long trigger = on.nextTrigger(new Date());\n+            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n+            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+            alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n+            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n+            Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n         }\n-        return;\n-      }\n     }\n \n-    createActionIntents(localNotification, mBuilder);\n-    // notificationId is a unique int for each localNotification that you must define\n-    Notification buildNotification = mBuilder.build();\n-    if (localNotification.isScheduled()) {\n-      triggerScheduledNotification(buildNotification, localNotification);\n-    } else {\n-      notificationManager.notify(localNotification.getId(), buildNotification);\n-    }\n-  }\n-\n-  // Create intents for open/dissmis actions\n-  private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-    // Open intent\n-    Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-    PendingIntent pendingIntent = PendingIntent.getActivity(context, localNotification.getId(), intent, PendingIntent.FLAG_CANCEL_CURRENT);\n-    mBuilder.setContentIntent(pendingIntent);\n-\n-    // Build action types\n-    String actionTypeId = localNotification.getActionTypeId();\n-    if (actionTypeId != null) {\n-      NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-      for (int i = 0; i < actionGroup.length; i++) {\n-        NotificationAction notificationAction = actionGroup[i];\n-        // TODO Add custom icons to actions\n-        Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-        PendingIntent actionPendingIntent = PendingIntent.getActivity(context, localNotification.getId() + notificationAction.getId().hashCode(), actionIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(R.drawable.ic_transparent, notificationAction.getTitle(), actionPendingIntent);\n-        if (notificationAction.isInput()) {\n-          RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY)\n-                  .setLabel(notificationAction.getTitle())\n-                  .build();\n-          actionBuilder.addRemoteInput(remoteInput);\n+    public void cancel(PluginCall call) {\n+        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n+        if (notificationsToCancel != null) {\n+            for (Integer id : notificationsToCancel) {\n+                dismissVisibleNotification(id);\n+                cancelTimerForNotification(id);\n+                storage.deleteNotification(Integer.toString(id));\n+            }\n         }\n-        mBuilder.addAction(actionBuilder.build());\n-      }\n+        call.success();\n     }\n \n-    // Dismiss intent\n-    Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-    dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-    dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    PendingIntent deleteIntent = PendingIntent.getBroadcast(\n-            context, localNotification.getId(), dissmissIntent, 0);\n-    mBuilder.setDeleteIntent(deleteIntent);\n-  }\n-\n-  @NonNull\n-  private Intent buildIntent(LocalNotification localNotification, String action) {\n-    Intent intent;\n-    if (activity != null) {\n-      intent = new Intent(context, activity.getClass());\n-    } else {\n-      String packageName = context.getPackageName();\n-      intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-    }\n-    intent.setAction(Intent.ACTION_MAIN);\n-    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-    intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    intent.putExtra(ACTION_INTENT_KEY, action);\n-    intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    return intent;\n-  }\n-\n-  /**\n-   * Build a notification trigger, such as triggering each N seconds, or\n-   * on a certain date \"shape\" (such as every first of the month)\n-   */\n-  // TODO support different AlarmManager.RTC modes depending on priority\n-  private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-    LocalNotificationSchedule schedule = request.getSchedule();\n-    Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-    notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-    notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-\n-    // Schedule at specific time (with repeating support)\n-    Date at = schedule.getAt();\n-    if (at != null) {\n-      if (at.getTime() < new Date().getTime()) {\n-        Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-        return;\n-      }\n-      if (schedule.isRepeating()) {\n-        long interval = at.getTime() - new Date().getTime();\n-        alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-      } else {\n-        alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-      }\n-      return;\n+    private void cancelTimerForNotification(Integer notificationId) {\n+        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n+        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n+        if (pi != null) {\n+            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+            alarmManager.cancel(pi);\n+        }\n     }\n \n-    // Schedule at specific intervals\n-    String every = schedule.getEvery();\n-    if (every != null) {\n-      Long everyInterval = schedule.getEveryInterval();\n-      if (everyInterval != null) {\n-        long startTime = new Date().getTime() + everyInterval;\n-        alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-      }\n-      return;\n+    private void dismissVisibleNotification(int notificationId) {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n+        notificationManager.cancel(notificationId);\n     }\n \n-    // Cron like scheduler\n-    DateMatch on = schedule.getOn();\n-    if (on != null) {\n-      long trigger = on.nextTrigger(new Date());\n-      notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-      pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-      alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n-      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n-      Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n-    }\n-  }\n-\n-  public void cancel(PluginCall call) {\n-    List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-    if (notificationsToCancel != null) {\n-      for (Integer id : notificationsToCancel) {\n-        dismissVisibleNotification(id);\n-        cancelTimerForNotification(id);\n-        storage.deleteNotification(Integer.toString(id));\n-      }\n-    }\n-    call.success();\n-  }\n-\n-  private void cancelTimerForNotification(Integer notificationId) {\n-    Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-    PendingIntent pi = PendingIntent.getBroadcast(\n-            context, notificationId, intent, 0);\n-    if (pi != null) {\n-      AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-      alarmManager.cancel(pi);\n+    public boolean areNotificationsEnabled() {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+        return notificationManager.areNotificationsEnabled();\n     }\n-  }\n-\n-  private void dismissVisibleNotification(int notificationId) {\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-    notificationManager.cancel(notificationId);\n-  }\n-\n-  public boolean areNotificationsEnabled(){\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-    return notificationManager.areNotificationsEnabled();\n-  }\n-\n-  public Uri getDefaultSoundUrl(Context context){\n-    int soundId = this.getDefaultSound(context);\n-    if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+\n+    public Uri getDefaultSoundUrl(Context context) {\n+        int soundId = this.getDefaultSound(context);\n+        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n \n-  private int getDefaultSound(Context context){\n-    if(defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n+    private int getDefaultSound(Context context) {\n+        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-    soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n+        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n \n-    if(soundConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        if (soundConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        }\n+\n+        defaultSoundID = resId;\n+        return resId;\n     }\n \n-    defaultSoundID = resId;\n-    return resId;\n-  }\n+    private int getDefaultSmallIcon(Context context) {\n+        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n \n-  private int getDefaultSmallIcon(Context context){\n-    if(defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n+        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-    smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n+        if (smallIconConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n+        }\n \n-    if(smallIconConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-    }\n+        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            resId = android.R.drawable.ic_dialog_info;\n+        }\n \n-    if(resId == AssetUtil.RESOURCE_ID_ZERO_VALUE){\n-      resId = android.R.drawable.ic_dialog_info;\n+        defaultSmallIconID = resId;\n+        return resId;\n     }\n-\n-    defaultSmallIconID = resId;\n-    return resId;\n-  }\n }\n", "next_change": {"commit": "f3022a30568f9f19b1ef537d212c88e873a2e65d", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\ndeleted file mode 100644\nindex 2e9b347d..00000000\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ /dev/null\n", "chunk": "@@ -1,426 +0,0 @@\n-package com.getcapacitor.plugin.notification;\n-\n-import android.app.Activity;\n-import android.app.AlarmManager;\n-import android.app.Notification;\n-import android.app.NotificationChannel;\n-import android.app.PendingIntent;\n-import android.content.ContentResolver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.graphics.Color;\n-import android.media.AudioAttributes;\n-import android.net.Uri;\n-import android.os.Build;\n-import android.os.Bundle;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.core.app.NotificationCompat;\n-import androidx.core.app.NotificationManagerCompat;\n-import androidx.core.app.RemoteInput;\n-import com.getcapacitor.CapConfig;\n-import com.getcapacitor.JSObject;\n-import com.getcapacitor.Logger;\n-import com.getcapacitor.PluginCall;\n-import com.getcapacitor.android.R;\n-import com.getcapacitor.plugin.util.AssetUtil;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.List;\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n-\n-/**\n- * Contains implementations for all notification actions\n- */\n-public class LocalNotificationManager {\n-    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    // Action constants\n-    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-    private Context context;\n-    private Activity activity;\n-    private NotificationStorage storage;\n-    private CapConfig config;\n-\n-    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-        storage = notificationStorage;\n-        this.activity = activity;\n-        this.context = context;\n-        this.config = config;\n-    }\n-\n-    /**\n-     * Method extecuted when notification is launched by user from the notification bar.\n-     */\n-    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-        if (notificationId == Integer.MIN_VALUE) {\n-            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-            return null;\n-        }\n-        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-        if (isRemovable) {\n-            notificationStorage.deleteNotification(Integer.toString(notificationId));\n-        }\n-        JSObject dataJson = new JSObject();\n-\n-        Bundle results = RemoteInput.getResultsFromIntent(data);\n-        if (results != null) {\n-            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-            dataJson.put(\"inputValue\", input.toString());\n-        }\n-        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-        dismissVisibleNotification(notificationId);\n-\n-        dataJson.put(\"actionId\", menuAction);\n-        JSONObject request = null;\n-        try {\n-            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-            if (notificationJsonString != null) {\n-                request = new JSObject(notificationJsonString);\n-            }\n-        } catch (JSONException e) {}\n-        dataJson.put(\"notification\", request);\n-        return dataJson;\n-    }\n-\n-    /**\n-     * Create notification channel\n-     */\n-    public void createNotificationChannel() {\n-        // Create the NotificationChannel, but only on API 26+ because\n-        // the NotificationChannel class is new and not in the support library\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-            CharSequence name = \"Default\";\n-            String description = \"Default\";\n-            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-            channel.setDescription(description);\n-            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-                .setUsage(AudioAttributes.USAGE_ALARM)\n-                .build();\n-            Uri soundUri = this.getDefaultSoundUrl(context);\n-            if (soundUri != null) {\n-                channel.setSound(soundUri, audioAttributes);\n-            }\n-            // Register the channel with the system; you can't change the importance\n-            // or other notification behaviors after this\n-            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-            notificationManager.createNotificationChannel(channel);\n-        }\n-    }\n-\n-    @Nullable\n-    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-        JSONArray ids = new JSONArray();\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-        if (!notificationsEnabled) {\n-            if (call != null) {\n-                call.error(\"Notifications not enabled on this device\");\n-            }\n-            return null;\n-        }\n-        for (LocalNotification localNotification : localNotifications) {\n-            Integer id = localNotification.getId();\n-            if (localNotification.getId() == null) {\n-                if (call != null) {\n-                    call.error(\"LocalNotification missing identifier\");\n-                }\n-                return null;\n-            }\n-            dismissVisibleNotification(id);\n-            cancelTimerForNotification(id);\n-            buildNotification(notificationManager, localNotification, call);\n-            ids.put(id);\n-        }\n-        return ids;\n-    }\n-\n-    // TODO Progressbar support\n-    // TODO System categories (DO_NOT_DISTURB etc.)\n-    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-    // TODO use NotificationCompat.MessagingStyle for latest API\n-    // TODO expandable notification NotificationCompat.MessagingStyle\n-    // TODO media style notification support NotificationCompat.MediaStyle\n-    // TODO custom small/large icons\n-    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-        if (localNotification.getChannelId() != null) {\n-            channelId = localNotification.getChannelId();\n-        }\n-        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n-            .setContentTitle(localNotification.getTitle())\n-            .setContentText(localNotification.getBody())\n-            .setAutoCancel(localNotification.isAutoCancel())\n-            .setOngoing(localNotification.isOngoing())\n-            .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n-            .setGroupSummary(localNotification.isGroupSummary());\n-\n-        // support multiline text\n-        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-        String sound = localNotification.getSound(context, getDefaultSound(context));\n-        if (sound != null) {\n-            Uri soundUri = Uri.parse(sound);\n-            // Grant permission to use sound\n-            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            mBuilder.setSound(soundUri);\n-            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-        } else {\n-            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n-        }\n-\n-        String group = localNotification.getGroup();\n-        if (group != null) {\n-            mBuilder.setGroup(group);\n-        }\n-\n-        // make sure scheduled time is shown instead of display time\n-        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n-        }\n-\n-        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-        mBuilder.setOnlyAlertOnce(true);\n-\n-        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n-\n-        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-        if (iconColor != null) {\n-            try {\n-                mBuilder.setColor(Color.parseColor(iconColor));\n-            } catch (IllegalArgumentException ex) {\n-                if (call != null) {\n-                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n-                }\n-                return;\n-            }\n-        }\n-\n-        createActionIntents(localNotification, mBuilder);\n-        // notificationId is a unique int for each localNotification that you must define\n-        Notification buildNotification = mBuilder.build();\n-        if (localNotification.isScheduled()) {\n-            triggerScheduledNotification(buildNotification, localNotification);\n-        } else {\n-            notificationManager.notify(localNotification.getId(), buildNotification);\n-        }\n-    }\n-\n-    // Create intents for open/dissmis actions\n-    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-        // Open intent\n-        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-        PendingIntent pendingIntent = PendingIntent.getActivity(\n-            context,\n-            localNotification.getId(),\n-            intent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-        mBuilder.setContentIntent(pendingIntent);\n-\n-        // Build action types\n-        String actionTypeId = localNotification.getActionTypeId();\n-        if (actionTypeId != null) {\n-            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-            for (NotificationAction notificationAction : actionGroup) {\n-                // TODO Add custom icons to actions\n-                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n-                    context,\n-                    localNotification.getId() + notificationAction.getId().hashCode(),\n-                    actionIntent,\n-                    PendingIntent.FLAG_CANCEL_CURRENT\n-                );\n-                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n-                    R.drawable.ic_transparent,\n-                    notificationAction.getTitle(),\n-                    actionPendingIntent\n-                );\n-                if (notificationAction.isInput()) {\n-                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n-                    actionBuilder.addRemoteInput(remoteInput);\n-                }\n-                mBuilder.addAction(actionBuilder.build());\n-            }\n-        }\n-\n-        // Dismiss intent\n-        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n-        mBuilder.setDeleteIntent(deleteIntent);\n-    }\n-\n-    @NonNull\n-    private Intent buildIntent(LocalNotification localNotification, String action) {\n-        Intent intent;\n-        if (activity != null) {\n-            intent = new Intent(context, activity.getClass());\n-        } else {\n-            String packageName = context.getPackageName();\n-            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-        }\n-        intent.setAction(Intent.ACTION_MAIN);\n-        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        intent.putExtra(ACTION_INTENT_KEY, action);\n-        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        return intent;\n-    }\n-\n-    /**\n-     * Build a notification trigger, such as triggering each N seconds, or\n-     * on a certain date \"shape\" (such as every first of the month)\n-     */\n-    // TODO support different AlarmManager.RTC modes depending on priority\n-    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-        LocalNotificationSchedule schedule = request.getSchedule();\n-        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n-            context,\n-            request.getId(),\n-            notificationIntent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-\n-        // Schedule at specific time (with repeating support)\n-        Date at = schedule.getAt();\n-        if (at != null) {\n-            if (at.getTime() < new Date().getTime()) {\n-                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-                return;\n-            }\n-            if (schedule.isRepeating()) {\n-                long interval = at.getTime() - new Date().getTime();\n-                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-            } else {\n-                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-            }\n-            return;\n-        }\n-\n-        // Schedule at specific intervals\n-        String every = schedule.getEvery();\n-        if (every != null) {\n-            Long everyInterval = schedule.getEveryInterval();\n-            if (everyInterval != null) {\n-                long startTime = new Date().getTime() + everyInterval;\n-                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-            }\n-            return;\n-        }\n-\n-        // Cron like scheduler\n-        DateMatch on = schedule.getOn();\n-        if (on != null) {\n-            long trigger = on.nextTrigger(new Date());\n-            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-            alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n-            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n-            Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n-        }\n-    }\n-\n-    public void cancel(PluginCall call) {\n-        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-        if (notificationsToCancel != null) {\n-            for (Integer id : notificationsToCancel) {\n-                dismissVisibleNotification(id);\n-                cancelTimerForNotification(id);\n-                storage.deleteNotification(Integer.toString(id));\n-            }\n-        }\n-        call.success();\n-    }\n-\n-    private void cancelTimerForNotification(Integer notificationId) {\n-        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n-        if (pi != null) {\n-            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-            alarmManager.cancel(pi);\n-        }\n-    }\n-\n-    private void dismissVisibleNotification(int notificationId) {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-        notificationManager.cancel(notificationId);\n-    }\n-\n-    public boolean areNotificationsEnabled() {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-        return notificationManager.areNotificationsEnabled();\n-    }\n-\n-    public Uri getDefaultSoundUrl(Context context) {\n-        int soundId = this.getDefaultSound(context);\n-        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n-        }\n-        return null;\n-    }\n-\n-    private int getDefaultSound(Context context) {\n-        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n-\n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n-\n-        if (soundConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n-        }\n-\n-        defaultSoundID = resId;\n-        return resId;\n-    }\n-\n-    private int getDefaultSmallIcon(Context context) {\n-        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n-\n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n-\n-        if (smallIconConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-        }\n-\n-        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            resId = android.R.drawable.ic_dialog_info;\n-        }\n-\n-        defaultSmallIconID = resId;\n-        return resId;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "2403ed4fcd6f5c1b54b0160fa3c000993779fa70", "url": "https://github.com/ionic-team/capacitor/commit/2403ed4fcd6f5c1b54b0160fa3c000993779fa70", "message": "catch exception for bad color string", "committedDate": "2020-03-16T19:30:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwMDQ0MQ==", "url": "https://github.com/ionic-team/capacitor/pull/2548#discussion_r393600441", "body": "For consistency, better use the same error message as Status Bar plugin\r\n\r\n```suggestion\r\n        call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\r\n```", "bodyText": "For consistency, better use the same error message as Status Bar plugin\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    call.error(\"The iconColor string was not able to be parsed.  Please provide a valid string hexidecimal color code.\", ex);\n          \n          \n            \n                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");", "bodyHTML": "<p dir=\"auto\">For consistency, better use the same error message as Status Bar plugin</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        call<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">The iconColor string was not able to </span>be <span class=\"x x-first x-last\">parsed.  Please provide a valid</span> string <span class=\"x x-first\">hexidecimal color code.</span><span class=\"pl-pds x\">\"</span></span><span class=\"x x-last\">, ex</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        call<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">Invalid color provided. Must </span>be <span class=\"x x-first x-last\">a hex</span> string <span class=\"x x-first\">(ex: #ff0000</span><span class=\"pl-pds x x-last\">\"</span></span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "jcesarmobile", "createdAt": "2020-03-17T11:07:39Z", "path": "android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java", "diffHunk": "@@ -174,6 +175,17 @@ private void buildNotification(NotificationManagerCompat notificationManager, Lo\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n+\n+    String iconColor = localNotification.getIconColor();\n+    if (iconColor != null) {\n+      try {\n+        mBuilder.setColor(Color.parseColor(iconColor));\n+      } catch (Exception ex) {\n+        call.error(\"The iconColor string was not able to be parsed.  Please provide a valid string hexidecimal color code.\", ex);", "originalCommit": "2403ed4fcd6f5c1b54b0160fa3c000993779fa70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0ODkwNw==", "url": "https://github.com/ionic-team/capacitor/pull/2548#discussion_r393848907", "bodyText": "fixed", "author": "andysousa", "createdAt": "2020-03-17T17:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwMDQ0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "59d02ab95b3aeff7076f012828b35703a9015a10", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 7f0515e1..a4fd2b3d 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -175,17 +178,6 @@ public class LocalNotificationManager {\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n-\n-    String iconColor = localNotification.getIconColor();\n-    if (iconColor != null) {\n-      try {\n-        mBuilder.setColor(Color.parseColor(iconColor));\n-      } catch (Exception ex) {\n-        call.error(\"The iconColor string was not able to be parsed.  Please provide a valid string hexidecimal color code.\", ex);\n-        return;\n-      }\n-    }\n-\n     createActionIntents(localNotification, mBuilder);\n     // notificationId is a unique int for each localNotification that you must define\n     Notification buildNotification = mBuilder.build();\n", "next_change": {"commit": "448e7b7a46858b3d8f963123549e0bcf03493805", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex a4fd2b3d..2bb048f9 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -174,6 +174,12 @@ public class LocalNotificationManager {\n       mBuilder.setGroup(group);\n     }\n \n+    // make sure scheduled time is shown instead of display time\n+    if (localNotification.isScheduled()) {\n+      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n+        .setShowWhen(true);\n+    }\n+\n     mBuilder.setVisibility(Notification.VISIBILITY_PRIVATE);\n     mBuilder.setOnlyAlertOnce(true);\n \n", "next_change": {"commit": "62b11fdc3c865747350ae7bbb0f1f3d129f0bfd6", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 2bb048f9..b7be3161 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -180,7 +180,7 @@ public class LocalNotificationManager {\n         .setShowWhen(true);\n     }\n \n-    mBuilder.setVisibility(Notification.VISIBILITY_PRIVATE);\n+    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n", "next_change": {"commit": "0bfa0bfeb7607e987b1a497bc8f5e0b64e9ca17d", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex b7be3161..202de9d8 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -184,6 +185,17 @@ public class LocalNotificationManager {\n     mBuilder.setOnlyAlertOnce(true);\n \n     mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n+\n+    String iconColor = localNotification.getIconColor();\n+    if (iconColor != null) {\n+      try {\n+        mBuilder.setColor(Color.parseColor(iconColor));\n+      } catch (IllegalArgumentException ex) {\n+        call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        return;\n+      }\n+    }\n+\n     createActionIntents(localNotification, mBuilder);\n     // notificationId is a unique int for each localNotification that you must define\n     Notification buildNotification = mBuilder.build();\n", "next_change": {"commit": "2a39a7d044d67096d555f09c22dde183b2f9b264", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 202de9d8..c0675465 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -168,30 +191,36 @@ public class LocalNotificationManager {\n               \"com.android.systemui\", soundUri,\n               Intent.FLAG_GRANT_READ_URI_PERMISSION);\n       mBuilder.setSound(soundUri);\n+      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+    } else {\n+      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n     }\n \n+\n     String group = localNotification.getGroup();\n     if (group != null) {\n       mBuilder.setGroup(group);\n     }\n \n     // make sure scheduled time is shown instead of display time\n-    if (localNotification.isScheduled()) {\n+    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n       mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n-        .setShowWhen(true);\n+              .setShowWhen(true);\n     }\n \n     mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n     mBuilder.setOnlyAlertOnce(true);\n \n-    mBuilder.setSmallIcon(localNotification.getSmallIcon(context));\n+    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n \n-    String iconColor = localNotification.getIconColor();\n+    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n     if (iconColor != null) {\n       try {\n         mBuilder.setColor(Color.parseColor(iconColor));\n       } catch (IllegalArgumentException ex) {\n-        call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        if(call != null) {\n+            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        }\n         return;\n       }\n     }\n", "next_change": {"commit": "e0ed9c90947c8e4bcd1f7b42f21c79d1e6bb50f3", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex c0675465..1336bea1 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -27,394 +25,399 @@ import com.getcapacitor.Logger;\n import com.getcapacitor.PluginCall;\n import com.getcapacitor.android.R;\n import com.getcapacitor.plugin.util.AssetUtil;\n-\n+import java.util.Date;\n+import java.util.List;\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import java.util.Date;\n-import java.util.List;\n-\n-\n /**\n  * Contains implementations for all notification actions\n  */\n public class LocalNotificationManager {\n-\n-  private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-  private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  // Action constants\n-  public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-  public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-  public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-  public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-  public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-  public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-  private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-  private Context context;\n-  private Activity activity;\n-  private NotificationStorage storage;\n-  private CapConfig config;\n-\n-  public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-    storage = notificationStorage;\n-    this.activity = activity;\n-    this.context = context;\n-    this.config = config;\n-  }\n-\n-  /**\n-   * Method extecuted when notification is launched by user from the notification bar.\n-   */\n-  public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-    Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-    int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-    if (notificationId == Integer.MIN_VALUE) {\n-      Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-      return null;\n+    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n+    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    // Action constants\n+    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n+    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n+    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n+    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n+    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n+\n+    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n+    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n+\n+    private Context context;\n+    private Activity activity;\n+    private NotificationStorage storage;\n+    private CapConfig config;\n+\n+    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n+        storage = notificationStorage;\n+        this.activity = activity;\n+        this.context = context;\n+        this.config = config;\n     }\n-    boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-    if (isRemovable) {\n-      notificationStorage.deleteNotification(Integer.toString(notificationId));\n-    }\n-    JSObject dataJson = new JSObject();\n \n-    Bundle results = RemoteInput.getResultsFromIntent(data);\n-    if (results != null) {\n-      CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-      dataJson.put(\"inputValue\", input.toString());\n-    }\n-    String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-    dismissVisibleNotification(notificationId);\n-\n-    dataJson.put(\"actionId\", menuAction);\n-    JSONObject request = null;\n-    try {\n-      String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-      if (notificationJsonString != null) {\n-        request = new JSObject(notificationJsonString);\n-      }\n-    } catch (JSONException e) {\n-    }\n-    dataJson.put(\"notification\", request);\n-    return dataJson;\n-  }\n-\n-  /**\n-   * Create notification channel\n-   */\n-  public void createNotificationChannel() {\n-    // Create the NotificationChannel, but only on API 26+ because\n-    // the NotificationChannel class is new and not in the support library\n-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-      CharSequence name = \"Default\";\n-      String description = \"Default\";\n-      int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-      NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-      channel.setDescription(description);\n-      AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-              .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-              .setUsage(AudioAttributes.USAGE_ALARM).build();\n-      Uri soundUri = this.getDefaultSoundUrl(context);\n-      if (soundUri != null) {\n-        channel.setSound(soundUri, audioAttributes);\n-      }\n-      // Register the channel with the system; you can't change the importance\n-      // or other notification behaviors after this\n-      android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-      notificationManager.createNotificationChannel(channel);\n-    }\n-  }\n-\n-  @Nullable\n-  public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-    JSONArray ids = new JSONArray();\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-    boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-    if (!notificationsEnabled) {\n-      if(call != null){\n-        call.error(\"Notifications not enabled on this device\");\n-      }\n-      return null;\n+    /**\n+     * Method extecuted when notification is launched by user from the notification bar.\n+     */\n+    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n+        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n+        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n+        if (notificationId == Integer.MIN_VALUE) {\n+            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n+            return null;\n+        }\n+        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n+        if (isRemovable) {\n+            notificationStorage.deleteNotification(Integer.toString(notificationId));\n+        }\n+        JSObject dataJson = new JSObject();\n+\n+        Bundle results = RemoteInput.getResultsFromIntent(data);\n+        if (results != null) {\n+            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n+            dataJson.put(\"inputValue\", input.toString());\n+        }\n+        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n+\n+        dismissVisibleNotification(notificationId);\n+\n+        dataJson.put(\"actionId\", menuAction);\n+        JSONObject request = null;\n+        try {\n+            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n+            if (notificationJsonString != null) {\n+                request = new JSObject(notificationJsonString);\n+            }\n+        } catch (JSONException e) {}\n+        dataJson.put(\"notification\", request);\n+        return dataJson;\n     }\n-    for (LocalNotification localNotification : localNotifications) {\n-      Integer id = localNotification.getId();\n-      if (localNotification.getId() == null) {\n-        if(call != null) {\n-          call.error(\"LocalNotification missing identifier\");\n+\n+    /**\n+     * Create notification channel\n+     */\n+    public void createNotificationChannel() {\n+        // Create the NotificationChannel, but only on API 26+ because\n+        // the NotificationChannel class is new and not in the support library\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            CharSequence name = \"Default\";\n+            String description = \"Default\";\n+            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n+            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n+            channel.setDescription(description);\n+            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n+                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n+                .setUsage(AudioAttributes.USAGE_ALARM)\n+                .build();\n+            Uri soundUri = this.getDefaultSoundUrl(context);\n+            if (soundUri != null) {\n+                channel.setSound(soundUri, audioAttributes);\n+            }\n+            // Register the channel with the system; you can't change the importance\n+            // or other notification behaviors after this\n+            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n+            notificationManager.createNotificationChannel(channel);\n         }\n-        return null;\n-      }\n-      dismissVisibleNotification(id);\n-      cancelTimerForNotification(id);\n-      buildNotification(notificationManager, localNotification, call);\n-      ids.put(id);\n     }\n-    return ids;\n-  }\n-\n-  // TODO Progressbar support\n-  // TODO System categories (DO_NOT_DISTURB etc.)\n-  // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-  // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-  // TODO use NotificationCompat.MessagingStyle for latest API\n-  // TODO expandable notification NotificationCompat.MessagingStyle\n-  // TODO media style notification support NotificationCompat.MediaStyle\n-  // TODO custom small/large icons\n-  private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-    String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-    if (localNotification.getChannelId() != null) {\n-      channelId = localNotification.getChannelId();\n+\n+    @Nullable\n+    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n+        JSONArray ids = new JSONArray();\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+\n+        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n+        if (!notificationsEnabled) {\n+            if (call != null) {\n+                call.error(\"Notifications not enabled on this device\");\n+            }\n+            return null;\n+        }\n+        for (LocalNotification localNotification : localNotifications) {\n+            Integer id = localNotification.getId();\n+            if (localNotification.getId() == null) {\n+                if (call != null) {\n+                    call.error(\"LocalNotification missing identifier\");\n+                }\n+                return null;\n+            }\n+            dismissVisibleNotification(id);\n+            cancelTimerForNotification(id);\n+            buildNotification(notificationManager, localNotification, call);\n+            ids.put(id);\n+        }\n+        return ids;\n     }\n-    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n+\n+    // TODO Progressbar support\n+    // TODO System categories (DO_NOT_DISTURB etc.)\n+    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n+    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n+    // TODO use NotificationCompat.MessagingStyle for latest API\n+    // TODO expandable notification NotificationCompat.MessagingStyle\n+    // TODO media style notification support NotificationCompat.MediaStyle\n+    // TODO custom small/large icons\n+    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n+        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n+        if (localNotification.getChannelId() != null) {\n+            channelId = localNotification.getChannelId();\n+        }\n+        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n             .setContentTitle(localNotification.getTitle())\n             .setContentText(localNotification.getBody())\n-            .setAutoCancel(true)\n-            .setOngoing(false)\n+            .setAutoCancel(localNotification.isAutoCancel())\n+            .setOngoing(localNotification.isOngoing())\n             .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n             .setGroupSummary(localNotification.isGroupSummary());\n \n+        // support multiline text\n+        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n+\n+        String sound = localNotification.getSound(context, getDefaultSound(context));\n+        if (sound != null) {\n+            Uri soundUri = Uri.parse(sound);\n+            // Grant permission to use sound\n+            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            mBuilder.setSound(soundUri);\n+            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+        } else {\n+            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        }\n \n-    // support multiline text\n-    mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-    String sound = localNotification.getSound(context, getDefaultSound(context));\n-    if (sound != null) {\n-      Uri soundUri = Uri.parse(sound);\n-      // Grant permission to use sound\n-      context.grantUriPermission(\n-              \"com.android.systemui\", soundUri,\n-              Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-      mBuilder.setSound(soundUri);\n-      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-    } else {\n-      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        String group = localNotification.getGroup();\n+        if (group != null) {\n+            mBuilder.setGroup(group);\n+        }\n+\n+        // make sure scheduled time is shown instead of display time\n+        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n+            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n+        }\n+\n+        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n+        mBuilder.setOnlyAlertOnce(true);\n+\n+        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+\n+        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n+        if (iconColor != null) {\n+            try {\n+                mBuilder.setColor(Color.parseColor(iconColor));\n+            } catch (IllegalArgumentException ex) {\n+                if (call != null) {\n+                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+                }\n+                return;\n+            }\n+        }\n+\n+        createActionIntents(localNotification, mBuilder);\n+        // notificationId is a unique int for each localNotification that you must define\n+        Notification buildNotification = mBuilder.build();\n+        if (localNotification.isScheduled()) {\n+            triggerScheduledNotification(buildNotification, localNotification);\n+        } else {\n+            notificationManager.notify(localNotification.getId(), buildNotification);\n+        }\n     }\n \n+    // Create intents for open/dissmis actions\n+    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n+        // Open intent\n+        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n+\n+        PendingIntent pendingIntent = PendingIntent.getActivity(\n+            context,\n+            localNotification.getId(),\n+            intent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+        mBuilder.setContentIntent(pendingIntent);\n+\n+        // Build action types\n+        String actionTypeId = localNotification.getActionTypeId();\n+        if (actionTypeId != null) {\n+            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n+            for (NotificationAction notificationAction : actionGroup) {\n+                // TODO Add custom icons to actions\n+                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n+                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n+                    context,\n+                    localNotification.getId() + notificationAction.getId().hashCode(),\n+                    actionIntent,\n+                    PendingIntent.FLAG_CANCEL_CURRENT\n+                );\n+                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n+                    R.drawable.ic_transparent,\n+                    notificationAction.getTitle(),\n+                    actionPendingIntent\n+                );\n+                if (notificationAction.isInput()) {\n+                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n+                    actionBuilder.addRemoteInput(remoteInput);\n+                }\n+                mBuilder.addAction(actionBuilder.build());\n+            }\n+        }\n \n-    String group = localNotification.getGroup();\n-    if (group != null) {\n-      mBuilder.setGroup(group);\n+        // Dismiss intent\n+        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n+        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n+        mBuilder.setDeleteIntent(deleteIntent);\n     }\n \n-    // make sure scheduled time is shown instead of display time\n-    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n-              .setShowWhen(true);\n+    @NonNull\n+    private Intent buildIntent(LocalNotification localNotification, String action) {\n+        Intent intent;\n+        if (activity != null) {\n+            intent = new Intent(context, activity.getClass());\n+        } else {\n+            String packageName = context.getPackageName();\n+            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n+        }\n+        intent.setAction(Intent.ACTION_MAIN);\n+        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n+        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        intent.putExtra(ACTION_INTENT_KEY, action);\n+        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        return intent;\n     }\n \n-    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-    mBuilder.setOnlyAlertOnce(true);\n+    /**\n+     * Build a notification trigger, such as triggering each N seconds, or\n+     * on a certain date \"shape\" (such as every first of the month)\n+     */\n+    // TODO support different AlarmManager.RTC modes depending on priority\n+    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n+        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+        LocalNotificationSchedule schedule = request.getSchedule();\n+        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n+        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n+        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n+        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n+            context,\n+            request.getId(),\n+            notificationIntent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+\n+        // Schedule at specific time (with repeating support)\n+        Date at = schedule.getAt();\n+        if (at != null) {\n+            if (at.getTime() < new Date().getTime()) {\n+                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n+                return;\n+            }\n+            if (schedule.isRepeating()) {\n+                long interval = at.getTime() - new Date().getTime();\n+                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n+            } else {\n+                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n+            }\n+            return;\n+        }\n \n-    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+        // Schedule at specific intervals\n+        String every = schedule.getEvery();\n+        if (every != null) {\n+            Long everyInterval = schedule.getEveryInterval();\n+            if (everyInterval != null) {\n+                long startTime = new Date().getTime() + everyInterval;\n+                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n+            }\n+            return;\n+        }\n \n-    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-    if (iconColor != null) {\n-      try {\n-        mBuilder.setColor(Color.parseColor(iconColor));\n-      } catch (IllegalArgumentException ex) {\n-        if(call != null) {\n-            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        // Cron like scheduler\n+        DateMatch on = schedule.getOn();\n+        if (on != null) {\n+            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n+            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+            alarmManager.setExact(AlarmManager.RTC, on.nextTrigger(new Date()), pendingIntent);\n         }\n-        return;\n-      }\n     }\n \n-    createActionIntents(localNotification, mBuilder);\n-    // notificationId is a unique int for each localNotification that you must define\n-    Notification buildNotification = mBuilder.build();\n-    if (localNotification.isScheduled()) {\n-      triggerScheduledNotification(buildNotification, localNotification);\n-    } else {\n-      notificationManager.notify(localNotification.getId(), buildNotification);\n-    }\n-  }\n-\n-  // Create intents for open/dissmis actions\n-  private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-    // Open intent\n-    Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-    PendingIntent pendingIntent = PendingIntent.getActivity(context, localNotification.getId(), intent, PendingIntent.FLAG_CANCEL_CURRENT);\n-    mBuilder.setContentIntent(pendingIntent);\n-\n-    // Build action types\n-    String actionTypeId = localNotification.getActionTypeId();\n-    if (actionTypeId != null) {\n-      NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-      for (int i = 0; i < actionGroup.length; i++) {\n-        NotificationAction notificationAction = actionGroup[i];\n-        // TODO Add custom icons to actions\n-        Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-        PendingIntent actionPendingIntent = PendingIntent.getActivity(context, localNotification.getId() + notificationAction.getId().hashCode(), actionIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(R.drawable.ic_transparent, notificationAction.getTitle(), actionPendingIntent);\n-        if (notificationAction.isInput()) {\n-          RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY)\n-                  .setLabel(notificationAction.getTitle())\n-                  .build();\n-          actionBuilder.addRemoteInput(remoteInput);\n+    public void cancel(PluginCall call) {\n+        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n+        if (notificationsToCancel != null) {\n+            for (Integer id : notificationsToCancel) {\n+                dismissVisibleNotification(id);\n+                cancelTimerForNotification(id);\n+                storage.deleteNotification(Integer.toString(id));\n+            }\n         }\n-        mBuilder.addAction(actionBuilder.build());\n-      }\n+        call.success();\n     }\n \n-    // Dismiss intent\n-    Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-    dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-    dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    PendingIntent deleteIntent = PendingIntent.getBroadcast(\n-            context, localNotification.getId(), dissmissIntent, 0);\n-    mBuilder.setDeleteIntent(deleteIntent);\n-  }\n-\n-  @NonNull\n-  private Intent buildIntent(LocalNotification localNotification, String action) {\n-    Intent intent;\n-    if (activity != null) {\n-      intent = new Intent(context, activity.getClass());\n-    } else {\n-      String packageName = context.getPackageName();\n-      intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-    }\n-    intent.setAction(Intent.ACTION_MAIN);\n-    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-    intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    intent.putExtra(ACTION_INTENT_KEY, action);\n-    intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    return intent;\n-  }\n-\n-  /**\n-   * Build a notification trigger, such as triggering each N seconds, or\n-   * on a certain date \"shape\" (such as every first of the month)\n-   */\n-  // TODO support different AlarmManager.RTC modes depending on priority\n-  private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-    LocalNotificationSchedule schedule = request.getSchedule();\n-    Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-    notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-    notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-\n-    // Schedule at specific time (with repeating support)\n-    Date at = schedule.getAt();\n-    if (at != null) {\n-      if (at.getTime() < new Date().getTime()) {\n-        Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-        return;\n-      }\n-      if (schedule.isRepeating()) {\n-        long interval = at.getTime() - new Date().getTime();\n-        alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-      } else {\n-        alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-      }\n-      return;\n+    private void cancelTimerForNotification(Integer notificationId) {\n+        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n+        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n+        if (pi != null) {\n+            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+            alarmManager.cancel(pi);\n+        }\n     }\n \n-    // Schedule at specific intervals\n-    String every = schedule.getEvery();\n-    if (every != null) {\n-      Long everyInterval = schedule.getEveryInterval();\n-      if (everyInterval != null) {\n-        long startTime = new Date().getTime() + everyInterval;\n-        alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-      }\n-      return;\n+    private void dismissVisibleNotification(int notificationId) {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n+        notificationManager.cancel(notificationId);\n     }\n \n-    // Cron like scheduler\n-    DateMatch on = schedule.getOn();\n-    if (on != null) {\n-      notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-      pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-      alarmManager.setExact(AlarmManager.RTC, on.nextTrigger(new Date()), pendingIntent);\n-    }\n-  }\n-\n-  public void cancel(PluginCall call) {\n-    List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-    if (notificationsToCancel != null) {\n-      for (Integer id : notificationsToCancel) {\n-        dismissVisibleNotification(id);\n-        cancelTimerForNotification(id);\n-        storage.deleteNotification(Integer.toString(id));\n-      }\n-    }\n-    call.success();\n-  }\n-\n-  private void cancelTimerForNotification(Integer notificationId) {\n-    Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-    PendingIntent pi = PendingIntent.getBroadcast(\n-            context, notificationId, intent, 0);\n-    if (pi != null) {\n-      AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-      alarmManager.cancel(pi);\n+    public boolean areNotificationsEnabled() {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+        return notificationManager.areNotificationsEnabled();\n     }\n-  }\n-\n-  private void dismissVisibleNotification(int notificationId) {\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-    notificationManager.cancel(notificationId);\n-  }\n-\n-  public boolean areNotificationsEnabled(){\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-    return notificationManager.areNotificationsEnabled();\n-  }\n-\n-  public Uri getDefaultSoundUrl(Context context){\n-    int soundId = this.getDefaultSound(context);\n-    if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+\n+    public Uri getDefaultSoundUrl(Context context) {\n+        int soundId = this.getDefaultSound(context);\n+        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n \n-  private int getDefaultSound(Context context){\n-    if(defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n+    private int getDefaultSound(Context context) {\n+        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-    soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n+        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n \n-    if(soundConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        if (soundConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        }\n+\n+        defaultSoundID = resId;\n+        return resId;\n     }\n \n-    defaultSoundID = resId;\n-    return resId;\n-  }\n+    private int getDefaultSmallIcon(Context context) {\n+        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n \n-  private int getDefaultSmallIcon(Context context){\n-    if(defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n+        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-    smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n+        if (smallIconConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n+        }\n \n-    if(smallIconConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-    }\n+        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            resId = android.R.drawable.ic_dialog_info;\n+        }\n \n-    if(resId == AssetUtil.RESOURCE_ID_ZERO_VALUE){\n-      resId = android.R.drawable.ic_dialog_info;\n+        defaultSmallIconID = resId;\n+        return resId;\n     }\n-\n-    defaultSmallIconID = resId;\n-    return resId;\n-  }\n }\n", "next_change": {"commit": "15af432094bb83fb78919db134a2cb0d8eda305d", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 1336bea1..1f55d0ec 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -25,399 +27,398 @@ import com.getcapacitor.Logger;\n import com.getcapacitor.PluginCall;\n import com.getcapacitor.android.R;\n import com.getcapacitor.plugin.util.AssetUtil;\n-import java.util.Date;\n-import java.util.List;\n+\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+\n+\n /**\n  * Contains implementations for all notification actions\n  */\n public class LocalNotificationManager {\n-    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    // Action constants\n-    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-    private Context context;\n-    private Activity activity;\n-    private NotificationStorage storage;\n-    private CapConfig config;\n-\n-    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-        storage = notificationStorage;\n-        this.activity = activity;\n-        this.context = context;\n-        this.config = config;\n-    }\n-\n-    /**\n-     * Method extecuted when notification is launched by user from the notification bar.\n-     */\n-    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-        if (notificationId == Integer.MIN_VALUE) {\n-            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-            return null;\n-        }\n-        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-        if (isRemovable) {\n-            notificationStorage.deleteNotification(Integer.toString(notificationId));\n-        }\n-        JSObject dataJson = new JSObject();\n \n-        Bundle results = RemoteInput.getResultsFromIntent(data);\n-        if (results != null) {\n-            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-            dataJson.put(\"inputValue\", input.toString());\n-        }\n-        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-        dismissVisibleNotification(notificationId);\n-\n-        dataJson.put(\"actionId\", menuAction);\n-        JSONObject request = null;\n-        try {\n-            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-            if (notificationJsonString != null) {\n-                request = new JSObject(notificationJsonString);\n-            }\n-        } catch (JSONException e) {}\n-        dataJson.put(\"notification\", request);\n-        return dataJson;\n+  private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n+  private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+  private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+  // Action constants\n+  public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n+  public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n+  public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n+  public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n+  public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n+\n+  public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n+  private static final String DEFAULT_PRESS_ACTION = \"tap\";\n+\n+  private Context context;\n+  private Activity activity;\n+  private NotificationStorage storage;\n+  private CapConfig config;\n+\n+  public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n+    storage = notificationStorage;\n+    this.activity = activity;\n+    this.context = context;\n+    this.config = config;\n+  }\n+\n+  /**\n+   * Method extecuted when notification is launched by user from the notification bar.\n+   */\n+  public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n+    Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n+    int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n+    if (notificationId == Integer.MIN_VALUE) {\n+      Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n+      return null;\n     }\n-\n-    /**\n-     * Create notification channel\n-     */\n-    public void createNotificationChannel() {\n-        // Create the NotificationChannel, but only on API 26+ because\n-        // the NotificationChannel class is new and not in the support library\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-            CharSequence name = \"Default\";\n-            String description = \"Default\";\n-            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-            channel.setDescription(description);\n-            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-                .setUsage(AudioAttributes.USAGE_ALARM)\n-                .build();\n-            Uri soundUri = this.getDefaultSoundUrl(context);\n-            if (soundUri != null) {\n-                channel.setSound(soundUri, audioAttributes);\n-            }\n-            // Register the channel with the system; you can't change the importance\n-            // or other notification behaviors after this\n-            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-            notificationManager.createNotificationChannel(channel);\n-        }\n+    boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n+    if (isRemovable) {\n+      notificationStorage.deleteNotification(Integer.toString(notificationId));\n     }\n+    JSObject dataJson = new JSObject();\n \n-    @Nullable\n-    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-        JSONArray ids = new JSONArray();\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-        if (!notificationsEnabled) {\n-            if (call != null) {\n-                call.error(\"Notifications not enabled on this device\");\n-            }\n-            return null;\n-        }\n-        for (LocalNotification localNotification : localNotifications) {\n-            Integer id = localNotification.getId();\n-            if (localNotification.getId() == null) {\n-                if (call != null) {\n-                    call.error(\"LocalNotification missing identifier\");\n-                }\n-                return null;\n-            }\n-            dismissVisibleNotification(id);\n-            cancelTimerForNotification(id);\n-            buildNotification(notificationManager, localNotification, call);\n-            ids.put(id);\n-        }\n-        return ids;\n+    Bundle results = RemoteInput.getResultsFromIntent(data);\n+    if (results != null) {\n+      CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n+      dataJson.put(\"inputValue\", input.toString());\n     }\n-\n-    // TODO Progressbar support\n-    // TODO System categories (DO_NOT_DISTURB etc.)\n-    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-    // TODO use NotificationCompat.MessagingStyle for latest API\n-    // TODO expandable notification NotificationCompat.MessagingStyle\n-    // TODO media style notification support NotificationCompat.MediaStyle\n-    // TODO custom small/large icons\n-    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-        if (localNotification.getChannelId() != null) {\n-            channelId = localNotification.getChannelId();\n+    String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n+\n+    dismissVisibleNotification(notificationId);\n+\n+    dataJson.put(\"actionId\", menuAction);\n+    JSONObject request = null;\n+    try {\n+      String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n+      if (notificationJsonString != null) {\n+        request = new JSObject(notificationJsonString);\n+      }\n+    } catch (JSONException e) {\n+    }\n+    dataJson.put(\"notification\", request);\n+    return dataJson;\n+  }\n+\n+  /**\n+   * Create notification channel\n+   */\n+  public void createNotificationChannel() {\n+    // Create the NotificationChannel, but only on API 26+ because\n+    // the NotificationChannel class is new and not in the support library\n+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+      CharSequence name = \"Default\";\n+      String description = \"Default\";\n+      int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n+      NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n+      channel.setDescription(description);\n+      AudioAttributes audioAttributes = new AudioAttributes.Builder()\n+              .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n+              .setUsage(AudioAttributes.USAGE_ALARM).build();\n+      Uri soundUri = this.getDefaultSoundUrl(context);\n+      if (soundUri != null) {\n+        channel.setSound(soundUri, audioAttributes);\n+      }\n+      // Register the channel with the system; you can't change the importance\n+      // or other notification behaviors after this\n+      android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n+      notificationManager.createNotificationChannel(channel);\n+    }\n+  }\n+\n+  @Nullable\n+  public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n+    JSONArray ids = new JSONArray();\n+    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+\n+    boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n+    if (!notificationsEnabled) {\n+      if(call != null){\n+        call.error(\"Notifications not enabled on this device\");\n+      }\n+      return null;\n+    }\n+    for (LocalNotification localNotification : localNotifications) {\n+      Integer id = localNotification.getId();\n+      if (localNotification.getId() == null) {\n+        if(call != null) {\n+          call.error(\"LocalNotification missing identifier\");\n         }\n-        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n+        return null;\n+      }\n+      dismissVisibleNotification(id);\n+      cancelTimerForNotification(id);\n+      buildNotification(notificationManager, localNotification, call);\n+      ids.put(id);\n+    }\n+    return ids;\n+  }\n+\n+  // TODO Progressbar support\n+  // TODO System categories (DO_NOT_DISTURB etc.)\n+  // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n+  // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n+  // TODO use NotificationCompat.MessagingStyle for latest API\n+  // TODO expandable notification NotificationCompat.MessagingStyle\n+  // TODO media style notification support NotificationCompat.MediaStyle\n+  // TODO custom small/large icons\n+  private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n+    String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n+    if (localNotification.getChannelId() != null) {\n+      channelId = localNotification.getChannelId();\n+    }\n+    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n             .setContentTitle(localNotification.getTitle())\n             .setContentText(localNotification.getBody())\n-            .setAutoCancel(localNotification.isAutoCancel())\n-            .setOngoing(localNotification.isOngoing())\n+            .setAutoCancel( localNotification.isAutoCancel( ) )\n+            .setOngoing( localNotification.isOngoing( ) )\n             .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n             .setGroupSummary(localNotification.isGroupSummary());\n \n-        // support multiline text\n-        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-        String sound = localNotification.getSound(context, getDefaultSound(context));\n-        if (sound != null) {\n-            Uri soundUri = Uri.parse(sound);\n-            // Grant permission to use sound\n-            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            mBuilder.setSound(soundUri);\n-            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-        } else {\n-            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n-        }\n \n-        String group = localNotification.getGroup();\n-        if (group != null) {\n-            mBuilder.setGroup(group);\n-        }\n-\n-        // make sure scheduled time is shown instead of display time\n-        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n-        }\n-\n-        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-        mBuilder.setOnlyAlertOnce(true);\n-\n-        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n-\n-        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-        if (iconColor != null) {\n-            try {\n-                mBuilder.setColor(Color.parseColor(iconColor));\n-            } catch (IllegalArgumentException ex) {\n-                if (call != null) {\n-                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n-                }\n-                return;\n-            }\n-        }\n-\n-        createActionIntents(localNotification, mBuilder);\n-        // notificationId is a unique int for each localNotification that you must define\n-        Notification buildNotification = mBuilder.build();\n-        if (localNotification.isScheduled()) {\n-            triggerScheduledNotification(buildNotification, localNotification);\n-        } else {\n-            notificationManager.notify(localNotification.getId(), buildNotification);\n-        }\n+    // support multiline text\n+    mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n+\n+    String sound = localNotification.getSound(context, getDefaultSound(context));\n+    if (sound != null) {\n+      Uri soundUri = Uri.parse(sound);\n+      // Grant permission to use sound\n+      context.grantUriPermission(\n+              \"com.android.systemui\", soundUri,\n+              Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+      mBuilder.setSound(soundUri);\n+      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+    } else {\n+      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n     }\n \n-    // Create intents for open/dissmis actions\n-    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-        // Open intent\n-        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-        PendingIntent pendingIntent = PendingIntent.getActivity(\n-            context,\n-            localNotification.getId(),\n-            intent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-        mBuilder.setContentIntent(pendingIntent);\n-\n-        // Build action types\n-        String actionTypeId = localNotification.getActionTypeId();\n-        if (actionTypeId != null) {\n-            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-            for (NotificationAction notificationAction : actionGroup) {\n-                // TODO Add custom icons to actions\n-                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n-                    context,\n-                    localNotification.getId() + notificationAction.getId().hashCode(),\n-                    actionIntent,\n-                    PendingIntent.FLAG_CANCEL_CURRENT\n-                );\n-                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n-                    R.drawable.ic_transparent,\n-                    notificationAction.getTitle(),\n-                    actionPendingIntent\n-                );\n-                if (notificationAction.isInput()) {\n-                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n-                    actionBuilder.addRemoteInput(remoteInput);\n-                }\n-                mBuilder.addAction(actionBuilder.build());\n-            }\n-        }\n \n-        // Dismiss intent\n-        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n-        mBuilder.setDeleteIntent(deleteIntent);\n+    String group = localNotification.getGroup();\n+    if (group != null) {\n+      mBuilder.setGroup(group);\n     }\n \n-    @NonNull\n-    private Intent buildIntent(LocalNotification localNotification, String action) {\n-        Intent intent;\n-        if (activity != null) {\n-            intent = new Intent(context, activity.getClass());\n-        } else {\n-            String packageName = context.getPackageName();\n-            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-        }\n-        intent.setAction(Intent.ACTION_MAIN);\n-        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        intent.putExtra(ACTION_INTENT_KEY, action);\n-        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        return intent;\n+    // make sure scheduled time is shown instead of display time\n+    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n+      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n+              .setShowWhen(true);\n     }\n \n-    /**\n-     * Build a notification trigger, such as triggering each N seconds, or\n-     * on a certain date \"shape\" (such as every first of the month)\n-     */\n-    // TODO support different AlarmManager.RTC modes depending on priority\n-    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-        LocalNotificationSchedule schedule = request.getSchedule();\n-        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n-            context,\n-            request.getId(),\n-            notificationIntent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-\n-        // Schedule at specific time (with repeating support)\n-        Date at = schedule.getAt();\n-        if (at != null) {\n-            if (at.getTime() < new Date().getTime()) {\n-                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-                return;\n-            }\n-            if (schedule.isRepeating()) {\n-                long interval = at.getTime() - new Date().getTime();\n-                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-            } else {\n-                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-            }\n-            return;\n-        }\n+    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n+    mBuilder.setOnlyAlertOnce(true);\n \n-        // Schedule at specific intervals\n-        String every = schedule.getEvery();\n-        if (every != null) {\n-            Long everyInterval = schedule.getEveryInterval();\n-            if (everyInterval != null) {\n-                long startTime = new Date().getTime() + everyInterval;\n-                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-            }\n-            return;\n-        }\n+    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n \n-        // Cron like scheduler\n-        DateMatch on = schedule.getOn();\n-        if (on != null) {\n-            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-            alarmManager.setExact(AlarmManager.RTC, on.nextTrigger(new Date()), pendingIntent);\n+    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n+    if (iconColor != null) {\n+      try {\n+        mBuilder.setColor(Color.parseColor(iconColor));\n+      } catch (IllegalArgumentException ex) {\n+        if(call != null) {\n+            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n         }\n+        return;\n+      }\n     }\n \n-    public void cancel(PluginCall call) {\n-        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-        if (notificationsToCancel != null) {\n-            for (Integer id : notificationsToCancel) {\n-                dismissVisibleNotification(id);\n-                cancelTimerForNotification(id);\n-                storage.deleteNotification(Integer.toString(id));\n-            }\n-        }\n-        call.success();\n+    createActionIntents(localNotification, mBuilder);\n+    // notificationId is a unique int for each localNotification that you must define\n+    Notification buildNotification = mBuilder.build();\n+    if (localNotification.isScheduled()) {\n+      triggerScheduledNotification(buildNotification, localNotification);\n+    } else {\n+      notificationManager.notify(localNotification.getId(), buildNotification);\n     }\n-\n-    private void cancelTimerForNotification(Integer notificationId) {\n-        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n-        if (pi != null) {\n-            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-            alarmManager.cancel(pi);\n+  }\n+\n+  // Create intents for open/dissmis actions\n+  private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n+    // Open intent\n+    Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n+\n+    PendingIntent pendingIntent = PendingIntent.getActivity(context, localNotification.getId(), intent, PendingIntent.FLAG_CANCEL_CURRENT);\n+    mBuilder.setContentIntent(pendingIntent);\n+\n+    // Build action types\n+    String actionTypeId = localNotification.getActionTypeId();\n+    if (actionTypeId != null) {\n+      NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n+      for (int i = 0; i < actionGroup.length; i++) {\n+        NotificationAction notificationAction = actionGroup[i];\n+        // TODO Add custom icons to actions\n+        Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n+        PendingIntent actionPendingIntent = PendingIntent.getActivity(context, localNotification.getId() + notificationAction.getId().hashCode(), actionIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(R.drawable.ic_transparent, notificationAction.getTitle(), actionPendingIntent);\n+        if (notificationAction.isInput()) {\n+          RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY)\n+                  .setLabel(notificationAction.getTitle())\n+                  .build();\n+          actionBuilder.addRemoteInput(remoteInput);\n         }\n+        mBuilder.addAction(actionBuilder.build());\n+      }\n     }\n \n-    private void dismissVisibleNotification(int notificationId) {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-        notificationManager.cancel(notificationId);\n+    // Dismiss intent\n+    Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n+    dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+    dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+    dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n+    LocalNotificationSchedule schedule = localNotification.getSchedule();\n+    dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+    PendingIntent deleteIntent = PendingIntent.getBroadcast(\n+            context, localNotification.getId(), dissmissIntent, 0);\n+    mBuilder.setDeleteIntent(deleteIntent);\n+  }\n+\n+  @NonNull\n+  private Intent buildIntent(LocalNotification localNotification, String action) {\n+    Intent intent;\n+    if (activity != null) {\n+      intent = new Intent(context, activity.getClass());\n+    } else {\n+      String packageName = context.getPackageName();\n+      intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n     }\n-\n-    public boolean areNotificationsEnabled() {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-        return notificationManager.areNotificationsEnabled();\n+    intent.setAction(Intent.ACTION_MAIN);\n+    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n+    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+    intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+    intent.putExtra(ACTION_INTENT_KEY, action);\n+    intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n+    LocalNotificationSchedule schedule = localNotification.getSchedule();\n+    intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+    return intent;\n+  }\n+\n+  /**\n+   * Build a notification trigger, such as triggering each N seconds, or\n+   * on a certain date \"shape\" (such as every first of the month)\n+   */\n+  // TODO support different AlarmManager.RTC modes depending on priority\n+  private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n+    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+    LocalNotificationSchedule schedule = request.getSchedule();\n+    Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n+    notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n+    notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n+    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+\n+    // Schedule at specific time (with repeating support)\n+    Date at = schedule.getAt();\n+    if (at != null) {\n+      if (at.getTime() < new Date().getTime()) {\n+        Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n+        return;\n+      }\n+      if (schedule.isRepeating()) {\n+        long interval = at.getTime() - new Date().getTime();\n+        alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n+      } else {\n+        alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n+      }\n+      return;\n     }\n \n-    public Uri getDefaultSoundUrl(Context context) {\n-        int soundId = this.getDefaultSound(context);\n-        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n-        }\n-        return null;\n+    // Schedule at specific intervals\n+    String every = schedule.getEvery();\n+    if (every != null) {\n+      Long everyInterval = schedule.getEveryInterval();\n+      if (everyInterval != null) {\n+        long startTime = new Date().getTime() + everyInterval;\n+        alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n+      }\n+      return;\n     }\n \n-    private int getDefaultSound(Context context) {\n-        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n+    // Cron like scheduler\n+    DateMatch on = schedule.getOn();\n+    if (on != null) {\n+      long trigger = on.nextTrigger(new Date());\n+      notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n+      pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+      alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n+      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n+      Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n+    }\n+  }\n+\n+  public void cancel(PluginCall call) {\n+    List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n+    if (notificationsToCancel != null) {\n+      for (Integer id : notificationsToCancel) {\n+        dismissVisibleNotification(id);\n+        cancelTimerForNotification(id);\n+        storage.deleteNotification(Integer.toString(id));\n+      }\n+    }\n+    call.success();\n+  }\n+\n+  private void cancelTimerForNotification(Integer notificationId) {\n+    Intent intent = new Intent(context, TimedNotificationPublisher.class);\n+    PendingIntent pi = PendingIntent.getBroadcast(\n+            context, notificationId, intent, 0);\n+    if (pi != null) {\n+      AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+      alarmManager.cancel(pi);\n+    }\n+  }\n+\n+  private void dismissVisibleNotification(int notificationId) {\n+    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n+    notificationManager.cancel(notificationId);\n+  }\n+\n+  public boolean areNotificationsEnabled(){\n+    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+    return notificationManager.areNotificationsEnabled();\n+  }\n+\n+  public Uri getDefaultSoundUrl(Context context){\n+    int soundId = this.getDefaultSound(context);\n+    if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+    }\n+    return null;\n+  }\n \n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n+  private int getDefaultSound(Context context){\n+    if(defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n \n-        if (soundConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n-        }\n+    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n+    soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n \n-        defaultSoundID = resId;\n-        return resId;\n+    if(soundConfigResourceName != null){\n+      resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n     }\n \n-    private int getDefaultSmallIcon(Context context) {\n-        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n+    defaultSoundID = resId;\n+    return resId;\n+  }\n \n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n+  private int getDefaultSmallIcon(Context context){\n+    if(defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n \n-        if (smallIconConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-        }\n+    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n+    smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n \n-        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            resId = android.R.drawable.ic_dialog_info;\n-        }\n+    if(smallIconConfigResourceName != null){\n+      resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n+    }\n \n-        defaultSmallIconID = resId;\n-        return resId;\n+    if(resId == AssetUtil.RESOURCE_ID_ZERO_VALUE){\n+      resId = android.R.drawable.ic_dialog_info;\n     }\n+\n+    defaultSmallIconID = resId;\n+    return resId;\n+  }\n }\n", "next_change": {"commit": "2201ba099b5f1362529a45d7e114761f5bf4f9bb", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\nindex 1f55d0ec..2e9b347d 100644\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n", "chunk": "@@ -13,412 +13,414 @@ import android.media.AudioAttributes;\n import android.net.Uri;\n import android.os.Build;\n import android.os.Bundle;\n-\n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n import androidx.core.app.NotificationCompat;\n import androidx.core.app.NotificationManagerCompat;\n import androidx.core.app.RemoteInput;\n-\n import com.getcapacitor.CapConfig;\n-import com.getcapacitor.Config;\n import com.getcapacitor.JSObject;\n import com.getcapacitor.Logger;\n import com.getcapacitor.PluginCall;\n import com.getcapacitor.android.R;\n import com.getcapacitor.plugin.util.AssetUtil;\n-\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n-\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.List;\n-\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n \n /**\n  * Contains implementations for all notification actions\n  */\n public class LocalNotificationManager {\n-\n-  private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-  private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-  // Action constants\n-  public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-  public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-  public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-  public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-  public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-  public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-  private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-  private Context context;\n-  private Activity activity;\n-  private NotificationStorage storage;\n-  private CapConfig config;\n-\n-  public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-    storage = notificationStorage;\n-    this.activity = activity;\n-    this.context = context;\n-    this.config = config;\n-  }\n-\n-  /**\n-   * Method extecuted when notification is launched by user from the notification bar.\n-   */\n-  public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-    Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-    int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-    if (notificationId == Integer.MIN_VALUE) {\n-      Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-      return null;\n-    }\n-    boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-    if (isRemovable) {\n-      notificationStorage.deleteNotification(Integer.toString(notificationId));\n+    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n+    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+    // Action constants\n+    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n+    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n+    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n+    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n+    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n+\n+    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n+    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n+\n+    private Context context;\n+    private Activity activity;\n+    private NotificationStorage storage;\n+    private CapConfig config;\n+\n+    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n+        storage = notificationStorage;\n+        this.activity = activity;\n+        this.context = context;\n+        this.config = config;\n     }\n-    JSObject dataJson = new JSObject();\n \n-    Bundle results = RemoteInput.getResultsFromIntent(data);\n-    if (results != null) {\n-      CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-      dataJson.put(\"inputValue\", input.toString());\n-    }\n-    String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-    dismissVisibleNotification(notificationId);\n-\n-    dataJson.put(\"actionId\", menuAction);\n-    JSONObject request = null;\n-    try {\n-      String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-      if (notificationJsonString != null) {\n-        request = new JSObject(notificationJsonString);\n-      }\n-    } catch (JSONException e) {\n-    }\n-    dataJson.put(\"notification\", request);\n-    return dataJson;\n-  }\n-\n-  /**\n-   * Create notification channel\n-   */\n-  public void createNotificationChannel() {\n-    // Create the NotificationChannel, but only on API 26+ because\n-    // the NotificationChannel class is new and not in the support library\n-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-      CharSequence name = \"Default\";\n-      String description = \"Default\";\n-      int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-      NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-      channel.setDescription(description);\n-      AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-              .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-              .setUsage(AudioAttributes.USAGE_ALARM).build();\n-      Uri soundUri = this.getDefaultSoundUrl(context);\n-      if (soundUri != null) {\n-        channel.setSound(soundUri, audioAttributes);\n-      }\n-      // Register the channel with the system; you can't change the importance\n-      // or other notification behaviors after this\n-      android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-      notificationManager.createNotificationChannel(channel);\n-    }\n-  }\n-\n-  @Nullable\n-  public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-    JSONArray ids = new JSONArray();\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-    boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-    if (!notificationsEnabled) {\n-      if(call != null){\n-        call.error(\"Notifications not enabled on this device\");\n-      }\n-      return null;\n+    /**\n+     * Method extecuted when notification is launched by user from the notification bar.\n+     */\n+    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n+        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n+        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n+        if (notificationId == Integer.MIN_VALUE) {\n+            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n+            return null;\n+        }\n+        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n+        if (isRemovable) {\n+            notificationStorage.deleteNotification(Integer.toString(notificationId));\n+        }\n+        JSObject dataJson = new JSObject();\n+\n+        Bundle results = RemoteInput.getResultsFromIntent(data);\n+        if (results != null) {\n+            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n+            dataJson.put(\"inputValue\", input.toString());\n+        }\n+        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n+\n+        dismissVisibleNotification(notificationId);\n+\n+        dataJson.put(\"actionId\", menuAction);\n+        JSONObject request = null;\n+        try {\n+            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n+            if (notificationJsonString != null) {\n+                request = new JSObject(notificationJsonString);\n+            }\n+        } catch (JSONException e) {}\n+        dataJson.put(\"notification\", request);\n+        return dataJson;\n     }\n-    for (LocalNotification localNotification : localNotifications) {\n-      Integer id = localNotification.getId();\n-      if (localNotification.getId() == null) {\n-        if(call != null) {\n-          call.error(\"LocalNotification missing identifier\");\n+\n+    /**\n+     * Create notification channel\n+     */\n+    public void createNotificationChannel() {\n+        // Create the NotificationChannel, but only on API 26+ because\n+        // the NotificationChannel class is new and not in the support library\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            CharSequence name = \"Default\";\n+            String description = \"Default\";\n+            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n+            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n+            channel.setDescription(description);\n+            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n+                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n+                .setUsage(AudioAttributes.USAGE_ALARM)\n+                .build();\n+            Uri soundUri = this.getDefaultSoundUrl(context);\n+            if (soundUri != null) {\n+                channel.setSound(soundUri, audioAttributes);\n+            }\n+            // Register the channel with the system; you can't change the importance\n+            // or other notification behaviors after this\n+            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n+            notificationManager.createNotificationChannel(channel);\n         }\n-        return null;\n-      }\n-      dismissVisibleNotification(id);\n-      cancelTimerForNotification(id);\n-      buildNotification(notificationManager, localNotification, call);\n-      ids.put(id);\n     }\n-    return ids;\n-  }\n-\n-  // TODO Progressbar support\n-  // TODO System categories (DO_NOT_DISTURB etc.)\n-  // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-  // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-  // TODO use NotificationCompat.MessagingStyle for latest API\n-  // TODO expandable notification NotificationCompat.MessagingStyle\n-  // TODO media style notification support NotificationCompat.MediaStyle\n-  // TODO custom small/large icons\n-  private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-    String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-    if (localNotification.getChannelId() != null) {\n-      channelId = localNotification.getChannelId();\n+\n+    @Nullable\n+    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n+        JSONArray ids = new JSONArray();\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+\n+        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n+        if (!notificationsEnabled) {\n+            if (call != null) {\n+                call.error(\"Notifications not enabled on this device\");\n+            }\n+            return null;\n+        }\n+        for (LocalNotification localNotification : localNotifications) {\n+            Integer id = localNotification.getId();\n+            if (localNotification.getId() == null) {\n+                if (call != null) {\n+                    call.error(\"LocalNotification missing identifier\");\n+                }\n+                return null;\n+            }\n+            dismissVisibleNotification(id);\n+            cancelTimerForNotification(id);\n+            buildNotification(notificationManager, localNotification, call);\n+            ids.put(id);\n+        }\n+        return ids;\n     }\n-    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n+\n+    // TODO Progressbar support\n+    // TODO System categories (DO_NOT_DISTURB etc.)\n+    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n+    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n+    // TODO use NotificationCompat.MessagingStyle for latest API\n+    // TODO expandable notification NotificationCompat.MessagingStyle\n+    // TODO media style notification support NotificationCompat.MediaStyle\n+    // TODO custom small/large icons\n+    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n+        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n+        if (localNotification.getChannelId() != null) {\n+            channelId = localNotification.getChannelId();\n+        }\n+        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n             .setContentTitle(localNotification.getTitle())\n             .setContentText(localNotification.getBody())\n-            .setAutoCancel( localNotification.isAutoCancel( ) )\n-            .setOngoing( localNotification.isOngoing( ) )\n+            .setAutoCancel(localNotification.isAutoCancel())\n+            .setOngoing(localNotification.isOngoing())\n             .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n             .setGroupSummary(localNotification.isGroupSummary());\n \n+        // support multiline text\n+        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n+\n+        String sound = localNotification.getSound(context, getDefaultSound(context));\n+        if (sound != null) {\n+            Uri soundUri = Uri.parse(sound);\n+            // Grant permission to use sound\n+            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            mBuilder.setSound(soundUri);\n+            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n+        } else {\n+            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        }\n+\n+        String group = localNotification.getGroup();\n+        if (group != null) {\n+            mBuilder.setGroup(group);\n+        }\n+\n+        // make sure scheduled time is shown instead of display time\n+        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n+            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n+        }\n+\n+        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n+        mBuilder.setOnlyAlertOnce(true);\n+\n+        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+\n+        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n+        if (iconColor != null) {\n+            try {\n+                mBuilder.setColor(Color.parseColor(iconColor));\n+            } catch (IllegalArgumentException ex) {\n+                if (call != null) {\n+                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+                }\n+                return;\n+            }\n+        }\n \n-    // support multiline text\n-    mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-    String sound = localNotification.getSound(context, getDefaultSound(context));\n-    if (sound != null) {\n-      Uri soundUri = Uri.parse(sound);\n-      // Grant permission to use sound\n-      context.grantUriPermission(\n-              \"com.android.systemui\", soundUri,\n-              Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-      mBuilder.setSound(soundUri);\n-      mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-    } else {\n-      mBuilder.setDefaults(Notification.DEFAULT_ALL);\n+        createActionIntents(localNotification, mBuilder);\n+        // notificationId is a unique int for each localNotification that you must define\n+        Notification buildNotification = mBuilder.build();\n+        if (localNotification.isScheduled()) {\n+            triggerScheduledNotification(buildNotification, localNotification);\n+        } else {\n+            notificationManager.notify(localNotification.getId(), buildNotification);\n+        }\n     }\n \n+    // Create intents for open/dissmis actions\n+    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n+        // Open intent\n+        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n+\n+        PendingIntent pendingIntent = PendingIntent.getActivity(\n+            context,\n+            localNotification.getId(),\n+            intent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+        mBuilder.setContentIntent(pendingIntent);\n+\n+        // Build action types\n+        String actionTypeId = localNotification.getActionTypeId();\n+        if (actionTypeId != null) {\n+            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n+            for (NotificationAction notificationAction : actionGroup) {\n+                // TODO Add custom icons to actions\n+                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n+                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n+                    context,\n+                    localNotification.getId() + notificationAction.getId().hashCode(),\n+                    actionIntent,\n+                    PendingIntent.FLAG_CANCEL_CURRENT\n+                );\n+                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n+                    R.drawable.ic_transparent,\n+                    notificationAction.getTitle(),\n+                    actionPendingIntent\n+                );\n+                if (notificationAction.isInput()) {\n+                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n+                    actionBuilder.addRemoteInput(remoteInput);\n+                }\n+                mBuilder.addAction(actionBuilder.build());\n+            }\n+        }\n \n-    String group = localNotification.getGroup();\n-    if (group != null) {\n-      mBuilder.setGroup(group);\n+        // Dismiss intent\n+        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n+        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n+        mBuilder.setDeleteIntent(deleteIntent);\n     }\n \n-    // make sure scheduled time is shown instead of display time\n-    if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-      mBuilder.setWhen(localNotification.getSchedule().getAt().getTime())\n-              .setShowWhen(true);\n+    @NonNull\n+    private Intent buildIntent(LocalNotification localNotification, String action) {\n+        Intent intent;\n+        if (activity != null) {\n+            intent = new Intent(context, activity.getClass());\n+        } else {\n+            String packageName = context.getPackageName();\n+            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n+        }\n+        intent.setAction(Intent.ACTION_MAIN);\n+        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n+        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n+        intent.putExtra(ACTION_INTENT_KEY, action);\n+        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n+        LocalNotificationSchedule schedule = localNotification.getSchedule();\n+        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n+        return intent;\n     }\n \n-    mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-    mBuilder.setOnlyAlertOnce(true);\n+    /**\n+     * Build a notification trigger, such as triggering each N seconds, or\n+     * on a certain date \"shape\" (such as every first of the month)\n+     */\n+    // TODO support different AlarmManager.RTC modes depending on priority\n+    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n+        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+        LocalNotificationSchedule schedule = request.getSchedule();\n+        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n+        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n+        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n+        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n+            context,\n+            request.getId(),\n+            notificationIntent,\n+            PendingIntent.FLAG_CANCEL_CURRENT\n+        );\n+\n+        // Schedule at specific time (with repeating support)\n+        Date at = schedule.getAt();\n+        if (at != null) {\n+            if (at.getTime() < new Date().getTime()) {\n+                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n+                return;\n+            }\n+            if (schedule.isRepeating()) {\n+                long interval = at.getTime() - new Date().getTime();\n+                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n+            } else {\n+                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n+            }\n+            return;\n+        }\n \n-    mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n+        // Schedule at specific intervals\n+        String every = schedule.getEvery();\n+        if (every != null) {\n+            Long everyInterval = schedule.getEveryInterval();\n+            if (everyInterval != null) {\n+                long startTime = new Date().getTime() + everyInterval;\n+                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n+            }\n+            return;\n+        }\n \n-    String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-    if (iconColor != null) {\n-      try {\n-        mBuilder.setColor(Color.parseColor(iconColor));\n-      } catch (IllegalArgumentException ex) {\n-        if(call != null) {\n-            call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n+        // Cron like scheduler\n+        DateMatch on = schedule.getOn();\n+        if (on != null) {\n+            long trigger = on.nextTrigger(new Date());\n+            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n+            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n+            alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n+            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n+            Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n         }\n-        return;\n-      }\n     }\n \n-    createActionIntents(localNotification, mBuilder);\n-    // notificationId is a unique int for each localNotification that you must define\n-    Notification buildNotification = mBuilder.build();\n-    if (localNotification.isScheduled()) {\n-      triggerScheduledNotification(buildNotification, localNotification);\n-    } else {\n-      notificationManager.notify(localNotification.getId(), buildNotification);\n-    }\n-  }\n-\n-  // Create intents for open/dissmis actions\n-  private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-    // Open intent\n-    Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-    PendingIntent pendingIntent = PendingIntent.getActivity(context, localNotification.getId(), intent, PendingIntent.FLAG_CANCEL_CURRENT);\n-    mBuilder.setContentIntent(pendingIntent);\n-\n-    // Build action types\n-    String actionTypeId = localNotification.getActionTypeId();\n-    if (actionTypeId != null) {\n-      NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-      for (int i = 0; i < actionGroup.length; i++) {\n-        NotificationAction notificationAction = actionGroup[i];\n-        // TODO Add custom icons to actions\n-        Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-        PendingIntent actionPendingIntent = PendingIntent.getActivity(context, localNotification.getId() + notificationAction.getId().hashCode(), actionIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(R.drawable.ic_transparent, notificationAction.getTitle(), actionPendingIntent);\n-        if (notificationAction.isInput()) {\n-          RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY)\n-                  .setLabel(notificationAction.getTitle())\n-                  .build();\n-          actionBuilder.addRemoteInput(remoteInput);\n+    public void cancel(PluginCall call) {\n+        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n+        if (notificationsToCancel != null) {\n+            for (Integer id : notificationsToCancel) {\n+                dismissVisibleNotification(id);\n+                cancelTimerForNotification(id);\n+                storage.deleteNotification(Integer.toString(id));\n+            }\n         }\n-        mBuilder.addAction(actionBuilder.build());\n-      }\n+        call.success();\n     }\n \n-    // Dismiss intent\n-    Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-    dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-    dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    PendingIntent deleteIntent = PendingIntent.getBroadcast(\n-            context, localNotification.getId(), dissmissIntent, 0);\n-    mBuilder.setDeleteIntent(deleteIntent);\n-  }\n-\n-  @NonNull\n-  private Intent buildIntent(LocalNotification localNotification, String action) {\n-    Intent intent;\n-    if (activity != null) {\n-      intent = new Intent(context, activity.getClass());\n-    } else {\n-      String packageName = context.getPackageName();\n-      intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-    }\n-    intent.setAction(Intent.ACTION_MAIN);\n-    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-    intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-    intent.putExtra(ACTION_INTENT_KEY, action);\n-    intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-    LocalNotificationSchedule schedule = localNotification.getSchedule();\n-    intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-    return intent;\n-  }\n-\n-  /**\n-   * Build a notification trigger, such as triggering each N seconds, or\n-   * on a certain date \"shape\" (such as every first of the month)\n-   */\n-  // TODO support different AlarmManager.RTC modes depending on priority\n-  private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-    LocalNotificationSchedule schedule = request.getSchedule();\n-    Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-    notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-    notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-\n-    // Schedule at specific time (with repeating support)\n-    Date at = schedule.getAt();\n-    if (at != null) {\n-      if (at.getTime() < new Date().getTime()) {\n-        Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-        return;\n-      }\n-      if (schedule.isRepeating()) {\n-        long interval = at.getTime() - new Date().getTime();\n-        alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-      } else {\n-        alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-      }\n-      return;\n+    private void cancelTimerForNotification(Integer notificationId) {\n+        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n+        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n+        if (pi != null) {\n+            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n+            alarmManager.cancel(pi);\n+        }\n     }\n \n-    // Schedule at specific intervals\n-    String every = schedule.getEvery();\n-    if (every != null) {\n-      Long everyInterval = schedule.getEveryInterval();\n-      if (everyInterval != null) {\n-        long startTime = new Date().getTime() + everyInterval;\n-        alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-      }\n-      return;\n+    private void dismissVisibleNotification(int notificationId) {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n+        notificationManager.cancel(notificationId);\n     }\n \n-    // Cron like scheduler\n-    DateMatch on = schedule.getOn();\n-    if (on != null) {\n-      long trigger = on.nextTrigger(new Date());\n-      notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-      pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-      alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n-      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n-      Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n-    }\n-  }\n-\n-  public void cancel(PluginCall call) {\n-    List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-    if (notificationsToCancel != null) {\n-      for (Integer id : notificationsToCancel) {\n-        dismissVisibleNotification(id);\n-        cancelTimerForNotification(id);\n-        storage.deleteNotification(Integer.toString(id));\n-      }\n-    }\n-    call.success();\n-  }\n-\n-  private void cancelTimerForNotification(Integer notificationId) {\n-    Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-    PendingIntent pi = PendingIntent.getBroadcast(\n-            context, notificationId, intent, 0);\n-    if (pi != null) {\n-      AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-      alarmManager.cancel(pi);\n+    public boolean areNotificationsEnabled() {\n+        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n+        return notificationManager.areNotificationsEnabled();\n     }\n-  }\n-\n-  private void dismissVisibleNotification(int notificationId) {\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-    notificationManager.cancel(notificationId);\n-  }\n-\n-  public boolean areNotificationsEnabled(){\n-    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-    return notificationManager.areNotificationsEnabled();\n-  }\n-\n-  public Uri getDefaultSoundUrl(Context context){\n-    int soundId = this.getDefaultSound(context);\n-    if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+\n+    public Uri getDefaultSoundUrl(Context context) {\n+        int soundId = this.getDefaultSound(context);\n+        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n \n-  private int getDefaultSound(Context context){\n-    if(defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n+    private int getDefaultSound(Context context) {\n+        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-    soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n+        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n \n-    if(soundConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        if (soundConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n+        }\n+\n+        defaultSoundID = resId;\n+        return resId;\n     }\n \n-    defaultSoundID = resId;\n-    return resId;\n-  }\n+    private int getDefaultSmallIcon(Context context) {\n+        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n \n-  private int getDefaultSmallIcon(Context context){\n-    if(defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n+        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n+        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n+        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n \n-    int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-    smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n+        if (smallIconConfigResourceName != null) {\n+            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n+        }\n \n-    if(smallIconConfigResourceName != null){\n-      resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-    }\n+        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n+            resId = android.R.drawable.ic_dialog_info;\n+        }\n \n-    if(resId == AssetUtil.RESOURCE_ID_ZERO_VALUE){\n-      resId = android.R.drawable.ic_dialog_info;\n+        defaultSmallIconID = resId;\n+        return resId;\n     }\n-\n-    defaultSmallIconID = resId;\n-    return resId;\n-  }\n }\n", "next_change": {"commit": "f3022a30568f9f19b1ef537d212c88e873a2e65d", "changed_code": [{"header": "diff --git a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java b/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\ndeleted file mode 100644\nindex 2e9b347d..00000000\n--- a/android/capacitor/src/main/java/com/getcapacitor/plugin/notification/LocalNotificationManager.java\n+++ /dev/null\n", "chunk": "@@ -1,426 +0,0 @@\n-package com.getcapacitor.plugin.notification;\n-\n-import android.app.Activity;\n-import android.app.AlarmManager;\n-import android.app.Notification;\n-import android.app.NotificationChannel;\n-import android.app.PendingIntent;\n-import android.content.ContentResolver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.graphics.Color;\n-import android.media.AudioAttributes;\n-import android.net.Uri;\n-import android.os.Build;\n-import android.os.Bundle;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.core.app.NotificationCompat;\n-import androidx.core.app.NotificationManagerCompat;\n-import androidx.core.app.RemoteInput;\n-import com.getcapacitor.CapConfig;\n-import com.getcapacitor.JSObject;\n-import com.getcapacitor.Logger;\n-import com.getcapacitor.PluginCall;\n-import com.getcapacitor.android.R;\n-import com.getcapacitor.plugin.util.AssetUtil;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.List;\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n-\n-/**\n- * Contains implementations for all notification actions\n- */\n-public class LocalNotificationManager {\n-    private static final String CONFIG_KEY_PREFIX = \"plugins.LocalNotifications.\";\n-    private static int defaultSoundID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    private static int defaultSmallIconID = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-    // Action constants\n-    public static final String NOTIFICATION_INTENT_KEY = \"LocalNotificationId\";\n-    public static final String NOTIFICATION_OBJ_INTENT_KEY = \"LocalNotficationObject\";\n-    public static final String ACTION_INTENT_KEY = \"LocalNotificationUserAction\";\n-    public static final String NOTIFICATION_IS_REMOVABLE_KEY = \"LocalNotificationRepeating\";\n-    public static final String REMOTE_INPUT_KEY = \"LocalNotificationRemoteInput\";\n-\n-    public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"default\";\n-    private static final String DEFAULT_PRESS_ACTION = \"tap\";\n-\n-    private Context context;\n-    private Activity activity;\n-    private NotificationStorage storage;\n-    private CapConfig config;\n-\n-    public LocalNotificationManager(NotificationStorage notificationStorage, Activity activity, Context context, CapConfig config) {\n-        storage = notificationStorage;\n-        this.activity = activity;\n-        this.context = context;\n-        this.config = config;\n-    }\n-\n-    /**\n-     * Method extecuted when notification is launched by user from the notification bar.\n-     */\n-    public JSObject handleNotificationActionPerformed(Intent data, NotificationStorage notificationStorage) {\n-        Logger.debug(Logger.tags(\"LN\"), \"LocalNotification received: \" + data.getDataString());\n-        int notificationId = data.getIntExtra(LocalNotificationManager.NOTIFICATION_INTENT_KEY, Integer.MIN_VALUE);\n-        if (notificationId == Integer.MIN_VALUE) {\n-            Logger.debug(Logger.tags(\"LN\"), \"Activity started without notification attached\");\n-            return null;\n-        }\n-        boolean isRemovable = data.getBooleanExtra(LocalNotificationManager.NOTIFICATION_IS_REMOVABLE_KEY, true);\n-        if (isRemovable) {\n-            notificationStorage.deleteNotification(Integer.toString(notificationId));\n-        }\n-        JSObject dataJson = new JSObject();\n-\n-        Bundle results = RemoteInput.getResultsFromIntent(data);\n-        if (results != null) {\n-            CharSequence input = results.getCharSequence(LocalNotificationManager.REMOTE_INPUT_KEY);\n-            dataJson.put(\"inputValue\", input.toString());\n-        }\n-        String menuAction = data.getStringExtra(LocalNotificationManager.ACTION_INTENT_KEY);\n-\n-        dismissVisibleNotification(notificationId);\n-\n-        dataJson.put(\"actionId\", menuAction);\n-        JSONObject request = null;\n-        try {\n-            String notificationJsonString = data.getStringExtra(LocalNotificationManager.NOTIFICATION_OBJ_INTENT_KEY);\n-            if (notificationJsonString != null) {\n-                request = new JSObject(notificationJsonString);\n-            }\n-        } catch (JSONException e) {}\n-        dataJson.put(\"notification\", request);\n-        return dataJson;\n-    }\n-\n-    /**\n-     * Create notification channel\n-     */\n-    public void createNotificationChannel() {\n-        // Create the NotificationChannel, but only on API 26+ because\n-        // the NotificationChannel class is new and not in the support library\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-            CharSequence name = \"Default\";\n-            String description = \"Default\";\n-            int importance = android.app.NotificationManager.IMPORTANCE_DEFAULT;\n-            NotificationChannel channel = new NotificationChannel(DEFAULT_NOTIFICATION_CHANNEL_ID, name, importance);\n-            channel.setDescription(description);\n-            AudioAttributes audioAttributes = new AudioAttributes.Builder()\n-                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n-                .setUsage(AudioAttributes.USAGE_ALARM)\n-                .build();\n-            Uri soundUri = this.getDefaultSoundUrl(context);\n-            if (soundUri != null) {\n-                channel.setSound(soundUri, audioAttributes);\n-            }\n-            // Register the channel with the system; you can't change the importance\n-            // or other notification behaviors after this\n-            android.app.NotificationManager notificationManager = context.getSystemService(android.app.NotificationManager.class);\n-            notificationManager.createNotificationChannel(channel);\n-        }\n-    }\n-\n-    @Nullable\n-    public JSONArray schedule(PluginCall call, List<LocalNotification> localNotifications) {\n-        JSONArray ids = new JSONArray();\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-\n-        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();\n-        if (!notificationsEnabled) {\n-            if (call != null) {\n-                call.error(\"Notifications not enabled on this device\");\n-            }\n-            return null;\n-        }\n-        for (LocalNotification localNotification : localNotifications) {\n-            Integer id = localNotification.getId();\n-            if (localNotification.getId() == null) {\n-                if (call != null) {\n-                    call.error(\"LocalNotification missing identifier\");\n-                }\n-                return null;\n-            }\n-            dismissVisibleNotification(id);\n-            cancelTimerForNotification(id);\n-            buildNotification(notificationManager, localNotification, call);\n-            ids.put(id);\n-        }\n-        return ids;\n-    }\n-\n-    // TODO Progressbar support\n-    // TODO System categories (DO_NOT_DISTURB etc.)\n-    // TODO control visibility by flag Notification.VISIBILITY_PRIVATE\n-    // TODO Group notifications (setGroup, setGroupSummary, setNumber)\n-    // TODO use NotificationCompat.MessagingStyle for latest API\n-    // TODO expandable notification NotificationCompat.MessagingStyle\n-    // TODO media style notification support NotificationCompat.MediaStyle\n-    // TODO custom small/large icons\n-    private void buildNotification(NotificationManagerCompat notificationManager, LocalNotification localNotification, PluginCall call) {\n-        String channelId = DEFAULT_NOTIFICATION_CHANNEL_ID;\n-        if (localNotification.getChannelId() != null) {\n-            channelId = localNotification.getChannelId();\n-        }\n-        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this.context, channelId)\n-            .setContentTitle(localNotification.getTitle())\n-            .setContentText(localNotification.getBody())\n-            .setAutoCancel(localNotification.isAutoCancel())\n-            .setOngoing(localNotification.isOngoing())\n-            .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n-            .setGroupSummary(localNotification.isGroupSummary());\n-\n-        // support multiline text\n-        mBuilder.setStyle(new NotificationCompat.BigTextStyle().bigText(localNotification.getBody()));\n-\n-        String sound = localNotification.getSound(context, getDefaultSound(context));\n-        if (sound != null) {\n-            Uri soundUri = Uri.parse(sound);\n-            // Grant permission to use sound\n-            context.grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-            mBuilder.setSound(soundUri);\n-            mBuilder.setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_LIGHTS);\n-        } else {\n-            mBuilder.setDefaults(Notification.DEFAULT_ALL);\n-        }\n-\n-        String group = localNotification.getGroup();\n-        if (group != null) {\n-            mBuilder.setGroup(group);\n-        }\n-\n-        // make sure scheduled time is shown instead of display time\n-        if (localNotification.isScheduled() && localNotification.getSchedule().getAt() != null) {\n-            mBuilder.setWhen(localNotification.getSchedule().getAt().getTime()).setShowWhen(true);\n-        }\n-\n-        mBuilder.setVisibility(NotificationCompat.VISIBILITY_PRIVATE);\n-        mBuilder.setOnlyAlertOnce(true);\n-\n-        mBuilder.setSmallIcon(localNotification.getSmallIcon(context, getDefaultSmallIcon(context)));\n-\n-        String iconColor = localNotification.getIconColor(config.getString(CONFIG_KEY_PREFIX + \"iconColor\"));\n-        if (iconColor != null) {\n-            try {\n-                mBuilder.setColor(Color.parseColor(iconColor));\n-            } catch (IllegalArgumentException ex) {\n-                if (call != null) {\n-                    call.error(\"Invalid color provided. Must be a hex string (ex: #ff0000\");\n-                }\n-                return;\n-            }\n-        }\n-\n-        createActionIntents(localNotification, mBuilder);\n-        // notificationId is a unique int for each localNotification that you must define\n-        Notification buildNotification = mBuilder.build();\n-        if (localNotification.isScheduled()) {\n-            triggerScheduledNotification(buildNotification, localNotification);\n-        } else {\n-            notificationManager.notify(localNotification.getId(), buildNotification);\n-        }\n-    }\n-\n-    // Create intents for open/dissmis actions\n-    private void createActionIntents(LocalNotification localNotification, NotificationCompat.Builder mBuilder) {\n-        // Open intent\n-        Intent intent = buildIntent(localNotification, DEFAULT_PRESS_ACTION);\n-\n-        PendingIntent pendingIntent = PendingIntent.getActivity(\n-            context,\n-            localNotification.getId(),\n-            intent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-        mBuilder.setContentIntent(pendingIntent);\n-\n-        // Build action types\n-        String actionTypeId = localNotification.getActionTypeId();\n-        if (actionTypeId != null) {\n-            NotificationAction[] actionGroup = storage.getActionGroup(actionTypeId);\n-            for (NotificationAction notificationAction : actionGroup) {\n-                // TODO Add custom icons to actions\n-                Intent actionIntent = buildIntent(localNotification, notificationAction.getId());\n-                PendingIntent actionPendingIntent = PendingIntent.getActivity(\n-                    context,\n-                    localNotification.getId() + notificationAction.getId().hashCode(),\n-                    actionIntent,\n-                    PendingIntent.FLAG_CANCEL_CURRENT\n-                );\n-                NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(\n-                    R.drawable.ic_transparent,\n-                    notificationAction.getTitle(),\n-                    actionPendingIntent\n-                );\n-                if (notificationAction.isInput()) {\n-                    RemoteInput remoteInput = new RemoteInput.Builder(REMOTE_INPUT_KEY).setLabel(notificationAction.getTitle()).build();\n-                    actionBuilder.addRemoteInput(remoteInput);\n-                }\n-                mBuilder.addAction(actionBuilder.build());\n-            }\n-        }\n-\n-        // Dismiss intent\n-        Intent dissmissIntent = new Intent(context, NotificationDismissReceiver.class);\n-        dissmissIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        dissmissIntent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        dissmissIntent.putExtra(ACTION_INTENT_KEY, \"dismiss\");\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        dissmissIntent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        PendingIntent deleteIntent = PendingIntent.getBroadcast(context, localNotification.getId(), dissmissIntent, 0);\n-        mBuilder.setDeleteIntent(deleteIntent);\n-    }\n-\n-    @NonNull\n-    private Intent buildIntent(LocalNotification localNotification, String action) {\n-        Intent intent;\n-        if (activity != null) {\n-            intent = new Intent(context, activity.getClass());\n-        } else {\n-            String packageName = context.getPackageName();\n-            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);\n-        }\n-        intent.setAction(Intent.ACTION_MAIN);\n-        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n-        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-        intent.putExtra(NOTIFICATION_INTENT_KEY, localNotification.getId());\n-        intent.putExtra(ACTION_INTENT_KEY, action);\n-        intent.putExtra(NOTIFICATION_OBJ_INTENT_KEY, localNotification.getSource());\n-        LocalNotificationSchedule schedule = localNotification.getSchedule();\n-        intent.putExtra(NOTIFICATION_IS_REMOVABLE_KEY, schedule == null || schedule.isRemovable());\n-        return intent;\n-    }\n-\n-    /**\n-     * Build a notification trigger, such as triggering each N seconds, or\n-     * on a certain date \"shape\" (such as every first of the month)\n-     */\n-    // TODO support different AlarmManager.RTC modes depending on priority\n-    private void triggerScheduledNotification(Notification notification, LocalNotification request) {\n-        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-        LocalNotificationSchedule schedule = request.getSchedule();\n-        Intent notificationIntent = new Intent(context, TimedNotificationPublisher.class);\n-        notificationIntent.putExtra(NOTIFICATION_INTENT_KEY, request.getId());\n-        notificationIntent.putExtra(TimedNotificationPublisher.NOTIFICATION_KEY, notification);\n-        PendingIntent pendingIntent = PendingIntent.getBroadcast(\n-            context,\n-            request.getId(),\n-            notificationIntent,\n-            PendingIntent.FLAG_CANCEL_CURRENT\n-        );\n-\n-        // Schedule at specific time (with repeating support)\n-        Date at = schedule.getAt();\n-        if (at != null) {\n-            if (at.getTime() < new Date().getTime()) {\n-                Logger.error(Logger.tags(\"LN\"), \"Scheduled time must be *after* current time\", null);\n-                return;\n-            }\n-            if (schedule.isRepeating()) {\n-                long interval = at.getTime() - new Date().getTime();\n-                alarmManager.setRepeating(AlarmManager.RTC, at.getTime(), interval, pendingIntent);\n-            } else {\n-                alarmManager.setExact(AlarmManager.RTC, at.getTime(), pendingIntent);\n-            }\n-            return;\n-        }\n-\n-        // Schedule at specific intervals\n-        String every = schedule.getEvery();\n-        if (every != null) {\n-            Long everyInterval = schedule.getEveryInterval();\n-            if (everyInterval != null) {\n-                long startTime = new Date().getTime() + everyInterval;\n-                alarmManager.setRepeating(AlarmManager.RTC, startTime, everyInterval, pendingIntent);\n-            }\n-            return;\n-        }\n-\n-        // Cron like scheduler\n-        DateMatch on = schedule.getOn();\n-        if (on != null) {\n-            long trigger = on.nextTrigger(new Date());\n-            notificationIntent.putExtra(TimedNotificationPublisher.CRON_KEY, on.toMatchString());\n-            pendingIntent = PendingIntent.getBroadcast(context, request.getId(), notificationIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n-            alarmManager.setExact(AlarmManager.RTC, trigger, pendingIntent);\n-            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n-            Logger.debug(Logger.tags(\"LN\"), \"notification \" + request.getId() + \" will next fire at \" + sdf.format(new Date(trigger)));\n-        }\n-    }\n-\n-    public void cancel(PluginCall call) {\n-        List<Integer> notificationsToCancel = LocalNotification.getLocalNotificationPendingList(call);\n-        if (notificationsToCancel != null) {\n-            for (Integer id : notificationsToCancel) {\n-                dismissVisibleNotification(id);\n-                cancelTimerForNotification(id);\n-                storage.deleteNotification(Integer.toString(id));\n-            }\n-        }\n-        call.success();\n-    }\n-\n-    private void cancelTimerForNotification(Integer notificationId) {\n-        Intent intent = new Intent(context, TimedNotificationPublisher.class);\n-        PendingIntent pi = PendingIntent.getBroadcast(context, notificationId, intent, 0);\n-        if (pi != null) {\n-            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n-            alarmManager.cancel(pi);\n-        }\n-    }\n-\n-    private void dismissVisibleNotification(int notificationId) {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this.context);\n-        notificationManager.cancel(notificationId);\n-    }\n-\n-    public boolean areNotificationsEnabled() {\n-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);\n-        return notificationManager.areNotificationsEnabled();\n-    }\n-\n-    public Uri getDefaultSoundUrl(Context context) {\n-        int soundId = this.getDefaultSound(context);\n-        if (soundId != AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + \"://\" + context.getPackageName() + \"/\" + soundId);\n-        }\n-        return null;\n-    }\n-\n-    private int getDefaultSound(Context context) {\n-        if (defaultSoundID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSoundID;\n-\n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String soundConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"sound\");\n-        soundConfigResourceName = AssetUtil.getResourceBaseName(soundConfigResourceName);\n-\n-        if (soundConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, soundConfigResourceName, \"raw\");\n-        }\n-\n-        defaultSoundID = resId;\n-        return resId;\n-    }\n-\n-    private int getDefaultSmallIcon(Context context) {\n-        if (defaultSmallIconID != AssetUtil.RESOURCE_ID_ZERO_VALUE) return defaultSmallIconID;\n-\n-        int resId = AssetUtil.RESOURCE_ID_ZERO_VALUE;\n-        String smallIconConfigResourceName = config.getString(CONFIG_KEY_PREFIX + \"smallIcon\");\n-        smallIconConfigResourceName = AssetUtil.getResourceBaseName(smallIconConfigResourceName);\n-\n-        if (smallIconConfigResourceName != null) {\n-            resId = AssetUtil.getResourceID(context, smallIconConfigResourceName, \"drawable\");\n-        }\n-\n-        if (resId == AssetUtil.RESOURCE_ID_ZERO_VALUE) {\n-            resId = android.R.drawable.ic_dialog_info;\n-        }\n-\n-        defaultSmallIconID = resId;\n-        return resId;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "96418553c00763221e5a1635720ecd91b5e42005", "url": "https://github.com/ionic-team/capacitor/commit/96418553c00763221e5a1635720ecd91b5e42005", "message": "PR feedback", "committedDate": "2020-03-17T17:25:58Z", "type": "commit"}]}