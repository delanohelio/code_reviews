{"pr_number": 8230, "pr_title": "Fix Class.getMethod() and Class.getMethods() missing cases", "pr_author": "theresa-m", "pr_createdAt": "2020-01-07T21:54:00Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8230", "merge_commit": "7e2412c58171f429453e117e0c059cff27b2222e", "timeline": [{"oid": "4901aa8880abf63122a4de12e76d48ab782cca88", "url": "https://github.com/eclipse-openj9/openj9/commit/4901aa8880abf63122a4de12e76d48ab782cca88", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-08T16:27:52Z", "type": "forcePushed"}, {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "url": "https://github.com/eclipse-openj9/openj9/commit/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-09T14:43:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366467531", "body": "Is the check `this != Object.class` necessary?", "bodyText": "Is the check this != Object.class necessary?", "bodyHTML": "<p dir=\"auto\">Is the check <code>this != Object.class</code> necessary?</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:17:03Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ4OTk5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367489992", "bodyText": "I believe this is referring to the javadoc line:\n\nIf C is a class other than Object, then include the result of invoking this algorithm recursively on the superclass of C.\n\nThough in practice I think it may not be needed. @ChengJin01 do you have any insights to this from your testing?", "author": "theresa-m", "createdAt": "2020-01-16T15:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNTI3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367505278", "bodyText": "It looks like this check is also done https://github.com/eclipse/openj9/blob/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625/jcl/src/java.base/share/classes/java/lang/Class.java#L1594 so its not necessary to do it twice.", "author": "theresa-m", "createdAt": "2020-01-16T16:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxMDE2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367510168", "bodyText": "@theresa-m, Object.class should be excluded in the search of superclass in any case. Please modify accordingly if any duplicate and verify the update with all tests.", "author": "ChengJin01", "createdAt": "2020-01-16T16:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366468438", "body": "It appears this method is going to repeat `getMethodImpl(name, parameterTypes, strSig)` regardless of other conditions which is not desirable.", "bodyText": "It appears this method is going to repeat getMethodImpl(name, parameterTypes, strSig) regardless of other conditions which is not desirable.", "bodyHTML": "<p dir=\"auto\">It appears this method is going to repeat <code>getMethodImpl(name, parameterTypes, strSig)</code> regardless of other conditions which is not desirable.</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:19:03Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5OTI4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367499286", "bodyText": "Yes good catch. I can rearrange that to prevent duplicate calls.", "author": "theresa-m", "createdAt": "2020-01-16T15:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTEyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469122", "body": "This method might return `null` while initial `result` isn't, this doesn't seem right.", "bodyText": "This method might return null while initial result isn't, this doesn't seem right.", "bodyHTML": "<p dir=\"auto\">This method might return <code>null</code> while initial <code>result</code> isn't, this doesn't seem right.</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:20:29Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469858", "body": "Any particular reason to create `new HashSet()` without actual usage after the following method call?", "bodyText": "Any particular reason to create new HashSet() without actual usage after the following method call?", "bodyHTML": "<p dir=\"auto\">Any particular reason to create <code>new HashSet()</code> without actual usage after the following method call?</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:22:06Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5NzU5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367497595", "bodyText": "If an interface inherits the same superinterface more than once somewhere in its hierarchy the HashSet will save some native calls.\nexample:\ninterface Y extends X {void m() {}}\ninterface Z extends X, Y {}\n\nX will only be searched once. this example is trivial but if X had many superinterfaces it would show an impact.", "author": "theresa-m", "createdAt": "2020-01-16T15:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MDExOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366470119", "body": "Similar comment about this `interfaceSet` as well.", "bodyText": "Similar comment about this interfaceSet as well.", "bodyHTML": "<p dir=\"auto\">Similar comment about this <code>interfaceSet</code> as well.</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:22:35Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"oid": "7eedaee3f27228e8837b6490e809b2895035c718", "url": "https://github.com/eclipse-openj9/openj9/commit/7eedaee3f27228e8837b6490e809b2895035c718", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-29T14:57:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374170918", "body": "`getMethods()` is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.\r\ncan we modify `getMethodImpl(name, parameterTypes, strSig)` to introduce a `startingPoint`, particularly for the case that the method found is declared by an interface class?", "bodyText": "getMethods() is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.\ncan we modify getMethodImpl(name, parameterTypes, strSig) to introduce a startingPoint, particularly for the case that the method found is declared by an interface class?", "bodyHTML": "<p dir=\"auto\"><code>getMethods()</code> is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.<br>\ncan we modify <code>getMethodImpl(name, parameterTypes, strSig)</code> to introduce a <code>startingPoint</code>, particularly for the case that the method found is declared by an interface class?</p>", "author": "JasonFengJ9", "createdAt": "2020-02-03T15:34:11Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,26 +1551,127 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n+\t}\n+\treturn cacheMethod(bestCandidate);\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, strSig, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, strSig, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tMethod[] methodCandidates = currentClass.getMethods();", "originalCommit": "7eedaee3f27228e8837b6490e809b2895035c718", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc1ODY1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374758658", "bodyText": "I agree that it is overkill.\nI think it would still be useful to take advantage of the getMethods helper functions for the sake of not duplicating code, and combining the logic was helpful in that I was able to improve correctness of getMethod and getMethods at the same time. I can limit the superclasses searches for this particular case.", "author": "theresa-m", "createdAt": "2020-02-04T15:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3NTgxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374775814", "bodyText": "Not against the idea. getMethods() just is a heavyweight api, can getMethodImpl & getDeclaredMethodImpl be used for the superclasses from the top to the bottom instead?\n\nimprove correctness of getMethod and getMethods at the same time\n\ngetMethod() calls getMethodHelper() which is being fixed by this PR.\ndoes getMethods() miss any method?", "author": "JasonFengJ9", "createdAt": "2020-02-04T16:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzE3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374787174", "bodyText": "Not against the idea. getMethods() just is a heavyweight api, can getMethodImpl & getDeclaredMethodImpl be used for the superclasses from the top to the bottom instead?\n\nI think your idea of adding a startingPoint type variable to getMethodImpl would be a good solution as well.\nedit: Although I'm not sure it would be a simple native change since each call to getMethodImpl uses the entire interface list to determine which interface is the most valid match.\n\n\nimprove correctness of getMethod and getMethods at the same time\n\ngetMethod() calls getMethodHelper() which is being fixed by this PR.\ndoes getMethods() miss any method?\n\nThere is one case for getMethods being fixed here as well that was uncovered by one of the tests from #7623. Maybe that will explain more how that line of thinking came about too :) I will make that more obvious in the issue description.", "author": "theresa-m", "createdAt": "2020-02-04T16:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzNzM4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374937388", "bodyText": "@JasonFengJ9  I made some updates to this approach to tighten things up. getMostSpecificMethodFromAllInterfacesOfCurrentClass will now call getMethodSet directly, and then only search for interfaces and not classes. Let me know what you think.", "author": "theresa-m", "createdAt": "2020-02-04T21:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1580,98 +1580,83 @@ Method getMethodHelper(\n  * for the most specific method declared in one of these interfaces.\n  *\n  * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param interfaceSet the set of interfaces to be collected\n  * @param name the specified method's name\n  * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ * @return the most specific method selected from all interfaces;\n  *         otherwise, return the method of the first interface from the top superclass\n  *         if the return types of all specified methods are identical.\n  */\n-private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, String strSig, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfaces(Class<?> currentClass, HashSet<Class<?>> interfaceSet, String name, String strSig, Class<?>... parameterTypes) {\n \tMethod candidateMethod = null;\n+\n \tif (currentClass != Object.class) {\n-\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, strSig, parameterTypes);\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfaces(currentClass.getSuperclass(), \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterfaceSet, name, strSig, parameterTypes);\n \t\t\n-\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, strSig, parameterTypes);\n+\t\t/* getMethodImpl returns the specified method declared by an interface given that\n+\t\t * the current class has not yet implemented this method.\n+\t\t */\n+\t\tMethod resultFromInterface = currentClass.getMethodImpl(name, parameterTypes, strSig);\n+\t\tif (resultFromInterface != null) {\n+\t\t\tClass<?>[] interfacesFromCurrentClass = currentClass.getInterfaces();\n+\t\t\tfor (Class<?> nextInterface : interfacesFromCurrentClass) {\t\t\t\t\n+\t\t\t\t/* No need to search for the duplicate interface */\n+\t\t\t\tif (!interfaceSet.contains(nextInterface)) {\n+\t\t\t\t\tinterfaceSet.add(nextInterface);\n+\t\t\t\t\tMethod resultMethod = getMoreSpecificMethodFromInterface(nextInterface, name, strSig, parameterTypes);\n+\t\t\t\t\t\n+\t\t\t\t\tif (resultMethod != null) {\n+\t\t\t\t\t\tif (candidateMethod == null) {\n+\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n+\t\t\t\t\t\t\tClass<?> CandidateRetType = candidateMethod.getReturnType();\n+\t\t\t\t\t\t\tif ((CandidateRetType != resultRetType) && CandidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n+\t\n \treturn candidateMethod;\n }\n \n /**\n- * Helper method searches all interfaces implemented by the current class or interface \n- * for the most specific method declared in one of these interfaces.\n- *\n- * @param currentClass the class or interface to be searched\n- * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * Helper method obtains the more specific method declared in the interface\n+ * \n+ * @param currentInterface the interface that declares the specified method\n  * @param name the specified method's name\n  * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n- *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ * @return the more specific method declared in this interface\n  */\n-private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n-\tMethod bestMethod = potentialCandidate;\n-\tMethod[] methodCandidates = currentClass.getMethods();\n-\n-\tfor (int index = 0; index < methodCandidates.length; index++) {\n-\t\tMethod candidateMethod = methodCandidates[index];\n-\n-\t\tif (candidateMethod == potentialCandidate) {\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\t/* match name and parameters to user specification */\n-\t\tif (!candidateMethod.getDeclaringClass().isInterface() \n-\t\t\t|| !candidateMethod.getName().equals(name) \n-\t\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n-\t\t) {\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tif (null == bestMethod) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tClass<?> bestRetType = bestMethod.getReturnType();\n-\t\tClass<?> candidateRetType = candidateMethod.getReturnType();\n-\n-\t\tif (bestRetType == candidateRetType) {\n-\t\t\tint bestModifiers = bestMethod.getModifiers();\n-\t\t\tint candidateModifiers = candidateMethod.getModifiers();\n-\t\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n-\t\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n-\t\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n-\t\t\t priority over superinterface */\n-\t\t\t if ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n-\t\t\t\t || methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n-\t\t\t\t bestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n-\t\t\t) {\n-\t\t\t\tbestMethod = candidateMethod;\n+private Method getMoreSpecificMethodFromInterface(Class<?> currentInterface, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod resultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\tMethod bestCandidate = resultMethod;\n+\t\n+\tif (resultMethod != null) {\n+\t\twhile (true) {\n+\t\t\tresultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, resultMethod);\n+\t\t\tif (resultMethod == null) {\n+\t\t\t\tbreak;\n \t\t\t}\n-\t\t} else {\n-\t\t\t/* resulting method should have the most specific return type */\n-\t\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n-\t\t\t\tbestMethod = candidateMethod;\n+\t\t\tif ((resultMethod.getModifiers() & Modifier.PUBLIC) != 0) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> bestCandidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n+\t\t\t\tif ((bestCandidateRetType != resultRetType) && bestCandidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = resultMethod;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn bestMethod;\n-}\n-\n-private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n-\tif (paramList1.length != paramList2.length) return false;\n-\n-\tfor (int index = 0; index < paramList1.length; index++) {\n-\t\tif (!paramList1[index].equals(paramList2[index])) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\treturn true;\n+\treturn bestCandidate;\n }\n \n /**\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1580,83 +1584,108 @@ Method getMethodHelper(\n  * for the most specific method declared in one of these interfaces.\n  *\n  * @param currentClass the class to be searched, including the current class and all superclasses\n- * @param interfaceSet the set of interfaces to be collected\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n  *         otherwise, return the method of the first interface from the top superclass\n  *         if the return types of all specified methods are identical.\n  */\n-private Method getMostSpecificMethodFromAllInterfaces(Class<?> currentClass, HashSet<Class<?>> interfaceSet, String name, String strSig, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, Class<?>... parameterTypes) {\n \tMethod candidateMethod = null;\n-\n \tif (currentClass != Object.class) {\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfaces(currentClass.getSuperclass(), \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterfaceSet, name, strSig, parameterTypes);\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, parameterTypes);\n \t\t\n-\t\t/* getMethodImpl returns the specified method declared by an interface given that\n-\t\t * the current class has not yet implemented this method.\n-\t\t */\n-\t\tMethod resultFromInterface = currentClass.getMethodImpl(name, parameterTypes, strSig);\n-\t\tif (resultFromInterface != null) {\n-\t\t\tClass<?>[] interfacesFromCurrentClass = currentClass.getInterfaces();\n-\t\t\tfor (Class<?> nextInterface : interfacesFromCurrentClass) {\t\t\t\t\n-\t\t\t\t/* No need to search for the duplicate interface */\n-\t\t\t\tif (!interfaceSet.contains(nextInterface)) {\n-\t\t\t\t\tinterfaceSet.add(nextInterface);\n-\t\t\t\t\tMethod resultMethod = getMoreSpecificMethodFromInterface(nextInterface, name, strSig, parameterTypes);\n-\t\t\t\t\t\n-\t\t\t\t\tif (resultMethod != null) {\n-\t\t\t\t\t\tif (candidateMethod == null) {\n-\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n-\t\t\t\t\t\t\tClass<?> CandidateRetType = candidateMethod.getReturnType();\n-\t\t\t\t\t\t\tif ((CandidateRetType != resultRetType) && CandidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, parameterTypes);\n \t}\n-\t\n \treturn candidateMethod;\n }\n \n /**\n- * Helper method obtains the more specific method declared in the interface\n- * \n- * @param currentInterface the interface that declares the specified method\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the more specific method declared in this interface\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n  */\n-private Method getMoreSpecificMethodFromInterface(Class<?> currentInterface, String name, String strSig, Class<?>... parameterTypes) {\n-\tMethod resultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\tMethod bestCandidate = resultMethod;\n-\t\n-\tif (resultMethod != null) {\n-\t\twhile (true) {\n-\t\t\tresultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, resultMethod);\n-\t\t\tif (resultMethod == null) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ((resultMethod.getModifiers() & Modifier.PUBLIC) != 0) {\n-\t\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\t\tClass<?> bestCandidateRetType = bestCandidate.getReturnType();\n-\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n-\t\t\t\tif ((bestCandidateRetType != resultRetType) && bestCandidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\tbestCandidate = resultMethod;\n-\t\t\t\t}\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n+\n+\tfor (MethodInfo mi : methodCandidates.values()) {\n+\t\tif (null == mi.jlrMethods) {\n+\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n+\t\t} else {\n+\t\t\tfor (Method m: mi.jlrMethods) {\n+\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn bestCandidate;\n+\treturn bestMethod;\n+\n+}\n+\n+private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n+\tif (candidateMethod == bestMethod) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\t/* match name and parameters to user specification */\n+\tif (!candidateMethod.getDeclaringClass().isInterface() \n+\t\t|| !candidateMethod.getName().equals(name) \n+\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\t) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\tif (null == bestMethod) {\n+\t\tbestMethod = candidateMethod;\n+\t\treturn bestMethod;\n+\t}\n+\n+\tClass<?> bestRetType = bestMethod.getReturnType();\n+\tClass<?> candidateRetType = candidateMethod.getReturnType();\n+\n+\tif (bestRetType == candidateRetType) {\n+\t\tint bestModifiers = bestMethod.getModifiers();\n+\t\tint candidateModifiers = candidateMethod.getModifiers();\n+\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n+\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n+\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n+\t\t\tpriority over superinterface */\n+\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n+\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n+\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n+\t\t) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t} else {\n+\t\t/* resulting method should have the most specific return type */\n+\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t}\n+\n+\treturn bestMethod;\n+}\n+\n+private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n+\tif (paramList1.length != paramList2.length) return false;\n+\n+\tfor (int index = 0; index < paramList1.length; index++) {\n+\t\tif (!paramList1[index].equals(paramList2[index])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\treturn true;\n }\n \n /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "7e2412c58171f429453e117e0c059cff27b2222e", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..b13dfac0d 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1603,59 +1610,75 @@ private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Cl\n  * Helper method searches all interfaces implemented by the current class or interface \n  * for the most specific method declared in one of these interfaces.\n  *\n- * @param currentClass the class or interface to be searched\n+ * @param infoCache\n  * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n  * @return the most specific method selected from all interfaces;\n  *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n  */\n-private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n+{\n \tMethod bestMethod = potentialCandidate;\n-\tMethod[] methodCandidates = currentClass.getMethods();\n-\n-\tfor (int index = 0; index < methodCandidates.length; index++) {\n-\t\tMethod candidateMethod = methodCandidates[index];\n+\t/* if infoCache is passed in, reuse from superclass */\n+\tif (null == infoCache) {\n+\t\tinfoCache = new HashMap<>(16);\n+\t}\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n \n-\t\tif (candidateMethod == potentialCandidate) {\n-\t\t\tcontinue;\n+\tfor (MethodInfo mi : methodCandidates.values()) {\n+\t\tif (null == mi.jlrMethods) {\n+\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n+\t\t} else {\n+\t\t\tfor (Method m: mi.jlrMethods) {\n+\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n+\t\t\t}\n \t\t}\n+\t}\n+\n+\treturn bestMethod;\n+\n+}\n+\n+private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n+\tif (candidateMethod == bestMethod) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\t/* match name and parameters to user specification */\n+\tif (!candidateMethod.getDeclaringClass().isInterface() \n+\t\t|| !candidateMethod.getName().equals(name) \n+\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\t) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\tif (null == bestMethod) {\n+\t\tbestMethod = candidateMethod;\n+\t\treturn bestMethod;\n+\t}\n \n-\t\t/* match name and parameters to user specification */\n-\t\tif (!candidateMethod.getDeclaringClass().isInterface() \n-\t\t\t|| !candidateMethod.getName().equals(name) \n-\t\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\tClass<?> bestRetType = bestMethod.getReturnType();\n+\tClass<?> candidateRetType = candidateMethod.getReturnType();\n+\n+\tif (bestRetType == candidateRetType) {\n+\t\tint bestModifiers = bestMethod.getModifiers();\n+\t\tint candidateModifiers = candidateMethod.getModifiers();\n+\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n+\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n+\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n+\t\t\tpriority over superinterface */\n+\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n+\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n+\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n \t\t) {\n-\t\t\tcontinue;\n+\t\t\tbestMethod = candidateMethod;\n \t\t}\n-\n-\t\tif (null == bestMethod) {\n+\t} else {\n+\t\t/* resulting method should have the most specific return type */\n+\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n \t\t\tbestMethod = candidateMethod;\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tClass<?> bestRetType = bestMethod.getReturnType();\n-\t\tClass<?> candidateRetType = candidateMethod.getReturnType();\n-\n-\t\tif (bestRetType == candidateRetType) {\n-\t\t\tint bestModifiers = bestMethod.getModifiers();\n-\t\t\tint candidateModifiers = candidateMethod.getModifiers();\n-\t\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n-\t\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n-\t\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n-\t\t\t priority over superinterface */\n-\t\t\t if ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n-\t\t\t\t || methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n-\t\t\t\t bestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n-\t\t\t) {\n-\t\t\t\tbestMethod = candidateMethod;\n-\t\t\t}\n-\t\t} else {\n-\t\t\t/* resulting method should have the most specific return type */\n-\t\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n-\t\t\t\tbestMethod = candidateMethod;\n-\t\t\t}\n \t\t}\n \t}\n \n", "next_change": {"commit": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex b13dfac0d..7f717fd30 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1556,147 +1534,28 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tif (!candidateFromInterface) {\n-\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\t\twhile (true) {\n-\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\t\tif (result == null) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\t\tif ((methodList != null) && publicMethod) {\n-\t\t\t\tmethodList.add(result);\n-\t\t\t}\n-\t\t\tif (forDeclaredMethod || publicMethod) {\n-\t\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n-\t\t\t\tClass<?> resultRetType = result.getReturnType();\n-\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\tbestCandidate = result;\n-\t\t\t\t}\n+\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\twhile (true) {\n+\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\tif (result == null) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\tif ((methodList != null) && publicMethod) {\n+\t\t\tmethodList.add(result);\n+\t\t}\n+\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\tbestCandidate = result;\n \t\t\t}\n \t\t}\n \t}\n \treturn cacheMethod(bestCandidate);\n }\n \n-/**\n- * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n- * for the most specific method declared in one of these interfaces.\n- *\n- * @param infoCache\n- * @param name the specified method's name\n- * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces from each superclass of the current class;\n- *         otherwise, return the method of the first interface from the top superclass\n- *         if the return types of all specified methods are identical.\n- */\n-private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n-\tString name, Class<?>... parameterTypes) \n-{\n-\tMethod candidateMethod = null;\n-\tif (this != Object.class) {\n-\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n-\t\tClass superclz = getSuperclass();\n-\t\tcandidateMethod = superclz.getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n-\t\t\n-\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(infoCache, candidateMethod, name, parameterTypes);\n-\t}\n-\treturn candidateMethod;\n-}\n-\n-/**\n- * Helper method searches all interfaces implemented by the current class or interface \n- * for the most specific method declared in one of these interfaces.\n- *\n- * @param infoCache\n- * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n- * @param name the specified method's name\n- * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n- *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n- */\n-private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n-\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n-{\n-\tMethod bestMethod = potentialCandidate;\n-\t/* if infoCache is passed in, reuse from superclass */\n-\tif (null == infoCache) {\n-\t\tinfoCache = new HashMap<>(16);\n-\t}\n-\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n-\n-\tfor (MethodInfo mi : methodCandidates.values()) {\n-\t\tif (null == mi.jlrMethods) {\n-\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n-\t\t} else {\n-\t\t\tfor (Method m: mi.jlrMethods) {\n-\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn bestMethod;\n-\n-}\n-\n-private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n-\tif (candidateMethod == bestMethod) {\n-\t\treturn bestMethod;\n-\t}\n-\n-\t/* match name and parameters to user specification */\n-\tif (!candidateMethod.getDeclaringClass().isInterface() \n-\t\t|| !candidateMethod.getName().equals(name) \n-\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n-\t) {\n-\t\treturn bestMethod;\n-\t}\n-\n-\tif (null == bestMethod) {\n-\t\tbestMethod = candidateMethod;\n-\t\treturn bestMethod;\n-\t}\n-\n-\tClass<?> bestRetType = bestMethod.getReturnType();\n-\tClass<?> candidateRetType = candidateMethod.getReturnType();\n-\n-\tif (bestRetType == candidateRetType) {\n-\t\tint bestModifiers = bestMethod.getModifiers();\n-\t\tint candidateModifiers = candidateMethod.getModifiers();\n-\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n-\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n-\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n-\t\t\tpriority over superinterface */\n-\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n-\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n-\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n-\t\t) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t}\n-\t} else {\n-\t\t/* resulting method should have the most specific return type */\n-\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t}\n-\t}\n-\n-\treturn bestMethod;\n-}\n-\n-private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n-\tif (paramList1.length != paramList2.length) return false;\n-\n-\tfor (int index = 0; index < paramList1.length; index++) {\n-\t\tif (!paramList1[index].equals(paramList2[index])) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\treturn true;\n-}\n-\n /**\n  * Answers a Method object which represents the first method found matching\n  * the arguments.\n", "next_change": {"commit": "79106399dc09660799e7accfe1bd529b712e254d", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 7f717fd30..89448dd51 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1534,28 +1556,147 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n-\t\t}\n-\t\tif (forDeclaredMethod || publicMethod) {\n-\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n-\t\t\tClass<?> resultRetType = result.getReturnType();\n-\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\tbestCandidate = result;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \treturn cacheMethod(bestCandidate);\n }\n \n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param infoCache\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n+\tString name, Class<?>... parameterTypes) \n+{\n+\tMethod candidateMethod = null;\n+\tif (this != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tClass superclz = getSuperclass();\n+\t\tcandidateMethod = superclz.getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(infoCache, candidateMethod, name, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param infoCache\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n+{\n+\tMethod bestMethod = potentialCandidate;\n+\t/* if infoCache is passed in, reuse from superclass */\n+\tif (null == infoCache) {\n+\t\tinfoCache = new HashMap<>(16);\n+\t}\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n+\n+\tfor (MethodInfo mi : methodCandidates.values()) {\n+\t\tif (null == mi.jlrMethods) {\n+\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n+\t\t} else {\n+\t\t\tfor (Method m: mi.jlrMethods) {\n+\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn bestMethod;\n+\n+}\n+\n+private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n+\tif (candidateMethod == bestMethod) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\t/* match name and parameters to user specification */\n+\tif (!candidateMethod.getDeclaringClass().isInterface() \n+\t\t|| !candidateMethod.getName().equals(name) \n+\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\t) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\tif (null == bestMethod) {\n+\t\tbestMethod = candidateMethod;\n+\t\treturn bestMethod;\n+\t}\n+\n+\tClass<?> bestRetType = bestMethod.getReturnType();\n+\tClass<?> candidateRetType = candidateMethod.getReturnType();\n+\n+\tif (bestRetType == candidateRetType) {\n+\t\tint bestModifiers = bestMethod.getModifiers();\n+\t\tint candidateModifiers = candidateMethod.getModifiers();\n+\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n+\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n+\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n+\t\t\tpriority over superinterface */\n+\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n+\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n+\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n+\t\t) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t} else {\n+\t\t/* resulting method should have the most specific return type */\n+\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t}\n+\n+\treturn bestMethod;\n+}\n+\n+private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n+\tif (paramList1.length != paramList2.length) return false;\n+\n+\tfor (int index = 0; index < paramList1.length; index++) {\n+\t\tif (!paramList1[index].equals(paramList2[index])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\treturn true;\n+}\n+\n /**\n  * Answers a Method object which represents the first method found matching\n  * the arguments.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"oid": "0715f9f8f7a3b2920884c427409dff8877a64373", "url": "https://github.com/eclipse-openj9/openj9/commit/0715f9f8f7a3b2920884c427409dff8877a64373", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-04T21:29:12Z", "type": "forcePushed"}, {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "url": "https://github.com/eclipse-openj9/openj9/commit/bbc2ff27a563388dd938aa3e7391d367fed07c36", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-12T11:39:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378336600", "body": "is there a chance that `infoCache` could be confused by `localInterfacesOnly` since the key is always `this` class? \r\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.", "bodyText": "is there a chance that infoCache could be confused by localInterfacesOnly since the key is always this class?\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.", "bodyHTML": "<p dir=\"auto\">is there a chance that <code>infoCache</code> could be confused by <code>localInterfacesOnly</code> since the key is always <code>this</code> class?<br>\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.</p>", "author": "JasonFengJ9", "createdAt": "2020-02-12T15:46:28Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,28 +1552,146 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n-\t\t}\n-\t\tif (forDeclaredMethod || publicMethod) {\n-\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n-\t\t\tClass<?> resultRetType = result.getReturnType();\n-\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\tbestCandidate = result;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \treturn cacheMethod(bestCandidate);\n }\n \n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n+\tString name, Class<?>... parameterTypes) \n+{\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), infoCache, name, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, infoCache, candidateMethod, name, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n+{\n+\tMethod bestMethod = potentialCandidate;\n+\t/* if infoCache is passed in, reuse from superclass */\n+\tif (null == infoCache) {\n+\t\tinfoCache = new HashMap<>(16);\n+\t}\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);", "originalCommit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyMDUzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378820535", "bodyText": "I made some modifications so it is more clear which this is being used by getMethodSet.", "author": "theresa-m", "createdAt": "2020-02-13T12:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwNzQ0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378907449", "bodyText": "infoCache seems not for late use after current getMethodHelper() call hence won't help much performance.\nIn that case, getInterfaces() is a better choice.", "author": "JasonFengJ9", "createdAt": "2020-02-13T14:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3ODM4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r476478382", "bodyText": "@theresa-m is there a PR update since last comment?", "author": "JasonFengJ9", "createdAt": "2020-08-25T14:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NDY4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r477284687", "bodyText": "In my opinion getMethodSet is okay. getInterfaces could be used but getMethodSet is already getting interfaces recursively calling getInterfaces. From a maintainability standpoint I think it will be advantageous to maintain one spot for the override logic in update: https://github.com/eclipse/openj9/blob/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9/jcl/src/java.base/share/classes/java/lang/Class.java#L3890", "author": "theresa-m", "createdAt": "2020-08-26T13:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5Mjk2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r477292966", "bodyText": "An alternative solution as discussed offline would be to move more of this logic into native code however this would require quite a bit of work.", "author": "theresa-m", "createdAt": "2020-08-26T13:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "7e2412c58171f429453e117e0c059cff27b2222e", "message": "Merge commit", "committedDate": null}, {"oid": "291051ce1f57671b5c10b53a0842f561bd81cc4b", "committedDate": "2020-09-09 17:12:42 -0400", "message": "Update javadoc of Class.getNestMembers()"}, {"oid": "79106399dc09660799e7accfe1bd529b712e254d", "committedDate": "2020-09-10 09:13:10 -0400", "message": "Merge pull request #10554 from hangshao0/JEP371"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "committedDate": "2020-10-13 16:50:15 -0400", "message": "Move MethodType static helpers to new helper Class"}, {"oid": "473488f7968bbca5d3d5232a9dd46aae65c2763c", "committedDate": "2020-10-21 12:32:52 -0400", "message": "Ignore circular InnerClass entries in getCanonicalName()"}, {"oid": "46759b866caac72669ca9fb6964d4238f079fdca", "committedDate": "2020-10-26 22:22:29 +0100", "message": "Cache Class#getSimpleName and Class#getCanonicalName"}, {"oid": "4021d2acf4598c56ad1e97917f676cf536ead0d7", "committedDate": "2020-10-28 11:30:42 -0400", "message": "Use package-private fields to avoid accessor functions"}, {"oid": "20e18286354d5e46fcc436f4de4e2c5f73a0457d", "committedDate": "2020-10-28 19:15:01 -0400", "message": "Revert \"Use package-private fields to avoid accessor functions\""}, {"oid": "e2740171b61aae7fd1e5ba02838e788797412cd7", "committedDate": "2020-10-28 19:15:38 -0400", "message": "Revert \"Cache Class#getSimpleName and Class#getCanonicalName\""}, {"oid": "f6e0dd6d203e26f054188360bdee1e85ca2fc93f", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java15 preprocessor flag"}, {"oid": "d4e18712765a66486d896a56cae11a4f6cddf61e", "committedDate": "2020-11-24 13:03:17 -0500", "message": "Remove Java14 preprocessor flag"}, {"oid": "e02b42e8d36d9de3e54ba4af59016e5e333a4495", "committedDate": "2020-11-24 13:03:18 -0500", "message": "Remove Java12 preprocessor flag"}, {"oid": "6baf1abf1cb907cb5a9b7f7d04e797138e07931f", "committedDate": "2020-11-24 13:34:30 -0500", "message": "Remove Java11 preprocessor flag"}, {"oid": "8642e39e68567548aef25ab8100a276bc30775ef", "committedDate": "2020-12-04 14:26:08 -0700", "message": "Enable java.lang.Class.getConstantPool() for Java 8"}, {"oid": "283266e8e399abde9a3380e2c132bb63f734993d", "committedDate": "2020-12-07 16:11:47 -0500", "message": "jdk.internal.access.SharedSecrets is required for JDK15+"}, {"oid": "d120a3ddb668573348cdecb89211f959758fa1d0", "committedDate": "2021-01-11 13:15:03 -0500", "message": "Remove repeated words"}, {"oid": "cf34f152b621fffc53707715df4fb7bbf429f79d", "committedDate": "2021-01-19 13:12:20 -0500", "message": "Update the check of isRecord() for record classes"}, {"oid": "bb7227688c83fcf80ca2e43bf5f47ad0e4eb5446", "committedDate": "2021-01-25 20:26:22 -0500", "message": "Get metadataCache field without caching to avoid circular dependency"}, {"oid": "fc4da648da9ecc9e938aa578ea20c7fa8de94c18", "committedDate": "2021-02-01 11:11:10 -0500", "message": "Change Class method to getPermittedSubclasses"}, {"oid": "c4da3f84a8287ba0c9a4f56dbba1430920c1f5e7", "committedDate": "2021-02-01 21:32:47 -0500", "message": "Capture the illegal access behavior in Class.newInstance()"}, {"oid": "cffc2e79c2111ecee72781a770fc6a46612b8b3c", "committedDate": "2021-02-02 16:37:39 -0500", "message": "JDK8 getMethod returns any matching method for an interface"}, {"oid": "c7017bfcd754887e3354485c1d095aaaa0813190", "committedDate": "2021-02-04 09:25:32 -0500", "message": "Merge pull request #11867 from JasonFengJ9/jdk8order"}, {"oid": "885e370ba9b22fc0ca807fbe317a5148df937028", "committedDate": "2021-03-08 15:21:59 -0500", "message": "Fix jdk17 javadoc errors"}, {"oid": "ade6e111615f2e08ccb2270ada09289c0d77e06e", "committedDate": "2021-04-06 11:39:43 -0700", "message": "Add isPrimitiveClass() method to Class.java"}, {"oid": "440536aabea9889dcd8d3ba25dbd5dec86b0cbfd", "committedDate": "2021-04-29 05:14:31 -0700", "message": "Modify Class and Method Descriptors to be compatible with Q types"}, {"oid": "b0c580991674e1e5095c40419472ae3dfd0aa969", "committedDate": "2021-04-29 11:31:26 -0400", "message": "Update github URLs to refer to eclipse-openj9"}, {"oid": "194f7f30f445fbc8e0f62b57788c1a43d0b28fcd", "committedDate": "2021-04-30 14:47:39 -0400", "message": "Merge pull request #12424 from OussamaSaoudi/VMDescriptorString"}, {"oid": "765cecbc30ef68880261cd3b75ba6dcc94bc1fe3", "committedDate": "2021-05-10 10:31:12 -0400", "message": "Access.protectionDomain() invokes clazz.getProtectionDomainInternal()"}, {"oid": "9e5d9f7ecd19ecb5cdc03d8e5ca463d7a1f775bd", "committedDate": "2021-06-03 15:55:30 -0400", "message": "JDK17 update : add JavaLangAccess methods & @SuppressWarnings(\"removal\")"}, {"oid": "0d7d04df1a547f78d3931adaf7983fd5344cce98", "committedDate": "2021-08-18 13:13:09 -0400", "message": "Commonize Class name String creation"}, {"oid": "d08f08c94dce579f1a2f013fd5b9741440892f35", "committedDate": "2021-08-24 16:06:55 -0400", "message": "Update exception message to support OJDK test case"}, {"oid": "091ff47b5e2d2d2044c34b7fceb383fa32e18b75", "committedDate": "2021-08-27 09:43:58 -0400", "message": "Merge pull request #13320 from gacholio/classname"}, {"oid": "399479cd410f26469795407edf0d8d39bf98673b", "committedDate": "2021-10-07 12:02:50 -0400", "message": "Valhalla Class/Unsafe stub methods"}, {"oid": "0bae7e35cbb0924df442f245cd9fde5b1aeef9d0", "committedDate": "2021-10-27 12:55:22 -0700", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "c430223380bd4a6bfd4a238953720395d7741b6e", "committedDate": "2021-10-28 11:19:29 -0400", "message": "Merge pull request #13424 from EricYangIBM/fixAnnotationCache"}, {"oid": "d57b7e4c78e8537343e028c3340cde1295f44920", "committedDate": "2021-10-29 15:52:55 -0400", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "b18c6449b550d0d4c3de6d72e750622fc25aa8c5", "committedDate": "2021-11-10 17:07:36 -0500", "message": "Use ReflectionFactory helpers to adopt JEP 416 MH changes"}, {"oid": "12257afce3f24d63dbb4db1b892e8cc5137a7a40", "committedDate": "2021-11-19 11:45:16 -0500", "message": "Check the InnerClass attribute of the enclosing class"}, {"oid": "55dd62c6660f6b9165f0b3edf80e54ea799de24c", "committedDate": "2021-11-19 16:06:52 -0500", "message": "Cache the packageName to which receiver belongs"}, {"oid": "c4da870822433c0c17febbbc9dec9c833a4ccaba", "committedDate": "2021-11-21 18:31:43 -0500", "message": "Merge pull request #13923 from r30shah/cacheClassPackageName"}, {"oid": "d9d09b92cd5f42dd6b44d0e066beb9ba8c8a9294", "committedDate": "2021-11-22 07:42:25 -0800", "message": "Fix inconsistency between J9Class and annotation data when redefine"}, {"oid": "9bdce75b08d68ce680f2af00c6ccc224aab91227", "committedDate": "2021-11-29 13:56:02 -0800", "message": "Fix sign extension"}, {"oid": "06ae5711cfba307e681e74302c844df3b4b8a4ee", "committedDate": "2021-12-02 12:54:43 -0500", "message": "Revert \"Fix inconsistency between J9Class and annotation data when redefine\""}, {"oid": "3037ba8427b2b06021ebb4fecb7b5763ed0208f0", "committedDate": "2021-12-02 20:11:12 +0000", "message": "Revert \"Revert \"Fix inconsistency between J9Class and annotation data when redefine\"\""}, {"oid": "7ac31098798693488264f994fe2a90ea07d33d0d", "committedDate": "2022-01-27 10:59:02 -0500", "message": "[JEP416] Add caller sensitive adapter methods in java.lang.Class"}, {"oid": "77fe8f78840c4ad248b22f10c91239b156df5809", "committedDate": "2022-01-27 11:11:39 -0500", "message": "Reformat [IF JAVA_SPEC_VERSION >= 18] macros"}, {"oid": "9f550da79d565d1eab3a9eca18c97e2a965a2783", "committedDate": "2022-01-28 16:01:57 -0500", "message": "Add stub VT method to unblock Valhalla builds"}, {"oid": "15edfc8013988729276fd5a33c9099540ace27b4", "committedDate": "2022-02-17 11:23:25 -0500", "message": "Add implementation of Class.isValue()"}, {"oid": "5082416994274baaa4abf64e15dfe8b6b003d857", "committedDate": "2022-04-21 16:35:07 -0400", "message": "Adopt java.util.HashMap.newHashMap(numMappings)"}, {"oid": "c80811003f2f3b5a921b84ac12d459816cbbc9de", "committedDate": "2022-06-15 09:28:34 -0400", "message": "jdk19 Class.forName(String) use system class loader for null caller"}, {"oid": "fa60b9a101e89bffb85fbd210fd299f2d4804974", "committedDate": "2022-06-15 18:29:31 -0400", "message": "Simplify Class.forName(String, Class)"}, {"oid": "163840839734c98f3250c36c76d0db2942fd068f", "committedDate": "2022-06-16 10:13:47 -0400", "message": "Cache Class.toString name"}, {"oid": "cddb8bf6b5369e216402500b677da356114a38f8", "committedDate": "2022-06-16 12:24:03 -0400", "message": "Merge pull request #15325 from tajila/perf2"}, {"oid": "3e3ea8b9f91fda8b8d4331ac2bea845b4c2310c9", "committedDate": "2022-06-21 16:16:56 -0400", "message": "Class.arrayType() throws UnsupportedOperationException in jdk19+"}, {"oid": "48b89002c07a9e7a822dad439dadc01e293d4777", "committedDate": "2022-06-23 11:15:44 -0400", "message": "Merge pull request #15298 from pshipton/atype"}, {"oid": "8c3ddeb763dd3e5067b6f88de9df1b253a33417e", "committedDate": "2022-09-14 15:28:27 -0400", "message": "Readd getConstantPool() method to Class.java"}, {"oid": "c6974dae39057d98d76333266a2ec58f3f5baeb2", "committedDate": "2022-09-22 14:25:23 -0400", "message": "Move value type public APIs in Class.java into Access.java"}, {"oid": "be64b454aa3140e1ac9333aa21b5ad4197bfb428", "committedDate": "2022-09-22 14:26:24 -0400", "message": "Add stub method Class.accessFlags()"}, {"oid": "b2710e8fa55f7063c3aedc007f7a37aa08c42f14", "committedDate": "2022-10-04 14:00:52 -0400", "message": "Add new method Class.isIdentity()"}, {"oid": "97c372bc05a435f35a0d28f6ca54941de1f91c46", "committedDate": "2022-10-27 14:45:10 -0400", "message": "Use valueObjectHashCode function when hashing value types"}, {"oid": "e590d7d69aebca8941df90d4a02c55d55f6620ba", "committedDate": "2022-10-31 10:50:10 -0400", "message": "Update Class.getModifiers() to include new Valhalla modifiers"}, {"oid": "1f294ad305445bfc8bd8c1f7edc42620c9bd5956", "committedDate": "2022-11-01 09:17:18 -0400", "message": "Merge pull request #16227 from hangshao0/master"}, {"oid": "76a00d5fd210daa86dcbd4bee85e622289fbfc8a", "committedDate": "2022-11-10 16:09:09 -0500", "message": "Replace openjdk.java.net with openjdk.org"}, {"oid": "82456a32974c56a6cafc001ee50b5467722dc604", "committedDate": "2022-11-16 16:10:50 -0500", "message": "Adds implementation for accessFlags() in Class.java"}, {"oid": "fddfd3f967c107bb3f5158f14f2de6f0101ead8d", "committedDate": "2022-11-17 12:59:35 -0500", "message": "Merge pull request #16217 from thallium/accessFlags"}, {"oid": "4f81c68d3e7b26d4ba8b014fc103b4aacfce2ad8", "committedDate": "2022-11-22 10:22:10 -0500", "message": "Unset Valhalla modifiers in Class.toGenericString()"}, {"oid": "55c52ff26d9a8755b9de00704dee2b7f6543a041", "committedDate": "2022-11-22 12:51:23 -0500", "message": "Merge pull request #16335 from hangshao0/Test"}, {"oid": "6972c5545f29d73f8a0eec32dcb9872e9a184cce", "committedDate": "2022-12-05 10:58:41 -0500", "message": "Fix javadoc warnings in jdknext"}, {"oid": "700dcf7f1d9adb700e6a6abdf9ad8a081dfd94f3", "committedDate": "2023-02-07 16:09:51 -0500", "message": "Make Class.getEnumConstantsShared() more robust"}, {"oid": "8b7d1216cdd4d6aa1a19cfc27e399ea49df4c524", "committedDate": "2023-02-28 07:57:42 -0500", "message": "Valhalla adds Access.classFileFormatVersion()"}, {"oid": "7cf506db3b37e1ccbf20925555b6b21e20fcc771", "committedDate": "2023-03-10 16:13:55 -0500", "message": "Update IBM copyright notices to remove last-modified year"}]}, {"oid": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "url": "https://github.com/eclipse-openj9/openj9/commit/b09b8df1b275eb94e149adf9805c810c72cc95e1", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-13T12:02:41Z", "type": "forcePushed"}, {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "url": "https://github.com/eclipse-openj9/openj9/commit/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-13T14:15:07Z", "type": "forcePushed"}, {"oid": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "url": "https://github.com/eclipse-openj9/openj9/commit/57ec2470aba0d567200e7754f76d4fed5b4110d3", "message": "Fix the missing case of Class.getMethod()\n\nThe change is adding code in the helper method\nof getMethod() to address the missing case when\nthe two specific methods are both declared\nby interfaces.\n\nFixes: #7897\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "ce60704e9678db4056d8afe08c13d3a02d554df0", "url": "https://github.com/eclipse-openj9/openj9/commit/ce60704e9678db4056d8afe08c13d3a02d554df0", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "forcePushed"}]}