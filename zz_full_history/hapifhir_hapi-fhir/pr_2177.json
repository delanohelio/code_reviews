{"pr_number": 2177, "pr_title": "Remove all references to Person from EMPI.", "pr_author": "tadgh", "pr_createdAt": "2020-11-17T02:20:23Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/2177", "timeline": [{"oid": "c64ca813739ffa111458f1684a5f783e3149ede4", "url": "https://github.com/hapifhir/hapi-fhir/commit/c64ca813739ffa111458f1684a5f783e3149ede4", "message": "Removed obsolete tests", "committedDate": "2020-11-27T22:11:52Z", "type": "commit"}, {"oid": "da3df490890b22bc48ae320d5efc3d1d1c98b420", "url": "https://github.com/hapifhir/hapi-fhir/commit/da3df490890b22bc48ae320d5efc3d1d1c98b420", "message": "Fixed build failures", "committedDate": "2020-11-27T23:00:24Z", "type": "commit"}, {"oid": "db28a94eee60b0096390775565cdeec72337144d", "url": "https://github.com/hapifhir/hapi-fhir/commit/db28a94eee60b0096390775565cdeec72337144d", "message": "Resolved alerts", "committedDate": "2020-11-30T14:09:38Z", "type": "commit"}, {"oid": "3f3b811b16f5f19df1e7d104393f4aa2bbc2a351", "url": "https://github.com/hapifhir/hapi-fhir/commit/3f3b811b16f5f19df1e7d104393f4aa2bbc2a351", "message": "Fixed Foreign Key references", "committedDate": "2020-11-30T22:21:56Z", "type": "commit"}, {"oid": "d63c580e82da79ec426eabf2758831a219f1a8f9", "url": "https://github.com/hapifhir/hapi-fhir/commit/d63c580e82da79ec426eabf2758831a219f1a8f9", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-01T18:18:42Z", "type": "commit"}, {"oid": "417ae55cb4a5eba7462138f4fa3ccfcf6f2a3d1d", "url": "https://github.com/hapifhir/hapi-fhir/commit/417ae55cb4a5eba7462138f4fa3ccfcf6f2a3d1d", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-02T14:29:47Z", "type": "commit"}, {"oid": "ffee7a894ff0a1f4d48cfbb17ed8a31e6c60a84f", "url": "https://github.com/hapifhir/hapi-fhir/commit/ffee7a894ff0a1f4d48cfbb17ed8a31e6c60a84f", "message": "Removed person refs", "committedDate": "2020-12-02T22:41:42Z", "type": "commit"}, {"oid": "6d74f4f39899a182bea792a834b4bd6fec641fa7", "url": "https://github.com/hapifhir/hapi-fhir/commit/6d74f4f39899a182bea792a834b4bd6fec641fa7", "message": "Fixed alert", "committedDate": "2020-12-03T02:00:49Z", "type": "commit"}, {"oid": "4352e0a61fa89058b5bab14493d857adb4f4b60c", "url": "https://github.com/hapifhir/hapi-fhir/commit/4352e0a61fa89058b5bab14493d857adb4f4b60c", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-03T16:28:21Z", "type": "commit"}, {"oid": "499a68a093f8dd25b04b32c2199389c290ed1659", "url": "https://github.com/hapifhir/hapi-fhir/commit/499a68a093f8dd25b04b32c2199389c290ed1659", "message": "Reviewed docs and added change entry", "committedDate": "2020-12-03T20:53:06Z", "type": "commit"}, {"oid": "5c40afb0c905ea93bd7d1f156fa77d3a4eddb4fb", "url": "https://github.com/hapifhir/hapi-fhir/commit/5c40afb0c905ea93bd7d1f156fa77d3a4eddb4fb", "message": "Updated doc headers", "committedDate": "2020-12-03T21:11:10Z", "type": "commit"}, {"oid": "51b3fb05250cbd209c0aa60555285fa8e83b4ba3", "url": "https://github.com/hapifhir/hapi-fhir/commit/51b3fb05250cbd209c0aa60555285fa8e83b4ba3", "message": "Synced Provider impl bw R4 and Dstu3", "committedDate": "2020-12-04T16:57:40Z", "type": "commit"}, {"oid": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "url": "https://github.com/hapifhir/hapi-fhir/commit/f5f7f2df14f732c131b360087deaa0b4827b05b5", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-07T16:55:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNzMyMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537707323", "body": "I recommend renaming to: myNewGoldenResource\r\n", "bodyText": "I recommend renaming to: myNewGoldenResource", "bodyHTML": "<p dir=\"auto\">I recommend renaming to: myNewGoldenResource</p>", "author": "fil512", "createdAt": "2020-12-07T17:53:04Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java", "diffHunk": "@@ -99,56 +107,67 @@\n \n \t/** This link created a new person **/\n \t@Column(name = \"NEW_PERSON\")\n-\tprivate Boolean myNewPerson;\n+\tprivate Boolean myHadToCreateNewResource;", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 6534658003..6e551ac1de 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n", "chunk": "@@ -106,8 +97,8 @@ public class MdmLink {\n \tprivate Boolean myEidMatch;\n \n \t/** This link created a new person **/\n-\t@Column(name = \"NEW_PERSON\")\n-\tprivate Boolean myHadToCreateNewResource;\n+\t@Column(name = \"NEW_GOLDEN_RESOURCE\")\n+\tprivate Boolean myHadToCreateNewGoldenResource;\n \n \t@Column(name = \"VECTOR\")\n \tprivate Long myVector;\n", "next_change": {"commit": "6018dd053787f424a7646ac1a7b0b76beec86fd3", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 6e551ac1de..500f7499d0 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n", "chunk": "@@ -97,7 +106,7 @@ public class MdmLink {\n \tprivate Boolean myEidMatch;\n \n \t/** This link created a new person **/\n-\t@Column(name = \"NEW_GOLDEN_RESOURCE\")\n+\t@Column(name = \"NEW_PERSON\")\n \tprivate Boolean myHadToCreateNewGoldenResource;\n \n \t@Column(name = \"VECTOR\")\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nsimilarity index 57%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nindex 500f7499d0..1bb2f4368d 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n", "chunk": "@@ -107,7 +99,7 @@ public class MdmLink {\n \n \t/** This link created a new person **/\n \t@Column(name = \"NEW_PERSON\")\n-\tprivate Boolean myHadToCreateNewGoldenResource;\n+\tprivate Boolean myNewPerson;\n \n \t@Column(name = \"VECTOR\")\n \tprivate Long myVector;\n", "next_change": null}, {"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nsimilarity index 57%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nindex 500f7499d0..1bb2f4368d 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n", "chunk": "@@ -115,132 +107,113 @@ public class MdmLink {\n \t@Column(name = \"SCORE\")\n \tprivate Double myScore;\n \n-\t//TODO GGG GL-1340\n-\t@Column(name = \"RULE_COUNT\")\n-\tprivate Long myRuleCount;\n-\n-\tpublic MdmLink() {}\n+\tpublic EmpiLink() {}\n \n-\tpublic MdmLink(String theVersion) {\n+\tpublic EmpiLink(String theVersion) {\n \t\tmyVersion = theVersion;\n \t}\n \n-\t@Column(name = \"TARGET_TYPE\", nullable = true, length = SOURCE_TYPE_LENGTH)\n-\tprivate String myMdmSourceType;\n+\t@Column(name = \"TARGET_TYPE\", nullable = true, length = TARGET_TYPE_LENGTH)\n+\tprivate String myEmpiTargetType;\n \n \tpublic Long getId() {\n \t\treturn myId;\n \t}\n \n-\tpublic MdmLink setId(Long theId) {\n+\tpublic EmpiLink setId(Long theId) {\n \t\tmyId = theId;\n \t\treturn this;\n \t}\n \n-\tpublic ResourceTable getGoldenResource() {\n-\t\treturn myGoldenResource;\n+\tpublic ResourceTable getPerson() {\n+\t\treturn myPerson;\n \t}\n \n-\tpublic MdmLink setGoldenResource(ResourceTable theGoldenResource) {\n-\t\tmyGoldenResource = theGoldenResource;\n-\t\tmyGoldenResourcePid = theGoldenResource.getId();\n-\n-\t\tmyPerson = theGoldenResource;\n-\t\tmyPersonPid = theGoldenResource.getId();\n-\n+\tpublic EmpiLink setPerson(ResourceTable thePerson) {\n+\t\tmyPerson = thePerson;\n+\t\tmyPersonPid = thePerson.getId();\n \t\treturn this;\n \t}\n \n-\tpublic Long getGoldenResourcePid() {\n-\t\treturn myGoldenResourcePid;\n+\tpublic Long getPersonPid() {\n+\t\treturn myPersonPid;\n \t}\n \n-\t/**\n-\t * @deprecated  Use {@link #setGoldenResourcePid(Long)} instead\n-\t */\n-\t@Deprecated\n-\tpublic MdmLink setPersonPid(Long thePersonPid) {\n+\tpublic EmpiLink setPersonPid(Long thePersonPid) {\n \t\tmyPersonPid = thePersonPid;\n \t\treturn this;\n \t}\n \n-\tpublic MdmLink setGoldenResourcePid(Long theGoldenResourcePid) {\n-\t\tsetPersonPid(theGoldenResourcePid);\n-\n-\t\tmyGoldenResourcePid = theGoldenResourcePid;\n-\t\treturn this;\n-\t}\n-\n-\tpublic ResourceTable getSource() {\n-\t\treturn mySource;\n+\tpublic ResourceTable getTarget() {\n+\t\treturn myTarget;\n \t}\n \n-\tpublic MdmLink setSource(ResourceTable theSource) {\n-\t\tmySource = theSource;\n-\t\tmySourcePid = theSource.getId();\n+\tpublic EmpiLink setTarget(ResourceTable theTarget) {\n+\t\tmyTarget = theTarget;\n+\t\tmyTargetPid = theTarget.getId();\n \t\treturn this;\n \t}\n \n-\tpublic Long getSourcePid() {\n-\t\treturn mySourcePid;\n+\tpublic Long getTargetPid() {\n+\t\treturn myTargetPid;\n \t}\n \n-\tpublic MdmLink setSourcePid(Long theSourcePid) {\n-\t\tmySourcePid = theSourcePid;\n+\tpublic EmpiLink setTargetPid(Long theTargetPid) {\n+\t\tmyTargetPid = theTargetPid;\n \t\treturn this;\n \t}\n \n-\tpublic MdmMatchResultEnum getMatchResult() {\n+\tpublic EmpiMatchResultEnum getMatchResult() {\n \t\treturn myMatchResult;\n \t}\n \n-\tpublic MdmLink setMatchResult(MdmMatchResultEnum theMatchResult) {\n+\tpublic EmpiLink setMatchResult(EmpiMatchResultEnum theMatchResult) {\n \t\tmyMatchResult = theMatchResult;\n \t\treturn this;\n \t}\n \n \tpublic boolean isNoMatch() {\n-\t\treturn myMatchResult == MdmMatchResultEnum.NO_MATCH;\n+\t\treturn myMatchResult == EmpiMatchResultEnum.NO_MATCH;\n \t}\n \n \tpublic boolean isMatch() {\n-\t\treturn myMatchResult == MdmMatchResultEnum.MATCH;\n+\t\treturn myMatchResult == EmpiMatchResultEnum.MATCH;\n \t}\n \n \tpublic boolean isPossibleMatch() {\n-\t\treturn myMatchResult == MdmMatchResultEnum.POSSIBLE_MATCH;\n+\t\treturn myMatchResult == EmpiMatchResultEnum.POSSIBLE_MATCH;\n \t}\n \n \tpublic boolean isRedirect() {\n-\t\treturn myMatchResult == MdmMatchResultEnum.REDIRECT;\n+\t\treturn myMatchResult == EmpiMatchResultEnum.REDIRECT;\n \t}\n \n \tpublic boolean isPossibleDuplicate() {\n-\t\treturn myMatchResult == MdmMatchResultEnum.POSSIBLE_DUPLICATE;\n+\t\treturn myMatchResult == EmpiMatchResultEnum.POSSIBLE_DUPLICATE;\n \t}\n \n-\tpublic MdmLinkSourceEnum getLinkSource() {\n+\tpublic EmpiLinkSourceEnum getLinkSource() {\n \t\treturn myLinkSource;\n \t}\n \n-\tpublic MdmLink setLinkSource(MdmLinkSourceEnum theLinkSource) {\n+\tpublic EmpiLink setLinkSource(EmpiLinkSourceEnum theLinkSource) {\n \t\tmyLinkSource = theLinkSource;\n \t\treturn this;\n \t}\n \n \tpublic boolean isAuto() {\n-\t\treturn myLinkSource == MdmLinkSourceEnum.AUTO;\n+\t\treturn myLinkSource == EmpiLinkSourceEnum.AUTO;\n \t}\n \n \tpublic boolean isManual() {\n-\t\treturn myLinkSource == MdmLinkSourceEnum.MANUAL;\n+\t\treturn myLinkSource == EmpiLinkSourceEnum.MANUAL;\n \t}\n \n \tpublic Date getCreated() {\n \t\treturn myCreated;\n \t}\n \n-\tpublic MdmLink setCreated(Date theCreated) {\n+\tpublic EmpiLink setCreated(Date theCreated) {\n \t\tmyCreated = theCreated;\n \t\treturn this;\n \t}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwODc0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537708748", "body": "these can be removed", "bodyText": "these can be removed", "bodyHTML": "<p dir=\"auto\">these can be removed</p>", "author": "fil512", "createdAt": "2020-12-07T17:55:09Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java", "diffHunk": "@@ -31,34 +31,35 @@\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiLoader {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiLoader.class);\n+public class MdmLoader {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmLoader.class);\n \n \t@Autowired\n-\tIEmpiSettings myEmpiProperties;\n+\tIMdmSettings myMdmSettings;\n \t@Autowired\n-\tEmpiProviderLoader myEmpiProviderLoader;\n+\tMdmProviderLoader myMdmProviderLoader;\n \t@Autowired\n-\tEmpiSubscriptionLoader myEmpiSubscriptionLoader;\n+\tMdmSubscriptionLoader myMdmSubscriptionLoader;\n \t@Autowired\n-\tEmpiSearchParameterLoader myEmpiSearchParameterLoader;\n+\tMdmSearchParameterLoader myMdmSearchParameterLoader;\n \n \t@EventListener(classes = {ContextRefreshedEvent.class})\n \t// This @Order is here to ensure that MatchingQueueSubscriberLoader has initialized before we initialize this.\n-\t// Otherwise the EMPI subscriptions won't get loaded into the SubscriptionRegistry\n+\t// Otherwise the MDM subscriptions won't get loaded into the SubscriptionRegistry\n \t@Order\n \tpublic void updateSubscriptions() {\n-\t\tif (!myEmpiProperties.isEnabled()) {\n+\t\tif (!myMdmSettings.isEnabled()) {\n \t\t\treturn;\n \t\t}\n \n-\t\tmyEmpiProviderLoader.loadProvider();\n-\t\tourLog.info(\"EMPI provider registered\");\n+\t\tmyMdmProviderLoader.loadProvider();\n+\t\tourLog.info(\"MDM provider registered\");\n \n-\t\tmyEmpiSubscriptionLoader.daoUpdateEmpiSubscriptions();\n-\t\tourLog.info(\"EMPI subscriptions updated\");\n+\t\tmyMdmSubscriptionLoader.daoUpdateMdmSubscriptions();\n+\t\tourLog.info(\"MDM subscriptions updated\");\n \n-\t\tmyEmpiSearchParameterLoader.daoUpdateEmpiSearchParameters();\n-\t\tourLog.info(\"EMPI search parameters updated\");\n+\t\t//TODO GGG MDM: Do we need these search parameters, or equivalent, anymore? Don't think so... ask @fil512\n+\t\tmyMdmSearchParameterLoader.daoUpdateMdmSearchParameters();", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\nindex 57b5b076a3..84a9c860cf 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\n", "chunk": "@@ -57,9 +55,5 @@ public class MdmLoader {\n \n \t\tmyMdmSubscriptionLoader.daoUpdateMdmSubscriptions();\n \t\tourLog.info(\"MDM subscriptions updated\");\n-\n-\t\t//TODO GGG MDM: Do we need these search parameters, or equivalent, anymore? Don't think so... ask @fil512\n-\t\tmyMdmSearchParameterLoader.daoUpdateMdmSearchParameters();\n-\t\tourLog.info(\"MDM search parameters updated\");\n \t}\n }\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiLoader.java\nsimilarity index 58%\nrename from hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiLoader.java\nindex 84a9c860cf..46fd60ecf9 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiLoader.java\n", "chunk": "@@ -31,29 +31,34 @@ import org.springframework.core.annotation.Order;\n import org.springframework.stereotype.Service;\n \n @Service\n-public class MdmLoader {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmLoader.class);\n+public class EmpiLoader {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiLoader.class);\n \n \t@Autowired\n-\tIMdmSettings myMdmSettings;\n+\tIEmpiSettings myEmpiProperties;\n \t@Autowired\n-\tMdmProviderLoader myMdmProviderLoader;\n+\tEmpiProviderLoader myEmpiProviderLoader;\n \t@Autowired\n-\tMdmSubscriptionLoader myMdmSubscriptionLoader;\n+\tEmpiSubscriptionLoader myEmpiSubscriptionLoader;\n+\t@Autowired\n+\tEmpiSearchParameterLoader myEmpiSearchParameterLoader;\n \n \t@EventListener(classes = {ContextRefreshedEvent.class})\n \t// This @Order is here to ensure that MatchingQueueSubscriberLoader has initialized before we initialize this.\n-\t// Otherwise the MDM subscriptions won't get loaded into the SubscriptionRegistry\n+\t// Otherwise the EMPI subscriptions won't get loaded into the SubscriptionRegistry\n \t@Order\n \tpublic void updateSubscriptions() {\n-\t\tif (!myMdmSettings.isEnabled()) {\n+\t\tif (!myEmpiProperties.isEnabled()) {\n \t\t\treturn;\n \t\t}\n \n-\t\tmyMdmProviderLoader.loadProvider();\n-\t\tourLog.info(\"MDM provider registered\");\n+\t\tmyEmpiProviderLoader.loadProvider();\n+\t\tourLog.info(\"EMPI provider registered\");\n+\n+\t\tmyEmpiSubscriptionLoader.daoUpdateEmpiSubscriptions();\n+\t\tourLog.info(\"EMPI subscriptions updated\");\n \n-\t\tmyMdmSubscriptionLoader.daoUpdateMdmSubscriptions();\n-\t\tourLog.info(\"MDM subscriptions updated\");\n+\t\tmyEmpiSearchParameterLoader.daoUpdateEmpiSearchParameters();\n+\t\tourLog.info(\"EMPI search parameters updated\");\n \t}\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwOTE1Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537709156", "body": "remove this class", "bodyText": "remove this class", "bodyHTML": "<p dir=\"auto\">remove this class</p>", "author": "fil512", "createdAt": "2020-12-07T17:55:38Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java", "diffHunk": "@@ -32,40 +32,42 @@\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiSearchParameterLoader {\n-\tpublic static final String EMPI_PERSON_ASSURANCE_SEARCH_PARAMETER_ID = \"person-assurance\";\n-\tpublic static final String EMPI_PERSON_ACTIVE_SEARCH_PARAMETER_ID = \"person-active\";\n+public class MdmSearchParameterLoader {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMDQ0Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537710446", "body": "Git is seeing these as delete / add which makes it harder to review.  If possible, it's better to rename and move classes in a git aware fashion so it can track the deltas.  It's possible that git just isn't able to do this...", "bodyText": "Git is seeing these as delete / add which makes it harder to review.  If possible, it's better to rename and move classes in a git aware fashion so it can track the deltas.  It's possible that git just isn't able to do this...", "bodyHTML": "<p dir=\"auto\">Git is seeing these as delete / add which makes it harder to review.  If possible, it's better to rename and move classes in a git aware fashion so it can track the deltas.  It's possible that git just isn't able to do this...</p>", "author": "fil512", "createdAt": "2020-12-07T17:57:22Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,338 @@\n+package ca.uhn.fhir.jpa.mdm.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IMdmLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n+import ca.uhn.fhir.mdm.api.MdmMatchOutcome;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class MdmLinkDaoSvc {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\ndeleted file mode 100644\nindex fe093af485..0000000000\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,338 +0,0 @@\n-package ca.uhn.fhir.jpa.mdm.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.jpa.dao.data.IMdmLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.MdmLink;\n-import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n-import ca.uhn.fhir.mdm.api.MdmMatchOutcome;\n-import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n-import ca.uhn.fhir.mdm.log.Logs;\n-import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class MdmLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IMdmLinkDao myMdmLinkDao;\n-\t@Autowired\n-\tprivate MdmLinkFactory myMdmLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic MdmLink createOrUpdateLinkEntity(IBaseResource theGoldenResource, IBaseResource theTargetResource, MdmMatchOutcome theMatchOutcome, MdmLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong goldenResourcePid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tMdmLink mdmLink = getOrCreateMdmLinkByGoldenResourcePidAndTargetResourcePid(goldenResourcePid, targetResourcePid);\n-\t\tmdmLink.setLinkSource(theLinkSource);\n-\t\tmdmLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tmdmLink.setEidMatch(theMatchOutcome.isEidMatch() | mdmLink.isEidMatch());\n-\t\tmdmLink.setHadToCreateNewResource(theMatchOutcome.isCreatedNewResource() | mdmLink.getHadToCreateNewResource());\n-\t\tmdmLink.setMdmTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (mdmLink.getScore() != null) {\n-\t\t\tmdmLink.setScore(Math.max(theMatchOutcome.score, mdmLink.getScore()));\n-\t\t} else {\n-\t\t\tmdmLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating MdmLink from %s to %s -> %s\", theGoldenResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(mdmLink);\n-\t\treturn mdmLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic MdmLink getOrCreateMdmLinkByGoldenResourcePidAndTargetResourcePid(Long theGoldenResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<MdmLink> oExisting = getLinkByGoldenResourcePidAndTargetResourcePid(theGoldenResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tMdmLink newLink = myMdmLinkFactory.newMdmLink();\n-\t\t\tnewLink.setGoldenResourcePid(theGoldenResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<MdmLink> getLinkByGoldenResourcePidAndTargetResourcePid(Long theGoldenResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theGoldenResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tMdmLink link = myMdmLinkFactory.newMdmLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theGoldenResourcePid);\n-\t\tExample<MdmLink> example = Example.of(link);\n-\t\treturn myMdmLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link MdmLink} entities matching these criteria.\n-\t */\n-\tpublic List<MdmLink> getMdmLinksByTargetPidAndMatchResult(Long theTargetPid, MdmMatchResultEnum theMatchResult) {\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched {@link MdmLink}. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link MdmLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<MdmLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(MdmMatchResultEnum.MATCH);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched {@link MdmLink}. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link MdmLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<MdmLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(MdmMatchResultEnum.MATCH);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a golden resource a target and a match result, return the matching {@link MdmLink}, if it exists.\n-\t *\n-\t * @param theGoldenResourcePid The Pid of the Golden Resource in the relationship\n-\t * @param theTargetPid         The Pid of the target in the relationship\n-\t * @param theMatchResult       The MatchResult you are looking for.\n-\t * @return an Optional {@link MdmLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<MdmLink> getMdmLinksByGoldenResourcePidTargetPidAndMatchResult(Long theGoldenResourcePid, Long theTargetPid, MdmMatchResultEnum theMatchResult) {\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n-\t\texampleLink.setGoldenResourcePid(theGoldenResourcePid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link MdmLink} which have {@link MdmMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of {@link MdmLink} that hold potential duplicate golden resources.\n-\t */\n-\tpublic List<MdmLink> getPossibleDuplicates() {\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n-\t\texampleLink.setMatchResult(MdmMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<MdmLink> findMdmLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setTargetPid(pid);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given {@link MdmLink}. Note that this does not clear out the Golden resource.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theMdmLink the {@link MdmLink} to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(MdmLink theMdmLink) {\n-\t\tmyMdmLinkDao.delete(theMdmLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource, return all links in which they are the source Golden Resource of the {@link MdmLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Golden Resource who's links you would like to retrieve.\n-\t * @return A list of all {@link MdmLink} entities in which theGoldenResource is the source Golden Resource\n-\t */\n-\tpublic List<MdmLink> findMdmLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setGoldenResourcePid(pid);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link MdmLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Golden Resource Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllMdmLinksAndReturnGoldenResourcePids() {\n-\t\tList<MdmLink> all = myMdmLinkDao.findAll();\n-\t\treturn deleteMdmLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteMdmLinksAndReturnGoldenResourcePids(List<MdmLink> theLinks) {\n-\t\tSet<Long> goldenResources = theLinks.stream().map(MdmLink::getGoldenResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//goldenResources.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tgoldenResources.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(MdmMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(MdmMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(MdmLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} MDM link records...\", theLinks.size());\n-\t\tmyMdmLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} MDM link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(goldenResources);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link MdmLink} entities for that type, and get the Pids\n-\t * for the Golden Resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Golden Resources resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllMdmLinksOfTypeAndReturnGoldenResourcePids(String theTargetType) {\n-\t\tMdmLink link = new MdmLink();\n-\t\tlink.setMdmTargetType(theTargetType);\n-\t\tExample<MdmLink> exampleLink = Example.of(link);\n-\t\tList<MdmLink> allOfType = myMdmLinkDao.findAll(exampleLink);\n-\t\treturn deleteMdmLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an MDM link to the database.\n-\t *\n-\t * @param theMdmLink the link to save.\n-\t * @return the persisted {@link MdmLink} entity.\n-\t */\n-\tpublic MdmLink save(MdmLink theMdmLink) {\n-\t\tif (theMdmLink.getCreated() == null) {\n-\t\t\ttheMdmLink.setCreated(new Date());\n-\t\t}\n-\t\ttheMdmLink.setUpdated(new Date());\n-\t\treturn myMdmLinkDao.save(theMdmLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link MdmLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The MDM link containing the data we would like to search for.\n-\t * @return a list of {@link MdmLink} entities which match the example.\n-\t */\n-\tpublic List<MdmLink> findMdmLinkByExample(Example<MdmLink> theExampleLink) {\n-\t\treturn myMdmLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link MdmLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<MdmLink> findMdmLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setTargetPid(pid);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link MdmLink} entities in which theGoldenResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theGoldenResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<MdmLink> findMdmMatchLinksBySource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(MdmMatchResultEnum.MATCH);\n-\t\tExample<MdmLink> example = Example.of(exampleLink);\n-\t\treturn myMdmLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new MdmLink, use this factory method.\n-\t * //TODO Should we make the constructor private for MdmLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link MdmLink}.\n-\t */\n-\tpublic MdmLink newMdmLink() {\n-\t\treturn myMdmLinkFactory.newMdmLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..08b4268c35\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,338 @@\n+package ca.uhn.fhir.jpa.mdm.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IMdmLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n+import ca.uhn.fhir.mdm.api.MdmMatchOutcome;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class MdmLinkDaoSvc {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IMdmLinkDao myMdmLinkDao;\n+\t@Autowired\n+\tprivate MdmLinkFactory myMdmLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic MdmLink createOrUpdateLinkEntity(IBaseResource theGoldenResource, IBaseResource theSourceResource, MdmMatchOutcome theMatchOutcome, MdmLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n+\t\tLong goldenResourcePid = myIdHelperService.getPidOrNull(theGoldenResource);\n+\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n+\n+\t\tMdmLink mdmLink = getOrCreateMdmLinkByGoldenResourcePidAndSourceResourcePid(goldenResourcePid, sourceResourcePid);\n+\t\tmdmLink.setLinkSource(theLinkSource);\n+\t\tmdmLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tmdmLink.setEidMatch(theMatchOutcome.isEidMatch() | mdmLink.isEidMatch());\n+\t\tmdmLink.setHadToCreateNewGoldenResource(theMatchOutcome.isCreatedNewResource() | mdmLink.getHadToCreateNewGoldenResource());\n+\t\tmdmLink.setMdmSourceType(myFhirContext.getResourceType(theSourceResource));\n+\t\tif (mdmLink.getScore() != null) {\n+\t\t\tmdmLink.setScore(Math.max(theMatchOutcome.score, mdmLink.getScore()));\n+\t\t} else {\n+\t\t\tmdmLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating MdmLink from %s to %s -> %s\", theGoldenResource.getIdElement().toUnqualifiedVersionless(), theSourceResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(mdmLink);\n+\t\treturn mdmLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic MdmLink getOrCreateMdmLinkByGoldenResourcePidAndSourceResourcePid(Long theGoldenResourcePid, Long theSourceResourcePid) {\n+\t\tOptional<MdmLink> oExisting = getLinkByGoldenResourcePidAndSourceResourcePid(theGoldenResourcePid, theSourceResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tMdmLink newLink = myMdmLinkFactory.newMdmLink();\n+\t\t\tnewLink.setGoldenResourcePid(theGoldenResourcePid);\n+\t\t\tnewLink.setSourcePid(theSourceResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<MdmLink> getLinkByGoldenResourcePidAndSourceResourcePid(Long theGoldenResourcePid, Long theSourceResourcePid) {\n+\t\tif (theSourceResourcePid == null || theGoldenResourcePid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tMdmLink link = myMdmLinkFactory.newMdmLink();\n+\t\tlink.setSourcePid(theSourceResourcePid);\n+\t\tlink.setGoldenResourcePid(theGoldenResourcePid);\n+\t\tExample<MdmLink> example = Example.of(link);\n+\t\treturn myMdmLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a source resource Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theSourcePid   the source of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t * @return a list of {@link MdmLink} entities matching these criteria.\n+\t */\n+\tpublic List<MdmLink> getMdmLinksBySourcePidAndMatchResult(Long theSourcePid, MdmMatchResultEnum theMatchResult) {\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n+\t\texampleLink.setSourcePid(theSourcePid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a source Pid, return its Matched {@link MdmLink}. There can only ever be at most one of these, but its possible\n+\t * the source has no matches, and may return an empty optional.\n+\t *\n+\t * @param theSourcePid The Pid of the source you wish to find the matching link for.\n+\t * @return the {@link MdmLink} that contains the Match information for the source.\n+\t */\n+\tpublic Optional<MdmLink> getMatchedLinkForSourcePid(Long theSourcePid) {\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n+\t\texampleLink.setSourcePid(theSourcePid);\n+\t\texampleLink.setMatchResult(MdmMatchResultEnum.MATCH);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched {@link MdmLink}. There can only ever be at most one of these, but its possible\n+\t * the source has no matches, and may return an empty optional.\n+\t *\n+\t * @param theSourceResource The IBaseResource representing the source you wish to find the matching link for.\n+\t * @return the {@link MdmLink} that contains the Match information for the source.\n+\t */\n+\tpublic Optional<MdmLink> getMatchedLinkForSource(IBaseResource theSourceResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n+\t\texampleLink.setSourcePid(pid);\n+\t\texampleLink.setMatchResult(MdmMatchResultEnum.MATCH);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a golden resource a source and a match result, return the matching {@link MdmLink}, if it exists.\n+\t *\n+\t * @param theGoldenResourcePid The Pid of the Golden Resource in the relationship\n+\t * @param theSourcePid         The Pid of the source in the relationship\n+\t * @param theMatchResult       The MatchResult you are looking for.\n+\t * @return an Optional {@link MdmLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<MdmLink> getMdmLinksByGoldenResourcePidSourcePidAndMatchResult(Long theGoldenResourcePid,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t Long theSourcePid, MdmMatchResultEnum theMatchResult) {\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n+\t\texampleLink.setGoldenResourcePid(theGoldenResourcePid);\n+\t\texampleLink.setSourcePid(theSourcePid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link MdmLink} which have {@link MdmMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of {@link MdmLink} that hold potential duplicate golden resources.\n+\t */\n+\tpublic List<MdmLink> getPossibleDuplicates() {\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink();\n+\t\texampleLink.setMatchResult(MdmMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<MdmLink> findMdmLinkBySource(IBaseResource theSourceResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setSourcePid(pid);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given {@link MdmLink}. Note that this does not clear out the Golden resource.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theMdmLink the {@link MdmLink} to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(MdmLink theMdmLink) {\n+\t\tmyMdmLinkDao.delete(theMdmLink);\n+\t}\n+\n+\t/**\n+\t * Given a Golden Resource, return all links in which they are the source Golden Resource of the {@link MdmLink}\n+\t *\n+\t * @param theGoldenResource The {@link IBaseResource} Golden Resource who's links you would like to retrieve.\n+\t * @return A list of all {@link MdmLink} entities in which theGoldenResource is the source Golden Resource\n+\t */\n+\tpublic List<MdmLink> findMdmLinksByGoldenResource(IBaseResource theGoldenResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setGoldenResourcePid(pid);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link MdmLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Golden Resource Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllMdmLinksAndReturnGoldenResourcePids() {\n+\t\tList<MdmLink> all = myMdmLinkDao.findAll();\n+\t\treturn deleteMdmLinksAndReturnGoldenResourcePids(all);\n+\t}\n+\n+\tprivate List<Long> deleteMdmLinksAndReturnGoldenResourcePids(List<MdmLink> theLinks) {\n+\t\tSet<Long> goldenResources = theLinks.stream().map(MdmLink::getGoldenResourcePid).collect(Collectors.toSet());\n+\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n+\t\t//and REDIRECT\n+\t\tgoldenResources.addAll(theLinks.stream()\n+\t\t\t.filter(link -> link.getMatchResult().equals(MdmMatchResultEnum.REDIRECT)\n+\t\t\t\t|| link.getMatchResult().equals(MdmMatchResultEnum.POSSIBLE_DUPLICATE))\n+\t\t\t.map(MdmLink::getSourcePid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} MDM link records...\", theLinks.size());\n+\t\tmyMdmLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} MDM link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(goldenResources);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link MdmLink} entities for that type, and get the Pids\n+\t * for the Golden Resources which were the sources of the links.\n+\t *\n+\t * @param theSourceType the type of relationship you would like to delete.\n+\t * @return A list of longs representing the Pids of the Golden Resources resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllMdmLinksOfTypeAndReturnGoldenResourcePids(String theSourceType) {\n+\t\tMdmLink link = new MdmLink();\n+\t\tlink.setMdmSourceType(theSourceType);\n+\t\tExample<MdmLink> exampleLink = Example.of(link);\n+\t\tList<MdmLink> allOfType = myMdmLinkDao.findAll(exampleLink);\n+\t\treturn deleteMdmLinksAndReturnGoldenResourcePids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an MDM link to the database.\n+\t *\n+\t * @param theMdmLink the link to save.\n+\t * @return the persisted {@link MdmLink} entity.\n+\t */\n+\tpublic MdmLink save(MdmLink theMdmLink) {\n+\t\tif (theMdmLink.getCreated() == null) {\n+\t\t\ttheMdmLink.setCreated(new Date());\n+\t\t}\n+\t\ttheMdmLink.setUpdated(new Date());\n+\t\treturn myMdmLinkDao.save(theMdmLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link MdmLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The MDM link containing the data we would like to search for.\n+\t * @return a list of {@link MdmLink} entities which match the example.\n+\t */\n+\tpublic List<MdmLink> findMdmLinkByExample(Example<MdmLink> theExampleLink) {\n+\t\treturn myMdmLinkDao.findAll(theExampleLink);\n+\t}\n+\n+\t/**\n+\t * Given a source {@link IBaseResource}, return all {@link MdmLink} entities in which this source is the source\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theSourceResource the source resource to find links for.\n+\t * @return all links for the source.\n+\t */\n+\tpublic List<MdmLink> findMdmLinksBySourceResource(IBaseResource theSourceResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setSourcePid(pid);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Finds all {@link MdmLink} entities in which theGoldenResource's PID is the source\n+\t * of the relationship.\n+\t *\n+\t * @param theGoldenResource the source resource to find links for.\n+\t * @return all links for the source.\n+\t */\n+\tpublic List<MdmLink> findMdmMatchLinksByGoldenResource(IBaseResource theGoldenResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMdmLink exampleLink = myMdmLinkFactory.newMdmLink().setGoldenResourcePid(pid);\n+\t\texampleLink.setMatchResult(MdmMatchResultEnum.MATCH);\n+\t\tExample<MdmLink> example = Example.of(exampleLink);\n+\t\treturn myMdmLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new MdmLink, use this factory method.\n+\t * //TODO Should we make the constructor private for MdmLink? or work out some way to ensure they can only be instantiated via factory.\n+\t *\n+\t * @return A new {@link MdmLink}.\n+\t */\n+\tpublic MdmLink newMdmLink() {\n+\t\treturn myMdmLinkFactory.newMdmLink();\n+\t}\n+\n+}\n", "next_change": {"commit": "0656037c8d7714b4acb9fbfdb6c6039f1123f25d", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nindex 08b4268c35..9c54828efd 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n", "chunk": "@@ -335,4 +309,12 @@ public class MdmLinkDaoSvc {\n \t\treturn myMdmLinkFactory.newMdmLink();\n \t}\n \n+\tpublic Optional<MdmLink> getMatchedOrPossibleMatchedLinkForSource(IAnyResource theResource) {\n+\t\t// TODO KHS instead of two queries, just do one query with an OR\n+\t\tOptional<MdmLink> retval = getMatchedLinkForSource(theResource);\n+\t\tif (!retval.isPresent()) {\n+\t\t\tretval = getPossibleMatchedLinkForSource(theResource);\n+\t\t}\n+\t\treturn retval;\n+\t}\n }\n", "next_change": {"commit": "54f578c8b1b17a048c2d1498dfd739a6fdb84bd2", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nindex 9c54828efd..705f4f71f6 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n", "chunk": "@@ -317,4 +381,13 @@ public class MdmLinkDaoSvc {\n \t\t}\n \t\treturn retval;\n \t}\n+\n+\tpublic Optional<MdmLink> getLinkByGoldenResourceAndSourceResource(@Nullable IAnyResource theGoldenResource, @Nullable IAnyResource theSourceResource) {\n+\t\tif (theGoldenResource == null || theSourceResource == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\treturn getLinkByGoldenResourcePidAndSourceResourcePid(\n+\t\t\tmyJpaIdHelperService.getPidOrNull(theGoldenResource),\n+\t\t\tmyJpaIdHelperService.getPidOrNull(theSourceResource));\n+\t}\n }\n", "next_change": {"commit": "49d298dba187d87b348add536bab90395fc7c350", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nindex 705f4f71f6..88e73b3799 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n", "chunk": "@@ -390,4 +387,14 @@ public class MdmLinkDaoSvc {\n \t\t\tmyJpaIdHelperService.getPidOrNull(theGoldenResource),\n \t\t\tmyJpaIdHelperService.getPidOrNull(theSourceResource));\n \t}\n+\n+\t@Transactional(propagation = Propagation.MANDATORY)\n+\tpublic void deleteLinksWithAnyReferenceToPids(List<Long> theGoldenResourcePids) {\n+\t\t// Split into chunks of 500 so older versions of Oracle don't run into issues (500 = 1000 / 2 since the dao\n+\t\t// method uses the list twice in the sql predicate)\n+\t\tList<List<Long>> chunks = ListUtils.partition(theGoldenResourcePids, 500);\n+\t\tfor (List<Long> chunk : chunks) {\n+\t\t\tmyMdmLinkDao.deleteLinksWithAnyReferenceToPids(chunk);\n+\t\t}\n+\t}\n }\n", "next_change": {"commit": "f933ff3d9cae019bc1da91c4969e463da119e7f4", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nindex 88e73b3799..be33dc9177 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n", "chunk": "@@ -364,37 +343,32 @@ public class MdmLinkDaoSvc {\n \t * Factory delegation method, whenever you need a new MdmLink, use this factory method.\n \t * //TODO Should we make the constructor private for MdmLink? or work out some way to ensure they can only be instantiated via factory.\n \t *\n-\t * @return A new {@link MdmLink}.\n+\t * @return A new {@link IMdmLink}.\n \t */\n-\tpublic MdmLink newMdmLink() {\n+\tpublic IMdmLink newMdmLink() {\n \t\treturn myMdmLinkFactory.newMdmLink();\n \t}\n \n-\tpublic Optional<MdmLink> getMatchedOrPossibleMatchedLinkForSource(IAnyResource theResource) {\n+\tpublic Optional<? extends IMdmLink> getMatchedOrPossibleMatchedLinkForSource(IAnyResource theResource) {\n \t\t// TODO KHS instead of two queries, just do one query with an OR\n-\t\tOptional<MdmLink> retval = getMatchedLinkForSource(theResource);\n+\t\tOptional<? extends IMdmLink> retval = getMatchedLinkForSource(theResource);\n \t\tif (!retval.isPresent()) {\n \t\t\tretval = getPossibleMatchedLinkForSource(theResource);\n \t\t}\n \t\treturn retval;\n \t}\n \n-\tpublic Optional<MdmLink> getLinkByGoldenResourceAndSourceResource(@Nullable IAnyResource theGoldenResource, @Nullable IAnyResource theSourceResource) {\n+\tpublic Optional<? extends IMdmLink> getLinkByGoldenResourceAndSourceResource(@Nullable IAnyResource theGoldenResource, @Nullable IAnyResource theSourceResource) {\n \t\tif (theGoldenResource == null || theSourceResource == null) {\n \t\t\treturn Optional.empty();\n \t\t}\n \t\treturn getLinkByGoldenResourcePidAndSourceResourcePid(\n-\t\t\tmyJpaIdHelperService.getPidOrNull(theGoldenResource),\n-\t\t\tmyJpaIdHelperService.getPidOrNull(theSourceResource));\n+\t\t\tmyIdHelperService.getPidOrNull(RequestPartitionId.allPartitions(), theGoldenResource),\n+\t\t\tmyIdHelperService.getPidOrNull(RequestPartitionId.allPartitions(), theSourceResource));\n \t}\n \n \t@Transactional(propagation = Propagation.MANDATORY)\n-\tpublic void deleteLinksWithAnyReferenceToPids(List<Long> theGoldenResourcePids) {\n-\t\t// Split into chunks of 500 so older versions of Oracle don't run into issues (500 = 1000 / 2 since the dao\n-\t\t// method uses the list twice in the sql predicate)\n-\t\tList<List<Long>> chunks = ListUtils.partition(theGoldenResourcePids, 500);\n-\t\tfor (List<Long> chunk : chunks) {\n-\t\t\tmyMdmLinkDao.deleteLinksWithAnyReferenceToPids(chunk);\n-\t\t}\n+\tpublic void deleteLinksWithAnyReferenceToPids(List<ResourcePersistentId> theGoldenResourcePids) {\n+\t\tmyMdmLinkDao.deleteLinksWithAnyReferenceToPids(theGoldenResourcePids);\n \t}\n }\n", "next_change": {"commit": "017cc4e29c2e780ac48521827f0b3ede00a83bbe", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nindex be33dc9177..a8adb68293 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n", "chunk": "@@ -368,7 +375,7 @@ public class MdmLinkDaoSvc {\n \t}\n \n \t@Transactional(propagation = Propagation.MANDATORY)\n-\tpublic void deleteLinksWithAnyReferenceToPids(List<ResourcePersistentId> theGoldenResourcePids) {\n+\tpublic void deleteLinksWithAnyReferenceToPids(List<P> theGoldenResourcePids) {\n \t\tmyMdmLinkDao.deleteLinksWithAnyReferenceToPids(theGoldenResourcePids);\n \t}\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMTQ2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537711465", "body": "What's the plan with these TODOs?  Will they be addressed in a future PR?", "bodyText": "What's the plan with these TODOs?  Will they be addressed in a future PR?", "bodyHTML": "<p dir=\"auto\">What's the plan with these TODOs?  Will they be addressed in a future PR?</p>", "author": "fil512", "createdAt": "2020-12-07T17:58:49Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java", "diffHunk": "@@ -45,72 +45,71 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n @Service\n-public class EmpiStorageInterceptor implements IEmpiStorageInterceptor {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiStorageInterceptor.class);\n+public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n \t@Autowired\n \tprivate ExpungeEverythingService myExpungeEverythingService;\n \t@Autowired\n-\tprivate EmpiLinkDeleteSvc myEmpiLinkDeleteSvc;\n+\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n \t@Autowired\n \tprivate FhirContext myFhirContext;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n-\tpublic void blockManualPersonManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n \t\t\tforbidIfHasMultipleEids(theBaseResource);\n \t\t}\n \n-\t\t// TODO EMPI find a better way to identify EMPI calls\n+\t\t// TODO GGG MDM find a better way to identify i nternal calls?\n \t\tif (isInternalRequest(theRequestDetails)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tforbidIfEmpiManagedTagIsPresent(theBaseResource);\n+\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n \t}\n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n-\tpublic void blockManualPersonManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theNewResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\n+\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theNewResource);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\tif (EmpiUtil.isEmpiManagedPerson(myFhirContext, theNewResource) &&\n-\t\t\tmyPersonHelper.isDeactivated(theNewResource)) {\n-\t\t\tourLog.debug(\"Deleting empi links to deactivated Person {}\", theNewResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myEmpiLinkDeleteSvc.deleteNonRedirectWithWithAnyReferenceTo(theNewResource);\n+\t\t//TODO GGG MDM: Check if this is actually handled already in mdm update code or not.", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb429b319b4164f72588810ac9102e240161803", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nindex 7481cc148c..ba5d09ae97 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n", "chunk": "@@ -84,10 +84,9 @@ public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n \t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\t//TODO GGG MDM: Check if this is actually handled already in mdm update code or not.\n \t\tif (myGoldenResourceHelper.isDeactivated(theUpdatedResource)) {\n \t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithWithAnyReferenceTo(theUpdatedResource);\n+\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n \t\t\tif (deleted > 0) {\n \t\t\t\tourLog.debug(\"Deleted {} MDM links\", deleted);\n \t\t\t}\n", "next_change": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nindex ba5d09ae97..52f9ae3bc1 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n", "chunk": "@@ -84,7 +84,7 @@ public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n \t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\tif (myGoldenResourceHelper.isDeactivated(theUpdatedResource)) {\n+\t\tif (MdmResourceUtil.isGoldenRecordRedirected(theUpdatedResource)) {\n \t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n \t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n \t\t\tif (deleted > 0) {\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\ndeleted file mode 100644\nindex 52f9ae3bc1..0000000000\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-package ca.uhn.fhir.jpa.mdm.interceptor;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.mdm.api.MdmConstants;\n-import ca.uhn.fhir.mdm.api.IMdmSettings;\n-import ca.uhn.fhir.mdm.model.CanonicalEID;\n-import ca.uhn.fhir.mdm.util.EIDHelper;\n-import ca.uhn.fhir.mdm.util.MdmResourceUtil;\n-import ca.uhn.fhir.mdm.util.GoldenResourceHelper;\n-import ca.uhn.fhir.interceptor.api.Hook;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n-import ca.uhn.fhir.jpa.dao.mdm.MdmLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.dao.expunge.ExpungeEverythingService;\n-import ca.uhn.fhir.jpa.entity.MdmLink;\n-import ca.uhn.fhir.rest.api.server.RequestDetails;\n-import ca.uhn.fhir.rest.server.exceptions.ForbiddenOperationException;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-@Service\n-public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n-\t@Autowired\n-\tprivate ExpungeEverythingService myExpungeEverythingService;\n-\t@Autowired\n-\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n-\t@Autowired\n-\tprivate GoldenResourceHelper myGoldenResourceHelper;\n-\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n-\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\n-\t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theBaseResource);\n-\t\t}\n-\n-\t\t// TODO GGG MDM find a better way to identify internal calls?\n-\t\tif (isInternalRequest(theRequestDetails)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n-\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n-\t\t}\n-\n-\t\tif (MdmResourceUtil.isGoldenRecordRedirected(theUpdatedResource)) {\n-\t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n-\t\t\tif (deleted > 0) {\n-\t\t\t\tourLog.debug(\"Deleted {} MDM links\", deleted);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (isInternalRequest(theRequestDetails)) {\n-\t\t\treturn;\n-\t\t}\n-\t\tforbidIfMdmManagedTagIsPresent(theOldResource);\n-\t\tforbidModifyingMdmTag(theUpdatedResource, theOldResource);\n-\n-\t\tif (myMdmSettings.isPreventEidUpdates()) {\n-\t\t\tforbidIfModifyingExternalEidOnTarget(theUpdatedResource, theOldResource);\n-\t\t}\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_DELETED)\n-\tpublic void deleteMdmLinks(RequestDetails theRequest, IBaseResource theResource) {\n-\t\tif (!myMdmSettings.isSupportedMdmType(myFhirContext.getResourceType(theResource))) {\n-\t\t\treturn;\n-\t\t}\n-\t\tmyMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource);\n-\t}\n-\n-\tprivate void forbidIfModifyingExternalEidOnTarget(IBaseResource theNewResource, IBaseResource theOldResource) {\n-\t\tList<CanonicalEID> newExternalEids = myEIDHelper.getExternalEid(theNewResource);\n-\t\tList<CanonicalEID> oldExternalEids = myEIDHelper.getExternalEid(theOldResource);\n-\t\tif (oldExternalEids.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (!myEIDHelper.eidMatchExists(newExternalEids, oldExternalEids)) {\n-\t\t\tthrowBlockEidChange();\n-\t\t}\n-\t}\n-\n-\tprivate void throwBlockEidChange() {\n-\t\tthrow new ForbiddenOperationException(\"While running with EID updates disabled, EIDs may not be updated on source resources\");\n-\t}\n-\n-\t/*\n-\t * Will throw a forbidden error if a request attempts to add/remove the MDM tag on a Resource.\n-\t */\n-\tprivate void forbidModifyingMdmTag(IBaseResource theNewResource, IBaseResource theOldResource) {\n-\t\tif (MdmResourceUtil.isMdmManaged(theNewResource) != MdmResourceUtil.isMdmManaged(theOldResource)) {\n-\t\t\tthrowBlockMdmManagedTagChange();\n-\t\t}\n-\t}\n-\n-\tprivate void forbidIfHasMultipleEids(IBaseResource theResource) {\n-\t\tString resourceType = extractResourceType(theResource);\n-\t\tif (myMdmSettings.isSupportedMdmType(resourceType)) {\n-\t\t\tif (myEIDHelper.getExternalEid(theResource).size() > 1) {\n-\t\t\t\tthrowBlockMultipleEids();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/*\n-\t * We assume that if we have RequestDetails, then this was an HTTP request and not an internal one.\n-\t */\n-\tprivate boolean isInternalRequest(RequestDetails theRequestDetails) {\n-\t\treturn theRequestDetails == null;\n-\t}\n-\n-\tprivate void forbidIfMdmManagedTagIsPresent(IBaseResource theResource) {\n-\t\tif (MdmResourceUtil.isMdmManaged(theResource)) {\n-\t\t\tthrowModificationBlockedByMdm();\n-\t\t}\n-\t\tif (MdmResourceUtil.hasGoldenRecordSystemTag(theResource)) {\n-\t\t\tthrowModificationBlockedByMdm();\n-\t\t}\n-\t}\n-\n-\tprivate void throwBlockMdmManagedTagChange() {\n-\t\tthrow new ForbiddenOperationException(\"The \" + MdmConstants.CODE_HAPI_MDM_MANAGED + \" tag on a resource may not be changed once created.\");\n-\t}\n-\n-\tprivate void throwModificationBlockedByMdm() {\n-\t\tthrow new ForbiddenOperationException(\"Cannot create or modify Resources that are managed by MDM. This resource contains a tag with one of these systems: \" + MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS + \" or \" + MdmConstants.SYSTEM_MDM_MANAGED);\n-\t}\n-\n-\tprivate void throwBlockMultipleEids() {\n-\t\tthrow new ForbiddenOperationException(\"While running with multiple EIDs disabled, source resources may have at most one EID.\");\n-\t}\n-\n-\tprivate String extractResourceType(IBaseResource theResource) {\n-\t\treturn myFhirContext.getResourceType(theResource);\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_EVERYTHING)\n-\tpublic void expungeAllMdmLinks(AtomicInteger theCounter) {\n-\t\tourLog.debug(\"Expunging all MdmLink records\");\n-\t\ttheCounter.addAndGet(myExpungeEverythingService.expungeEverythingByType(MdmLink.class));\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_RESOURCE)\n-\tpublic void expungeAllMatchedMdmLinks(AtomicInteger theCounter, IBaseResource theResource) {\n-\t\tourLog.debug(\"Expunging MdmLink records with reference to {}\", theResource.getIdElement());\n-\t\ttheCounter.addAndGet(myMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource));\n-\t}\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nnew file mode 100644\nindex 0000000000..52f9ae3bc1\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n", "chunk": "@@ -0,0 +1,191 @@\n+package ca.uhn.fhir.jpa.mdm.interceptor;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.util.EIDHelper;\n+import ca.uhn.fhir.mdm.util.MdmResourceUtil;\n+import ca.uhn.fhir.mdm.util.GoldenResourceHelper;\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.jpa.dao.mdm.MdmLinkDeleteSvc;\n+import ca.uhn.fhir.jpa.dao.expunge.ExpungeEverythingService;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.rest.api.server.RequestDetails;\n+import ca.uhn.fhir.rest.server.exceptions.ForbiddenOperationException;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Service\n+public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n+\t@Autowired\n+\tprivate ExpungeEverythingService myExpungeEverythingService;\n+\t@Autowired\n+\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n+\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n+\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\n+\t\t//If running in single EID mode, forbid multiple eids.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theBaseResource);\n+\t\t}\n+\n+\t\t// TODO GGG MDM find a better way to identify internal calls?\n+\t\tif (isInternalRequest(theRequestDetails)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n+\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\t\t//If running in single EID mode, forbid multiple eids.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n+\t\t}\n+\n+\t\tif (MdmResourceUtil.isGoldenRecordRedirected(theUpdatedResource)) {\n+\t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n+\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n+\t\t\tif (deleted > 0) {\n+\t\t\t\tourLog.debug(\"Deleted {} MDM links\", deleted);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (isInternalRequest(theRequestDetails)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tforbidIfMdmManagedTagIsPresent(theOldResource);\n+\t\tforbidModifyingMdmTag(theUpdatedResource, theOldResource);\n+\n+\t\tif (myMdmSettings.isPreventEidUpdates()) {\n+\t\t\tforbidIfModifyingExternalEidOnTarget(theUpdatedResource, theOldResource);\n+\t\t}\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_DELETED)\n+\tpublic void deleteMdmLinks(RequestDetails theRequest, IBaseResource theResource) {\n+\t\tif (!myMdmSettings.isSupportedMdmType(myFhirContext.getResourceType(theResource))) {\n+\t\t\treturn;\n+\t\t}\n+\t\tmyMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource);\n+\t}\n+\n+\tprivate void forbidIfModifyingExternalEidOnTarget(IBaseResource theNewResource, IBaseResource theOldResource) {\n+\t\tList<CanonicalEID> newExternalEids = myEIDHelper.getExternalEid(theNewResource);\n+\t\tList<CanonicalEID> oldExternalEids = myEIDHelper.getExternalEid(theOldResource);\n+\t\tif (oldExternalEids.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (!myEIDHelper.eidMatchExists(newExternalEids, oldExternalEids)) {\n+\t\t\tthrowBlockEidChange();\n+\t\t}\n+\t}\n+\n+\tprivate void throwBlockEidChange() {\n+\t\tthrow new ForbiddenOperationException(\"While running with EID updates disabled, EIDs may not be updated on source resources\");\n+\t}\n+\n+\t/*\n+\t * Will throw a forbidden error if a request attempts to add/remove the MDM tag on a Resource.\n+\t */\n+\tprivate void forbidModifyingMdmTag(IBaseResource theNewResource, IBaseResource theOldResource) {\n+\t\tif (MdmResourceUtil.isMdmManaged(theNewResource) != MdmResourceUtil.isMdmManaged(theOldResource)) {\n+\t\t\tthrowBlockMdmManagedTagChange();\n+\t\t}\n+\t}\n+\n+\tprivate void forbidIfHasMultipleEids(IBaseResource theResource) {\n+\t\tString resourceType = extractResourceType(theResource);\n+\t\tif (myMdmSettings.isSupportedMdmType(resourceType)) {\n+\t\t\tif (myEIDHelper.getExternalEid(theResource).size() > 1) {\n+\t\t\t\tthrowBlockMultipleEids();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * We assume that if we have RequestDetails, then this was an HTTP request and not an internal one.\n+\t */\n+\tprivate boolean isInternalRequest(RequestDetails theRequestDetails) {\n+\t\treturn theRequestDetails == null;\n+\t}\n+\n+\tprivate void forbidIfMdmManagedTagIsPresent(IBaseResource theResource) {\n+\t\tif (MdmResourceUtil.isMdmManaged(theResource)) {\n+\t\t\tthrowModificationBlockedByMdm();\n+\t\t}\n+\t\tif (MdmResourceUtil.hasGoldenRecordSystemTag(theResource)) {\n+\t\t\tthrowModificationBlockedByMdm();\n+\t\t}\n+\t}\n+\n+\tprivate void throwBlockMdmManagedTagChange() {\n+\t\tthrow new ForbiddenOperationException(\"The \" + MdmConstants.CODE_HAPI_MDM_MANAGED + \" tag on a resource may not be changed once created.\");\n+\t}\n+\n+\tprivate void throwModificationBlockedByMdm() {\n+\t\tthrow new ForbiddenOperationException(\"Cannot create or modify Resources that are managed by MDM. This resource contains a tag with one of these systems: \" + MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS + \" or \" + MdmConstants.SYSTEM_MDM_MANAGED);\n+\t}\n+\n+\tprivate void throwBlockMultipleEids() {\n+\t\tthrow new ForbiddenOperationException(\"While running with multiple EIDs disabled, source resources may have at most one EID.\");\n+\t}\n+\n+\tprivate String extractResourceType(IBaseResource theResource) {\n+\t\treturn myFhirContext.getResourceType(theResource);\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_EVERYTHING)\n+\tpublic void expungeAllMdmLinks(AtomicInteger theCounter) {\n+\t\tourLog.debug(\"Expunging all MdmLink records\");\n+\t\ttheCounter.addAndGet(myExpungeEverythingService.expungeEverythingByType(MdmLink.class));\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_RESOURCE)\n+\tpublic void expungeAllMatchedMdmLinks(AtomicInteger theCounter, IBaseResource theResource) {\n+\t\tourLog.debug(\"Expunging MdmLink records with reference to {}\", theResource.getIdElement());\n+\t\ttheCounter.addAndGet(myMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource));\n+\t}\n+}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMzkxMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537713910", "body": "I was initially thrown by the term \"deactivated\" but I think it's a good term here.  It does make me wonder if there's a better one.  What do other mdm systems call this...?", "bodyText": "I was initially thrown by the term \"deactivated\" but I think it's a good term here.  It does make me wonder if there's a better one.  What do other mdm systems call this...?", "bodyHTML": "<p dir=\"auto\">I was initially thrown by the term \"deactivated\" but I think it's a good term here.  It does make me wonder if there's a better one.  What do other mdm systems call this...?</p>", "author": "fil512", "createdAt": "2020-12-07T18:02:10Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java", "diffHunk": "@@ -45,72 +45,71 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n @Service\n-public class EmpiStorageInterceptor implements IEmpiStorageInterceptor {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiStorageInterceptor.class);\n+public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n \t@Autowired\n \tprivate ExpungeEverythingService myExpungeEverythingService;\n \t@Autowired\n-\tprivate EmpiLinkDeleteSvc myEmpiLinkDeleteSvc;\n+\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n \t@Autowired\n \tprivate FhirContext myFhirContext;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n-\tpublic void blockManualPersonManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n \t\t\tforbidIfHasMultipleEids(theBaseResource);\n \t\t}\n \n-\t\t// TODO EMPI find a better way to identify EMPI calls\n+\t\t// TODO GGG MDM find a better way to identify i nternal calls?\n \t\tif (isInternalRequest(theRequestDetails)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tforbidIfEmpiManagedTagIsPresent(theBaseResource);\n+\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n \t}\n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n-\tpublic void blockManualPersonManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theNewResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\n+\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theNewResource);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\tif (EmpiUtil.isEmpiManagedPerson(myFhirContext, theNewResource) &&\n-\t\t\tmyPersonHelper.isDeactivated(theNewResource)) {\n-\t\t\tourLog.debug(\"Deleting empi links to deactivated Person {}\", theNewResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myEmpiLinkDeleteSvc.deleteNonRedirectWithWithAnyReferenceTo(theNewResource);\n+\t\t//TODO GGG MDM: Check if this is actually handled already in mdm update code or not.\n+\t\tif (myGoldenResourceHelper.isDeactivated(theUpdatedResource)) {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb429b319b4164f72588810ac9102e240161803", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nindex 7481cc148c..ba5d09ae97 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n", "chunk": "@@ -84,10 +84,9 @@ public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n \t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\t//TODO GGG MDM: Check if this is actually handled already in mdm update code or not.\n \t\tif (myGoldenResourceHelper.isDeactivated(theUpdatedResource)) {\n \t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithWithAnyReferenceTo(theUpdatedResource);\n+\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n \t\t\tif (deleted > 0) {\n \t\t\t\tourLog.debug(\"Deleted {} MDM links\", deleted);\n \t\t\t}\n", "next_change": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nindex ba5d09ae97..52f9ae3bc1 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n", "chunk": "@@ -84,7 +84,7 @@ public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n \t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\tif (myGoldenResourceHelper.isDeactivated(theUpdatedResource)) {\n+\t\tif (MdmResourceUtil.isGoldenRecordRedirected(theUpdatedResource)) {\n \t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n \t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n \t\t\tif (deleted > 0) {\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\ndeleted file mode 100644\nindex 52f9ae3bc1..0000000000\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-package ca.uhn.fhir.jpa.mdm.interceptor;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.mdm.api.MdmConstants;\n-import ca.uhn.fhir.mdm.api.IMdmSettings;\n-import ca.uhn.fhir.mdm.model.CanonicalEID;\n-import ca.uhn.fhir.mdm.util.EIDHelper;\n-import ca.uhn.fhir.mdm.util.MdmResourceUtil;\n-import ca.uhn.fhir.mdm.util.GoldenResourceHelper;\n-import ca.uhn.fhir.interceptor.api.Hook;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n-import ca.uhn.fhir.jpa.dao.mdm.MdmLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.dao.expunge.ExpungeEverythingService;\n-import ca.uhn.fhir.jpa.entity.MdmLink;\n-import ca.uhn.fhir.rest.api.server.RequestDetails;\n-import ca.uhn.fhir.rest.server.exceptions.ForbiddenOperationException;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-@Service\n-public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n-\t@Autowired\n-\tprivate ExpungeEverythingService myExpungeEverythingService;\n-\t@Autowired\n-\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n-\t@Autowired\n-\tprivate GoldenResourceHelper myGoldenResourceHelper;\n-\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n-\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\n-\t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theBaseResource);\n-\t\t}\n-\n-\t\t// TODO GGG MDM find a better way to identify internal calls?\n-\t\tif (isInternalRequest(theRequestDetails)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n-\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n-\t\t}\n-\n-\t\tif (MdmResourceUtil.isGoldenRecordRedirected(theUpdatedResource)) {\n-\t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n-\t\t\tif (deleted > 0) {\n-\t\t\t\tourLog.debug(\"Deleted {} MDM links\", deleted);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (isInternalRequest(theRequestDetails)) {\n-\t\t\treturn;\n-\t\t}\n-\t\tforbidIfMdmManagedTagIsPresent(theOldResource);\n-\t\tforbidModifyingMdmTag(theUpdatedResource, theOldResource);\n-\n-\t\tif (myMdmSettings.isPreventEidUpdates()) {\n-\t\t\tforbidIfModifyingExternalEidOnTarget(theUpdatedResource, theOldResource);\n-\t\t}\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_DELETED)\n-\tpublic void deleteMdmLinks(RequestDetails theRequest, IBaseResource theResource) {\n-\t\tif (!myMdmSettings.isSupportedMdmType(myFhirContext.getResourceType(theResource))) {\n-\t\t\treturn;\n-\t\t}\n-\t\tmyMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource);\n-\t}\n-\n-\tprivate void forbidIfModifyingExternalEidOnTarget(IBaseResource theNewResource, IBaseResource theOldResource) {\n-\t\tList<CanonicalEID> newExternalEids = myEIDHelper.getExternalEid(theNewResource);\n-\t\tList<CanonicalEID> oldExternalEids = myEIDHelper.getExternalEid(theOldResource);\n-\t\tif (oldExternalEids.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (!myEIDHelper.eidMatchExists(newExternalEids, oldExternalEids)) {\n-\t\t\tthrowBlockEidChange();\n-\t\t}\n-\t}\n-\n-\tprivate void throwBlockEidChange() {\n-\t\tthrow new ForbiddenOperationException(\"While running with EID updates disabled, EIDs may not be updated on source resources\");\n-\t}\n-\n-\t/*\n-\t * Will throw a forbidden error if a request attempts to add/remove the MDM tag on a Resource.\n-\t */\n-\tprivate void forbidModifyingMdmTag(IBaseResource theNewResource, IBaseResource theOldResource) {\n-\t\tif (MdmResourceUtil.isMdmManaged(theNewResource) != MdmResourceUtil.isMdmManaged(theOldResource)) {\n-\t\t\tthrowBlockMdmManagedTagChange();\n-\t\t}\n-\t}\n-\n-\tprivate void forbidIfHasMultipleEids(IBaseResource theResource) {\n-\t\tString resourceType = extractResourceType(theResource);\n-\t\tif (myMdmSettings.isSupportedMdmType(resourceType)) {\n-\t\t\tif (myEIDHelper.getExternalEid(theResource).size() > 1) {\n-\t\t\t\tthrowBlockMultipleEids();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/*\n-\t * We assume that if we have RequestDetails, then this was an HTTP request and not an internal one.\n-\t */\n-\tprivate boolean isInternalRequest(RequestDetails theRequestDetails) {\n-\t\treturn theRequestDetails == null;\n-\t}\n-\n-\tprivate void forbidIfMdmManagedTagIsPresent(IBaseResource theResource) {\n-\t\tif (MdmResourceUtil.isMdmManaged(theResource)) {\n-\t\t\tthrowModificationBlockedByMdm();\n-\t\t}\n-\t\tif (MdmResourceUtil.hasGoldenRecordSystemTag(theResource)) {\n-\t\t\tthrowModificationBlockedByMdm();\n-\t\t}\n-\t}\n-\n-\tprivate void throwBlockMdmManagedTagChange() {\n-\t\tthrow new ForbiddenOperationException(\"The \" + MdmConstants.CODE_HAPI_MDM_MANAGED + \" tag on a resource may not be changed once created.\");\n-\t}\n-\n-\tprivate void throwModificationBlockedByMdm() {\n-\t\tthrow new ForbiddenOperationException(\"Cannot create or modify Resources that are managed by MDM. This resource contains a tag with one of these systems: \" + MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS + \" or \" + MdmConstants.SYSTEM_MDM_MANAGED);\n-\t}\n-\n-\tprivate void throwBlockMultipleEids() {\n-\t\tthrow new ForbiddenOperationException(\"While running with multiple EIDs disabled, source resources may have at most one EID.\");\n-\t}\n-\n-\tprivate String extractResourceType(IBaseResource theResource) {\n-\t\treturn myFhirContext.getResourceType(theResource);\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_EVERYTHING)\n-\tpublic void expungeAllMdmLinks(AtomicInteger theCounter) {\n-\t\tourLog.debug(\"Expunging all MdmLink records\");\n-\t\ttheCounter.addAndGet(myExpungeEverythingService.expungeEverythingByType(MdmLink.class));\n-\t}\n-\n-\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_RESOURCE)\n-\tpublic void expungeAllMatchedMdmLinks(AtomicInteger theCounter, IBaseResource theResource) {\n-\t\tourLog.debug(\"Expunging MdmLink records with reference to {}\", theResource.getIdElement());\n-\t\ttheCounter.addAndGet(myMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource));\n-\t}\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nnew file mode 100644\nindex 0000000000..52f9ae3bc1\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n", "chunk": "@@ -0,0 +1,191 @@\n+package ca.uhn.fhir.jpa.mdm.interceptor;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.util.EIDHelper;\n+import ca.uhn.fhir.mdm.util.MdmResourceUtil;\n+import ca.uhn.fhir.mdm.util.GoldenResourceHelper;\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.jpa.dao.mdm.MdmLinkDeleteSvc;\n+import ca.uhn.fhir.jpa.dao.expunge.ExpungeEverythingService;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.rest.api.server.RequestDetails;\n+import ca.uhn.fhir.rest.server.exceptions.ForbiddenOperationException;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Service\n+public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n+\t@Autowired\n+\tprivate ExpungeEverythingService myExpungeEverythingService;\n+\t@Autowired\n+\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n+\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n+\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\n+\t\t//If running in single EID mode, forbid multiple eids.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theBaseResource);\n+\t\t}\n+\n+\t\t// TODO GGG MDM find a better way to identify internal calls?\n+\t\tif (isInternalRequest(theRequestDetails)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n+\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\t\t//If running in single EID mode, forbid multiple eids.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n+\t\t}\n+\n+\t\tif (MdmResourceUtil.isGoldenRecordRedirected(theUpdatedResource)) {\n+\t\t\tourLog.debug(\"Deleting MDM links to deactivated Golden resource {}\", theUpdatedResource.getIdElement().toUnqualifiedVersionless());\n+\t\t\tint deleted = myMdmLinkDeleteSvc.deleteNonRedirectWithAnyReferenceTo(theUpdatedResource);\n+\t\t\tif (deleted > 0) {\n+\t\t\t\tourLog.debug(\"Deleted {} MDM links\", deleted);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (isInternalRequest(theRequestDetails)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tforbidIfMdmManagedTagIsPresent(theOldResource);\n+\t\tforbidModifyingMdmTag(theUpdatedResource, theOldResource);\n+\n+\t\tif (myMdmSettings.isPreventEidUpdates()) {\n+\t\t\tforbidIfModifyingExternalEidOnTarget(theUpdatedResource, theOldResource);\n+\t\t}\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_DELETED)\n+\tpublic void deleteMdmLinks(RequestDetails theRequest, IBaseResource theResource) {\n+\t\tif (!myMdmSettings.isSupportedMdmType(myFhirContext.getResourceType(theResource))) {\n+\t\t\treturn;\n+\t\t}\n+\t\tmyMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource);\n+\t}\n+\n+\tprivate void forbidIfModifyingExternalEidOnTarget(IBaseResource theNewResource, IBaseResource theOldResource) {\n+\t\tList<CanonicalEID> newExternalEids = myEIDHelper.getExternalEid(theNewResource);\n+\t\tList<CanonicalEID> oldExternalEids = myEIDHelper.getExternalEid(theOldResource);\n+\t\tif (oldExternalEids.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (!myEIDHelper.eidMatchExists(newExternalEids, oldExternalEids)) {\n+\t\t\tthrowBlockEidChange();\n+\t\t}\n+\t}\n+\n+\tprivate void throwBlockEidChange() {\n+\t\tthrow new ForbiddenOperationException(\"While running with EID updates disabled, EIDs may not be updated on source resources\");\n+\t}\n+\n+\t/*\n+\t * Will throw a forbidden error if a request attempts to add/remove the MDM tag on a Resource.\n+\t */\n+\tprivate void forbidModifyingMdmTag(IBaseResource theNewResource, IBaseResource theOldResource) {\n+\t\tif (MdmResourceUtil.isMdmManaged(theNewResource) != MdmResourceUtil.isMdmManaged(theOldResource)) {\n+\t\t\tthrowBlockMdmManagedTagChange();\n+\t\t}\n+\t}\n+\n+\tprivate void forbidIfHasMultipleEids(IBaseResource theResource) {\n+\t\tString resourceType = extractResourceType(theResource);\n+\t\tif (myMdmSettings.isSupportedMdmType(resourceType)) {\n+\t\t\tif (myEIDHelper.getExternalEid(theResource).size() > 1) {\n+\t\t\t\tthrowBlockMultipleEids();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * We assume that if we have RequestDetails, then this was an HTTP request and not an internal one.\n+\t */\n+\tprivate boolean isInternalRequest(RequestDetails theRequestDetails) {\n+\t\treturn theRequestDetails == null;\n+\t}\n+\n+\tprivate void forbidIfMdmManagedTagIsPresent(IBaseResource theResource) {\n+\t\tif (MdmResourceUtil.isMdmManaged(theResource)) {\n+\t\t\tthrowModificationBlockedByMdm();\n+\t\t}\n+\t\tif (MdmResourceUtil.hasGoldenRecordSystemTag(theResource)) {\n+\t\t\tthrowModificationBlockedByMdm();\n+\t\t}\n+\t}\n+\n+\tprivate void throwBlockMdmManagedTagChange() {\n+\t\tthrow new ForbiddenOperationException(\"The \" + MdmConstants.CODE_HAPI_MDM_MANAGED + \" tag on a resource may not be changed once created.\");\n+\t}\n+\n+\tprivate void throwModificationBlockedByMdm() {\n+\t\tthrow new ForbiddenOperationException(\"Cannot create or modify Resources that are managed by MDM. This resource contains a tag with one of these systems: \" + MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS + \" or \" + MdmConstants.SYSTEM_MDM_MANAGED);\n+\t}\n+\n+\tprivate void throwBlockMultipleEids() {\n+\t\tthrow new ForbiddenOperationException(\"While running with multiple EIDs disabled, source resources may have at most one EID.\");\n+\t}\n+\n+\tprivate String extractResourceType(IBaseResource theResource) {\n+\t\treturn myFhirContext.getResourceType(theResource);\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_EVERYTHING)\n+\tpublic void expungeAllMdmLinks(AtomicInteger theCounter) {\n+\t\tourLog.debug(\"Expunging all MdmLink records\");\n+\t\ttheCounter.addAndGet(myExpungeEverythingService.expungeEverythingByType(MdmLink.class));\n+\t}\n+\n+\t@Hook(Pointcut.STORAGE_PRESTORAGE_EXPUNGE_RESOURCE)\n+\tpublic void expungeAllMatchedMdmLinks(AtomicInteger theCounter, IBaseResource theResource) {\n+\t\tourLog.debug(\"Expunging MdmLink records with reference to {}\", theResource.getIdElement());\n+\t\ttheCounter.addAndGet(myMdmLinkDeleteSvc.deleteWithAnyReferenceTo(theResource));\n+\t}\n+}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxNjg5Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537716893", "body": "hmm.  I don't understand the question", "bodyText": "hmm.  I don't understand the question", "bodyHTML": "<p dir=\"auto\">hmm.  I don't understand the question</p>", "author": "fil512", "createdAt": "2020-12-07T18:06:43Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java", "diffHunk": "@@ -32,43 +33,48 @@\n import java.util.List;\n \n @Service\n-public class EmpiResourceFilteringSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmResourceFilteringSvc {\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n-\tEmpiSearchParamSvc myEmpiSearchParamSvc;\n+\tMdmSearchParamSvc myMdmSearchParamSvc;\n \t@Autowired\n \tFhirContext myFhirContext;\n \n \t/**\n-\t * Given a resource from the EMPI Channel, determine whether or not EMPI processing should occur on it.\n+\t * Given a resource from the MDM Channel, determine whether or not MDM processing should occur on it.\n \t *\n-\t * EMPI processing should occur if for any {@link EmpiResourceSearchParamJson) Search Param, the resource contains a value.\n+\t * MDM processing should occur if for any {@link MdmResourceSearchParamJson ) Search Param, the resource contains a value.\n \t *\n \t * If the resource has no attributes that appear in the candidate search params, processing should be skipped, as there is not\n-\t * sufficient information to perform meaningful EMPI processing. (For example, how can EMPI processing occur on a patient that has _no_ attributes?)\n+\t * sufficient information to perform meaningful MDM processing. (For example, how can MDM processing occur on a patient that has _no_ attributes?)\n \t *\n-\t * @param theResource the resource that you wish to check against EMPI rules.\n+\t * @param theResource the resource that you wish to check against MDM rules.\n \t *\n-\t * @return whether or not EMPI processing should proceed\n+\t * @return whether or not MDM processing should proceed\n \t */\n \tpublic boolean shouldBeProcessed(IAnyResource theResource) {\n+\t\t//TODO GGG ask KHS: Skip the infinite loop, whoops. Better way to do this? tighter subscription criteria?", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb429b319b4164f72588810ac9102e240161803", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\nindex 07e2b7298a..af7199ea0a 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n", "chunk": "@@ -56,11 +56,11 @@ public class MdmResourceFilteringSvc {\n \t * @return whether or not MDM processing should proceed\n \t */\n \tpublic boolean shouldBeProcessed(IAnyResource theResource) {\n-\t\t//TODO GGG ask KHS: Skip the infinite loop, whoops. Better way to do this? tighter subscription criteria?\n \t\tif (MdmUtil.isMdmManaged(theResource)) {\n \t\t\tourLog.debug(\"MDM Message handler is dropping [{}] as it is MDM-managed.\", theResource);\n \t\t\treturn false;\n \t\t}\n+\n \t\tString resourceType = myFhirContext.getResourceType(theResource);\n \t\tList<MdmResourceSearchParamJson> candidateSearchParams = myMdmSettings.getMdmRules().getCandidateSearchParams();\n \n", "next_change": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\nindex af7199ea0a..0cb449e406 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n", "chunk": "@@ -56,7 +56,7 @@ public class MdmResourceFilteringSvc {\n \t * @return whether or not MDM processing should proceed\n \t */\n \tpublic boolean shouldBeProcessed(IAnyResource theResource) {\n-\t\tif (MdmUtil.isMdmManaged(theResource)) {\n+\t\tif (MdmResourceUtil.isMdmManaged(theResource)) {\n \t\t\tourLog.debug(\"MDM Message handler is dropping [{}] as it is MDM-managed.\", theResource);\n \t\t\treturn false;\n \t\t}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceFilteringSvc.java\nsimilarity index 51%\nrename from hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceFilteringSvc.java\nindex 0cb449e406..040ea57521 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceFilteringSvc.java\n", "chunk": "@@ -33,48 +32,43 @@ import org.springframework.stereotype.Service;\n import java.util.List;\n \n @Service\n-public class MdmResourceFilteringSvc {\n-\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+public class EmpiResourceFilteringSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n \n \t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n+\tprivate IEmpiSettings myEmpiSettings;\n \t@Autowired\n-\tMdmSearchParamSvc myMdmSearchParamSvc;\n+\tEmpiSearchParamSvc myEmpiSearchParamSvc;\n \t@Autowired\n \tFhirContext myFhirContext;\n \n \t/**\n-\t * Given a resource from the MDM Channel, determine whether or not MDM processing should occur on it.\n+\t * Given a resource from the EMPI Channel, determine whether or not EMPI processing should occur on it.\n \t *\n-\t * MDM processing should occur if for any {@link MdmResourceSearchParamJson ) Search Param, the resource contains a value.\n+\t * EMPI processing should occur if for any {@link EmpiResourceSearchParamJson) Search Param, the resource contains a value.\n \t *\n \t * If the resource has no attributes that appear in the candidate search params, processing should be skipped, as there is not\n-\t * sufficient information to perform meaningful MDM processing. (For example, how can MDM processing occur on a patient that has _no_ attributes?)\n+\t * sufficient information to perform meaningful EMPI processing. (For example, how can EMPI processing occur on a patient that has _no_ attributes?)\n \t *\n-\t * @param theResource the resource that you wish to check against MDM rules.\n+\t * @param theResource the resource that you wish to check against EMPI rules.\n \t *\n-\t * @return whether or not MDM processing should proceed\n+\t * @return whether or not EMPI processing should proceed\n \t */\n \tpublic boolean shouldBeProcessed(IAnyResource theResource) {\n-\t\tif (MdmResourceUtil.isMdmManaged(theResource)) {\n-\t\t\tourLog.debug(\"MDM Message handler is dropping [{}] as it is MDM-managed.\", theResource);\n-\t\t\treturn false;\n-\t\t}\n-\n \t\tString resourceType = myFhirContext.getResourceType(theResource);\n-\t\tList<MdmResourceSearchParamJson> candidateSearchParams = myMdmSettings.getMdmRules().getCandidateSearchParams();\n+\t\tList<EmpiResourceSearchParamJson> candidateSearchParams = myEmpiSettings.getEmpiRules().getCandidateSearchParams();\n \n \t\tif (candidateSearchParams.isEmpty()) {\n \t\t\treturn true;\n \t\t}\n \n \t\tboolean containsValueForSomeSearchParam = candidateSearchParams.stream()\n-\t\t\t.filter(csp -> myMdmSearchParamSvc.searchParamTypeIsValidForResourceType(csp.getResourceType(), resourceType))\n+\t\t\t.filter(csp -> myEmpiSearchParamSvc.searchParamTypeIsValidForResourceType(csp.getResourceType(), resourceType))\n \t\t\t.flatMap(csp -> csp.getSearchParams().stream())\n-\t\t\t.map(searchParam -> myMdmSearchParamSvc.getValueFromResourceForSearchParam(theResource, searchParam))\n+\t\t\t.map(searchParam -> myEmpiSearchParamSvc.getValueFromResourceForSearchParam(theResource, searchParam))\n \t\t\t.anyMatch(valueList -> !valueList.isEmpty());\n \n-\t\tourLog.trace(\"Is {} suitable for MDM processing? : {}\", theResource.getId(), containsValueForSomeSearchParam);\n+\t\tourLog.trace(\"Is {} suitable for EMPI processing? : {}\", theResource.getId(), containsValueForSomeSearchParam);\n \t\treturn containsValueForSomeSearchParam;\n \t}\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxNzYwNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537717604", "body": "Consider renaming to `FindCandidateByExampleSvc`", "bodyText": "Consider renaming to FindCandidateByExampleSvc", "bodyHTML": "<p dir=\"auto\">Consider renaming to <code>FindCandidateByExampleSvc</code></p>", "author": "fil512", "createdAt": "2020-12-07T18:07:49Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByScoreSvc.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package ca.uhn.fhir.jpa.mdm.svc.candidate;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.api.IMdmMatchFinderSvc;\n+import ca.uhn.fhir.mdm.api.MatchedTarget;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.mdm.dao.MdmLinkDaoSvc;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class FindCandidateByScoreSvc extends BaseCandidateFinder {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMDAzMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537720030", "body": "delete this class", "bodyText": "delete this class", "bodyHTML": "<p dir=\"auto\">delete this class</p>", "author": "fil512", "createdAt": "2020-12-07T18:11:38Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/model/CanonicalIdentityAssuranceLevel.java", "diffHunk": "@@ -1,8 +1,8 @@\n-package ca.uhn.fhir.empi.model;\n+package ca.uhn.fhir.mdm.model;\n \n /*-\n  * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n+ * HAPI FHIR - Master Data Management", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMTI5Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537721293", "body": "Delete all mdm classes concerning assurance level", "bodyText": "Delete all mdm classes concerning assurance level", "bodyHTML": "<p dir=\"auto\">Delete all mdm classes concerning assurance level</p>", "author": "fil512", "createdAt": "2020-12-07T18:13:32Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/AssuranceLevelUtil.java", "diffHunk": "@@ -20,21 +20,21 @@\n  * #L%\n  */\n \n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n+import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.model.CanonicalIdentityAssuranceLevel;\n import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n \n /**\n  * Helper class to determine assurance level based on Link Source and Match Result.\n- * This is strictly for use in populating Person links.\n+ * This is strictly for use in populating Golden Resource links.\n  */\n public final class AssuranceLevelUtil {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDk0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537724948", "body": "Is this actually a `PrimitiveTypeEqualsPredicate` ?", "bodyText": "Is this actually a PrimitiveTypeEqualsPredicate ?", "bodyHTML": "<p dir=\"auto\">Is this actually a <code>PrimitiveTypeEqualsPredicate</code> ?</p>", "author": "fil512", "createdAt": "2020-12-07T18:19:12Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n+\t\t}\n+\t}\n+\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..fd1b385123 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -109,69 +108,10 @@ public class GoldenResourceHelper {\n \t\t}\n \n \t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n \n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n-\t}\n-\n-\t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n-\t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n-\t}\n-\n-\t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n-\t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo   Resource to clone the specified filed to\n-\t * @param field   Field name to be copied\n-\t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n-\n-\t\t\ttheToFieldValues.add(newFieldValue);\n-\t\t}\n-\t}\n-\n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n+\t\t// set identifier on the source resource\n+\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n \t}\n \n \tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\ndeleted file mode 100644\nindex fd1b385123..0000000000\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,278 +0,0 @@\n-package ca.uhn.fhir.mdm.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n-import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.context.FhirVersionEnum;\n-import ca.uhn.fhir.context.RuntimeResourceDefinition;\n-import ca.uhn.fhir.fhirpath.IFhirPath;\n-import ca.uhn.fhir.mdm.api.IMdmSettings;\n-import ca.uhn.fhir.mdm.log.Logs;\n-import ca.uhn.fhir.mdm.model.CanonicalEID;\n-import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n-import ca.uhn.fhir.util.FhirTerser;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBase;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IPrimitiveType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n-import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n-\n-@Service\n-public class GoldenResourceHelper {\n-\n-\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n-\n-\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n-\n-\t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n-\t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n-\n-\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n-\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n-\n-\t\treturn (T) newGoldenResource;\n-\t}\n-\n-\t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n-\t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n-\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n-\n-\t\t// set identifier on the source resource\n-\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n-\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\t/**\n-\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n-\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n-\t *\n-\t * @param theGoldenResource The golden resource to update the external EID on.\n-\t * @param theSourceResource The source we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n-\t */\n-\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n-\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tif (incomingSourceEid.isEmpty()) {\n-\t\t\treturn theGoldenResource;\n-\t\t}\n-\n-\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n-\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n-\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n-\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n-\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n-\t\t}\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theGoldenResource);\n-\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n-\t\t}\n-\n-\t\tgoldenResourceIdentifiers.clear();\n-\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n-\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n-\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n-\t\t//\tTODO NG - Revisit when merge rules are defined\n-\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n-\n-//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-//\t\t\tcase R4:\n-//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tcase DSTU3:\n-//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tdefault:\n-//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-//\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n-\t * EID, but the incoming resource also has an EID that does not match.\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n-\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n-\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n-\t\ttheMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n-\t\t}\n-\t}\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nnew file mode 100644\nindex 0000000000..fd1b385123\n--- /dev/null\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -0,0 +1,278 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n+\n+\t\t// set identifier on the source resource\n+\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\t/**\n+\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n+\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n+\t * <p>\n+\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n+\t *\n+\t * @param theGoldenResource The golden resource to update the external EID on.\n+\t * @param theSourceResource The source we will retrieve the external EID from.\n+\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n+\t */\n+\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n+\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n+\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tif (incomingSourceEid.isEmpty()) {\n+\t\t\treturn theGoldenResource;\n+\t\t}\n+\n+\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n+\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n+\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n+\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n+\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n+\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n+\t\t}\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(theGoldenResource);\n+\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n+\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n+\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n+\n+\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n+\t\t}\n+\n+\t\tgoldenResourceIdentifiers.clear();\n+\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n+\t}\n+\n+\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n+\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n+\t}\n+\n+\t/**\n+\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n+\t */\n+\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n+\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n+\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n+\t\t//\tTODO NG - Revisit when merge rules are defined\n+\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n+\n+//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+//\t\t\tcase R4:\n+//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tcase DSTU3:\n+//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tdefault:\n+//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n+\t * EID, but the incoming resource also has an EID that does not match.\n+\t */\n+\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n+\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n+\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n+\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n+\t}\n+\n+\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n+\t\ttheMdmTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n+\t\t}\n+\t}\n+}\n", "next_change": {"commit": "ccb5b1aaad468eb290342d3975b5a8690332f977", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex fd1b385123..fb8c419676 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -275,4 +276,20 @@ public class GoldenResourceHelper {\n \t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n \t\t}\n \t}\n+\n+\t/**\n+\t * Clones the specified canonical EID into the identifier field on the resource\n+\t *\n+\t * @param theFhirContext         Context to pull resource definitions from\n+\t * @param theResourceToCloneInto Resource to set the EID on\n+\t * @param theEid                 EID to be set\n+\t */\n+\tpublic void cloneEidIntoResource(FhirContext theFhirContext, IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = theFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tca.uhn.fhir.util.TerserUtil.cloneEidIntoResource(theFhirContext, resourceIdentifier,\n+\t\t\tIdentifierUtil.toId(theFhirContext, theEid), theResourceToCloneInto);\n+\t}\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNTY2MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537725660", "body": "This should probably be a static util function so we can use it elsewhere..", "bodyText": "This should probably be a static util function so we can use it elsewhere..", "bodyHTML": "<p dir=\"auto\">This should probably be a static util function so we can use it elsewhere..</p>", "author": "fil512", "createdAt": "2020-12-07T18:20:18Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n+\t\t}\n+\t}\n+\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n+\t\treturn theItems.stream().filter(i -> {\n+\t\t\treturn predicate.test(i, theItem);\n+\t\t}).findFirst().isPresent();\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tcloneEidIntoResource(theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\ndeleted file mode 100644\nindex 8582a75ea2..0000000000\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,377 +0,0 @@\n-package ca.uhn.fhir.mdm.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n-import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.context.FhirVersionEnum;\n-import ca.uhn.fhir.context.RuntimeResourceDefinition;\n-import ca.uhn.fhir.fhirpath.IFhirPath;\n-import ca.uhn.fhir.mdm.api.IMdmSettings;\n-import ca.uhn.fhir.mdm.log.Logs;\n-import ca.uhn.fhir.mdm.model.CanonicalEID;\n-import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n-import ca.uhn.fhir.util.FhirTerser;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBase;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IPrimitiveType;\n-import org.hl7.fhir.r4.model.BooleanType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n-import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n-\n-@Service\n-public class GoldenResourceHelper {\n-\n-\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n-\n-\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n-\n-\t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n-\t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n-\n-\t\tMdmUtil.setMdmManaged(newGoldenResource);\n-\t\tMdmUtil.setGoldenResource(newGoldenResource);\n-\n-\t\treturn (T) newGoldenResource;\n-\t}\n-\n-\t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n-\t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n-\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n-\n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n-\t}\n-\n-\t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n-\t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n-\t}\n-\n-\t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n-\t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo   Resource to clone the specified filed to\n-\t * @param field   Field name to be copied\n-\t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n-\n-\t\t\ttheToFieldValues.add(newFieldValue);\n-\t\t}\n-\t}\n-\n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n-\t}\n-\n-\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tcloneEidIntoResource(theGoldenResourceIdentifier, base, theNewGoldenResource);\n-\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\t/**\n-\t * Updates EID on Golden Resource, based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n-\t *\n-\t * @param theGoldenResource The golden resource to update the external EID on.\n-\t * @param theTargetResource The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n-\t */\n-\tpublic IAnyResource updateGoldenResourceExternalEidFromTargetResource(IAnyResource theGoldenResource, IAnyResource\n-\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tif (incomingTargetEid.isEmpty()) {\n-\t\t\treturn theGoldenResource;\n-\t\t}\n-\n-\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n-\t\t\t\t+ \" is applying this EIDs to its related Target Resource, as this Target Resource does not yet have an external EID\");\n-\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingTargetEid);\n-\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingTargetEid)) {\n-\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\tString.format(\"Target EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n-\t\t\t\t\tincomingTargetEid.toString(), goldenResourceOfficialEid.toString()));\n-\t\t}\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theGoldenResource);\n-\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n-\t\t}\n-\n-\t\tgoldenResourceIdentifiers.clear();\n-\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n-\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n-\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tcloneEidIntoResource(theGoldenResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) eid.toR4();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) eid.toDSTU3();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\n-\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) new BooleanType(theFlag);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn ((BooleanType) theFlag).booleanValue();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType) theFlag).booleanValue();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n-\t\t//\tTODO NG - Revisit when merge rules are defined\n-\t\tcloneCompositeField(theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n-\n-//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-//\t\t\tcase R4:\n-//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tcase DSTU3:\n-//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tdefault:\n-//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-//\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a target that has a golden resource with an official\n-\t * EID, but the incoming resource also has an EID that does not match.\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n-\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n-\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theTargetResource, MdmTransactionContext\n-\t\ttheMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateGoldenResourceExternalEidFromTargetResource(theGoldenResource, theTargetResource, theMdmTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivateResource(IAnyResource theResource) {\n-\t\tMdmUtil.setGoldenResourceRedirected(theResource);\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n-\t\treturn MdmUtil.isGoldenRecordRedirected(theGoldenResource);\n-\t}\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nnew file mode 100644\nindex 0000000000..fd1b385123\n--- /dev/null\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -0,0 +1,278 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n+\n+\t\t// set identifier on the source resource\n+\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\t/**\n+\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n+\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n+\t * <p>\n+\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n+\t *\n+\t * @param theGoldenResource The golden resource to update the external EID on.\n+\t * @param theSourceResource The source we will retrieve the external EID from.\n+\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n+\t */\n+\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n+\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n+\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tif (incomingSourceEid.isEmpty()) {\n+\t\t\treturn theGoldenResource;\n+\t\t}\n+\n+\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n+\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n+\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n+\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n+\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n+\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n+\t\t}\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(theGoldenResource);\n+\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n+\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n+\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n+\n+\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n+\t\t}\n+\n+\t\tgoldenResourceIdentifiers.clear();\n+\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n+\t}\n+\n+\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n+\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n+\t}\n+\n+\t/**\n+\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n+\t */\n+\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n+\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n+\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n+\t\t//\tTODO NG - Revisit when merge rules are defined\n+\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n+\n+//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+//\t\t\tcase R4:\n+//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tcase DSTU3:\n+//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tdefault:\n+//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n+\t * EID, but the incoming resource also has an EID that does not match.\n+\t */\n+\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n+\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n+\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n+\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n+\t}\n+\n+\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n+\t\ttheMdmTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n+\t\t}\n+\t}\n+}\n", "next_change": {"commit": "ccb5b1aaad468eb290342d3975b5a8690332f977", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex fd1b385123..fb8c419676 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -275,4 +276,20 @@ public class GoldenResourceHelper {\n \t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n \t\t}\n \t}\n+\n+\t/**\n+\t * Clones the specified canonical EID into the identifier field on the resource\n+\t *\n+\t * @param theFhirContext         Context to pull resource definitions from\n+\t * @param theResourceToCloneInto Resource to set the EID on\n+\t * @param theEid                 EID to be set\n+\t */\n+\tpublic void cloneEidIntoResource(FhirContext theFhirContext, IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = theFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tca.uhn.fhir.util.TerserUtil.cloneEidIntoResource(theFhirContext, resourceIdentifier,\n+\t\t\tIdentifierUtil.toId(theFhirContext, theEid), theResourceToCloneInto);\n+\t}\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzA1NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537727055", "body": "nitpick this class is getting kind of long.  is there a distinct responsibility in here that could be carved out into a separate class?\r\n", "bodyText": "nitpick this class is getting kind of long.  is there a distinct responsibility in here that could be carved out into a separate class?", "bodyHTML": "<p dir=\"auto\">nitpick this class is getting kind of long.  is there a distinct responsibility in here that could be carved out into a separate class?</p>", "author": "fil512", "createdAt": "2020-12-07T18:22:09Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n+\t\t}\n+\t}\n+\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n+\t\treturn theItems.stream().filter(i -> {\n+\t\t\treturn predicate.test(i, theItem);\n+\t\t}).findFirst().isPresent();\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tcloneEidIntoResource(theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\t/**\n+\t * Updates EID on Golden Resource, based on the incoming target resource. If the incoming resource has an external EID, it is applied\n+\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n+\t * <p>\n+\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n+\t *\n+\t * @param theGoldenResource The golden resource to update the external EID on.\n+\t * @param theTargetResource The target we will retrieve the external EID from.\n+\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n+\t */\n+\tpublic IAnyResource updateGoldenResourceExternalEidFromTargetResource(IAnyResource theGoldenResource, IAnyResource\n+\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n+\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n+\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tif (incomingTargetEid.isEmpty()) {\n+\t\t\treturn theGoldenResource;\n+\t\t}\n+\n+\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n+\t\t\t\t+ \" is applying this EIDs to its related Target Resource, as this Target Resource does not yet have an external EID\");\n+\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingTargetEid);\n+\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingTargetEid)) {\n+\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString.format(\"Target EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n+\t\t\t\t\tincomingTargetEid.toString(), goldenResourceOfficialEid.toString()));\n+\t\t}\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(theGoldenResource);\n+\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n+\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n+\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n+\n+\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n+\t\t}\n+\n+\t\tgoldenResourceIdentifiers.clear();\n+\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n+\t}\n+\n+\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n+\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n+\t}\n+\n+\t/**\n+\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n+\t */\n+\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n+\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n+\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\tcloneEidIntoResource(theGoldenResource, incomingExternalEid);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\treturn (T) eid.toR4();\n+\t\t\tcase DSTU3:\n+\t\t\t\treturn (T) eid.toDSTU3();\n+\t\t}\n+\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\n+\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\treturn (T) new BooleanType(theFlag);\n+\t\t\tcase DSTU3:\n+\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n+\t\t}\n+\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\treturn ((BooleanType) theFlag).booleanValue();\n+\t\t\tcase DSTU3:\n+\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType) theFlag).booleanValue();\n+\t\t}\n+\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n+\t\t//\tTODO NG - Revisit when merge rules are defined\n+\t\tcloneCompositeField(theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n+\n+//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+//\t\t\tcase R4:\n+//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tcase DSTU3:\n+//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tdefault:\n+//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * An incoming resource is a potential duplicate if it matches a target that has a golden resource with an official\n+\t * EID, but the incoming resource also has an EID that does not match.\n+\t */\n+\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n+\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n+\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n+\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n+\t}\n+\n+\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theTargetResource, MdmTransactionContext\n+\t\ttheMdmTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tupdateGoldenResourceExternalEidFromTargetResource(theGoldenResource, theTargetResource, theMdmTransactionContext);\n+\t\t}\n+\t}\n+\n+\tpublic void deactivateResource(IAnyResource theResource) {\n+\t\tMdmUtil.setGoldenResourceRedirected(theResource);\n+\t}\n+\n+\tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n+\t\treturn MdmUtil.isGoldenRecordRedirected(theGoldenResource);\n+\t}\n+}", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..fd1b385123 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -359,19 +268,11 @@ public class GoldenResourceHelper {\n \t\tourLog.debug(theMessage);\n \t}\n \n-\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theTargetResource, MdmTransactionContext\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n \t\ttheMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateGoldenResourceExternalEidFromTargetResource(theGoldenResource, theTargetResource, theMdmTransactionContext);\n+\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n \t\t}\n \t}\n-\n-\tpublic void deactivateResource(IAnyResource theResource) {\n-\t\tMdmUtil.setGoldenResourceRedirected(theResource);\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n-\t\treturn MdmUtil.isGoldenRecordRedirected(theGoldenResource);\n-\t}\n }\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\ndeleted file mode 100644\nindex fd1b385123..0000000000\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,278 +0,0 @@\n-package ca.uhn.fhir.mdm.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n-import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.context.FhirVersionEnum;\n-import ca.uhn.fhir.context.RuntimeResourceDefinition;\n-import ca.uhn.fhir.fhirpath.IFhirPath;\n-import ca.uhn.fhir.mdm.api.IMdmSettings;\n-import ca.uhn.fhir.mdm.log.Logs;\n-import ca.uhn.fhir.mdm.model.CanonicalEID;\n-import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n-import ca.uhn.fhir.util.FhirTerser;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBase;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IPrimitiveType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n-import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n-\n-@Service\n-public class GoldenResourceHelper {\n-\n-\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n-\n-\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n-\n-\t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n-\t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n-\n-\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n-\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n-\n-\t\treturn (T) newGoldenResource;\n-\t}\n-\n-\t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n-\t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n-\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n-\n-\t\t// set identifier on the source resource\n-\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n-\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\t/**\n-\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n-\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n-\t *\n-\t * @param theGoldenResource The golden resource to update the external EID on.\n-\t * @param theSourceResource The source we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n-\t */\n-\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n-\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tif (incomingSourceEid.isEmpty()) {\n-\t\t\treturn theGoldenResource;\n-\t\t}\n-\n-\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n-\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n-\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n-\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n-\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n-\t\t}\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theGoldenResource);\n-\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n-\t\t}\n-\n-\t\tgoldenResourceIdentifiers.clear();\n-\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n-\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n-\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n-\t\t//\tTODO NG - Revisit when merge rules are defined\n-\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n-\n-//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-//\t\t\tcase R4:\n-//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tcase DSTU3:\n-//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tdefault:\n-//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-//\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n-\t * EID, but the incoming resource also has an EID that does not match.\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n-\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n-\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n-\t\ttheMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n-\t\t}\n-\t}\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nnew file mode 100644\nindex 0000000000..fd1b385123\n--- /dev/null\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -0,0 +1,278 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n+\n+\t\t// set identifier on the source resource\n+\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\t/**\n+\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n+\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n+\t * <p>\n+\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n+\t *\n+\t * @param theGoldenResource The golden resource to update the external EID on.\n+\t * @param theSourceResource The source we will retrieve the external EID from.\n+\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n+\t */\n+\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n+\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n+\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tif (incomingSourceEid.isEmpty()) {\n+\t\t\treturn theGoldenResource;\n+\t\t}\n+\n+\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n+\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n+\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n+\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n+\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n+\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n+\t\t}\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(theGoldenResource);\n+\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n+\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n+\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n+\n+\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n+\t\t}\n+\n+\t\tgoldenResourceIdentifiers.clear();\n+\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n+\t}\n+\n+\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n+\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n+\t}\n+\n+\t/**\n+\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n+\t */\n+\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n+\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n+\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n+\t\t//\tTODO NG - Revisit when merge rules are defined\n+\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n+\n+//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+//\t\t\tcase R4:\n+//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tcase DSTU3:\n+//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tdefault:\n+//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n+\t * EID, but the incoming resource also has an EID that does not match.\n+\t */\n+\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n+\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n+\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n+\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n+\t}\n+\n+\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n+\t\ttheMdmTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n+\t\t}\n+\t}\n+}\n", "next_change": {"commit": "ccb5b1aaad468eb290342d3975b5a8690332f977", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex fd1b385123..fb8c419676 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -275,4 +276,20 @@ public class GoldenResourceHelper {\n \t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n \t\t}\n \t}\n+\n+\t/**\n+\t * Clones the specified canonical EID into the identifier field on the resource\n+\t *\n+\t * @param theFhirContext         Context to pull resource definitions from\n+\t * @param theResourceToCloneInto Resource to set the EID on\n+\t * @param theEid                 EID to be set\n+\t */\n+\tpublic void cloneEidIntoResource(FhirContext theFhirContext, IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = theFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tca.uhn.fhir.util.TerserUtil.cloneEidIntoResource(theFhirContext, resourceIdentifier,\n+\t\t\tIdentifierUtil.toId(theFhirContext, theEid), theResourceToCloneInto);\n+\t}\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzM2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537727365", "body": "MdmResourceUtil?", "bodyText": "MdmResourceUtil?", "bodyHTML": "<p dir=\"auto\">MdmResourceUtil?</p>", "author": "fil512", "createdAt": "2020-12-07T18:22:39Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n+import org.hl7.fhir.instance.model.api.IBaseCoding;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Optional;\n+\n+public final class MdmUtil {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzkxNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537727915", "body": "nitpick: rename to `PrimitiveTypeEqualsPredicate`", "bodyText": "nitpick: rename to PrimitiveTypeEqualsPredicate", "bodyHTML": "<p dir=\"auto\">nitpick: rename to <code>PrimitiveTypeEqualsPredicate</code></p>", "author": "fil512", "createdAt": "2020-12-07T18:23:33Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicate.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+\n+import java.lang.reflect.Field;\n+import java.util.function.BiPredicate;\n+\n+public class PrimitiveTypeComparingPredicate implements BiPredicate {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyOTU1OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537729558", "body": "why is there a Patient patient?", "bodyText": "why is there a Patient patient?", "bodyHTML": "<p dir=\"auto\">why is there a Patient patient?</p>", "author": "fil512", "createdAt": "2020-12-07T18:26:05Z", "path": "hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.r4.model.Address;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.hl7.fhir.r4.model.DateType;\n+import org.hl7.fhir.r4.model.Enumerations;\n+import org.hl7.fhir.r4.model.Identifier;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PrimitiveTypeComparingPredicateTest {\n+\n+\tprivate static FhirContext myFhirContext;\n+\n+\tprivate FhirTerser myTerser;\n+\n+\tprivate IBase myPositiveTest1;\n+\n+\tprivate IBase myPositiveTest2;\n+\n+\tprivate IBase myPositiveTest3;\n+\n+\tprivate IBase myNegativeTest;\n+\n+\tprivate PrimitiveTypeComparingPredicate cut = new PrimitiveTypeComparingPredicate();\n+\n+\t@BeforeAll\n+\tpublic static void initContext() {\n+\t\tmyFhirContext = FhirContext.forR4();\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\tmyTerser = myFhirContext.newTerser();\n+\n+\t\tmyPositiveTest1 = newPatient();\n+\t\tmyPositiveTest2 = newPatient();\n+\t\tmyPositiveTest3 = newPatient();\n+\n+\t\tPatient patient = newPatient();\n+\t\tpatient.setActive(false);\n+\t\tpatient.setMultipleBirth(new BooleanType(false));\n+\t\tmyNegativeTest = patient;", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTkwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537731909", "body": "Nitpick: This test is misleading.  It's not testing transitivity.  It's just testing that three identical resources are all equal to each other.  It doesn't do anything beyond testing that `assertTrue(cut.test(myPositiveTest1, myPositiveTest2));`", "bodyText": "Nitpick: This test is misleading.  It's not testing transitivity.  It's just testing that three identical resources are all equal to each other.  It doesn't do anything beyond testing that assertTrue(cut.test(myPositiveTest1, myPositiveTest2));", "bodyHTML": "<p dir=\"auto\">Nitpick: This test is misleading.  It's not testing transitivity.  It's just testing that three identical resources are all equal to each other.  It doesn't do anything beyond testing that <code>assertTrue(cut.test(myPositiveTest1, myPositiveTest2));</code></p>", "author": "fil512", "createdAt": "2020-12-07T18:29:33Z", "path": "hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.r4.model.Address;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.hl7.fhir.r4.model.DateType;\n+import org.hl7.fhir.r4.model.Enumerations;\n+import org.hl7.fhir.r4.model.Identifier;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PrimitiveTypeComparingPredicateTest {\n+\n+\tprivate static FhirContext myFhirContext;\n+\n+\tprivate FhirTerser myTerser;\n+\n+\tprivate IBase myPositiveTest1;\n+\n+\tprivate IBase myPositiveTest2;\n+\n+\tprivate IBase myPositiveTest3;\n+\n+\tprivate IBase myNegativeTest;\n+\n+\tprivate PrimitiveTypeComparingPredicate cut = new PrimitiveTypeComparingPredicate();\n+\n+\t@BeforeAll\n+\tpublic static void initContext() {\n+\t\tmyFhirContext = FhirContext.forR4();\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\tmyTerser = myFhirContext.newTerser();\n+\n+\t\tmyPositiveTest1 = newPatient();\n+\t\tmyPositiveTest2 = newPatient();\n+\t\tmyPositiveTest3 = newPatient();\n+\n+\t\tPatient patient = newPatient();\n+\t\tpatient.setActive(false);\n+\t\tpatient.setMultipleBirth(new BooleanType(false));\n+\t\tmyNegativeTest = patient;\n+\t}\n+\n+\tprivate Patient newPatient() {\n+\t\tPatient patient;\n+\t\tpatient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tpatient.setGender(Enumerations.AdministrativeGender.FEMALE);\n+\t\tpatient.setBirthDateElement(new DateType(\"1901-01-01\"));\n+\n+\t\tAddress address = new Address();\n+\t\taddress.addLine(\"Somwhere\");\n+\t\taddress.setCity(\"Toronto\");\n+\t\taddress.setCountry(\"Canada\");\n+\t\tpatient.setAddress(Collections.singletonList(address));\n+\t\treturn patient;\n+\t}\n+\n+\t@Test\n+\tpublic void testNegativeMatchOnTheSameType() {\n+\t\tassertFalse(cut.test(myPositiveTest1, myNegativeTest));\n+\t\tassertFalse(cut.test(myNegativeTest, myPositiveTest1));\n+\t}\n+\n+\t@Test\n+\tpublic void testNegativeMatchOnDifferentTypes() {\n+\t\tPatient patient = newPatient();\n+\t\tIdentifier identifier = patient.addIdentifier();\n+\t\tidentifier.setValue(\"TEST_VALUE\");\n+\t\tassertFalse(cut.test(myNegativeTest, identifier));\n+\t}\n+\n+\t@Test\n+\tpublic void testSymmetry() {\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest2));\n+\t\tassertTrue(cut.test(myPositiveTest2, myPositiveTest1));\n+\t}\n+\n+\t@Test\n+\tpublic void testReflexivity() {\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest1));\n+\t}\n+\n+\t@Test\n+\tpublic void testTransitivity() {\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest2));\n+\t\tassertTrue(cut.test(myPositiveTest2, myPositiveTest3));\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest3));", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMjk2NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537732964", "body": "This is really nice!  Will be interesting to see how it evolves as we add survivability rules!", "bodyText": "This is really nice!  Will be interesting to see how it evolves as we add survivability rules!", "bodyHTML": "<p dir=\"auto\">This is really nice!  Will be interesting to see how it evolves as we add survivability rules!</p>", "author": "fil512", "createdAt": "2020-12-07T18:31:13Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..fd1b385123 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -109,69 +108,10 @@ public class GoldenResourceHelper {\n \t\t}\n \n \t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n \n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n-\t}\n-\n-\t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n-\t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n-\t}\n-\n-\t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n-\t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo   Resource to clone the specified filed to\n-\t * @param field   Field name to be copied\n-\t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n-\n-\t\t\ttheToFieldValues.add(newFieldValue);\n-\t\t}\n-\t}\n-\n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n+\t\t// set identifier on the source resource\n+\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n \t}\n \n \tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\ndeleted file mode 100644\nindex fd1b385123..0000000000\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,278 +0,0 @@\n-package ca.uhn.fhir.mdm.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n-import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.context.FhirVersionEnum;\n-import ca.uhn.fhir.context.RuntimeResourceDefinition;\n-import ca.uhn.fhir.fhirpath.IFhirPath;\n-import ca.uhn.fhir.mdm.api.IMdmSettings;\n-import ca.uhn.fhir.mdm.log.Logs;\n-import ca.uhn.fhir.mdm.model.CanonicalEID;\n-import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n-import ca.uhn.fhir.util.FhirTerser;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBase;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IPrimitiveType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n-import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n-\n-@Service\n-public class GoldenResourceHelper {\n-\n-\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n-\n-\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n-\n-\t@Autowired\n-\tprivate IMdmSettings myMdmSettings;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n-\t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n-\n-\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n-\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n-\n-\t\treturn (T) newGoldenResource;\n-\t}\n-\n-\t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n-\t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n-\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n-\n-\t\t// set identifier on the source resource\n-\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n-\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\t/**\n-\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n-\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n-\t *\n-\t * @param theGoldenResource The golden resource to update the external EID on.\n-\t * @param theSourceResource The source we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n-\t */\n-\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n-\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tif (incomingSourceEid.isEmpty()) {\n-\t\t\treturn theGoldenResource;\n-\t\t}\n-\n-\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n-\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n-\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n-\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n-\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n-\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n-\t\t}\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theGoldenResource);\n-\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n-\t\treturn theGoldenResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : goldenResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n-\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n-\t\t}\n-\n-\t\tgoldenResourceIdentifiers.clear();\n-\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n-\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n-\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n-\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n-\t\t//\tTODO NG - Revisit when merge rules are defined\n-\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n-\n-//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-//\t\t\tcase R4:\n-//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tcase DSTU3:\n-//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n-//\t\t\t\tbreak;\n-//\t\t\tdefault:\n-//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-//\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n-\t * EID, but the incoming resource also has an EID that does not match.\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n-\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n-\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n-\t\ttheMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n-\t\t}\n-\t}\n-}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nnew file mode 100644\nindex 0000000000..fd1b385123\n--- /dev/null\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -0,0 +1,278 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tstatic final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmResourceUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmResourceUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theSourceResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, IdentifierUtil.toId(myFhirContext, hapiEid));\n+\n+\t\t// set identifier on the source resource\n+\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theSourceResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\t/**\n+\t * Updates EID on Golden Resource, based on the incoming source resource. If the incoming resource has an external EID, it is applied\n+\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n+\t * <p>\n+\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n+\t *\n+\t * @param theGoldenResource The golden resource to update the external EID on.\n+\t * @param theSourceResource The source we will retrieve the external EID from.\n+\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n+\t */\n+\tpublic IAnyResource updateGoldenResourceExternalEidFromSourceResource(IAnyResource theGoldenResource, IAnyResource\n+\t\ttheSourceResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n+\t\tList<CanonicalEID> incomingSourceEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tif (incomingSourceEid.isEmpty()) {\n+\t\t\treturn theGoldenResource;\n+\t\t}\n+\n+\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theSourceResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n+\t\t\t\t+ \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n+\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingSourceEid);\n+\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingSourceEid)) {\n+\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theSourceResource.getIdElement().toVersionless() + \" with EIDs \" + incomingSourceEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString.format(\"Source EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n+\t\t\t\t\tincomingSourceEid.toString(), goldenResourceOfficialEid.toString()));\n+\t\t}\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(theGoldenResource);\n+\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n+\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n+\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n+\n+\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n+\t\t}\n+\n+\t\tgoldenResourceIdentifiers.clear();\n+\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n+\t}\n+\n+\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n+\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n+\t}\n+\n+\t/**\n+\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n+\t */\n+\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingSourceExternalEids) {\n+\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tfor (CanonicalEID incomingExternalEid : theIncomingSourceExternalEids) {\n+\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\tTerserUtil.cloneEidIntoResource(myFhirContext, theGoldenResource, incomingExternalEid);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n+\t\t//\tTODO NG - Revisit when merge rules are defined\n+\t\tTerserUtil.cloneCompositeField(myFhirContext, theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n+\n+//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+//\t\t\tcase R4:\n+//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tcase DSTU3:\n+//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tdefault:\n+//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * An incoming resource is a potential duplicate if it matches a source that has a golden resource with an official\n+\t * EID, but the incoming resource also has an EID that does not match.\n+\t */\n+\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n+\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n+\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n+\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n+\t}\n+\n+\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theSourceResource, MdmTransactionContext\n+\t\ttheMdmTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n+\t\t}\n+\t}\n+}\n", "next_change": {"commit": "ccb5b1aaad468eb290342d3975b5a8690332f977", "changed_code": [{"header": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex fd1b385123..fb8c419676 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -275,4 +276,20 @@ public class GoldenResourceHelper {\n \t\t\tupdateGoldenResourceExternalEidFromSourceResource(theGoldenResource, theSourceResource, theMdmTransactionContext);\n \t\t}\n \t}\n+\n+\t/**\n+\t * Clones the specified canonical EID into the identifier field on the resource\n+\t *\n+\t * @param theFhirContext         Context to pull resource definitions from\n+\t * @param theResourceToCloneInto Resource to set the EID on\n+\t * @param theEid                 EID to be set\n+\t */\n+\tpublic void cloneEidIntoResource(FhirContext theFhirContext, IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = theFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tca.uhn.fhir.util.TerserUtil.cloneEidIntoResource(theFhirContext, resourceIdentifier,\n+\t\t\tIdentifierUtil.toId(theFhirContext, theEid), theResourceToCloneInto);\n+\t}\n }\n", "next_change": null}]}}]}}]}}]}}, {"oid": "af461cd343b6a0b93ff501ee91a0100646e4d37c", "url": "https://github.com/hapifhir/hapi-fhir/commit/af461cd343b6a0b93ff501ee91a0100646e4d37c", "message": "Apply doc update suggestions from code review\n\nCo-authored-by: Ken Stevens <khstevens@gmail.com>", "committedDate": "2020-12-07T19:04:04Z", "type": "commit"}, {"oid": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "url": "https://github.com/hapifhir/hapi-fhir/commit/fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "message": "Review updates", "committedDate": "2020-12-07T23:03:56Z", "type": "commit"}, {"oid": "b503d50b6726074f923169943d418960c02c84cd", "url": "https://github.com/hapifhir/hapi-fhir/commit/b503d50b6726074f923169943d418960c02c84cd", "message": "Addressed failures", "committedDate": "2020-12-08T00:18:58Z", "type": "commit"}, {"oid": "61c1b6cfb273170f3e7224b87ce28d8cd9d39d56", "url": "https://github.com/hapifhir/hapi-fhir/commit/61c1b6cfb273170f3e7224b87ce28d8cd9d39d56", "message": "Updated docs", "committedDate": "2020-12-08T00:30:18Z", "type": "commit"}, {"oid": "d3c094438855b18cbd8c0a5e647367414a1e6e38", "url": "https://github.com/hapifhir/hapi-fhir/commit/d3c094438855b18cbd8c0a5e647367414a1e6e38", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-08T03:02:45Z", "type": "commit"}, {"oid": "6018dd053787f424a7646ac1a7b0b76beec86fd3", "url": "https://github.com/hapifhir/hapi-fhir/commit/6018dd053787f424a7646ac1a7b0b76beec86fd3", "message": "Fixed ambitious schema update", "committedDate": "2020-12-08T15:44:11Z", "type": "commit"}, {"oid": "aef84c9fe9ce9045bc132c7f568f591f796e54b7", "url": "https://github.com/hapifhir/hapi-fhir/commit/aef84c9fe9ce9045bc132c7f568f591f796e54b7", "message": "Updated docs yet again", "committedDate": "2020-12-08T16:24:40Z", "type": "commit"}, {"oid": "efb429b319b4164f72588810ac9102e240161803", "url": "https://github.com/hapifhir/hapi-fhir/commit/efb429b319b4164f72588810ac9102e240161803", "message": "Fixed todos and reverted FK check in the test", "committedDate": "2020-12-08T18:00:02Z", "type": "commit"}, {"oid": "4c7b59798332ea79bab653e2b8180290b26b3308", "url": "https://github.com/hapifhir/hapi-fhir/commit/4c7b59798332ea79bab653e2b8180290b26b3308", "message": "Addressed more code review comments", "committedDate": "2020-12-08T20:32:01Z", "type": "commit"}, {"oid": "4b610801fa30d02c27eeb2544e09834062caa9f4", "url": "https://github.com/hapifhir/hapi-fhir/commit/4b610801fa30d02c27eeb2544e09834062caa9f4", "message": "Added header", "committedDate": "2020-12-08T21:47:19Z", "type": "commit"}, {"oid": "b3a9ab20dcdffae8550b5bae1aa2132a331eb1ad", "url": "https://github.com/hapifhir/hapi-fhir/commit/b3a9ab20dcdffae8550b5bae1aa2132a331eb1ad", "message": "Updated wording assertion in exception tracing", "committedDate": "2020-12-09T00:05:21Z", "type": "commit"}, {"oid": "52fd83c654a95339fd5975d6e1b43257d10e156a", "url": "https://github.com/hapifhir/hapi-fhir/commit/52fd83c654a95339fd5975d6e1b43257d10e156a", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-09T14:14:58Z", "type": "commit"}, {"oid": "0dfc4597e8941367f141824865d10f98976566aa", "url": "https://github.com/hapifhir/hapi-fhir/commit/0dfc4597e8941367f141824865d10f98976566aa", "message": "comment fixes and removing dead code", "committedDate": "2020-11-05T14:24:53Z", "type": "commit"}, {"oid": "ef2041d89d5e4b6e2207f0ec625e771d9f53167c", "url": "https://github.com/hapifhir/hapi-fhir/commit/ef2041d89d5e4b6e2207f0ec625e771d9f53167c", "message": "Merge remote-tracking branch 'origin/master' into 2161-refactor-empi", "committedDate": "2020-11-05T14:25:38Z", "type": "commit"}, {"oid": "5797cd0682bf6e12aa79f6230eedb1240778704f", "url": "https://github.com/hapifhir/hapi-fhir/commit/5797cd0682bf6e12aa79f6230eedb1240778704f", "message": "* Add source_resource_id column\n* Add source_resource columm\nStill need to depracate the old columns.\nReworked a Matcher to ignore Person", "committedDate": "2020-11-05T18:07:45Z", "type": "commit"}, {"oid": "656b8aeba706ed3f7dcfd71b305629c82188f489", "url": "https://github.com/hapifhir/hapi-fhir/commit/656b8aeba706ed3f7dcfd71b305629c82188f489", "message": "Partial removal of getPersonFromTarget", "committedDate": "2020-11-05T18:41:01Z", "type": "commit"}, {"oid": "4bfc62804cd55a3c4d740219cd63c82402867295", "url": "https://github.com/hapifhir/hapi-fhir/commit/4bfc62804cd55a3c4d740219cd63c82402867295", "message": "WIP removing Person", "committedDate": "2020-11-05T19:23:53Z", "type": "commit"}, {"oid": "e9509f99634d4899ca2c9e40b9e84e1763bc8912", "url": "https://github.com/hapifhir/hapi-fhir/commit/e9509f99634d4899ca2c9e40b9e84e1763bc8912", "message": "WIP removing Person - ID cloning", "committedDate": "2020-11-05T19:46:30Z", "type": "commit"}, {"oid": "0b4f6475204ed139e2144322c4fa10c6d756633b", "url": "https://github.com/hapifhir/hapi-fhir/commit/0b4f6475204ed139e2144322c4fa10c6d756633b", "message": "EID copy magic", "committedDate": "2020-11-05T22:39:25Z", "type": "commit"}, {"oid": "aba69533600db47f8146889302a986ec51040477", "url": "https://github.com/hapifhir/hapi-fhir/commit/aba69533600db47f8146889302a986ec51040477", "message": "Mild comment :)", "committedDate": "2020-11-06T04:06:54Z", "type": "commit"}, {"oid": "71856dbd64d7126dbf6edf3433d6a23a81ba2959", "url": "https://github.com/hapifhir/hapi-fhir/commit/71856dbd64d7126dbf6edf3433d6a23a81ba2959", "message": "WIP Refactoring", "committedDate": "2020-11-06T17:29:11Z", "type": "commit"}, {"oid": "79793f9c403b059fb68274cf63952406dd635ee7", "url": "https://github.com/hapifhir/hapi-fhir/commit/79793f9c403b059fb68274cf63952406dd635ee7", "message": "WIP Refactoring 2", "committedDate": "2020-11-06T18:16:50Z", "type": "commit"}, {"oid": "063d04cc79f274da0434ab184eeca17652ecd999", "url": "https://github.com/hapifhir/hapi-fhir/commit/063d04cc79f274da0434ab184eeca17652ecd999", "message": "One more test passing. rework EID updates to support the terser method", "committedDate": "2020-11-06T19:54:37Z", "type": "commit"}, {"oid": "27afbe93b3ae19dee64116a8bc31ff49fc550840", "url": "https://github.com/hapifhir/hapi-fhir/commit/27afbe93b3ae19dee64116a8bc31ff49fc550840", "message": "Cleanup", "committedDate": "2020-11-06T20:39:33Z", "type": "commit"}, {"oid": "9422ba7a025f18273d72babf0d65b22a02c9b202", "url": "https://github.com/hapifhir/hapi-fhir/commit/9422ba7a025f18273d72babf0d65b22a02c9b202", "message": "WIP Refactoring 3", "committedDate": "2020-11-06T22:02:07Z", "type": "commit"}, {"oid": "4c0fab8cec786d435760e5bf1e271e298e3b869c", "url": "https://github.com/hapifhir/hapi-fhir/commit/4c0fab8cec786d435760e5bf1e271e298e3b869c", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-11-09T14:06:50Z", "type": "commit"}, {"oid": "5d6ede660be921ea2eb12c6223c9e1eafddb47f1", "url": "https://github.com/hapifhir/hapi-fhir/commit/5d6ede660be921ea2eb12c6223c9e1eafddb47f1", "message": "Use case #3 testing", "committedDate": "2020-11-09T16:07:58Z", "type": "commit"}, {"oid": "ac3b1e3e17adb53600637fea8e40f3dbeb8cf1c0", "url": "https://github.com/hapifhir/hapi-fhir/commit/ac3b1e3e17adb53600637fea8e40f3dbeb8cf1c0", "message": "Fixed code for use case #3 test case", "committedDate": "2020-11-09T16:46:56Z", "type": "commit"}, {"oid": "4865e8a4101e6492a2bca3706a143249ee8163ce", "url": "https://github.com/hapifhir/hapi-fhir/commit/4865e8a4101e6492a2bca3706a143249ee8163ce", "message": "Fixed code for use case #2 test case", "committedDate": "2020-11-09T20:29:50Z", "type": "commit"}, {"oid": "06446ae0bfd5b9d892ebe9bec7e671081a89def8", "url": "https://github.com/hapifhir/hapi-fhir/commit/06446ae0bfd5b9d892ebe9bec7e671081a89def8", "message": "Address review comments", "committedDate": "2020-11-09T20:29:50Z", "type": "commit"}, {"oid": "a73d0421ba81523e92bfa16d4b0f8256250f035c", "url": "https://github.com/hapifhir/hapi-fhir/commit/a73d0421ba81523e92bfa16d4b0f8256250f035c", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-09T20:31:13Z", "type": "commit"}, {"oid": "9e82602be9ef469d927fb972cd0bb554cd99031f", "url": "https://github.com/hapifhir/hapi-fhir/commit/9e82602be9ef469d927fb972cd0bb554cd99031f", "message": "Begin refactor of provider tests", "committedDate": "2020-11-09T21:14:02Z", "type": "commit"}, {"oid": "c55de80c6aec722c54cd4e696b63e57a7191a1f0", "url": "https://github.com/hapifhir/hapi-fhir/commit/c55de80c6aec722c54cd4e696b63e57a7191a1f0", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-09T21:14:06Z", "type": "commit"}, {"oid": "99e3dbaccd7d35fa6ed82805db9359799b4dbb5e", "url": "https://github.com/hapifhir/hapi-fhir/commit/99e3dbaccd7d35fa6ed82805db9359799b4dbb5e", "message": "Removed link matching from PersonHelper", "committedDate": "2020-11-09T22:35:04Z", "type": "commit"}, {"oid": "8efafa112a1271ce41d986a3431714f60fd6b17b", "url": "https://github.com/hapifhir/hapi-fhir/commit/8efafa112a1271ce41d986a3431714f60fd6b17b", "message": "Debugging case 4", "committedDate": "2020-11-09T22:54:49Z", "type": "commit"}, {"oid": "d7974a6f1d9ca01a85c082af1df41e046879c03b", "url": "https://github.com/hapifhir/hapi-fhir/commit/d7974a6f1d9ca01a85c082af1df41e046879c03b", "message": "continue refactor of providers", "committedDate": "2020-11-10T02:44:11Z", "type": "commit"}, {"oid": "625744b23dae486f60e8914beca93a3844b4833e", "url": "https://github.com/hapifhir/hapi-fhir/commit/625744b23dae486f60e8914beca93a3844b4833e", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-10T02:45:18Z", "type": "commit"}, {"oid": "d2e9201f1156679ee5c09d41554664212e0c944e", "url": "https://github.com/hapifhir/hapi-fhir/commit/d2e9201f1156679ee5c09d41554664212e0c944e", "message": "Code is compiling again :)", "committedDate": "2020-11-10T02:49:38Z", "type": "commit"}, {"oid": "a67b3a8298236be307b6fc05f688459c20b93871", "url": "https://github.com/hapifhir/hapi-fhir/commit/a67b3a8298236be307b6fc05f688459c20b93871", "message": "Fixed possible-matcher", "committedDate": "2020-11-10T15:46:43Z", "type": "commit"}, {"oid": "9bd222af7fc169f0068a2d1d80b169b097d11f04", "url": "https://github.com/hapifhir/hapi-fhir/commit/9bd222af7fc169f0068a2d1d80b169b097d11f04", "message": "Manual match debuggging", "committedDate": "2020-11-10T17:13:04Z", "type": "commit"}, {"oid": "ffbe35e2cddacbb74cb0bea76087e41176784182", "url": "https://github.com/hapifhir/hapi-fhir/commit/ffbe35e2cddacbb74cb0bea76087e41176784182", "message": "Partial refactor of Provider", "committedDate": "2020-11-10T17:26:20Z", "type": "commit"}, {"oid": "16022107c65844d36732e788650921e266abcf70", "url": "https://github.com/hapifhir/hapi-fhir/commit/16022107c65844d36732e788650921e266abcf70", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-10T17:26:22Z", "type": "commit"}, {"oid": "40fc2973e465d63b2ebd5748141cf545d5475e37", "url": "https://github.com/hapifhir/hapi-fhir/commit/40fc2973e465d63b2ebd5748141cf545d5475e37", "message": "Manual match debuggging 2", "committedDate": "2020-11-10T17:47:38Z", "type": "commit"}, {"oid": "a8b0afa626fd1ce8802dc6a9ad35e85441180352", "url": "https://github.com/hapifhir/hapi-fhir/commit/a8b0afa626fd1ce8802dc6a9ad35e85441180352", "message": "Match link passing", "committedDate": "2020-11-10T20:37:16Z", "type": "commit"}, {"oid": "bde163b7e82ecbbe1506cf9c6d036eb2d3a0f6f9", "url": "https://github.com/hapifhir/hapi-fhir/commit/bde163b7e82ecbbe1506cf9c6d036eb2d3a0f6f9", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-10T21:18:25Z", "type": "commit"}, {"oid": "4a9b853beb2558664d4e363807ff01c1c43cc49b", "url": "https://github.com/hapifhir/hapi-fhir/commit/4a9b853beb2558664d4e363807ff01c1c43cc49b", "message": "Fix compilation error", "committedDate": "2020-11-10T23:00:01Z", "type": "commit"}, {"oid": "5d1612eef4d7528dc94891c6c36e1d6ce4146c6a", "url": "https://github.com/hapifhir/hapi-fhir/commit/5d1612eef4d7528dc94891c6c36e1d6ce4146c6a", "message": "Remove target version 9", "committedDate": "2020-11-10T23:38:26Z", "type": "commit"}, {"oid": "57c0e10a53d4df989eaedcd6505f91334e8b8a20", "url": "https://github.com/hapifhir/hapi-fhir/commit/57c0e10a53d4df989eaedcd6505f91334e8b8a20", "message": "More tests", "committedDate": "2020-11-11T01:31:04Z", "type": "commit"}, {"oid": "b0f449ff5e5fbb87470aa2aed6ef886b6624a271", "url": "https://github.com/hapifhir/hapi-fhir/commit/b0f449ff5e5fbb87470aa2aed6ef886b6624a271", "message": "MergerSvcTest WIP", "committedDate": "2020-11-11T15:17:03Z", "type": "commit"}, {"oid": "331acc1b554f02bd279248d1f706b63237eb2443", "url": "https://github.com/hapifhir/hapi-fhir/commit/331acc1b554f02bd279248d1f706b63237eb2443", "message": "Attempting to perform MDM on a new resource type", "committedDate": "2020-11-11T19:15:35Z", "type": "commit"}, {"oid": "3d34502fae3a7c72d48f5545251274387e1f786e", "url": "https://github.com/hapifhir/hapi-fhir/commit/3d34502fae3a7c72d48f5545251274387e1f786e", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-11T19:15:58Z", "type": "commit"}, {"oid": "46235226cf31e53146e3c576ac4490760c00304a", "url": "https://github.com/hapifhir/hapi-fhir/commit/46235226cf31e53146e3c576ac4490760c00304a", "message": "Whack of matcher changes for vector calculation to only count _relevant_ field matchers", "committedDate": "2020-11-11T19:25:36Z", "type": "commit"}, {"oid": "71ab400006265052967838cd4e73005437805363", "url": "https://github.com/hapifhir/hapi-fhir/commit/71ab400006265052967838cd4e73005437805363", "message": "Fix matcher. Add another medication test", "committedDate": "2020-11-11T20:26:41Z", "type": "commit"}, {"oid": "2bbfb6dfaa05ab149bf9740a771594270ba6cd45", "url": "https://github.com/hapifhir/hapi-fhir/commit/2bbfb6dfaa05ab149bf9740a771594270ba6cd45", "message": "WIP", "committedDate": "2020-11-11T20:27:57Z", "type": "commit"}, {"oid": "84d9d080dff890d72f7630b8a35cc346a20fa55b", "url": "https://github.com/hapifhir/hapi-fhir/commit/84d9d080dff890d72f7630b8a35cc346a20fa55b", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-11T20:28:04Z", "type": "commit"}, {"oid": "ae3040415cdc102c6d53beb25551d9491ed2f334", "url": "https://github.com/hapifhir/hapi-fhir/commit/ae3040415cdc102c6d53beb25551d9491ed2f334", "message": "Fix vector map bug i just wrote. woopsie doopsie", "committedDate": "2020-11-11T21:36:54Z", "type": "commit"}, {"oid": "a28e9e736acbfabec2051e67676619db40ee3434", "url": "https://github.com/hapifhir/hapi-fhir/commit/a28e9e736acbfabec2051e67676619db40ee3434", "message": "WIP", "committedDate": "2020-11-11T22:25:44Z", "type": "commit"}, {"oid": "f7c47f911bd8006690206f25a9e5caf803413c6b", "url": "https://github.com/hapifhir/hapi-fhir/commit/f7c47f911bd8006690206f25a9e5caf803413c6b", "message": "Merge Service", "committedDate": "2020-11-12T20:59:00Z", "type": "commit"}, {"oid": "1d530c6517e942a0b8deca03e4c0399f2b4bd060", "url": "https://github.com/hapifhir/hapi-fhir/commit/1d530c6517e942a0b8deca03e4c0399f2b4bd060", "message": "Added tests and cleaned test code", "committedDate": "2020-11-12T22:22:04Z", "type": "commit"}, {"oid": "e490011a1f7253d0b8c790aade9cab01ed178578", "url": "https://github.com/hapifhir/hapi-fhir/commit/e490011a1f7253d0b8c790aade9cab01ed178578", "message": "Begin large rename", "committedDate": "2020-11-12T23:36:52Z", "type": "commit"}, {"oid": "687e24fa83a9d756fb15e4e92188070c748983fb", "url": "https://github.com/hapifhir/hapi-fhir/commit/687e24fa83a9d756fb15e4e92188070c748983fb", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-12T23:37:53Z", "type": "commit"}, {"oid": "f648d8ec2baa06f0730a66f4ce11f9999330f9dd", "url": "https://github.com/hapifhir/hapi-fhir/commit/f648d8ec2baa06f0730a66f4ce11f9999330f9dd", "message": "renaming in personsvc", "committedDate": "2020-11-13T14:44:15Z", "type": "commit"}, {"oid": "68fad00a299dc55a1c68c6f4b423887507c4bacf", "url": "https://github.com/hapifhir/hapi-fhir/commit/68fad00a299dc55a1c68c6f4b423887507c4bacf", "message": "Correct bug with attempting to modify an EID", "committedDate": "2020-11-13T16:45:24Z", "type": "commit"}, {"oid": "dadd5f3caf357be07340e2a5685c5e30462b9d05", "url": "https://github.com/hapifhir/hapi-fhir/commit/dadd5f3caf357be07340e2a5685c5e30462b9d05", "message": "Resolved EmpiLinkSvcTest failures", "committedDate": "2020-11-13T19:22:45Z", "type": "commit"}, {"oid": "1fc96899436ce51b5ebcfd52f79e770ab061bc1f", "url": "https://github.com/hapifhir/hapi-fhir/commit/1fc96899436ce51b5ebcfd52f79e770ab061bc1f", "message": "Renamed source to golden", "committedDate": "2020-11-13T19:28:24Z", "type": "commit"}, {"oid": "9df0c16b95cda8b5836ce3aee8403ec43c133152", "url": "https://github.com/hapifhir/hapi-fhir/commit/9df0c16b95cda8b5836ce3aee8403ec43c133152", "message": "Resolved EmpiProviderClearLinkR4Tests and misc src to gld renames", "committedDate": "2020-11-13T20:13:14Z", "type": "commit"}, {"oid": "c0bef70e12c44246326e39c7ef06211b13f84043", "url": "https://github.com/hapifhir/hapi-fhir/commit/c0bef70e12c44246326e39c7ef06211b13f84043", "message": "Add optional resource type to EMPI provider method", "committedDate": "2020-11-13T21:42:09Z", "type": "commit"}, {"oid": "fa0e87b56c69cc810b96b730876bc718d604b6c7", "url": "https://github.com/hapifhir/hapi-fhir/commit/fa0e87b56c69cc810b96b730876bc718d604b6c7", "message": "Links WIP", "committedDate": "2020-11-13T21:56:13Z", "type": "commit"}, {"oid": "176f7f041274778c7c08dd79e56b36a65ad0dadb", "url": "https://github.com/hapifhir/hapi-fhir/commit/176f7f041274778c7c08dd79e56b36a65ad0dadb", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-13T21:57:23Z", "type": "commit"}, {"oid": "1ad0246c2a60e69c016c3a41731bc07738e3db44", "url": "https://github.com/hapifhir/hapi-fhir/commit/1ad0246c2a60e69c016c3a41731bc07738e3db44", "message": "Added config fix", "committedDate": "2020-11-13T22:16:10Z", "type": "commit"}, {"oid": "0ad1b129d3dd750fddd1c79b6eb8fc0eac2f8c4e", "url": "https://github.com/hapifhir/hapi-fhir/commit/0ad1b129d3dd750fddd1c79b6eb8fc0eac2f8c4e", "message": "Links WIP 2", "committedDate": "2020-11-13T22:47:56Z", "type": "commit"}, {"oid": "514dab77840cf91d9884925108943d276a7ceffb", "url": "https://github.com/hapifhir/hapi-fhir/commit/514dab77840cf91d9884925108943d276a7ceffb", "message": "Updated resource type handling", "committedDate": "2020-11-16T16:26:31Z", "type": "commit"}, {"oid": "54f0021b29a59a139c3aec800240bb2eb32cd7fe", "url": "https://github.com/hapifhir/hapi-fhir/commit/54f0021b29a59a139c3aec800240bb2eb32cd7fe", "message": "All Batch tests now passing", "committedDate": "2020-11-16T17:50:28Z", "type": "commit"}, {"oid": "869814606d9be6bd488609d7235e7d63280ab15e", "url": "https://github.com/hapifhir/hapi-fhir/commit/869814606d9be6bd488609d7235e7d63280ab15e", "message": "Fixed code for UpdateLinkR4Test", "committedDate": "2020-11-16T20:08:34Z", "type": "commit"}, {"oid": "799f6adecbe5b54e967a5362fde886e490c890f0", "url": "https://github.com/hapifhir/hapi-fhir/commit/799f6adecbe5b54e967a5362fde886e490c890f0", "message": "Finish tests in BatchSvcImplTest", "committedDate": "2020-11-16T20:45:50Z", "type": "commit"}, {"oid": "9a481242c75f4e3a5b5e4354765bdb9f3917152a", "url": "https://github.com/hapifhir/hapi-fhir/commit/9a481242c75f4e3a5b5e4354765bdb9f3917152a", "message": "Resolved MergePersonsR4Test failures", "committedDate": "2020-11-16T22:42:09Z", "type": "commit"}, {"oid": "6fa12bb947144a3ef1c4f2c7bed91cff0e12562e", "url": "https://github.com/hapifhir/hapi-fhir/commit/6fa12bb947144a3ef1c4f2c7bed91cff0e12562e", "message": "Finish tests in EmpiResourceDaoSvcTest", "committedDate": "2020-11-16T23:26:44Z", "type": "commit"}, {"oid": "36d7dde2e1a6b184e8b522cbebc2408f13fff81d", "url": "https://github.com/hapifhir/hapi-fhir/commit/36d7dde2e1a6b184e8b522cbebc2408f13fff81d", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-16T23:27:18Z", "type": "commit"}, {"oid": "bc6940fd6aaecdd7f0c599dda4bd314eab53a326", "url": "https://github.com/hapifhir/hapi-fhir/commit/bc6940fd6aaecdd7f0c599dda4bd314eab53a326", "message": "Finish tests for provider", "committedDate": "2020-11-16T23:47:39Z", "type": "commit"}, {"oid": "dae587912d6bb431942f3debb19a9055ab518d82", "url": "https://github.com/hapifhir/hapi-fhir/commit/dae587912d6bb431942f3debb19a9055ab518d82", "message": "Update test json files", "committedDate": "2020-11-16T23:50:14Z", "type": "commit"}, {"oid": "45ec435c8f660b4f4bb67ba7f4123b852bbdde6e", "url": "https://github.com/hapifhir/hapi-fhir/commit/45ec435c8f660b4f4bb67ba7f4123b852bbdde6e", "message": "Fixed code to pass FieldMatcherTest", "committedDate": "2020-11-17T00:00:27Z", "type": "commit"}, {"oid": "406bbafafe5eb66d7cc19035d81d4e7878ef0a85", "url": "https://github.com/hapifhir/hapi-fhir/commit/406bbafafe5eb66d7cc19035d81d4e7878ef0a85", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:00:33Z", "type": "commit"}, {"oid": "511696bd84876dba6a9143aa0b78cc2919b9a84a", "url": "https://github.com/hapifhir/hapi-fhir/commit/511696bd84876dba6a9143aa0b78cc2919b9a84a", "message": "Fix validator error messages", "committedDate": "2020-11-17T00:11:19Z", "type": "commit"}, {"oid": "9940d4c4eb98072d3f6cc5a8a48ebf9600e9a286", "url": "https://github.com/hapifhir/hapi-fhir/commit/9940d4c4eb98072d3f6cc5a8a48ebf9600e9a286", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:12:08Z", "type": "commit"}, {"oid": "4d9414597b4e560f384737eafcf2da6f0260e803", "url": "https://github.com/hapifhir/hapi-fhir/commit/4d9414597b4e560f384737eafcf2da6f0260e803", "message": "Updated mocks for EID helper test", "committedDate": "2020-11-17T00:19:14Z", "type": "commit"}, {"oid": "70284b257434e639bf8b2cdd0555c2860e229db7", "url": "https://github.com/hapifhir/hapi-fhir/commit/70284b257434e639bf8b2cdd0555c2860e229db7", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:19:19Z", "type": "commit"}, {"oid": "23898579bd54490a15c389a193d9402d645a219b", "url": "https://github.com/hapifhir/hapi-fhir/commit/23898579bd54490a15c389a193d9402d645a219b", "message": "fix customresourcematcher test", "committedDate": "2020-11-17T00:42:11Z", "type": "commit"}, {"oid": "d15ce0db0835ef4313db06476f0af3c3d72639a3", "url": "https://github.com/hapifhir/hapi-fhir/commit/d15ce0db0835ef4313db06476f0af3c3d72639a3", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:42:16Z", "type": "commit"}, {"oid": "e4ce94bc7cb9c0ce4c5739bb82629073fdc90b5e", "url": "https://github.com/hapifhir/hapi-fhir/commit/e4ce94bc7cb9c0ce4c5739bb82629073fdc90b5e", "message": "Fix resourcemastchersvc tests", "committedDate": "2020-11-17T01:06:46Z", "type": "commit"}, {"oid": "676f6315e6fbe6e7edaea0f40716246da1f396a3", "url": "https://github.com/hapifhir/hapi-fhir/commit/676f6315e6fbe6e7edaea0f40716246da1f396a3", "message": "Fix tests", "committedDate": "2020-11-17T01:21:42Z", "type": "commit"}, {"oid": "c50c4edea4c849d1ee38ff2a4169e0d59014509c", "url": "https://github.com/hapifhir/hapi-fhir/commit/c50c4edea4c849d1ee38ff2a4169e0d59014509c", "message": "Merge remote-tracking branch 'origin/master' into 2161-refactor-empi", "committedDate": "2020-11-17T14:27:39Z", "type": "commit"}, {"oid": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "url": "https://github.com/hapifhir/hapi-fhir/commit/805d5b1d6c1c800295cbe99af777b53f6290dd71", "message": "Merge branch '2161-refactor-empi' into gg_20201105-remove-person-references", "committedDate": "2020-11-17T14:28:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1NzI0Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525357242", "body": "Consider changing to GOLDEN_RESOURCE_PID and renaming variable to myGoldenResourcePid", "bodyText": "Consider changing to GOLDEN_RESOURCE_PID and renaming variable to myGoldenResourcePid", "bodyHTML": "<p dir=\"auto\">Consider changing to GOLDEN_RESOURCE_PID and renaming variable to myGoldenResourcePid</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:41:09Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -60,6 +60,13 @@\n \t@Column(name = \"PID\")\n \tprivate Long myId;\n \n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nsimilarity index 70%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 26b540c709..afc6f6ff96 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n", "chunk": "@@ -61,16 +61,18 @@ public class EmpiLink {\n \tprivate Long myId;\n \n \t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n-\t@JoinColumn(name = \"SOURCE_RESOURCE_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_SOURCE_RESOURCE\"), insertable=false, updatable=false, nullable=false)\n-\tprivate ResourceTable mySourceResource;\n+\t@JoinColumn(name = \"GOLDEN_RESOURCE_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_GOLDEN_RESOURCE\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myGoldenResource;\n \n-\t@Column(name = \"SOURCE_RESOURCE_PID\", nullable=false)\n-\tprivate Long mySourceResourcePid;\n+\t@Column(name = \"GOLDEN_RESOURCE_PID\", nullable=false)\n+\tprivate Long myGoldenResourcePid;\n \n+\t@Deprecated\n \t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n \t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n \tprivate ResourceTable myPerson;\n \n+\t@Deprecated\n \t@Column(name = \"PERSON_PID\", nullable=false)\n \tprivate Long myPersonPid;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1NzkwMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525357901", "body": "Change to myGoldenResourcePid, and add rule count", "bodyText": "Change to myGoldenResourcePid, and add rule count", "bodyHTML": "<p dir=\"auto\">Change to myGoldenResourcePid, and add rule count</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:42:07Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -289,18 +303,27 @@ public EmpiLink setEmpiTargetType(String theEmpiTargetType) {\n \tpublic String toString() {\n \t\treturn new ToStringBuilder(this)\n \t\t\t.append(\"myId\", myId)\n-\t\t\t.append(\"myPersonPid\", myPersonPid)\n+\t\t\t.append(\"myPersonPid\", mySourceResourcePid)", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nsimilarity index 70%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 26b540c709..afc6f6ff96 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n", "chunk": "@@ -289,13 +291,13 @@ public class EmpiLink {\n \t\treturn myHadToCreateNewResource != null && myHadToCreateNewResource;\n \t}\n \n-\tpublic EmpiLink setHadToCreateNewResource(Boolean theHadToCreateNewResource) {\n+\tpublic MdmLink setHadToCreateNewResource(Boolean theHadToCreateNewResource) {\n \t\tmyHadToCreateNewResource = theHadToCreateNewResource;\n \t\treturn this;\n \t}\n \n-\tpublic EmpiLink setEmpiTargetType(String theEmpiTargetType) {\n-\t\tmyEmpiTargetType = theEmpiTargetType;\n+\tpublic MdmLink setMdmTargetType(String mdmTargetType) {\n+\t\tmyMdmTargetType = mdmTargetType;\n \t\treturn this;\n \t}\n \n", "next_change": null}, {"header": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nsimilarity index 70%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 26b540c709..afc6f6ff96 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n", "chunk": "@@ -303,19 +305,20 @@ public class EmpiLink {\n \tpublic String toString() {\n \t\treturn new ToStringBuilder(this)\n \t\t\t.append(\"myId\", myId)\n-\t\t\t.append(\"myPersonPid\", mySourceResourcePid)\n+\t\t\t.append(\"myGoldenResource\", myGoldenResourcePid)\n \t\t\t.append(\"myTargetPid\", myTargetPid)\n-\t\t\t.append(\"myEmpiTargetType\", myEmpiTargetType)\n+\t\t\t.append(\"myMdmTargetType\", myMdmTargetType)\n \t\t\t.append(\"myMatchResult\", myMatchResult)\n \t\t\t.append(\"myLinkSource\", myLinkSource)\n \t\t\t.append(\"myEidMatch\", myEidMatch)\n-\t\t\t.append(\"myNewPerson\", myHadToCreateNewResource)\n+\t\t\t.append(\"myHadToCreateNewResource\", myHadToCreateNewResource)\n \t\t\t.append(\"myScore\", myScore)\n+\t\t\t.append(\"myRuleCount\", myRuleCount)\n \t\t\t.toString();\n \t}\n \n-\tpublic String getEmpiTargetType() {\n-\t\treturn myEmpiTargetType;\n+\tpublic String getMdmTargetType() {\n+\t\treturn myMdmTargetType;\n \t}\n \n \tpublic Long getRuleCount() {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1ODM5OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525358398", "body": "Rename to myMdmSettings", "bodyText": "Rename to myMdmSettings", "bodyHTML": "<p dir=\"auto\">Rename to myMdmSettings</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:42:52Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java", "diffHunk": "@@ -106,51 +108,51 @@ public void matchEmpiAndUpdateLinks(ResourceModifiedMessage theMsg) {\n \t\t}\n \t}\n \n-\tprivate EmpiTransactionContext createEmpiContext(ResourceModifiedMessage theMsg) {\n+\tprivate MdmTransactionContext createEmpiContext(ResourceModifiedMessage theMsg, String theResourceType) {\n \t\tTransactionLogMessages transactionLogMessages = TransactionLogMessages.createFromTransactionGuid(theMsg.getTransactionId());\n-\t\tEmpiTransactionContext.OperationType empiOperation;\n+\t\tMdmTransactionContext.OperationType empiOperation;\n \t\tswitch (theMsg.getOperationType()) {\n \t\t\tcase CREATE:\n-\t\t\t\tempiOperation = EmpiTransactionContext.OperationType.CREATE_RESOURCE;\n+\t\t\t\tempiOperation = MdmTransactionContext.OperationType.CREATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase UPDATE:\n-\t\t\t\tempiOperation = EmpiTransactionContext.OperationType.UPDATE_RESOURCE;\n+\t\t\t\tempiOperation = MdmTransactionContext.OperationType.UPDATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase MANUALLY_TRIGGERED:\n-\t\t\t\tempiOperation = EmpiTransactionContext.OperationType.SUBMIT_RESOURCE_TO_EMPI;\n+\t\t\t\tempiOperation = MdmTransactionContext.OperationType.SUBMIT_RESOURCE_TO_EMPI;\n \t\t\t\tbreak;\n \t\t\tcase DELETE:\n \t\t\tdefault:\n \t\t\t\tourLog.trace(\"Not creating an EmpiTransactionContext for {}\", theMsg.getOperationType());\n \t\t\t\tthrow new InvalidRequestException(\"We can't handle non-update/create operations in EMPI\");\n \t\t}\n-\t\treturn new EmpiTransactionContext(transactionLogMessages, empiOperation);\n+\t\treturn new MdmTransactionContext(transactionLogMessages, empiOperation, theResourceType);\n \t}\n \n \tprivate void validateResourceType(String theResourceType) {\n-\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n+\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/broker/MdmMessageHandler.java\nsimilarity index 60%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/broker/MdmMessageHandler.java\nindex 814ef671df..1f9c3bdc60 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/broker/MdmMessageHandler.java\n", "chunk": "@@ -68,75 +68,75 @@ public class EmpiMessageHandler implements MessageHandler {\n \n \t\tResourceModifiedMessage msg = ((ResourceModifiedJsonMessage) theMessage).getPayload();\n \t\ttry {\n-\t\t\tif (myEmpiResourceFilteringSvc.shouldBeProcessed(getResourceFromPayload(msg))) {\n-\t\t\t\tmatchEmpiAndUpdateLinks(msg);\n+\t\t\tif (myMdmResourceFilteringSvc.shouldBeProcessed(getResourceFromPayload(msg))) {\n+\t\t\t\tmatchMdmAndUpdateLinks(msg);\n \t\t\t}\n \t\t} catch (Exception e) {\n-\t\t\tourLog.error(\"Failed to handle EMPI Matching Resource:\", e);\n+\t\t\tourLog.error(\"Failed to handle MDM Matching Resource:\", e);\n \t\t\tthrow e;\n \t\t}\n \t}\n-\tpublic void matchEmpiAndUpdateLinks(ResourceModifiedMessage theMsg) {\n+\tpublic void matchMdmAndUpdateLinks(ResourceModifiedMessage theMsg) {\n \t\tString resourceType = theMsg.getId(myFhirContext).getResourceType();\n \t\tvalidateResourceType(resourceType);\n-\t\tMdmTransactionContext empiContext =  createEmpiContext(theMsg, resourceType);\n+\t\tMdmTransactionContext mdmContext =  createMdmContext(theMsg, resourceType);\n \t\ttry {\n \t\t\tswitch (theMsg.getOperationType()) {\n \t\t\t\tcase CREATE:\n-\t\t\t\t\thandleCreatePatientOrPractitioner(theMsg, empiContext);\n+\t\t\t\t\thandleCreatePatientOrPractitioner(theMsg, mdmContext);\n \t\t\t\t\tbreak;\n \t\t\t\tcase UPDATE:\n \t\t\t\tcase MANUALLY_TRIGGERED:\n-\t\t\t\t\thandleUpdatePatientOrPractitioner(theMsg, empiContext);\n+\t\t\t\t\thandleUpdatePatientOrPractitioner(theMsg, mdmContext);\n \t\t\t\t\tbreak;\n \t\t\t\tcase DELETE:\n \t\t\t\tdefault:\n \t\t\t\t\tourLog.trace(\"Not processing modified message for {}\", theMsg.getOperationType());\n \t\t\t}\n \t\t}catch (Exception e) {\n-\t\t\tlog(empiContext, \"Failure during EMPI processing: \" + e.getMessage(), e);\n+\t\t\tlog(mdmContext, \"Failure during MDM processing: \" + e.getMessage(), e);\n \t\t} finally {\n \n-\t\t\t// Interceptor call: EMPI_AFTER_PERSISTED_RESOURCE_CHECKED\n+\t\t\t// Interceptor call: MDM_AFTER_PERSISTED_RESOURCE_CHECKED\n \t\t\tResourceOperationMessage outgoingMsg = new ResourceOperationMessage(myFhirContext, theMsg.getPayload(myFhirContext), theMsg.getOperationType());\n \t\t\toutgoingMsg.setTransactionId(theMsg.getTransactionId());\n \n \t\t\tHookParams params = new HookParams()\n \t\t\t\t.add(ResourceOperationMessage.class, outgoingMsg)\n-\t\t\t\t.add(TransactionLogMessages.class, empiContext.getTransactionLogMessages());\n-\t\t\tmyInterceptorBroadcaster.callHooks(Pointcut.EMPI_AFTER_PERSISTED_RESOURCE_CHECKED, params);\n+\t\t\t\t.add(TransactionLogMessages.class, mdmContext.getTransactionLogMessages());\n+\t\t\tmyInterceptorBroadcaster.callHooks(Pointcut.MDM_AFTER_PERSISTED_RESOURCE_CHECKED, params);\n \t\t}\n \t}\n \n-\tprivate MdmTransactionContext createEmpiContext(ResourceModifiedMessage theMsg, String theResourceType) {\n+\tprivate MdmTransactionContext createMdmContext(ResourceModifiedMessage theMsg, String theResourceType) {\n \t\tTransactionLogMessages transactionLogMessages = TransactionLogMessages.createFromTransactionGuid(theMsg.getTransactionId());\n-\t\tMdmTransactionContext.OperationType empiOperation;\n+\t\tMdmTransactionContext.OperationType mdmOperation;\n \t\tswitch (theMsg.getOperationType()) {\n \t\t\tcase CREATE:\n-\t\t\t\tempiOperation = MdmTransactionContext.OperationType.CREATE_RESOURCE;\n+\t\t\t\tmdmOperation = MdmTransactionContext.OperationType.CREATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase UPDATE:\n-\t\t\t\tempiOperation = MdmTransactionContext.OperationType.UPDATE_RESOURCE;\n+\t\t\t\tmdmOperation = MdmTransactionContext.OperationType.UPDATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase MANUALLY_TRIGGERED:\n-\t\t\t\tempiOperation = MdmTransactionContext.OperationType.SUBMIT_RESOURCE_TO_EMPI;\n+\t\t\t\tmdmOperation = MdmTransactionContext.OperationType.SUBMIT_RESOURCE_TO_MDM;\n \t\t\t\tbreak;\n \t\t\tcase DELETE:\n \t\t\tdefault:\n-\t\t\t\tourLog.trace(\"Not creating an EmpiTransactionContext for {}\", theMsg.getOperationType());\n-\t\t\t\tthrow new InvalidRequestException(\"We can't handle non-update/create operations in EMPI\");\n+\t\t\t\tourLog.trace(\"Not creating an MdmTransactionContext for {}\", theMsg.getOperationType());\n+\t\t\t\tthrow new InvalidRequestException(\"We can't handle non-update/create operations in MDM\");\n \t\t}\n-\t\treturn new MdmTransactionContext(transactionLogMessages, empiOperation, theResourceType);\n+\t\treturn new MdmTransactionContext(transactionLogMessages, mdmOperation, theResourceType);\n \t}\n \n \tprivate void validateResourceType(String theResourceType) {\n-\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n-\t\t\tthrow new IllegalStateException(\"Unsupported resource type submitted to EMPI matching queue: \" + theResourceType);\n+\t\tif (!myMdmSettings.isSupportedMdmType(theResourceType)) {\n+\t\t\tthrow new IllegalStateException(\"Unsupported resource type submitted to MDM matching queue: \" + theResourceType);\n \t\t}\n \t}\n \n \tprivate void handleCreatePatientOrPractitioner(ResourceModifiedMessage theMsg, MdmTransactionContext theMdmTransactionContext) {\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(getResourceFromPayload(theMsg), theMdmTransactionContext);\n+\t\tmyMdmMatchLinkSvc.updateMdmLinksForMdmTarget(getResourceFromPayload(theMsg), theMdmTransactionContext);\n \t}\n \n \tprivate IAnyResource getResourceFromPayload(ResourceModifiedMessage theMsg) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1ODg1OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525358859", "body": "Chance Empi prefix to Mdm and rename variables appropriately.", "bodyText": "Chance Empi prefix to Mdm and rename variables appropriately.", "bodyHTML": "<p dir=\"auto\">Chance Empi prefix to Mdm and rename variables appropriately.</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:43:36Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java", "diffHunk": "@@ -168,8 +174,8 @@ IEmpiLinkQuerySvc empiLinkQuerySvc() {\n \t}\n \n \t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl ) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl);\n+\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\ndeleted file mode 100644\nindex 177d267ec6..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n+++ /dev/null\n", "chunk": "@@ -1,240 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n-import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n-import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n-import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.MessageHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n-import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.GoldenResourceMergerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiSourceResourceFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n-import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n-import ca.uhn.fhir.validation.IResourceLoader;\n-import org.slf4j.Logger;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-\n-@Configuration\n-public class EmpiConsumerConfig {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Bean\n-\tIEmpiStorageInterceptor empiStorageInterceptor() {\n-\t\treturn new EmpiStorageInterceptor();\n-\t}\n-\n-\t@Bean\n-\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n-\t\treturn new EmpiQueueConsumerLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiMessageHandler empiMessageHandler() {\n-\t\treturn new EmpiMessageHandler();\n-\t}\n-\n-\t@Bean\n-\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n-\t\treturn new EmpiMatchLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiEidUpdateService eidUpdateService() {\n-\t\treturn new EmpiEidUpdateService();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n-\t\treturn new EmpiResourceDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkSvc empiLinkSvc() {\n-\t\treturn new EmpiLinkSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tPersonHelper personHelper(FhirContext theFhirContext) {\n-\t\treturn new PersonHelper(theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tMessageHelper messageHelper(IEmpiSettings theEmpiSettings, FhirContext theFhirContext) {\n-\t\treturn new MessageHelper(theEmpiSettings, theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n-\t\treturn new EmpiSubscriptionLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n-\t\treturn new EmpiSearchParameterLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSourceResourceFindingSvc empiPersonFindingSvc() {\n-\t\treturn new EmpiSourceResourceFindingSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByEidSvc findCandidateByEidSvc() {\n-\t\treturn new FindCandidateByEidSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n-\t\treturn new FindCandidateByLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n-\t\treturn new FindCandidateByScoreSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiProviderLoader empiProviderLoader() {\n-\t\treturn new EmpiProviderLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n-\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n-\t}\n-\n-\t@Bean\n-\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n-\t\treturn new EmpiMatchFinderSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIGoldenResourceMergerSvc empiPersonMergerSvc() {\n-\t\treturn new GoldenResourceMergerSvcImpl();\n-\t}\n-\n-\n-\t@Bean\n-\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n-\t\treturn new EmpiLinkQuerySvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl, theIEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n-\t\treturn new EmpiCandidateSearchSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n-\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n-\t\treturn new EmpiLinkDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n-\t\treturn new EmpiLinkFactory(theEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n-\t\treturn new EmpiLinkUpdaterSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tEmpiLoader empiLoader() {\n-\t\treturn new EmpiLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n-\t\treturn new EmpiLinkDeleteSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n-\t\treturn new EmpiResourceFilteringSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader, IEmpiSettings theEmpiSettings, MessageHelper messageHelper) {\n-\t\treturn new EmpiControllerHelper(theFhirContext, theResourceLoader, theEmpiSettings, messageHelper);\n-\t}\n-\n-\t@Bean\n-\tIEmpiControllerSvc empiControllerSvc() {\n-\t\treturn new EmpiControllerSvcImpl();\n-\t}\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\nnew file mode 100644\nindex 0000000000..7c624955eb\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n", "chunk": "@@ -0,0 +1,230 @@\n+package ca.uhn.fhir.jpa.empi.config;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n+import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.IEmpiPersonMergerSvc;\n+import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n+import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n+import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n+import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n+import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n+import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n+import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n+import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiPersonMergerSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiPersonFindingSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n+import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n+import ca.uhn.fhir.validation.IResourceLoader;\n+import org.slf4j.Logger;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+@Configuration\n+public class EmpiConsumerConfig {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Bean\n+\tIEmpiStorageInterceptor empiStorageInterceptor() {\n+\t\treturn new EmpiStorageInterceptor();\n+\t}\n+\n+\t@Bean\n+\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n+\t\treturn new EmpiQueueConsumerLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiMessageHandler empiMessageHandler() {\n+\t\treturn new EmpiMessageHandler();\n+\t}\n+\n+\t@Bean\n+\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n+\t\treturn new EmpiMatchLinkSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiEidUpdateService eidUpdateService() {\n+\t\treturn new EmpiEidUpdateService();\n+\t}\n+\n+\t@Bean\n+\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n+\t\treturn new EmpiResourceDaoSvc();\n+\t}\n+\n+\t@Bean\n+\tIEmpiLinkSvc empiLinkSvc() {\n+\t\treturn new EmpiLinkSvcImpl();\n+\t}\n+\n+\t@Bean\n+\tPersonHelper personHelper(FhirContext theFhirContext) {\n+\t\treturn new PersonHelper(theFhirContext);\n+\t}\n+\n+\t@Bean\n+\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n+\t\treturn new EmpiSubscriptionLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n+\t\treturn new EmpiSearchParameterLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiPersonFindingSvc empiPersonFindingSvc() {\n+\t\treturn new EmpiPersonFindingSvc();\n+\t}\n+\n+\t@Bean\n+\tFindCandidateByEidSvc findCandidateByEidSvc() {\n+\t\treturn new FindCandidateByEidSvc();\n+\t}\n+\n+\t@Bean\n+\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n+\t\treturn new FindCandidateByLinkSvc();\n+\t}\n+\n+\t@Bean\n+\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n+\t\treturn new FindCandidateByScoreSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiProviderLoader empiProviderLoader() {\n+\t\treturn new EmpiProviderLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n+\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n+\t}\n+\n+\t@Bean\n+\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n+\t\treturn new EmpiMatchFinderSvcImpl();\n+\t}\n+\n+\t@Bean\n+\tIEmpiPersonMergerSvc empiPersonMergerSvc() {\n+\t\treturn new EmpiPersonMergerSvcImpl();\n+\t}\n+\n+\n+\t@Bean\n+\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n+\t\treturn new EmpiLinkQuerySvcImpl();\n+\t}\n+\n+\t@Bean\n+\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl ) {\n+\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl);\n+\t}\n+\n+\t@Bean\n+\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n+\t\treturn new EmpiCandidateSearchSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n+\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n+\t}\n+\n+\t@Bean\n+    EmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n+\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n+\t}\n+\n+\t@Bean\n+\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n+\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n+\t}\n+\n+\t@Bean\n+\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n+\t\treturn new EmpiLinkDaoSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n+\t\treturn new EmpiLinkFactory(theEmpiSettings);\n+\t}\n+\n+\t@Bean\n+\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n+\t\treturn new EmpiLinkUpdaterSvcImpl();\n+\t}\n+\n+\t@Bean\n+\tEmpiLoader empiLoader() {\n+\t\treturn new EmpiLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n+\t\treturn new EmpiLinkDeleteSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n+\t\treturn new EmpiResourceFilteringSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader) { return new EmpiControllerHelper(theFhirContext, theResourceLoader); }\n+\n+\t@Bean\n+\tIEmpiControllerSvc empiControllerSvc() {return new EmpiControllerSvcImpl(); }\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\ndeleted file mode 100644\nindex 7c624955eb..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n+++ /dev/null\n", "chunk": "@@ -1,230 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n-import ca.uhn.fhir.empi.api.IEmpiPersonMergerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n-import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n-import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n-import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonMergerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiPersonFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n-import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n-import ca.uhn.fhir.validation.IResourceLoader;\n-import org.slf4j.Logger;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-\n-@Configuration\n-public class EmpiConsumerConfig {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Bean\n-\tIEmpiStorageInterceptor empiStorageInterceptor() {\n-\t\treturn new EmpiStorageInterceptor();\n-\t}\n-\n-\t@Bean\n-\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n-\t\treturn new EmpiQueueConsumerLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiMessageHandler empiMessageHandler() {\n-\t\treturn new EmpiMessageHandler();\n-\t}\n-\n-\t@Bean\n-\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n-\t\treturn new EmpiMatchLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiEidUpdateService eidUpdateService() {\n-\t\treturn new EmpiEidUpdateService();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n-\t\treturn new EmpiResourceDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkSvc empiLinkSvc() {\n-\t\treturn new EmpiLinkSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tPersonHelper personHelper(FhirContext theFhirContext) {\n-\t\treturn new PersonHelper(theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n-\t\treturn new EmpiSubscriptionLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n-\t\treturn new EmpiSearchParameterLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiPersonFindingSvc empiPersonFindingSvc() {\n-\t\treturn new EmpiPersonFindingSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByEidSvc findCandidateByEidSvc() {\n-\t\treturn new FindCandidateByEidSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n-\t\treturn new FindCandidateByLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n-\t\treturn new FindCandidateByScoreSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiProviderLoader empiProviderLoader() {\n-\t\treturn new EmpiProviderLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n-\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n-\t}\n-\n-\t@Bean\n-\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n-\t\treturn new EmpiMatchFinderSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiPersonMergerSvc empiPersonMergerSvc() {\n-\t\treturn new EmpiPersonMergerSvcImpl();\n-\t}\n-\n-\n-\t@Bean\n-\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n-\t\treturn new EmpiLinkQuerySvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl ) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl);\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n-\t\treturn new EmpiCandidateSearchSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n-\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n-\t}\n-\n-\t@Bean\n-    EmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n-\t\treturn new EmpiLinkDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n-\t\treturn new EmpiLinkFactory(theEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n-\t\treturn new EmpiLinkUpdaterSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tEmpiLoader empiLoader() {\n-\t\treturn new EmpiLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n-\t\treturn new EmpiLinkDeleteSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n-\t\treturn new EmpiResourceFilteringSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader) { return new EmpiControllerHelper(theFhirContext, theResourceLoader); }\n-\n-\t@Bean\n-\tIEmpiControllerSvc empiControllerSvc() {return new EmpiControllerSvcImpl(); }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1OTE4Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525359182", "body": "Change Empi prefix to Mdm and rename variables appropriately.", "bodyText": "Change Empi prefix to Mdm and rename variables appropriately.", "bodyHTML": "<p dir=\"auto\">Change Empi prefix to Mdm and rename variables appropriately.</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:44:05Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java", "diffHunk": "@@ -223,8 +229,12 @@ EmpiResourceFilteringSvc empiResourceFilteringSvc() {\n \t}\n \n \t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader) { return new EmpiControllerHelper(theFhirContext, theResourceLoader); }\n+\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader, IEmpiSettings theEmpiSettings, MessageHelper messageHelper) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\ndeleted file mode 100644\nindex 177d267ec6..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n+++ /dev/null\n", "chunk": "@@ -1,240 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n-import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n-import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n-import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.MessageHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n-import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.GoldenResourceMergerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiSourceResourceFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n-import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n-import ca.uhn.fhir.validation.IResourceLoader;\n-import org.slf4j.Logger;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-\n-@Configuration\n-public class EmpiConsumerConfig {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Bean\n-\tIEmpiStorageInterceptor empiStorageInterceptor() {\n-\t\treturn new EmpiStorageInterceptor();\n-\t}\n-\n-\t@Bean\n-\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n-\t\treturn new EmpiQueueConsumerLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiMessageHandler empiMessageHandler() {\n-\t\treturn new EmpiMessageHandler();\n-\t}\n-\n-\t@Bean\n-\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n-\t\treturn new EmpiMatchLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiEidUpdateService eidUpdateService() {\n-\t\treturn new EmpiEidUpdateService();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n-\t\treturn new EmpiResourceDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkSvc empiLinkSvc() {\n-\t\treturn new EmpiLinkSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tPersonHelper personHelper(FhirContext theFhirContext) {\n-\t\treturn new PersonHelper(theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tMessageHelper messageHelper(IEmpiSettings theEmpiSettings, FhirContext theFhirContext) {\n-\t\treturn new MessageHelper(theEmpiSettings, theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n-\t\treturn new EmpiSubscriptionLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n-\t\treturn new EmpiSearchParameterLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSourceResourceFindingSvc empiPersonFindingSvc() {\n-\t\treturn new EmpiSourceResourceFindingSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByEidSvc findCandidateByEidSvc() {\n-\t\treturn new FindCandidateByEidSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n-\t\treturn new FindCandidateByLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n-\t\treturn new FindCandidateByScoreSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiProviderLoader empiProviderLoader() {\n-\t\treturn new EmpiProviderLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n-\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n-\t}\n-\n-\t@Bean\n-\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n-\t\treturn new EmpiMatchFinderSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIGoldenResourceMergerSvc empiPersonMergerSvc() {\n-\t\treturn new GoldenResourceMergerSvcImpl();\n-\t}\n-\n-\n-\t@Bean\n-\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n-\t\treturn new EmpiLinkQuerySvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl, theIEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n-\t\treturn new EmpiCandidateSearchSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n-\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n-\t\treturn new EmpiLinkDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n-\t\treturn new EmpiLinkFactory(theEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n-\t\treturn new EmpiLinkUpdaterSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tEmpiLoader empiLoader() {\n-\t\treturn new EmpiLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n-\t\treturn new EmpiLinkDeleteSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n-\t\treturn new EmpiResourceFilteringSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader, IEmpiSettings theEmpiSettings, MessageHelper messageHelper) {\n-\t\treturn new EmpiControllerHelper(theFhirContext, theResourceLoader, theEmpiSettings, messageHelper);\n-\t}\n-\n-\t@Bean\n-\tIEmpiControllerSvc empiControllerSvc() {\n-\t\treturn new EmpiControllerSvcImpl();\n-\t}\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\nnew file mode 100644\nindex 0000000000..7c624955eb\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n", "chunk": "@@ -0,0 +1,230 @@\n+package ca.uhn.fhir.jpa.empi.config;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n+import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.IEmpiPersonMergerSvc;\n+import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n+import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n+import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n+import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n+import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n+import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n+import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n+import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiPersonMergerSvcImpl;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n+import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiPersonFindingSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n+import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n+import ca.uhn.fhir.validation.IResourceLoader;\n+import org.slf4j.Logger;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+@Configuration\n+public class EmpiConsumerConfig {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Bean\n+\tIEmpiStorageInterceptor empiStorageInterceptor() {\n+\t\treturn new EmpiStorageInterceptor();\n+\t}\n+\n+\t@Bean\n+\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n+\t\treturn new EmpiQueueConsumerLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiMessageHandler empiMessageHandler() {\n+\t\treturn new EmpiMessageHandler();\n+\t}\n+\n+\t@Bean\n+\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n+\t\treturn new EmpiMatchLinkSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiEidUpdateService eidUpdateService() {\n+\t\treturn new EmpiEidUpdateService();\n+\t}\n+\n+\t@Bean\n+\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n+\t\treturn new EmpiResourceDaoSvc();\n+\t}\n+\n+\t@Bean\n+\tIEmpiLinkSvc empiLinkSvc() {\n+\t\treturn new EmpiLinkSvcImpl();\n+\t}\n+\n+\t@Bean\n+\tPersonHelper personHelper(FhirContext theFhirContext) {\n+\t\treturn new PersonHelper(theFhirContext);\n+\t}\n+\n+\t@Bean\n+\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n+\t\treturn new EmpiSubscriptionLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n+\t\treturn new EmpiSearchParameterLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiPersonFindingSvc empiPersonFindingSvc() {\n+\t\treturn new EmpiPersonFindingSvc();\n+\t}\n+\n+\t@Bean\n+\tFindCandidateByEidSvc findCandidateByEidSvc() {\n+\t\treturn new FindCandidateByEidSvc();\n+\t}\n+\n+\t@Bean\n+\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n+\t\treturn new FindCandidateByLinkSvc();\n+\t}\n+\n+\t@Bean\n+\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n+\t\treturn new FindCandidateByScoreSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiProviderLoader empiProviderLoader() {\n+\t\treturn new EmpiProviderLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n+\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n+\t}\n+\n+\t@Bean\n+\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n+\t\treturn new EmpiMatchFinderSvcImpl();\n+\t}\n+\n+\t@Bean\n+\tIEmpiPersonMergerSvc empiPersonMergerSvc() {\n+\t\treturn new EmpiPersonMergerSvcImpl();\n+\t}\n+\n+\n+\t@Bean\n+\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n+\t\treturn new EmpiLinkQuerySvcImpl();\n+\t}\n+\n+\t@Bean\n+\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl ) {\n+\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl);\n+\t}\n+\n+\t@Bean\n+\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n+\t\treturn new EmpiCandidateSearchSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n+\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n+\t}\n+\n+\t@Bean\n+    EmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n+\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n+\t}\n+\n+\t@Bean\n+\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n+\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n+\t}\n+\n+\t@Bean\n+\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n+\t\treturn new EmpiLinkDaoSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n+\t\treturn new EmpiLinkFactory(theEmpiSettings);\n+\t}\n+\n+\t@Bean\n+\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n+\t\treturn new EmpiLinkUpdaterSvcImpl();\n+\t}\n+\n+\t@Bean\n+\tEmpiLoader empiLoader() {\n+\t\treturn new EmpiLoader();\n+\t}\n+\n+\t@Bean\n+\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n+\t\treturn new EmpiLinkDeleteSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n+\t\treturn new EmpiResourceFilteringSvc();\n+\t}\n+\n+\t@Bean\n+\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader) { return new EmpiControllerHelper(theFhirContext, theResourceLoader); }\n+\n+\t@Bean\n+\tIEmpiControllerSvc empiControllerSvc() {return new EmpiControllerSvcImpl(); }\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\ndeleted file mode 100644\nindex 7c624955eb..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n+++ /dev/null\n", "chunk": "@@ -1,230 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n-import ca.uhn.fhir.empi.api.IEmpiPersonMergerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n-import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n-import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n-import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonMergerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiPersonFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n-import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n-import ca.uhn.fhir.validation.IResourceLoader;\n-import org.slf4j.Logger;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-\n-@Configuration\n-public class EmpiConsumerConfig {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Bean\n-\tIEmpiStorageInterceptor empiStorageInterceptor() {\n-\t\treturn new EmpiStorageInterceptor();\n-\t}\n-\n-\t@Bean\n-\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n-\t\treturn new EmpiQueueConsumerLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiMessageHandler empiMessageHandler() {\n-\t\treturn new EmpiMessageHandler();\n-\t}\n-\n-\t@Bean\n-\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n-\t\treturn new EmpiMatchLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiEidUpdateService eidUpdateService() {\n-\t\treturn new EmpiEidUpdateService();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n-\t\treturn new EmpiResourceDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkSvc empiLinkSvc() {\n-\t\treturn new EmpiLinkSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tPersonHelper personHelper(FhirContext theFhirContext) {\n-\t\treturn new PersonHelper(theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n-\t\treturn new EmpiSubscriptionLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n-\t\treturn new EmpiSearchParameterLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiPersonFindingSvc empiPersonFindingSvc() {\n-\t\treturn new EmpiPersonFindingSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByEidSvc findCandidateByEidSvc() {\n-\t\treturn new FindCandidateByEidSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n-\t\treturn new FindCandidateByLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n-\t\treturn new FindCandidateByScoreSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiProviderLoader empiProviderLoader() {\n-\t\treturn new EmpiProviderLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n-\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n-\t}\n-\n-\t@Bean\n-\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n-\t\treturn new EmpiMatchFinderSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiPersonMergerSvc empiPersonMergerSvc() {\n-\t\treturn new EmpiPersonMergerSvcImpl();\n-\t}\n-\n-\n-\t@Bean\n-\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n-\t\treturn new EmpiLinkQuerySvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl ) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl);\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n-\t\treturn new EmpiCandidateSearchSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n-\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n-\t}\n-\n-\t@Bean\n-    EmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n-\t\treturn new EmpiLinkDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n-\t\treturn new EmpiLinkFactory(theEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n-\t\treturn new EmpiLinkUpdaterSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tEmpiLoader empiLoader() {\n-\t\treturn new EmpiLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n-\t\treturn new EmpiLinkDeleteSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n-\t\treturn new EmpiResourceFilteringSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader) { return new EmpiControllerHelper(theFhirContext, theResourceLoader); }\n-\n-\t@Bean\n-\tIEmpiControllerSvc empiControllerSvc() {return new EmpiControllerSvcImpl(); }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MTcxOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525361719", "body": "This functionality is pending further requirements elicitation?", "bodyText": "This functionality is pending further requirements elicitation?", "bodyHTML": "<p dir=\"auto\">This functionality is pending further requirements elicitation?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:47:50Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java", "diffHunk": "@@ -78,7 +78,7 @@ private SearchParameter buildAssuranceEmpiSearchParameterR4() {\n \t\tSearchParameter retval = new SearchParameter();\n \t\tretval.setId(EMPI_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\nsimilarity index 66%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\nindex 04cbfcbebd..7d447fe61e 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\n", "chunk": "@@ -74,11 +74,11 @@ public class EmpiSearchParameterLoader {\n \t\treturn retval;\n \t}\n \n-\tprivate SearchParameter buildAssuranceEmpiSearchParameterR4() {\n+\tprivate SearchParameter buildAssuranceMdmSearchParameterR4() {\n \t\tSearchParameter retval = new SearchParameter();\n-\t\tretval.setId(EMPI_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);\n+\t\tretval.setId(MDM_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);\n \t\tretval.setStatus(Enumerations.PublicationStatus.ACTIVE);\n-\t\tretval.getMeta().addTag().setSystem(EmpiConstants.SYSTEM_MDM_MANAGED).setCode(EmpiConstants.CODE_HAPI_MDM_MANAGED);\n+\t\tretval.getMeta().addTag().setSystem(MdmConstants.SYSTEM_MDM_MANAGED).setCode(MdmConstants.CODE_HAPI_MDM_MANAGED);\n \t\tretval.setCode(\"assurance\");\n \t\tretval.addBase(\"Person\");\n \t\tretval.setType(Enumerations.SearchParamType.TOKEN);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MjI5Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525362297", "body": "Rename source to golden", "bodyText": "Rename source to golden", "bodyHTML": "<p dir=\"auto\">Rename source to golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:48:20Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -59,61 +60,60 @@\n \tprivate FhirContext myFhirContext;\n \n \t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..4a16a1d782\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,319 @@\n+package ca.uhn.fhir.jpa.empi.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate EmpiLinkFactory myEmpiLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n+\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tif (empiLink.getScore() != null) {\n+\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n+\t\t} else {\n+\t\t\tempiLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n+\t\t\tnewLink.setPersonPid(thePersonPid);\n+\t\t\tnewLink.setTargetPid(theResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a Target Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theTargetPid the target of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t *\n+\t * @return a list of {@link EmpiLink} entities matching these criteria.\n+\t */\n+\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n+\t *\n+\t * @param thePersonPid The Pid of the Person in the relationship\n+\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param theMatchResult The MatchResult you are looking for.\n+\t *\n+\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setPersonPid(thePersonPid);\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of EmpiLinks that hold potential duplicate persons.\n+\t */\n+\tpublic List<EmpiLink> getPossibleDuplicates() {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theEmpiLink the EmpiLink to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(EmpiLink theEmpiLink) {\n+\t\tmyEmpiLinkDao.delete(theEmpiLink);\n+\t}\n+\n+\t/**\n+\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n+\t *\n+\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n+\t *\n+\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Person Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t}\n+\n+\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n+\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n+\t\tmyEmpiLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(persons);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n+\t * for the Person resources which were the sources of the links.\n+\t *\n+\t * @param theTargetType the type of relationship you would like to delete.\n+\t *\n+\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setEmpiTargetType(theTargetType);\n+\t\tExample<EmpiLink> exampleLink = Example.of(link);\n+\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an EmpiLink to the database.\n+\t *\n+\t * @param theEmpiLink the link to save.\n+\t *\n+\t * @return the persisted {@link EmpiLink} entity.\n+\t */\n+\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n+\t\tif (theEmpiLink.getCreated() == null) {\n+\t\t\ttheEmpiLink.setCreated(new Date());\n+\t\t}\n+\t\ttheEmpiLink.setUpdated(new Date());\n+\t\treturn myEmpiLinkDao.save(theEmpiLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n+\t *\n+\t * @return a list of {@link EmpiLink} entities which match the example.\n+\t */\n+   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n+\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n+   }\n+\n+\t/**\n+\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theTargetResource the target resource to find links for.\n+\t *\n+\t * @return all links for the target.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n+\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t * @return A new {@link EmpiLink}.\n+\t */\n+\tpublic EmpiLink newEmpiLink() {\n+\t\treturn myEmpiLinkFactory.newEmpiLink();\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex 4a16a1d782..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,319 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setPersonPid(thePersonPid);\n-\t\t\tnewLink.setTargetPid(theResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n-\n-\t\tif (theTargetPid == null || thePersonPid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetPid);\n-\t\tlink.setPersonPid(thePersonPid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t *\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setPersonPid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t *\n-\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t *\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t *\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t *\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-   }\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t *\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MjY2Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525362663", "body": "Rename source to golden", "bodyText": "Rename source to golden", "bodyHTML": "<p dir=\"auto\">Rename source to golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:48:37Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -59,61 +60,60 @@\n \tprivate FhirContext myFhirContext;\n \n \t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n+\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n \n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n \t\tempiLink.setLinkSource(theLinkSource);\n \t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n \t\t// Preserve these flags for link updates\n \t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n \t\tif (empiLink.getScore() != null) {\n \t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n \t\t} else {\n \t\t\tempiLink.setScore(theMatchOutcome.score);\n \t\t}\n \n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n \t\tourLog.debug(message);\n \t\tsave(empiLink);\n \t\treturn empiLink;\n \t}\n \n \t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..4a16a1d782\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,319 @@\n+package ca.uhn.fhir.jpa.empi.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate EmpiLinkFactory myEmpiLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n+\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tif (empiLink.getScore() != null) {\n+\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n+\t\t} else {\n+\t\t\tempiLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n+\t\t\tnewLink.setPersonPid(thePersonPid);\n+\t\t\tnewLink.setTargetPid(theResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a Target Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theTargetPid the target of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t *\n+\t * @return a list of {@link EmpiLink} entities matching these criteria.\n+\t */\n+\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n+\t *\n+\t * @param thePersonPid The Pid of the Person in the relationship\n+\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param theMatchResult The MatchResult you are looking for.\n+\t *\n+\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setPersonPid(thePersonPid);\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of EmpiLinks that hold potential duplicate persons.\n+\t */\n+\tpublic List<EmpiLink> getPossibleDuplicates() {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theEmpiLink the EmpiLink to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(EmpiLink theEmpiLink) {\n+\t\tmyEmpiLinkDao.delete(theEmpiLink);\n+\t}\n+\n+\t/**\n+\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n+\t *\n+\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n+\t *\n+\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Person Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t}\n+\n+\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n+\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n+\t\tmyEmpiLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(persons);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n+\t * for the Person resources which were the sources of the links.\n+\t *\n+\t * @param theTargetType the type of relationship you would like to delete.\n+\t *\n+\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setEmpiTargetType(theTargetType);\n+\t\tExample<EmpiLink> exampleLink = Example.of(link);\n+\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an EmpiLink to the database.\n+\t *\n+\t * @param theEmpiLink the link to save.\n+\t *\n+\t * @return the persisted {@link EmpiLink} entity.\n+\t */\n+\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n+\t\tif (theEmpiLink.getCreated() == null) {\n+\t\t\ttheEmpiLink.setCreated(new Date());\n+\t\t}\n+\t\ttheEmpiLink.setUpdated(new Date());\n+\t\treturn myEmpiLinkDao.save(theEmpiLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n+\t *\n+\t * @return a list of {@link EmpiLink} entities which match the example.\n+\t */\n+   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n+\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n+   }\n+\n+\t/**\n+\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theTargetResource the target resource to find links for.\n+\t *\n+\t * @return all links for the target.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n+\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t * @return A new {@link EmpiLink}.\n+\t */\n+\tpublic EmpiLink newEmpiLink() {\n+\t\treturn myEmpiLinkFactory.newEmpiLink();\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex 4a16a1d782..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,319 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setPersonPid(thePersonPid);\n-\t\t\tnewLink.setTargetPid(theResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n-\n-\t\tif (theTargetPid == null || thePersonPid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetPid);\n-\t\tlink.setPersonPid(thePersonPid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t *\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setPersonPid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t *\n-\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t *\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t *\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t *\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-   }\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t *\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NDg2MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525364861", "body": "Rename source to golden and update comments", "bodyText": "Rename source to golden and update comments", "bodyHTML": "<p dir=\"auto\">Rename source to golden and update comments</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:50:19Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -162,15 +162,14 @@ public EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Lo\n \t/**\n \t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n \t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param thePersonPid   The Pid of the Person in the relationship\n+\t * @param theTargetPid   The Pid of the target in the relationship\n \t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n \t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n \t */\n \tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..4a16a1d782\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,319 @@\n+package ca.uhn.fhir.jpa.empi.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate EmpiLinkFactory myEmpiLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n+\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tif (empiLink.getScore() != null) {\n+\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n+\t\t} else {\n+\t\t\tempiLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n+\t\t\tnewLink.setPersonPid(thePersonPid);\n+\t\t\tnewLink.setTargetPid(theResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a Target Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theTargetPid the target of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t *\n+\t * @return a list of {@link EmpiLink} entities matching these criteria.\n+\t */\n+\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n+\t *\n+\t * @param thePersonPid The Pid of the Person in the relationship\n+\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param theMatchResult The MatchResult you are looking for.\n+\t *\n+\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setPersonPid(thePersonPid);\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of EmpiLinks that hold potential duplicate persons.\n+\t */\n+\tpublic List<EmpiLink> getPossibleDuplicates() {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theEmpiLink the EmpiLink to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(EmpiLink theEmpiLink) {\n+\t\tmyEmpiLinkDao.delete(theEmpiLink);\n+\t}\n+\n+\t/**\n+\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n+\t *\n+\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n+\t *\n+\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Person Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t}\n+\n+\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n+\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n+\t\tmyEmpiLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(persons);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n+\t * for the Person resources which were the sources of the links.\n+\t *\n+\t * @param theTargetType the type of relationship you would like to delete.\n+\t *\n+\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setEmpiTargetType(theTargetType);\n+\t\tExample<EmpiLink> exampleLink = Example.of(link);\n+\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an EmpiLink to the database.\n+\t *\n+\t * @param theEmpiLink the link to save.\n+\t *\n+\t * @return the persisted {@link EmpiLink} entity.\n+\t */\n+\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n+\t\tif (theEmpiLink.getCreated() == null) {\n+\t\t\ttheEmpiLink.setCreated(new Date());\n+\t\t}\n+\t\ttheEmpiLink.setUpdated(new Date());\n+\t\treturn myEmpiLinkDao.save(theEmpiLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n+\t *\n+\t * @return a list of {@link EmpiLink} entities which match the example.\n+\t */\n+   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n+\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n+   }\n+\n+\t/**\n+\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theTargetResource the target resource to find links for.\n+\t *\n+\t * @return all links for the target.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n+\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t * @return A new {@link EmpiLink}.\n+\t */\n+\tpublic EmpiLink newEmpiLink() {\n+\t\treturn myEmpiLinkFactory.newEmpiLink();\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex 4a16a1d782..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,319 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setPersonPid(thePersonPid);\n-\t\t\tnewLink.setTargetPid(theResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n-\n-\t\tif (theTargetPid == null || thePersonPid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetPid);\n-\t\tlink.setPersonPid(thePersonPid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t *\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setPersonPid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t *\n-\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t *\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t *\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t *\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-   }\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t *\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NjY3MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525366670", "body": "rename to goldenResources", "bodyText": "rename to goldenResources", "bodyHTML": "<p dir=\"auto\">rename to goldenResources</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:51:53Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -233,14 +231,20 @@ public void deleteLink(EmpiLink theEmpiLink) {\n \t * @return A list of Long representing the related Person Pids.\n \t */\n \t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n \t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n \t}\n \n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..4a16a1d782\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,319 @@\n+package ca.uhn.fhir.jpa.empi.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate EmpiLinkFactory myEmpiLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n+\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tif (empiLink.getScore() != null) {\n+\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n+\t\t} else {\n+\t\t\tempiLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n+\t\t\tnewLink.setPersonPid(thePersonPid);\n+\t\t\tnewLink.setTargetPid(theResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a Target Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theTargetPid the target of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t *\n+\t * @return a list of {@link EmpiLink} entities matching these criteria.\n+\t */\n+\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n+\t *\n+\t * @param thePersonPid The Pid of the Person in the relationship\n+\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param theMatchResult The MatchResult you are looking for.\n+\t *\n+\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setPersonPid(thePersonPid);\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of EmpiLinks that hold potential duplicate persons.\n+\t */\n+\tpublic List<EmpiLink> getPossibleDuplicates() {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theEmpiLink the EmpiLink to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(EmpiLink theEmpiLink) {\n+\t\tmyEmpiLinkDao.delete(theEmpiLink);\n+\t}\n+\n+\t/**\n+\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n+\t *\n+\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n+\t *\n+\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Person Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t}\n+\n+\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n+\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n+\t\tmyEmpiLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(persons);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n+\t * for the Person resources which were the sources of the links.\n+\t *\n+\t * @param theTargetType the type of relationship you would like to delete.\n+\t *\n+\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setEmpiTargetType(theTargetType);\n+\t\tExample<EmpiLink> exampleLink = Example.of(link);\n+\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an EmpiLink to the database.\n+\t *\n+\t * @param theEmpiLink the link to save.\n+\t *\n+\t * @return the persisted {@link EmpiLink} entity.\n+\t */\n+\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n+\t\tif (theEmpiLink.getCreated() == null) {\n+\t\t\ttheEmpiLink.setCreated(new Date());\n+\t\t}\n+\t\ttheEmpiLink.setUpdated(new Date());\n+\t\treturn myEmpiLinkDao.save(theEmpiLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n+\t *\n+\t * @return a list of {@link EmpiLink} entities which match the example.\n+\t */\n+   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n+\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n+   }\n+\n+\t/**\n+\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theTargetResource the target resource to find links for.\n+\t *\n+\t * @return all links for the target.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n+\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t * @return A new {@link EmpiLink}.\n+\t */\n+\tpublic EmpiLink newEmpiLink() {\n+\t\treturn myEmpiLinkFactory.newEmpiLink();\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex 4a16a1d782..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,319 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setPersonPid(thePersonPid);\n-\t\t\tnewLink.setTargetPid(theResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n-\n-\t\tif (theTargetPid == null || thePersonPid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetPid);\n-\t\tlink.setPersonPid(thePersonPid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t *\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setPersonPid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t *\n-\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t *\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t *\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t *\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-   }\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t *\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NzA2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525367065", "body": "rename source to golden, update javadocs", "bodyText": "rename source to golden, update javadocs", "bodyHTML": "<p dir=\"auto\">rename source to golden, update javadocs</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:52:28Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -308,12 +308,55 @@ public EmpiLink save(EmpiLink theEmpiLink) {\n \t\treturn myEmpiLinkDao.findAll(example);\n \t}\n \n+\t/**\n+\t * Finds all links pointing from the target resource to the source resource.\n+\t *\n+\t * @param theTargetResource Resource referencing the source resource\n+\t * @param theSourceResource Resource being referenced by the source resource\n+\t *\n+\t * @return\n+\t * \t\tReturns all EMPI links pointing to the source from target resource\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..4a16a1d782\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,319 @@\n+package ca.uhn.fhir.jpa.empi.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate EmpiLinkFactory myEmpiLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n+\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tif (empiLink.getScore() != null) {\n+\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n+\t\t} else {\n+\t\t\tempiLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n+\t\t\tnewLink.setPersonPid(thePersonPid);\n+\t\t\tnewLink.setTargetPid(theResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a Target Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theTargetPid the target of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t *\n+\t * @return a list of {@link EmpiLink} entities matching these criteria.\n+\t */\n+\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n+\t *\n+\t * @param thePersonPid The Pid of the Person in the relationship\n+\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param theMatchResult The MatchResult you are looking for.\n+\t *\n+\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setPersonPid(thePersonPid);\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of EmpiLinks that hold potential duplicate persons.\n+\t */\n+\tpublic List<EmpiLink> getPossibleDuplicates() {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theEmpiLink the EmpiLink to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(EmpiLink theEmpiLink) {\n+\t\tmyEmpiLinkDao.delete(theEmpiLink);\n+\t}\n+\n+\t/**\n+\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n+\t *\n+\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n+\t *\n+\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Person Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t}\n+\n+\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n+\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n+\t\tmyEmpiLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(persons);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n+\t * for the Person resources which were the sources of the links.\n+\t *\n+\t * @param theTargetType the type of relationship you would like to delete.\n+\t *\n+\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setEmpiTargetType(theTargetType);\n+\t\tExample<EmpiLink> exampleLink = Example.of(link);\n+\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an EmpiLink to the database.\n+\t *\n+\t * @param theEmpiLink the link to save.\n+\t *\n+\t * @return the persisted {@link EmpiLink} entity.\n+\t */\n+\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n+\t\tif (theEmpiLink.getCreated() == null) {\n+\t\t\ttheEmpiLink.setCreated(new Date());\n+\t\t}\n+\t\ttheEmpiLink.setUpdated(new Date());\n+\t\treturn myEmpiLinkDao.save(theEmpiLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n+\t *\n+\t * @return a list of {@link EmpiLink} entities which match the example.\n+\t */\n+   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n+\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n+   }\n+\n+\t/**\n+\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theTargetResource the target resource to find links for.\n+\t *\n+\t * @return all links for the target.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n+\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t * @return A new {@link EmpiLink}.\n+\t */\n+\tpublic EmpiLink newEmpiLink() {\n+\t\treturn myEmpiLinkFactory.newEmpiLink();\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex 4a16a1d782..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,319 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setPersonPid(thePersonPid);\n-\t\t\tnewLink.setTargetPid(theResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n-\n-\t\tif (theTargetPid == null || thePersonPid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetPid);\n-\t\tlink.setPersonPid(thePersonPid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t *\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setPersonPid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t *\n-\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t *\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t *\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t *\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-   }\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t *\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODkyNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525368927", "body": "May be a good idea to pull todo out of javadocs", "bodyText": "May be a good idea to pull todo out of javadocs", "bodyHTML": "<p dir=\"auto\">May be a good idea to pull todo out of javadocs</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:55:10Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -308,12 +308,55 @@ public EmpiLink save(EmpiLink theEmpiLink) {\n \t\treturn myEmpiLinkDao.findAll(example);\n \t}\n \n+\t/**\n+\t * Finds all links pointing from the target resource to the source resource.\n+\t *\n+\t * @param theTargetResource Resource referencing the source resource\n+\t * @param theSourceResource Resource being referenced by the source resource\n+\t *\n+\t * @return\n+\t * \t\tReturns all EMPI links pointing to the source from target resource\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (targetPid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (sourcePid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n+\t * of the relationship.\n+\t *\n+\t * @param theSourceResource the source resource to find links for.\n+\t * @return all links for the source.\n+\t */\n+\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n \t/**\n \t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n \t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t *", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\nnew file mode 100644\nindex 0000000000..4a16a1d782\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n", "chunk": "@@ -0,0 +1,319 @@\n+package ca.uhn.fhir.jpa.empi.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate EmpiLinkFactory myEmpiLinkFactory;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\n+\t@Transactional\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n+\t\t// Preserve these flags for link updates\n+\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n+\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tif (empiLink.getScore() != null) {\n+\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n+\t\t} else {\n+\t\t\tempiLink.setScore(theMatchOutcome.score);\n+\t\t}\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n+\t\t\tnewLink.setPersonPid(thePersonPid);\n+\t\t\tnewLink.setTargetPid(theResourcePid);\n+\t\t\treturn newLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a Target Pid, and a match result, return all links that match these criteria.\n+\t *\n+\t * @param theTargetPid the target of the relationship.\n+\t * @param theMatchResult the Match Result of the relationship\n+\t *\n+\t * @return a list of {@link EmpiLink} entities matching these criteria.\n+\t */\n+\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n+\t * the target has no matches, and may return an empty optional.\n+\t *\n+\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n+\t * @return the {@link EmpiLink} that contains the Match information for the target.\n+\t */\n+\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setTargetPid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n+\t *\n+\t * @param thePersonPid The Pid of the Person in the relationship\n+\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param theMatchResult The MatchResult you are looking for.\n+\t *\n+\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n+\t */\n+\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setPersonPid(thePersonPid);\n+\t\texampleLink.setTargetPid(theTargetPid);\n+\t\texampleLink.setMatchResult(theMatchResult);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n+\t *\n+\t * @return A list of EmpiLinks that hold potential duplicate persons.\n+\t */\n+\tpublic List<EmpiLink> getPossibleDuplicates() {\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n+\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findOne(example);\n+\t}\n+\n+\t/**\n+\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n+\t * It is a simple entity delete.\n+\t *\n+\t * @param theEmpiLink the EmpiLink to delete.\n+\t */\n+\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n+\tpublic void deleteLink(EmpiLink theEmpiLink) {\n+\t\tmyEmpiLinkDao.delete(theEmpiLink);\n+\t}\n+\n+\t/**\n+\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n+\t *\n+\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n+\t *\n+\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n+\t *\n+\t * @return A list of Long representing the related Person Pids.\n+\t */\n+\t@Transactional\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t}\n+\n+\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n+\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n+\t\tmyEmpiLinkDao.deleteAll(theLinks);\n+\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n+\t\treturn new ArrayList<>(persons);\n+\t}\n+\n+\t/**\n+\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n+\t * for the Person resources which were the sources of the links.\n+\t *\n+\t * @param theTargetType the type of relationship you would like to delete.\n+\t *\n+\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n+\t */\n+\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setEmpiTargetType(theTargetType);\n+\t\tExample<EmpiLink> exampleLink = Example.of(link);\n+\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n+\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n+\t}\n+\n+\t/**\n+\t * Persist an EmpiLink to the database.\n+\t *\n+\t * @param theEmpiLink the link to save.\n+\t *\n+\t * @return the persisted {@link EmpiLink} entity.\n+\t */\n+\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n+\t\tif (theEmpiLink.getCreated() == null) {\n+\t\t\ttheEmpiLink.setCreated(new Date());\n+\t\t}\n+\t\ttheEmpiLink.setUpdated(new Date());\n+\t\treturn myEmpiLinkDao.save(theEmpiLink);\n+\t}\n+\n+\n+\t/**\n+\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n+\t *\n+\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n+\t *\n+\t * @return a list of {@link EmpiLink} entities which match the example.\n+\t */\n+   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n+\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n+   }\n+\n+\t/**\n+\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n+\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n+\t *\n+\t * @param theTargetResource the target resource to find links for.\n+\t *\n+\t * @return all links for the target.\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n+\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t * @return A new {@link EmpiLink}.\n+\t */\n+\tpublic EmpiLink newEmpiLink() {\n+\t\treturn myEmpiLinkFactory.newEmpiLink();\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex 4a16a1d782..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,319 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setPersonPid(thePersonPid);\n-\t\t\tnewLink.setTargetPid(theResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n-\n-\t\tif (theTargetPid == null || thePersonPid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetPid);\n-\t\tlink.setPersonPid(thePersonPid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t *\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setPersonPid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Person, return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param thePersonResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t *\n-\t * @return A list of all {@link EmpiLink} entities in which thePersonResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByPerson(IBaseResource thePersonResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(thePersonResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setPersonPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t *\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t *\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t *\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-   public List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-   }\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t *\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTQ3OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525369478", "body": "Fix empi/person in the naming", "bodyText": "Fix empi/person in the naming", "bodyHTML": "<p dir=\"auto\">Fix empi/person in the naming</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:55:56Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java", "diffHunk": "@@ -42,15 +42,17 @@\n \n \tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n \tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n+\tfinal IEmpiSettings myEmpiSettings;\n \n \t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl) {\n+\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\ndeleted file mode 100644\nindex 1c84c64322..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.List;\n-\n-/**\n- * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n- *\n- */\n-public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n-\tfinal IEmpiSettings myEmpiSettings;\n-\n-\t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n-\t\tmyEmpiSettings = theIEmpiSettings;\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllMdmLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n-\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n-\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-\n-\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.MDM_CLEAR + \" does not support resource type: \" + theResourceType);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n-\t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnGoldenResourcePids();\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-}\n-\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\nnew file mode 100644\nindex 0000000000..e4aa76b739\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n", "chunk": "@@ -0,0 +1,77 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.util.EmpiUtil;\n+import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import java.util.List;\n+\n+/**\n+ * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n+ *\n+ */\n+public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n+\n+\t@Autowired\n+\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl) {\n+\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n+\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n+\t}\n+\n+\t@Override\n+\tpublic long expungeAllEmpiLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n+\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n+\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n+\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n+\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n+\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n+\t\treturn personPids.size();\n+\t}\n+\n+\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n+\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n+\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_CLEAR + \" does not support resource type: \" + theResourceType);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n+\t\tourLog.info(\"Clearing all EMPI Links...\");\n+\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnPersonPids();\n+\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n+\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n+\t\treturn personPids.size();\n+\t}\n+}\n+\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\ndeleted file mode 100644\nindex e4aa76b739..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.List;\n-\n-/**\n- * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n- *\n- */\n-public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n-\n-\t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl) {\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n-\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n-\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-\n-\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_CLEAR + \" does not support resource type: \" + theResourceType);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n-\t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnPersonPids();\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTY2Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525369666", "body": "Address empi", "bodyText": "Address empi", "bodyHTML": "<p dir=\"auto\">Address empi</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:56:15Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java", "diffHunk": "@@ -60,15 +62,15 @@ public long expungeAllEmpiLinksOfTargetType(String theResourceType, ServletReque\n \t}\n \n \tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_CLEAR + \" does not support resource type: \" + theResourceType);\n+\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n+\t\t\tthrow new InvalidRequestException(ProviderConstants.MDM_CLEAR + \" does not support resource type: \" + theResourceType);\n \t\t}\n \t}\n \n \t@Override\n \tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n \t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnPersonPids();\n+\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnGoldenResourcePids();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\ndeleted file mode 100644\nindex 1c84c64322..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.List;\n-\n-/**\n- * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n- *\n- */\n-public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n-\tfinal IEmpiSettings myEmpiSettings;\n-\n-\t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n-\t\tmyEmpiSettings = theIEmpiSettings;\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllMdmLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n-\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n-\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-\n-\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.MDM_CLEAR + \" does not support resource type: \" + theResourceType);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n-\t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnGoldenResourcePids();\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-}\n-\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\nnew file mode 100644\nindex 0000000000..e4aa76b739\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n", "chunk": "@@ -0,0 +1,77 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.util.EmpiUtil;\n+import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import java.util.List;\n+\n+/**\n+ * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n+ *\n+ */\n+public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n+\n+\t@Autowired\n+\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl) {\n+\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n+\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n+\t}\n+\n+\t@Override\n+\tpublic long expungeAllEmpiLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n+\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n+\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n+\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n+\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n+\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n+\t\treturn personPids.size();\n+\t}\n+\n+\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n+\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n+\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_CLEAR + \" does not support resource type: \" + theResourceType);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n+\t\tourLog.info(\"Clearing all EMPI Links...\");\n+\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnPersonPids();\n+\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n+\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n+\t\treturn personPids.size();\n+\t}\n+}\n+\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\ndeleted file mode 100644\nindex e4aa76b739..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.List;\n-\n-/**\n- * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n- *\n- */\n-public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n-\n-\t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl) {\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n-\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n-\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-\n-\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_CLEAR + \" does not support resource type: \" + theResourceType);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n-\t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnPersonPids();\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTgyNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525369826", "body": "rename params", "bodyText": "rename params", "bodyHTML": "<p dir=\"auto\">rename params</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:56:29Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java", "diffHunk": "@@ -47,53 +47,53 @@\n \t@Autowired\n \tEmpiControllerHelper myEmpiControllerHelper;\n \t@Autowired\n-\tIEmpiPersonMergerSvc myEmpiPersonMergerSvc;\n+\tIGoldenResourceMergerSvc myEmpiPersonMergerSvc;\n \t@Autowired\n \tIEmpiLinkQuerySvc myEmpiLinkQuerySvc;\n \t@Autowired\n \tIEmpiLinkUpdaterSvc myIEmpiLinkUpdaterSvc;\n \n \t@Override\n-\tpublic IAnyResource mergePersons(String theFromPersonId, String theToPersonId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tIAnyResource fromPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n-\t\tIAnyResource toPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n+\tpublic IAnyResource mergeGoldenResources(String theFromPersonId, String theToPersonId, MdmTransactionContext theMdmTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\ndeleted file mode 100644\nindex 0036d1b008..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,100 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkJson;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiControllerUtil;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.jetbrains.annotations.Nullable;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.stream.Stream;\n-\n-/**\n- * This class acts as a layer between EmpiProviders and EMPI services to support a REST API that's not a FHIR Operation API.\n- */\n-@Service\n-public class EmpiControllerSvcImpl implements IEmpiControllerSvc {\n-\t@Autowired\n-\tEmpiControllerHelper myEmpiControllerHelper;\n-\t@Autowired\n-\tIGoldenResourceMergerSvc myEmpiPersonMergerSvc;\n-\t@Autowired\n-\tIEmpiLinkQuerySvc myEmpiLinkQuerySvc;\n-\t@Autowired\n-\tIEmpiLinkUpdaterSvc myIEmpiLinkUpdaterSvc;\n-\n-\t@Override\n-\tpublic IAnyResource mergeGoldenResources(String theFromPersonId, String theToPersonId, MdmTransactionContext theMdmTransactionContext) {\n-\t\tIAnyResource fromPerson = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPersonId);\n-\t\tIAnyResource toPerson = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPersonId);\n-\t\tmyEmpiControllerHelper.validateMergeResources(fromPerson, toPerson);\n-\t\tmyEmpiControllerHelper.validateSameVersion(fromPerson, theFromPersonId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(toPerson, theToPersonId);\n-\n-\t\treturn myEmpiPersonMergerSvc.mergeGoldenResources(fromPerson, toPerson, theMdmTransactionContext);\n-\t}\n-\n-\t@Override\n-\tpublic Stream<EmpiLinkJson> queryLinks(@Nullable String thePersonId, @Nullable String theTargetId, @Nullable String theMatchResult, @Nullable String theLinkSource, MdmTransactionContext theEmpiContext) {\n-\t\tIIdType personId = EmpiControllerUtil.extractPersonIdDtOrNull(ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, thePersonId);\n-\t\tIIdType targetId = EmpiControllerUtil.extractTargetIdDtOrNull(ProviderConstants.MDM_QUERY_LINKS_RESOURCE_ID, theTargetId);\n-\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n-\t\tEmpiLinkSourceEnum linkSource = EmpiControllerUtil.extractLinkSourceOrNull(theLinkSource);\n-\n-\t\treturn myEmpiLinkQuerySvc.queryLinks(personId, targetId, matchResult, linkSource, theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic Stream<EmpiLinkJson> getDuplicateGoldenResources(MdmTransactionContext theEmpiContext) {\n-\t\treturn myEmpiLinkQuerySvc.getDuplicatePersons(theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic IAnyResource updateLink(String theGoldenResourceId, String theTargetId, String theMatchResult, MdmTransactionContext theEmpiContext) {\n-\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n-\t\tIAnyResource person = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, theGoldenResourceId);\n-\t\tIAnyResource target = myEmpiControllerHelper.getLatestTargetFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_RESOURCE_ID, theTargetId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(person, theGoldenResourceId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(target, theTargetId);\n-\n-\t\treturn myIEmpiLinkUpdaterSvc.updateLink(person, target, matchResult, theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic void notDuplicateGoldenResource(String thePersonId, String theTargetPersonId, MdmTransactionContext theEmpiContext) {\n-\t\tIAnyResource person = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, thePersonId);\n-\t\tIAnyResource target = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_RESOURCE_ID, theTargetPersonId);\n-\n-\t\tmyIEmpiLinkUpdaterSvc.notDuplicatePerson(person, target, theEmpiContext);\n-\t}\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\nnew file mode 100644\nindex 0000000000..ae7e2c9215\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\n", "chunk": "@@ -0,0 +1,100 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkJson;\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n+import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n+import ca.uhn.fhir.empi.api.IEmpiPersonMergerSvc;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n+import ca.uhn.fhir.empi.provider.EmpiControllerUtil;\n+import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IIdType;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.stream.Stream;\n+\n+/**\n+ * This class acts as a layer between EmpiProviders and EMPI services to support a REST API that's not a FHIR Operation API.\n+ */\n+@Service\n+public class EmpiControllerSvcImpl implements IEmpiControllerSvc {\n+\t@Autowired\n+\tEmpiControllerHelper myEmpiControllerHelper;\n+\t@Autowired\n+\tIEmpiPersonMergerSvc myEmpiPersonMergerSvc;\n+\t@Autowired\n+\tIEmpiLinkQuerySvc myEmpiLinkQuerySvc;\n+\t@Autowired\n+\tIEmpiLinkUpdaterSvc myIEmpiLinkUpdaterSvc;\n+\n+\t@Override\n+\tpublic IAnyResource mergePersons(String theFromPersonId, String theToPersonId, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tIAnyResource fromPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n+\t\tIAnyResource toPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n+\t\tmyEmpiControllerHelper.validateMergeResources(fromPerson, toPerson);\n+\t\tmyEmpiControllerHelper.validateSameVersion(fromPerson, theFromPersonId);\n+\t\tmyEmpiControllerHelper.validateSameVersion(toPerson, theToPersonId);\n+\n+\t\treturn myEmpiPersonMergerSvc.mergePersons(fromPerson, toPerson, theEmpiTransactionContext);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<EmpiLinkJson> queryLinks(@Nullable String thePersonId, @Nullable String theTargetId, @Nullable String theMatchResult, @Nullable String theLinkSource, EmpiTransactionContext theEmpiContext) {\n+\t\tIIdType personId = EmpiControllerUtil.extractPersonIdDtOrNull(ProviderConstants.EMPI_QUERY_LINKS_PERSON_ID, thePersonId);\n+\t\tIIdType targetId = EmpiControllerUtil.extractTargetIdDtOrNull(ProviderConstants.EMPI_QUERY_LINKS_TARGET_ID, theTargetId);\n+\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n+\t\tEmpiLinkSourceEnum linkSource = EmpiControllerUtil.extractLinkSourceOrNull(theLinkSource);\n+\n+\t\treturn myEmpiLinkQuerySvc.queryLinks(personId, targetId, matchResult, linkSource, theEmpiContext);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<EmpiLinkJson> getDuplicatePersons(EmpiTransactionContext theEmpiContext) {\n+\t\treturn myEmpiLinkQuerySvc.getDuplicatePersons(theEmpiContext);\n+\t}\n+\n+\t@Override\n+\tpublic IAnyResource updateLink(String thePersonId, String theTargetId, String theMatchResult, EmpiTransactionContext theEmpiContext) {\n+\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n+\t\tIAnyResource person = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, thePersonId);\n+\t\tIAnyResource target = myEmpiControllerHelper.getLatestTargetFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, theTargetId);\n+\t\tmyEmpiControllerHelper.validateSameVersion(person, thePersonId);\n+\t\tmyEmpiControllerHelper.validateSameVersion(target, theTargetId);\n+\n+\t\treturn myIEmpiLinkUpdaterSvc.updateLink(person, target, matchResult, theEmpiContext);\n+\t}\n+\n+\t@Override\n+\tpublic void notDuplicatePerson(String thePersonId, String theTargetPersonId, EmpiTransactionContext theEmpiContext) {\n+\t\tIAnyResource person = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, thePersonId);\n+\t\tIAnyResource target = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, theTargetPersonId);\n+\n+\t\tmyIEmpiLinkUpdaterSvc.notDuplicatePerson(person, target, theEmpiContext);\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\ndeleted file mode 100644\nindex ae7e2c9215..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,100 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkJson;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiPersonMergerSvc;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiControllerUtil;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.jetbrains.annotations.Nullable;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.stream.Stream;\n-\n-/**\n- * This class acts as a layer between EmpiProviders and EMPI services to support a REST API that's not a FHIR Operation API.\n- */\n-@Service\n-public class EmpiControllerSvcImpl implements IEmpiControllerSvc {\n-\t@Autowired\n-\tEmpiControllerHelper myEmpiControllerHelper;\n-\t@Autowired\n-\tIEmpiPersonMergerSvc myEmpiPersonMergerSvc;\n-\t@Autowired\n-\tIEmpiLinkQuerySvc myEmpiLinkQuerySvc;\n-\t@Autowired\n-\tIEmpiLinkUpdaterSvc myIEmpiLinkUpdaterSvc;\n-\n-\t@Override\n-\tpublic IAnyResource mergePersons(String theFromPersonId, String theToPersonId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tIAnyResource fromPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n-\t\tIAnyResource toPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n-\t\tmyEmpiControllerHelper.validateMergeResources(fromPerson, toPerson);\n-\t\tmyEmpiControllerHelper.validateSameVersion(fromPerson, theFromPersonId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(toPerson, theToPersonId);\n-\n-\t\treturn myEmpiPersonMergerSvc.mergePersons(fromPerson, toPerson, theEmpiTransactionContext);\n-\t}\n-\n-\t@Override\n-\tpublic Stream<EmpiLinkJson> queryLinks(@Nullable String thePersonId, @Nullable String theTargetId, @Nullable String theMatchResult, @Nullable String theLinkSource, EmpiTransactionContext theEmpiContext) {\n-\t\tIIdType personId = EmpiControllerUtil.extractPersonIdDtOrNull(ProviderConstants.EMPI_QUERY_LINKS_PERSON_ID, thePersonId);\n-\t\tIIdType targetId = EmpiControllerUtil.extractTargetIdDtOrNull(ProviderConstants.EMPI_QUERY_LINKS_TARGET_ID, theTargetId);\n-\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n-\t\tEmpiLinkSourceEnum linkSource = EmpiControllerUtil.extractLinkSourceOrNull(theLinkSource);\n-\n-\t\treturn myEmpiLinkQuerySvc.queryLinks(personId, targetId, matchResult, linkSource, theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic Stream<EmpiLinkJson> getDuplicatePersons(EmpiTransactionContext theEmpiContext) {\n-\t\treturn myEmpiLinkQuerySvc.getDuplicatePersons(theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic IAnyResource updateLink(String thePersonId, String theTargetId, String theMatchResult, EmpiTransactionContext theEmpiContext) {\n-\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n-\t\tIAnyResource person = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, thePersonId);\n-\t\tIAnyResource target = myEmpiControllerHelper.getLatestTargetFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, theTargetId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(person, thePersonId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(target, theTargetId);\n-\n-\t\treturn myIEmpiLinkUpdaterSvc.updateLink(person, target, matchResult, theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic void notDuplicatePerson(String thePersonId, String theTargetPersonId, EmpiTransactionContext theEmpiContext) {\n-\t\tIAnyResource person = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, thePersonId);\n-\t\tIAnyResource target = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, theTargetPersonId);\n-\n-\t\tmyIEmpiLinkUpdaterSvc.notDuplicatePerson(person, target, theEmpiContext);\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDkwOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525370908", "body": "Remove EMPI / SourceResource", "bodyText": "Remove EMPI / SourceResource", "bodyHTML": "<p dir=\"auto\">Remove EMPI / SourceResource</p>", "author": "nvg-smile", "createdAt": "2020-11-17T17:58:05Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -51,7 +51,7 @@\n \t@Autowired\n \tprivate IEmpiLinkSvc myEmpiLinkSvc;\n \t@Autowired\n-\tprivate EmpiPersonFindingSvc myEmpiPersonFindingSvc;\n+\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 59%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..8293a1e6b3 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n", "chunk": "@@ -43,33 +43,33 @@ import java.util.List;\n import java.util.Optional;\n \n @Service\n-public class EmpiEidUpdateService {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmEidUpdateService {\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\tprivate MdmResourceDaoSvc myMdmResourceDaoSvc;\n \t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n+\tprivate IMdmLinkSvc myMdmLinkSvc;\n \t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n+\tprivate MdmGoldenResourceFindingSvc myMdmGoldenResourceFindingSvc;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tprivate MdmLinkDaoSvc myMdmLinkDaoSvc;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n+\tvoid handleMdmUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tMdmUpdateContext updateContext = new MdmUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n \t\t\t// Copy over any new external EIDs which don't already exist.\n \t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n \t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\t\t\tmyMdmLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n \t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mzk2Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525373963", "body": "Introduce a boolean flag to remove comments, along the lines of \"isOverwritableEidResource\", may be?", "bodyText": "Introduce a boolean flag to remove comments, along the lines of \"isOverwritableEidResource\", may be?", "bodyHTML": "<p dir=\"auto\">Introduce a boolean flag to remove comments, along the lines of \"isOverwritableEidResource\", may be?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:02:42Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -61,68 +61,70 @@\n \t@Autowired\n \tprivate IEmpiSettings myEmpiSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedPersonCandidate, theResource);\n-\n+\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n-\t\t\tmyPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\t// Copy over any new external EIDs which don't already exist.\n+\t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n+\t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedPersonCandidate, theEmpiTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedPerson(), theEmpiTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n \t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myPersonHelper.getLinkCount(theUpdateContext.getMatchedPerson()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 59%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..8293a1e6b3 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n", "chunk": "@@ -80,47 +80,47 @@ public class EmpiEidUpdateService {\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n \t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n \t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NDEwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525374109", "body": "Fix SourceResource", "bodyText": "Fix SourceResource", "bodyHTML": "<p dir=\"auto\">Fix SourceResource</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:02:57Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -61,68 +61,70 @@\n \t@Autowired\n \tprivate IEmpiSettings myEmpiSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedPersonCandidate, theResource);\n-\n+\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n-\t\t\tmyPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\t// Copy over any new external EIDs which don't already exist.\n+\t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n+\t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedPersonCandidate, theEmpiTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedPerson(), theEmpiTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n \t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myPersonHelper.getLinkCount(theUpdateContext.getMatchedPerson()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n-\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theEmpiTransactionContext, theUpdateContext.getExistingPerson());\n+\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n-\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n \t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedPersonCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getPersonPid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 59%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..8293a1e6b3 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n", "chunk": "@@ -80,47 +80,47 @@ public class EmpiEidUpdateService {\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n \t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n \t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NDk3Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525374972", "body": "Do we need to update EmpiMatchOutcome into MdmMatchOutcome and fix enum literals? ", "bodyText": "Do we need to update EmpiMatchOutcome into MdmMatchOutcome and fix enum literals?", "bodyHTML": "<p dir=\"auto\">Do we need to update EmpiMatchOutcome into MdmMatchOutcome and fix enum literals?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:04:26Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -61,68 +61,70 @@\n \t@Autowired\n \tprivate IEmpiSettings myEmpiSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedPersonCandidate, theResource);\n-\n+\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n-\t\t\tmyPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\t// Copy over any new external EIDs which don't already exist.\n+\t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n+\t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedPersonCandidate, theEmpiTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedPerson(), theEmpiTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n \t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myPersonHelper.getLinkCount(theUpdateContext.getMatchedPerson()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n-\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theEmpiTransactionContext, theUpdateContext.getExistingPerson());\n+\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n-\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n \t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedPersonCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getPersonPid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n-\tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext, IAnyResource theOldPerson) {\n-\t\tlog(theEmpiTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createPersonFromEmpiTarget(theResource);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n+\t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n+\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\n+\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n-\tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tlog(theEmpiTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theEmpiTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\tlog(theEmpiTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n+\t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n+\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 59%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..8293a1e6b3 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n", "chunk": "@@ -80,47 +80,47 @@ public class EmpiEidUpdateService {\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n \t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n \t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NjE2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525376169", "body": "Remove obsolete code", "bodyText": "Remove obsolete code", "bodyHTML": "<p dir=\"auto\">Remove obsolete code</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:06:04Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java", "diffHunk": "@@ -102,33 +101,36 @@ private boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theT\n \t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n \t}\n \n-\t@Override\n-\t@Transactional\n-\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-\n-\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n-\n-\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-\t\t\t.map(this::personLinkFromEmpiLink)\n-\t\t\t.collect(Collectors.toList());\n-\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-\t\tif (newLinks.size() > origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t} else if (newLinks.size() < origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t}\n-\n-\t}\n+//\t@Override\n+//\t@Transactional\n+//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\ndeleted file mode 100644\nindex 79100f79a7..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.transaction.Transactional;\n-import java.util.Optional;\n-\n-/**\n- * This class is in charge of managing EmpiLinks between Persons and target resources\n- */\n-@Service\n-public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n-\t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n-\n-\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n-\t\t\tlog(theMdmTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" is linked as NO_MATCH with \" +\n-\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n-\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n-\n-//\t\tswitch (matchResultEnum) {\n-//\t\t\tcase MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase NO_MATCH:\n-//\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_DUPLICATE:\n-//\t\t\t\tbreak;\n-//\t\t}\n-\t\tmyEmpiResourceDaoSvc.upsertSourceResource(thePerson, theMdmTransactionContext.getResourceType());\n-\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n-\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n-\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n-\t\t// TODO perf collapse into one query\n-\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n-\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n-\t}\n-\n-//\t@Override\n-//\t@Transactional\n-//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-//\t\t// int origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-//\t\tint origLinkCount = myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(thePersonResource).size();\n-//\n-//\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksBySourceResource(thePersonResource);\n-//\n-//\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-//\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-//\t\t\t.map(this::personLinkFromEmpiLink)\n-//\t\t\t.collect(Collectors.toList());\n-//\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-//\t\tif (newLinks.size() > origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t} else if (newLinks.size() < origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t}\n-//\n-//\t}\n-\n-\t@Override\n-\tpublic void deleteLink(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t// myPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-//\t\t myEmpiLinkDaoSvc.deleteEmpiLinks(theSourceResource, theTargetResource);\n-\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theSourceResource, theTargetResource);\n-\t\tif (oEmpiLink.isPresent()) {\n-\t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theMdmTransactionContext, \"Deleting EmpiLink [\" + theSourceResource.getIdElement().toVersionless() + \" -> \" + theTargetResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n-\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n-\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n-\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n-\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n-\t}\n-\n-\t/**\n-\t * Helper function which runs various business rules about what types of requests are allowed.\n-\t */\n-\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n-\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n-\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n-\t\t}\n-\n-\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n-\t */\n-\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n-\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n-\t}\n-\n-\t/**\n-\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n-\t */\n-\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n-\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n-\t}\n-\n-\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n-\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n-\t\t\treturn Optional.empty();\n-\t\t} else {\n-\t\t\treturn myEmpiLinkDaoSvc.getLinkBySourceResourcePidAndTargetResourcePid(\n-\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n-\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n-\t\t\t);\n-\t\t}\n-\t}\n-\n-\tprivate void createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(theSourceResource, theTargetResource, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\nnew file mode 100644\nindex 0000000000..f9c2063633\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n", "chunk": "@@ -0,0 +1,189 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import javax.transaction.Transactional;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class is in charge of managing EmpiLinks between Persons and target resources\n+ */\n+@Service\n+public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate PersonHelper myPersonHelper;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\t@Override\n+\t@Transactional\n+\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n+\n+\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n+\t\t\tlog(theEmpiTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n+\t\t\t\t\" is linked as NO_MATCH with \" +\n+\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n+\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n+\t\t\treturn;\n+\t\t}\n+\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n+\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n+\t\tswitch (matchResultEnum) {\n+\t\t\tcase MATCH:\n+\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n+\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n+\t\t\t\tbreak;\n+\t\t\tcase POSSIBLE_MATCH:\n+\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase NO_MATCH:\n+\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase POSSIBLE_DUPLICATE:\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n+\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n+\t}\n+\n+\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n+\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n+\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n+\t\t// TODO perf collapse into one query\n+\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n+\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n+\t}\n+\n+\t@Override\n+\t@Transactional\n+\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n+\n+\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n+\n+\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n+\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n+\t\t\t.map(this::personLinkFromEmpiLink)\n+\t\t\t.collect(Collectors.toList());\n+\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n+\t\tif (newLinks.size() > origLinkCount) {\n+\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n+\t\t} else if (newLinks.size() < origLinkCount) {\n+\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n+\t\t}\n+\n+\t}\n+\n+\t@Override\n+\tpublic void deleteLink(IAnyResource theExistingPerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tmyPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n+\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theExistingPerson, theResource);\n+\t\tif (oEmpiLink.isPresent()) {\n+\t\t\tEmpiLink empiLink = oEmpiLink.get();\n+\t\t\tlog(theEmpiTransactionContext, \"Deleting EmpiLink [\" + theExistingPerson.getIdElement().toVersionless() + \" -> \" + theResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n+\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n+\t\t}\n+\t}\n+\n+\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n+\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n+\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n+\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n+\t}\n+\n+\t/**\n+\t * Helper function which runs various business rules about what types of requests are allowed.\n+\t */\n+\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n+\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n+\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n+\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n+\t\t}\n+\n+\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n+\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n+\t */\n+\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n+\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n+\t}\n+\n+\t/**\n+\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n+\t */\n+\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n+\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n+\t}\n+\n+\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n+\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n+\t\t\treturn Optional.empty();\n+\t\t} else {\n+\t\t\treturn myEmpiLinkDaoSvc.getLinkByPersonPidAndTargetPid(\n+\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n+\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\tprivate void createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(thePerson, theResource, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n+\t}\n+\n+\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\ndeleted file mode 100644\nindex f9c2063633..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,189 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.transaction.Transactional;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * This class is in charge of managing EmpiLinks between Persons and target resources\n- */\n-@Service\n-public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n-\t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n-\n-\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n-\t\t\tlog(theEmpiTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" is linked as NO_MATCH with \" +\n-\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n-\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n-\t\tswitch (matchResultEnum) {\n-\t\t\tcase MATCH:\n-\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-\t\t\t\tbreak;\n-\t\t\tcase POSSIBLE_MATCH:\n-\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase NO_MATCH:\n-\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase POSSIBLE_DUPLICATE:\n-\t\t\t\tbreak;\n-\t\t}\n-\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n-\t}\n-\n-\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n-\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n-\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n-\t\t// TODO perf collapse into one query\n-\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n-\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n-\t}\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-\n-\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n-\n-\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-\t\t\t.map(this::personLinkFromEmpiLink)\n-\t\t\t.collect(Collectors.toList());\n-\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-\t\tif (newLinks.size() > origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t} else if (newLinks.size() < origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void deleteLink(IAnyResource theExistingPerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tmyPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theExistingPerson, theResource);\n-\t\tif (oEmpiLink.isPresent()) {\n-\t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theEmpiTransactionContext, \"Deleting EmpiLink [\" + theExistingPerson.getIdElement().toVersionless() + \" -> \" + theResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n-\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n-\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n-\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n-\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n-\t}\n-\n-\t/**\n-\t * Helper function which runs various business rules about what types of requests are allowed.\n-\t */\n-\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n-\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n-\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n-\t\t}\n-\n-\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n-\t */\n-\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n-\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n-\t}\n-\n-\t/**\n-\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n-\t */\n-\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n-\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n-\t}\n-\n-\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n-\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n-\t\t\treturn Optional.empty();\n-\t\t} else {\n-\t\t\treturn myEmpiLinkDaoSvc.getLinkByPersonPidAndTargetPid(\n-\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n-\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n-\t\t\t);\n-\t\t}\n-\t}\n-\n-\tprivate void createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(thePerson, theResource, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NjMxNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525376314", "body": "handle S/R", "bodyText": "handle S/R", "bodyHTML": "<p dir=\"auto\">handle S/R</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:06:19Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java", "diffHunk": "@@ -102,33 +101,36 @@ private boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theT\n \t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n \t}\n \n-\t@Override\n-\t@Transactional\n-\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-\n-\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n-\n-\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-\t\t\t.map(this::personLinkFromEmpiLink)\n-\t\t\t.collect(Collectors.toList());\n-\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-\t\tif (newLinks.size() > origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t} else if (newLinks.size() < origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t}\n-\n-\t}\n+//\t@Override\n+//\t@Transactional\n+//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n+//\t\t// int origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n+//\t\tint origLinkCount = myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(thePersonResource).size();\n+//\n+//\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksBySourceResource(thePersonResource);\n+//\n+//\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n+//\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n+//\t\t\t.map(this::personLinkFromEmpiLink)\n+//\t\t\t.collect(Collectors.toList());\n+//\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n+//\t\tif (newLinks.size() > origLinkCount) {\n+//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n+//\t\t} else if (newLinks.size() < origLinkCount) {\n+//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n+//\t\t}\n+//\n+//\t}\n \n \t@Override\n-\tpublic void deleteLink(IAnyResource theExistingPerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tmyPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theExistingPerson, theResource);\n+\tpublic void deleteLink(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t// myPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n+//\t\t myEmpiLinkDaoSvc.deleteEmpiLinks(theSourceResource, theTargetResource);\n+\n+\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theSourceResource, theTargetResource);\n \t\tif (oEmpiLink.isPresent()) {\n \t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theEmpiTransactionContext, \"Deleting EmpiLink [\" + theExistingPerson.getIdElement().toVersionless() + \" -> \" + theResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n+\t\t\tlog(theMdmTransactionContext, \"Deleting EmpiLink [\" + theSourceResource.getIdElement().toVersionless() + \" -> \" + theTargetResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\ndeleted file mode 100644\nindex 79100f79a7..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,191 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.transaction.Transactional;\n-import java.util.Optional;\n-\n-/**\n- * This class is in charge of managing EmpiLinks between Persons and target resources\n- */\n-@Service\n-public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n-\t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n-\n-\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n-\t\t\tlog(theMdmTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" is linked as NO_MATCH with \" +\n-\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n-\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n-\n-//\t\tswitch (matchResultEnum) {\n-//\t\t\tcase MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase NO_MATCH:\n-//\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_DUPLICATE:\n-//\t\t\t\tbreak;\n-//\t\t}\n-\t\tmyEmpiResourceDaoSvc.upsertSourceResource(thePerson, theMdmTransactionContext.getResourceType());\n-\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n-\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n-\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n-\t\t// TODO perf collapse into one query\n-\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n-\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n-\t}\n-\n-//\t@Override\n-//\t@Transactional\n-//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-//\t\t// int origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-//\t\tint origLinkCount = myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(thePersonResource).size();\n-//\n-//\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksBySourceResource(thePersonResource);\n-//\n-//\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-//\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-//\t\t\t.map(this::personLinkFromEmpiLink)\n-//\t\t\t.collect(Collectors.toList());\n-//\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-//\t\tif (newLinks.size() > origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t} else if (newLinks.size() < origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t}\n-//\n-//\t}\n-\n-\t@Override\n-\tpublic void deleteLink(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t// myPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-//\t\t myEmpiLinkDaoSvc.deleteEmpiLinks(theSourceResource, theTargetResource);\n-\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theSourceResource, theTargetResource);\n-\t\tif (oEmpiLink.isPresent()) {\n-\t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theMdmTransactionContext, \"Deleting EmpiLink [\" + theSourceResource.getIdElement().toVersionless() + \" -> \" + theTargetResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n-\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n-\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n-\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n-\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n-\t}\n-\n-\t/**\n-\t * Helper function which runs various business rules about what types of requests are allowed.\n-\t */\n-\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n-\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n-\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n-\t\t}\n-\n-\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n-\t */\n-\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n-\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n-\t}\n-\n-\t/**\n-\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n-\t */\n-\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n-\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n-\t}\n-\n-\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n-\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n-\t\t\treturn Optional.empty();\n-\t\t} else {\n-\t\t\treturn myEmpiLinkDaoSvc.getLinkBySourceResourcePidAndTargetResourcePid(\n-\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n-\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n-\t\t\t);\n-\t\t}\n-\t}\n-\n-\tprivate void createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(theSourceResource, theTargetResource, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\nnew file mode 100644\nindex 0000000000..f9c2063633\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n", "chunk": "@@ -0,0 +1,189 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import javax.transaction.Transactional;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class is in charge of managing EmpiLinks between Persons and target resources\n+ */\n+@Service\n+public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate PersonHelper myPersonHelper;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\t@Override\n+\t@Transactional\n+\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n+\n+\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n+\t\t\tlog(theEmpiTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n+\t\t\t\t\" is linked as NO_MATCH with \" +\n+\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n+\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n+\t\t\treturn;\n+\t\t}\n+\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n+\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n+\t\tswitch (matchResultEnum) {\n+\t\t\tcase MATCH:\n+\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n+\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n+\t\t\t\tbreak;\n+\t\t\tcase POSSIBLE_MATCH:\n+\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase NO_MATCH:\n+\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase POSSIBLE_DUPLICATE:\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n+\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n+\t}\n+\n+\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n+\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n+\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n+\t\t// TODO perf collapse into one query\n+\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n+\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n+\t}\n+\n+\t@Override\n+\t@Transactional\n+\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n+\n+\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n+\n+\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n+\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n+\t\t\t.map(this::personLinkFromEmpiLink)\n+\t\t\t.collect(Collectors.toList());\n+\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n+\t\tif (newLinks.size() > origLinkCount) {\n+\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n+\t\t} else if (newLinks.size() < origLinkCount) {\n+\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n+\t\t}\n+\n+\t}\n+\n+\t@Override\n+\tpublic void deleteLink(IAnyResource theExistingPerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tmyPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n+\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theExistingPerson, theResource);\n+\t\tif (oEmpiLink.isPresent()) {\n+\t\t\tEmpiLink empiLink = oEmpiLink.get();\n+\t\t\tlog(theEmpiTransactionContext, \"Deleting EmpiLink [\" + theExistingPerson.getIdElement().toVersionless() + \" -> \" + theResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n+\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n+\t\t}\n+\t}\n+\n+\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n+\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n+\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n+\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n+\t}\n+\n+\t/**\n+\t * Helper function which runs various business rules about what types of requests are allowed.\n+\t */\n+\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n+\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n+\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n+\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n+\t\t}\n+\n+\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n+\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n+\t */\n+\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n+\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n+\t}\n+\n+\t/**\n+\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n+\t */\n+\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n+\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n+\t}\n+\n+\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n+\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n+\t\t\treturn Optional.empty();\n+\t\t} else {\n+\t\t\treturn myEmpiLinkDaoSvc.getLinkByPersonPidAndTargetPid(\n+\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n+\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\tprivate void createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(thePerson, theResource, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n+\t}\n+\n+\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\ndeleted file mode 100644\nindex f9c2063633..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,189 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.transaction.Transactional;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * This class is in charge of managing EmpiLinks between Persons and target resources\n- */\n-@Service\n-public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n-\t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n-\n-\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n-\t\t\tlog(theEmpiTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" is linked as NO_MATCH with \" +\n-\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n-\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n-\t\tswitch (matchResultEnum) {\n-\t\t\tcase MATCH:\n-\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-\t\t\t\tbreak;\n-\t\t\tcase POSSIBLE_MATCH:\n-\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase NO_MATCH:\n-\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase POSSIBLE_DUPLICATE:\n-\t\t\t\tbreak;\n-\t\t}\n-\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n-\t}\n-\n-\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n-\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n-\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n-\t\t// TODO perf collapse into one query\n-\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n-\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n-\t}\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-\n-\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n-\n-\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-\t\t\t.map(this::personLinkFromEmpiLink)\n-\t\t\t.collect(Collectors.toList());\n-\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-\t\tif (newLinks.size() > origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t} else if (newLinks.size() < origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void deleteLink(IAnyResource theExistingPerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tmyPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theExistingPerson, theResource);\n-\t\tif (oEmpiLink.isPresent()) {\n-\t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theEmpiTransactionContext, \"Deleting EmpiLink [\" + theExistingPerson.getIdElement().toVersionless() + \" -> \" + theResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n-\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n-\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n-\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n-\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n-\t}\n-\n-\t/**\n-\t * Helper function which runs various business rules about what types of requests are allowed.\n-\t */\n-\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n-\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n-\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n-\t\t}\n-\n-\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n-\t */\n-\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n-\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n-\t}\n-\n-\t/**\n-\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n-\t */\n-\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n-\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n-\t}\n-\n-\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n-\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n-\t\t\treturn Optional.empty();\n-\t\t} else {\n-\t\t\treturn myEmpiLinkDaoSvc.getLinkByPersonPidAndTargetPid(\n-\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n-\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n-\t\t\t);\n-\t\t}\n-\t}\n-\n-\tprivate void createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(thePerson, theResource, theMatchOutcome, theLinkSource, theEmpiTransactionContext);\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NzQxMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525377412", "body": "rename EMPI previx", "bodyText": "rename EMPI previx", "bodyHTML": "<p dir=\"auto\">rename EMPI previx</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:08:01Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java", "diffHunk": "@@ -63,48 +63,49 @@\n \t * Does nothing if resource is determined to be not managed by EMPI.\n \t *\n \t * @param theResource the incoming EMPI target, which is either a Patient or Practitioner.\n-\t * @param theEmpiTransactionContext\n+\t * @param theMdmTransactionContext\n \t * @return an {@link TransactionLogMessages} which contains all informational messages related to EMPI processing of this resource.\n \t */\n-\tpublic EmpiTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\tpublic MdmTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tif (EmpiUtil.isEmpiAccessible(theResource)) {\n-\t\t\treturn doEmpiUpdate(theResource, theEmpiTransactionContext);\n+\t\t\treturn doEmpiUpdate(theResource, theMdmTransactionContext);\n \t\t} else {\n \t\t\treturn null;\n \t\t}\n \t}\n \n-\tprivate EmpiTransactionContext doEmpiUpdate(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tCandidateList candidateList = myEmpiPersonFindingSvc.findPersonCandidates(theResource);\n+\tprivate MdmTransactionContext doEmpiUpdate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\tCandidateList candidateList = myEmpiSourceResourceFindingSvc.findSourceResourceCandidates(theResource);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\ndeleted file mode 100644\nindex 4e7a86d409..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,165 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.CandidateList;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiSourceResourceFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.MatchedSourceResourceCandidate;\n-import ca.uhn.fhir.rest.server.TransactionLogMessages;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * EmpiMatchLinkSvc is the entrypoint for HAPI's EMPI system. An incoming resource can call\n- * updateEmpiLinksForEmpiTarget and the underlying EMPI system will take care of matching it to a person, or creating a\n- * new Person if a suitable one was not found.\n- */\n-@Service\n-public class EmpiMatchLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n-\t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n-\t@Autowired\n-\tprivate PersonHelper myGoldenResourceHelper;\n-\t@Autowired\n-\tprivate EmpiEidUpdateService myEidUpdateService;\n-\n-\t/**\n-\t * Given an Empi Target (consisting of either a Patient or a Practitioner), find a suitable Person candidate for them,\n-\t * or create one if one does not exist. Performs matching based on rules defined in empi-rules.json.\n-\t * Does nothing if resource is determined to be not managed by EMPI.\n-\t *\n-\t * @param theResource the incoming EMPI target, which is either a Patient or Practitioner.\n-\t * @param theMdmTransactionContext\n-\t * @return an {@link TransactionLogMessages} which contains all informational messages related to EMPI processing of this resource.\n-\t */\n-\tpublic MdmTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tif (EmpiUtil.isEmpiAccessible(theResource)) {\n-\t\t\treturn doEmpiUpdate(theResource, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\tprivate MdmTransactionContext doEmpiUpdate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tCandidateList candidateList = myEmpiSourceResourceFindingSvc.findSourceResourceCandidates(theResource);\n-\n-\t\tif (candidateList.isEmpty()) {\n-\t\t\thandleEmpiWithNoCandidates(theResource, theMdmTransactionContext);\n-\t\t} else if (candidateList.exactlyOneMatch()) {\n-\t\t\thandleEmpiWithSingleCandidate(theResource, candidateList.getOnlyMatch(), theMdmTransactionContext);\n-\t\t} else {\n-\t\t\thandleEmpiWithMultipleCandidates(theResource, candidateList, theMdmTransactionContext);\n-\t\t}\n-\t\treturn theMdmTransactionContext;\n-\t}\n-\n-\tprivate void handleEmpiWithMultipleCandidates(IAnyResource theResource, CandidateList theCandidateList, MdmTransactionContext theMdmTransactionContext) {\n-\t\tMatchedSourceResourceCandidate firstMatch = theCandidateList.getFirstMatch();\n-\t\tLong samplePersonPid = firstMatch.getCandidatePersonPid().getIdAsLong();\n-\t\tboolean allSamePerson = theCandidateList.stream()\n-\t\t\t.allMatch(candidate -> candidate.getCandidatePersonPid().getIdAsLong().equals(samplePersonPid));\n-\n-\t\tif (allSamePerson) {\n-\t\t\tlog(theMdmTransactionContext, \"EMPI received multiple match candidates, but they are all linked to the same person.\");\n-\t\t\thandleEmpiWithSingleCandidate(theResource, firstMatch, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\tlog(theMdmTransactionContext, \"EMPI received multiple match candidates, that were linked to different Persons. Setting POSSIBLE_DUPLICATES and POSSIBLE_MATCHES.\");\n-\t\t\t//Set them all as POSSIBLE_MATCH\n-\t\t\tList<IAnyResource> persons = new ArrayList<>();\n-\t\t\tfor (MatchedSourceResourceCandidate matchedSourceResourceCandidate : theCandidateList.getCandidates()) {\n-\t\t\t\tIAnyResource person = myEmpiSourceResourceFindingSvc\n-\t\t\t\t\t.getSourceResourceFromMatchedSourceResourceCandidate(matchedSourceResourceCandidate, theMdmTransactionContext.getResourceType());\n-\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_MATCH;\n-\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n-\t\t\t\tmyEmpiLinkSvc.updateLink(person, theResource, outcome, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t\t\tpersons.add(person);\n-\t\t\t}\n-\n-\t\t\t//Set all Persons as POSSIBLE_DUPLICATE of the last person.\n-\t\t\tIAnyResource firstPerson = persons.get(0);\n-\t\t\tpersons.subList(1, persons.size())\n-\t\t\t\t.forEach(possibleDuplicatePerson -> {\n-\t\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_DUPLICATE;\n-\t\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n-\t\t\t\t\tmyEmpiLinkSvc.updateLink(firstPerson, possibleDuplicatePerson, outcome, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void handleEmpiWithNoCandidates(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tlog(theMdmTransactionContext, String.format(\"There were no matched candidates for EMPI, creating a new %s.\", theResource.getIdElement().getResourceType()));\n-\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n-\t\t// TODO GGG :)\n-\t\t// 1. Get the right helper\n-\t\t// 2. Create source resoruce for the EMPI target\n-\t\t// 3. UPDATE EMPI LINK TABLE\n-\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t}\n-\n-\tprivate void handleEmpiCreate(IAnyResource theTargetResource, MatchedSourceResourceCandidate thePersonCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tlog(theMdmTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n-\t\tIAnyResource sourceResource = myEmpiSourceResourceFindingSvc.getSourceResourceFromMatchedSourceResourceCandidate(thePersonCandidate, theMdmTransactionContext.getResourceType());\n-\n-\t\tif (myGoldenResourceHelper.isPotentialDuplicate(sourceResource, theTargetResource)) {\n-\t\t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\t\tIAnyResource newSourceResource = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theTargetResource);\n-\t\t\tmyEmpiLinkSvc.updateLink(newSourceResource, theTargetResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t\tmyEmpiLinkSvc.updateLink(newSourceResource, sourceResource, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\tif (thePersonCandidate.isMatch()) {\n-\t\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(sourceResource, theTargetResource, theMdmTransactionContext);\n-\t\t\t\t// myPersonHelper.updatePersonFromNewlyCreatedEmpiTarget(person, theResource, theEmpiTransactionContext);\n-\t\t\t}\n-\t\t\tmyEmpiLinkSvc.updateLink(sourceResource, theTargetResource, thePersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t}\n-\t}\n-\n-\tprivate void handleEmpiWithSingleCandidate(IAnyResource theResource, MatchedSourceResourceCandidate thePersonCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tlog(theMdmTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n-\t\tif (theMdmTransactionContext.getRestOperation().equals(MdmTransactionContext.OperationType.UPDATE_RESOURCE)) {\n-\t\t\tmyEidUpdateService.handleEmpiUpdate(theResource, thePersonCandidate, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\thandleEmpiCreate(theResource, thePersonCandidate, theMdmTransactionContext);\n-\t\t}\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\nnew file mode 100644\nindex 0000000000..35e8f228c8\n--- /dev/null\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\n", "chunk": "@@ -0,0 +1,158 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.empi.util.EmpiUtil;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.CandidateList;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiPersonFindingSvc;\n+import ca.uhn.fhir.jpa.empi.svc.candidate.MatchedPersonCandidate;\n+import ca.uhn.fhir.rest.server.TransactionLogMessages;\n+\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * EmpiMatchLinkSvc is the entrypoint for HAPI's EMPI system. An incoming resource can call\n+ * updateEmpiLinksForEmpiTarget and the underlying EMPI system will take care of matching it to a person, or creating a\n+ * new Person if a suitable one was not found.\n+ */\n+@Service\n+public class EmpiMatchLinkSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n+\t@Autowired\n+\tprivate EmpiPersonFindingSvc myEmpiPersonFindingSvc;\n+\t@Autowired\n+\tprivate PersonHelper myPersonHelper;\n+\t@Autowired\n+\tprivate EmpiEidUpdateService myEidUpdateService;\n+\n+\t/**\n+\t * Given an Empi Target (consisting of either a Patient or a Practitioner), find a suitable Person candidate for them,\n+\t * or create one if one does not exist. Performs matching based on rules defined in empi-rules.json.\n+\t * Does nothing if resource is determined to be not managed by EMPI.\n+\t *\n+\t * @param theResource the incoming EMPI target, which is either a Patient or Practitioner.\n+\t * @param theEmpiTransactionContext\n+\t * @return an {@link TransactionLogMessages} which contains all informational messages related to EMPI processing of this resource.\n+\t */\n+\tpublic EmpiTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (EmpiUtil.isEmpiAccessible(theResource)) {\n+\t\t\treturn doEmpiUpdate(theResource, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate EmpiTransactionContext doEmpiUpdate(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tCandidateList candidateList = myEmpiPersonFindingSvc.findPersonCandidates(theResource);\n+\t\tif (candidateList.isEmpty()) {\n+\t\t\thandleEmpiWithNoCandidates(theResource, theEmpiTransactionContext);\n+\t\t} else if (candidateList.exactlyOneMatch()) {\n+\t\t\thandleEmpiWithSingleCandidate(theResource, candidateList.getOnlyMatch(), theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\thandleEmpiWithMultipleCandidates(theResource, candidateList, theEmpiTransactionContext);\n+\t\t}\n+\t\treturn theEmpiTransactionContext;\n+\t}\n+\n+\tprivate void handleEmpiWithMultipleCandidates(IAnyResource theResource, CandidateList theCandidateList, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tMatchedPersonCandidate firstMatch = theCandidateList.getFirstMatch();\n+\t\tLong samplePersonPid = firstMatch.getCandidatePersonPid().getIdAsLong();\n+\t\tboolean allSamePerson = theCandidateList.stream()\n+\t\t\t.allMatch(candidate -> candidate.getCandidatePersonPid().getIdAsLong().equals(samplePersonPid));\n+\n+\t\tif (allSamePerson) {\n+\t\t\tlog(theEmpiTransactionContext, \"EMPI received multiple match candidates, but they are all linked to the same person.\");\n+\t\t\thandleEmpiWithSingleCandidate(theResource, firstMatch, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\tlog(theEmpiTransactionContext, \"EMPI received multiple match candidates, that were linked to different Persons. Setting POSSIBLE_DUPLICATES and POSSIBLE_MATCHES.\");\n+\t\t\t//Set them all as POSSIBLE_MATCH\n+\t\t\tList<IAnyResource> persons = new ArrayList<>();\n+\t\t\tfor (MatchedPersonCandidate matchedPersonCandidate : theCandidateList.getCandidates()) {\n+\t\t\t\tIAnyResource person = myEmpiPersonFindingSvc.getPersonFromMatchedPersonCandidate(matchedPersonCandidate);\n+\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_MATCH;\n+\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n+\t\t\t\tmyEmpiLinkSvc.updateLink(person, theResource, outcome, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tpersons.add(person);\n+\t\t\t}\n+\n+\t\t\t//Set all Persons as POSSIBLE_DUPLICATE of the last person.\n+\t\t\tIAnyResource firstPerson = persons.get(0);\n+\t\t\tpersons.subList(1, persons.size())\n+\t\t\t\t.forEach(possibleDuplicatePerson -> {\n+\t\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_DUPLICATE;\n+\t\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n+\t\t\t\t\tmyEmpiLinkSvc.updateLink(firstPerson, possibleDuplicatePerson, outcome, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate void handleEmpiWithNoCandidates(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tlog(theEmpiTransactionContext, \"There were no matched candidates for EMPI, creating a new Person.\");\n+\t\tIAnyResource newPerson = myPersonHelper.createPersonFromEmpiTarget(theResource);\n+\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t}\n+\n+\tprivate void handleEmpiCreate(IAnyResource theResource, MatchedPersonCandidate thePersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tlog(theEmpiTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n+\t\tIAnyResource person = myEmpiPersonFindingSvc.getPersonFromMatchedPersonCandidate(thePersonCandidate);\n+\t\tif (myPersonHelper.isPotentialDuplicate(person, theResource)) {\n+\t\t\tlog(theEmpiTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n+\t\t\tIAnyResource newPerson = myPersonHelper.createPersonFromEmpiTarget(theResource);\n+\t\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\tmyEmpiLinkSvc.updateLink(newPerson, person, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\tif (thePersonCandidate.isMatch()) {\n+\t\t\t\tmyPersonHelper.handleExternalEidAddition(person, theResource, theEmpiTransactionContext);\n+\t\t\t\tmyPersonHelper.updatePersonFromNewlyCreatedEmpiTarget(person, theResource, theEmpiTransactionContext);\n+\t\t\t}\n+\t\t\tmyEmpiLinkSvc.updateLink(person, theResource, thePersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t}\n+\t}\n+\n+\tprivate void handleEmpiWithSingleCandidate(IAnyResource theResource, MatchedPersonCandidate thePersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tlog(theEmpiTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n+\t\tif (theEmpiTransactionContext.getRestOperation().equals(EmpiTransactionContext.OperationType.UPDATE_RESOURCE)) {\n+\t\t\tmyEidUpdateService.handleEmpiUpdate(theResource, thePersonCandidate, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\thandleEmpiCreate(theResource, thePersonCandidate, theEmpiTransactionContext);\n+\t\t}\n+\t}\n+\n+\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+}\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\ndeleted file mode 100644\nindex 35e8f228c8..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,158 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.CandidateList;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiPersonFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.MatchedPersonCandidate;\n-import ca.uhn.fhir.rest.server.TransactionLogMessages;\n-\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * EmpiMatchLinkSvc is the entrypoint for HAPI's EMPI system. An incoming resource can call\n- * updateEmpiLinksForEmpiTarget and the underlying EMPI system will take care of matching it to a person, or creating a\n- * new Person if a suitable one was not found.\n- */\n-@Service\n-public class EmpiMatchLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n-\t@Autowired\n-\tprivate EmpiPersonFindingSvc myEmpiPersonFindingSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate EmpiEidUpdateService myEidUpdateService;\n-\n-\t/**\n-\t * Given an Empi Target (consisting of either a Patient or a Practitioner), find a suitable Person candidate for them,\n-\t * or create one if one does not exist. Performs matching based on rules defined in empi-rules.json.\n-\t * Does nothing if resource is determined to be not managed by EMPI.\n-\t *\n-\t * @param theResource the incoming EMPI target, which is either a Patient or Practitioner.\n-\t * @param theEmpiTransactionContext\n-\t * @return an {@link TransactionLogMessages} which contains all informational messages related to EMPI processing of this resource.\n-\t */\n-\tpublic EmpiTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (EmpiUtil.isEmpiAccessible(theResource)) {\n-\t\t\treturn doEmpiUpdate(theResource, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\tprivate EmpiTransactionContext doEmpiUpdate(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tCandidateList candidateList = myEmpiPersonFindingSvc.findPersonCandidates(theResource);\n-\t\tif (candidateList.isEmpty()) {\n-\t\t\thandleEmpiWithNoCandidates(theResource, theEmpiTransactionContext);\n-\t\t} else if (candidateList.exactlyOneMatch()) {\n-\t\t\thandleEmpiWithSingleCandidate(theResource, candidateList.getOnlyMatch(), theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\thandleEmpiWithMultipleCandidates(theResource, candidateList, theEmpiTransactionContext);\n-\t\t}\n-\t\treturn theEmpiTransactionContext;\n-\t}\n-\n-\tprivate void handleEmpiWithMultipleCandidates(IAnyResource theResource, CandidateList theCandidateList, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tMatchedPersonCandidate firstMatch = theCandidateList.getFirstMatch();\n-\t\tLong samplePersonPid = firstMatch.getCandidatePersonPid().getIdAsLong();\n-\t\tboolean allSamePerson = theCandidateList.stream()\n-\t\t\t.allMatch(candidate -> candidate.getCandidatePersonPid().getIdAsLong().equals(samplePersonPid));\n-\n-\t\tif (allSamePerson) {\n-\t\t\tlog(theEmpiTransactionContext, \"EMPI received multiple match candidates, but they are all linked to the same person.\");\n-\t\t\thandleEmpiWithSingleCandidate(theResource, firstMatch, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tlog(theEmpiTransactionContext, \"EMPI received multiple match candidates, that were linked to different Persons. Setting POSSIBLE_DUPLICATES and POSSIBLE_MATCHES.\");\n-\t\t\t//Set them all as POSSIBLE_MATCH\n-\t\t\tList<IAnyResource> persons = new ArrayList<>();\n-\t\t\tfor (MatchedPersonCandidate matchedPersonCandidate : theCandidateList.getCandidates()) {\n-\t\t\t\tIAnyResource person = myEmpiPersonFindingSvc.getPersonFromMatchedPersonCandidate(matchedPersonCandidate);\n-\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_MATCH;\n-\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n-\t\t\t\tmyEmpiLinkSvc.updateLink(person, theResource, outcome, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\t\t\tpersons.add(person);\n-\t\t\t}\n-\n-\t\t\t//Set all Persons as POSSIBLE_DUPLICATE of the last person.\n-\t\t\tIAnyResource firstPerson = persons.get(0);\n-\t\t\tpersons.subList(1, persons.size())\n-\t\t\t\t.forEach(possibleDuplicatePerson -> {\n-\t\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_DUPLICATE;\n-\t\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n-\t\t\t\t\tmyEmpiLinkSvc.updateLink(firstPerson, possibleDuplicatePerson, outcome, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void handleEmpiWithNoCandidates(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tlog(theEmpiTransactionContext, \"There were no matched candidates for EMPI, creating a new Person.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createPersonFromEmpiTarget(theResource);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t}\n-\n-\tprivate void handleEmpiCreate(IAnyResource theResource, MatchedPersonCandidate thePersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tlog(theEmpiTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n-\t\tIAnyResource person = myEmpiPersonFindingSvc.getPersonFromMatchedPersonCandidate(thePersonCandidate);\n-\t\tif (myPersonHelper.isPotentialDuplicate(person, theResource)) {\n-\t\t\tlog(theEmpiTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\t\tIAnyResource newPerson = myPersonHelper.createPersonFromEmpiTarget(theResource);\n-\t\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\t\tmyEmpiLinkSvc.updateLink(newPerson, person, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tif (thePersonCandidate.isMatch()) {\n-\t\t\t\tmyPersonHelper.handleExternalEidAddition(person, theResource, theEmpiTransactionContext);\n-\t\t\t\tmyPersonHelper.updatePersonFromNewlyCreatedEmpiTarget(person, theResource, theEmpiTransactionContext);\n-\t\t\t}\n-\t\t\tmyEmpiLinkSvc.updateLink(person, theResource, thePersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tprivate void handleEmpiWithSingleCandidate(IAnyResource theResource, MatchedPersonCandidate thePersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tlog(theEmpiTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n-\t\tif (theEmpiTransactionContext.getRestOperation().equals(EmpiTransactionContext.OperationType.UPDATE_RESOURCE)) {\n-\t\t\tmyEidUpdateService.handleEmpiUpdate(theResource, thePersonCandidate, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\thandleEmpiCreate(theResource, thePersonCandidate, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NzgyMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525377820", "body": "Remove import", "bodyText": "Remove import", "bodyHTML": "<p dir=\"auto\">Remove import</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:08:42Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java", "diffHunk": "@@ -22,96 +22,89 @@\n \n import ca.uhn.fhir.empi.api.EmpiConstants;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n+import ca.uhn.fhir.jpa.model.entity.TagTypeEnum;\n import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n import ca.uhn.fhir.rest.api.server.IBundleProvider;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n import ca.uhn.fhir.rest.param.TokenParam;\n import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\nindex 039b222c0e..c640215f60 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n", "chunk": "@@ -22,10 +22,10 @@ package ca.uhn.fhir.jpa.empi.svc;\n \n import ca.uhn.fhir.empi.api.EmpiConstants;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.empi.util.EmpiUtil;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n-import ca.uhn.fhir.jpa.model.entity.TagTypeEnum;\n import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n import ca.uhn.fhir.rest.api.server.IBundleProvider;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\ndeleted file mode 100644\nindex c640215f60..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,117 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n-import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n-import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n-import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n-import ca.uhn.fhir.rest.api.server.IBundleProvider;\n-import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n-import ca.uhn.fhir.rest.param.TokenParam;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.PostConstruct;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-@Service\n-public class EmpiResourceDaoSvc {\n-\tprivate static final int MAX_MATCHING_PERSONS = 1000;\n-\t@Autowired\n-\tDaoRegistry myDaoRegistry;\n-\t@Autowired\n-\tIEmpiSettings myEmpiConfig;\n-\n-\tprivate IFhirResourceDao<IBaseResource> myPatientDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPersonDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPractitionerDao;\n-\n-\t@PostConstruct\n-\tpublic void postConstruct() {\n-\t\tmyPatientDao = myDaoRegistry.getResourceDao(\"Patient\");\n-\t\tmyPersonDao = myDaoRegistry.getResourceDao(\"Person\");\n-\t\tmyPractitionerDao = myDaoRegistry.getResourceDao(\"Practitioner\");\n-\t}\n-\n-\tpublic IAnyResource readPatient(IIdType theId) {\n-\t\treturn (IAnyResource) myPatientDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPerson(IIdType theId) {\n-\t\treturn (IAnyResource) myPersonDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPractitioner(IIdType theId) {\n-\t\treturn (IAnyResource) myPractitionerDao.read(theId);\n-\t}\n-\n-\tpublic DaoMethodOutcome updatePerson(IAnyResource thePerson) {\n-\t\tif (thePerson.getIdElement().hasIdPart()) {\n-\t\t\treturn myPersonDao.update(thePerson);\n-\t\t} else {\n-\t\t\treturn myPersonDao.create(thePerson);\n-\t\t}\n-\t}\n-\n-\tpublic IAnyResource readPersonByPid(ResourcePersistentId thePersonPid) {\n-\t\treturn (IAnyResource) myPersonDao.readByPid(thePersonPid);\n-\t}\n-\n-\tpublic Optional<IAnyResource> searchPersonByEid(String theEid) {\n-\t\tSearchParameterMap map = new SearchParameterMap();\n-\t\tmap.setLoadSynchronous(true);\n-\t\tmap.add(\"identifier\", new TokenParam(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem(), theEid));\n-\t\tmap.add(\"active\", new TokenParam(\"true\"));\n-\t\tIBundleProvider search = myPersonDao.search(map);\n-\n-\t\t// Could add the meta tag to the query, but it's probably more efficient to filter on it afterwards since in practice\n-\t\t// it will always be present.\n-\t\tList<IBaseResource> list = search.getResources(0, MAX_MATCHING_PERSONS).stream()\n-\t\t\t.filter(EmpiUtil::isEmpiManaged)\n-\t\t\t.collect(Collectors.toList());\n-\n-\t\tif (list.isEmpty()) {\n-\t\t\treturn Optional.empty();\n-\t\t} else if (list.size() > 1) {\n-\t\t\tthrow new InternalErrorException(\"Found more than one active \" +\n-\t\t\t\tEmpiConstants.CODE_HAPI_EMPI_MANAGED +\n-\t\t\t\t\" Person with EID \" +\n-\t\t\t\ttheEid +\n-\t\t\t\t\": \" +\n-\t\t\t\tlist.get(0).getIdElement().getValue() +\n-\t\t\t\t\", \" +\n-\t\t\t\tlist.get(1).getIdElement().getValue()\n-\t\t\t\t);\n-\t\t} else {\n-\t\t\treturn Optional.of((IAnyResource) list.get(0));\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}, {"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\nindex 039b222c0e..c640215f60 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n", "chunk": "@@ -33,78 +33,85 @@ import ca.uhn.fhir.rest.param.TokenParam;\n import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.jetbrains.annotations.NotNull;\n+import org.hl7.fhir.instance.model.api.IIdType;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n+import javax.annotation.PostConstruct;\n import java.util.List;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n \n @Service\n public class EmpiResourceDaoSvc {\n-\n \tprivate static final int MAX_MATCHING_PERSONS = 1000;\n-\n \t@Autowired\n \tDaoRegistry myDaoRegistry;\n \t@Autowired\n \tIEmpiSettings myEmpiConfig;\n \n-\tpublic DaoMethodOutcome upsertSourceResource(IAnyResource theSourceResource, String theResourceType) {\n-\t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n-\t\tif (theSourceResource.getIdElement().hasIdPart()) {\n-\t\t\treturn resourceDao.update(theSourceResource);\n-\t\t} else {\n-\t\t\treturn resourceDao.create(theSourceResource);\n-\t\t}\n+\tprivate IFhirResourceDao<IBaseResource> myPatientDao;\n+\tprivate IFhirResourceDao<IBaseResource> myPersonDao;\n+\tprivate IFhirResourceDao<IBaseResource> myPractitionerDao;\n+\n+\t@PostConstruct\n+\tpublic void postConstruct() {\n+\t\tmyPatientDao = myDaoRegistry.getResourceDao(\"Patient\");\n+\t\tmyPersonDao = myDaoRegistry.getResourceDao(\"Person\");\n+\t\tmyPractitionerDao = myDaoRegistry.getResourceDao(\"Practitioner\");\n \t}\n \n-\t/**\n-\t* Given a resource, remove its Golden Resource tag.\n-\t* @param theGoldenResource the {@link IAnyResource} to remove the tag from.\n-\t* @param theResourcetype the type of that resource\n-\t*/\n-\tpublic void removeGoldenResourceTag(IAnyResource theGoldenResource, String theResourcetype) {\n-\t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourcetype);\n-\t\tresourceDao.removeTag(theGoldenResource.getIdElement(), TagTypeEnum.TAG, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD);\n+\tpublic IAnyResource readPatient(IIdType theId) {\n+\t\treturn (IAnyResource) myPatientDao.read(theId);\n \t}\n \n-\tpublic IAnyResource readSourceResourceByPid(ResourcePersistentId theSourceResourcePid, String theResourceType) {\n-\t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n-\t\treturn (IAnyResource) resourceDao.readByPid(theSourceResourcePid);\n+\tpublic IAnyResource readPerson(IIdType theId) {\n+\t\treturn (IAnyResource) myPersonDao.read(theId);\n \t}\n \n-\t//TODO GGG MDM address this\n-\tpublic Optional<IAnyResource> searchGoldenResourceByEID(String theEid, String theResourceType) {\n-\t\tSearchParameterMap map = buildEidSearchParameterMap(theEid);\n+\tpublic IAnyResource readPractitioner(IIdType theId) {\n+\t\treturn (IAnyResource) myPractitionerDao.read(theId);\n+\t}\n \n-\t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n-\t\tIBundleProvider search = resourceDao.search(map);\n-\t\tList<IBaseResource> resources = search.getResources(0, MAX_MATCHING_PERSONS);\n+\tpublic DaoMethodOutcome updatePerson(IAnyResource thePerson) {\n+\t\tif (thePerson.getIdElement().hasIdPart()) {\n+\t\t\treturn myPersonDao.update(thePerson);\n+\t\t} else {\n+\t\t\treturn myPersonDao.create(thePerson);\n+\t\t}\n+\t}\n \n-\t\tif (resources.isEmpty()) {\n+\tpublic IAnyResource readPersonByPid(ResourcePersistentId thePersonPid) {\n+\t\treturn (IAnyResource) myPersonDao.readByPid(thePersonPid);\n+\t}\n+\n+\tpublic Optional<IAnyResource> searchPersonByEid(String theEid) {\n+\t\tSearchParameterMap map = new SearchParameterMap();\n+\t\tmap.setLoadSynchronous(true);\n+\t\tmap.add(\"identifier\", new TokenParam(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem(), theEid));\n+\t\tmap.add(\"active\", new TokenParam(\"true\"));\n+\t\tIBundleProvider search = myPersonDao.search(map);\n+\n+\t\t// Could add the meta tag to the query, but it's probably more efficient to filter on it afterwards since in practice\n+\t\t// it will always be present.\n+\t\tList<IBaseResource> list = search.getResources(0, MAX_MATCHING_PERSONS).stream()\n+\t\t\t.filter(EmpiUtil::isEmpiManaged)\n+\t\t\t.collect(Collectors.toList());\n+\n+\t\tif (list.isEmpty()) {\n \t\t\treturn Optional.empty();\n-\t\t} else if (resources.size() > 1) {\n+\t\t} else if (list.size() > 1) {\n \t\t\tthrow new InternalErrorException(\"Found more than one active \" +\n-\t\t\t\tEmpiConstants.CODE_HAPI_MDM_MANAGED +\n+\t\t\t\tEmpiConstants.CODE_HAPI_EMPI_MANAGED +\n \t\t\t\t\" Person with EID \" +\n \t\t\t\ttheEid +\n \t\t\t\t\": \" +\n-\t\t\t\tresources.get(0).getIdElement().getValue() +\n+\t\t\t\tlist.get(0).getIdElement().getValue() +\n \t\t\t\t\", \" +\n-\t\t\t\tresources.get(1).getIdElement().getValue()\n-\t\t\t);\n+\t\t\t\tlist.get(1).getIdElement().getValue()\n+\t\t\t\t);\n \t\t} else {\n-\t\t\treturn Optional.of((IAnyResource) resources.get(0));\n+\t\t\treturn Optional.of((IAnyResource) list.get(0));\n \t\t}\n \t}\n-\n-\t@NotNull\n-\tprivate SearchParameterMap buildEidSearchParameterMap(String theTheEid) {\n-\t\tSearchParameterMap map = new SearchParameterMap();\n-\t\tmap.setLoadSynchronous(true);\n-\t\tmap.add(\"identifier\", new TokenParam(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem(), theTheEid));\n-\t\tmap.add(\"_tag\", new TokenParam(EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD));\n-\t\treturn map;\n-\t}\n }\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\ndeleted file mode 100644\nindex c640215f60..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ /dev/null\n", "chunk": "@@ -1,117 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n-import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n-import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n-import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n-import ca.uhn.fhir.rest.api.server.IBundleProvider;\n-import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n-import ca.uhn.fhir.rest.param.TokenParam;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.PostConstruct;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-@Service\n-public class EmpiResourceDaoSvc {\n-\tprivate static final int MAX_MATCHING_PERSONS = 1000;\n-\t@Autowired\n-\tDaoRegistry myDaoRegistry;\n-\t@Autowired\n-\tIEmpiSettings myEmpiConfig;\n-\n-\tprivate IFhirResourceDao<IBaseResource> myPatientDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPersonDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPractitionerDao;\n-\n-\t@PostConstruct\n-\tpublic void postConstruct() {\n-\t\tmyPatientDao = myDaoRegistry.getResourceDao(\"Patient\");\n-\t\tmyPersonDao = myDaoRegistry.getResourceDao(\"Person\");\n-\t\tmyPractitionerDao = myDaoRegistry.getResourceDao(\"Practitioner\");\n-\t}\n-\n-\tpublic IAnyResource readPatient(IIdType theId) {\n-\t\treturn (IAnyResource) myPatientDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPerson(IIdType theId) {\n-\t\treturn (IAnyResource) myPersonDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPractitioner(IIdType theId) {\n-\t\treturn (IAnyResource) myPractitionerDao.read(theId);\n-\t}\n-\n-\tpublic DaoMethodOutcome updatePerson(IAnyResource thePerson) {\n-\t\tif (thePerson.getIdElement().hasIdPart()) {\n-\t\t\treturn myPersonDao.update(thePerson);\n-\t\t} else {\n-\t\t\treturn myPersonDao.create(thePerson);\n-\t\t}\n-\t}\n-\n-\tpublic IAnyResource readPersonByPid(ResourcePersistentId thePersonPid) {\n-\t\treturn (IAnyResource) myPersonDao.readByPid(thePersonPid);\n-\t}\n-\n-\tpublic Optional<IAnyResource> searchPersonByEid(String theEid) {\n-\t\tSearchParameterMap map = new SearchParameterMap();\n-\t\tmap.setLoadSynchronous(true);\n-\t\tmap.add(\"identifier\", new TokenParam(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem(), theEid));\n-\t\tmap.add(\"active\", new TokenParam(\"true\"));\n-\t\tIBundleProvider search = myPersonDao.search(map);\n-\n-\t\t// Could add the meta tag to the query, but it's probably more efficient to filter on it afterwards since in practice\n-\t\t// it will always be present.\n-\t\tList<IBaseResource> list = search.getResources(0, MAX_MATCHING_PERSONS).stream()\n-\t\t\t.filter(EmpiUtil::isEmpiManaged)\n-\t\t\t.collect(Collectors.toList());\n-\n-\t\tif (list.isEmpty()) {\n-\t\t\treturn Optional.empty();\n-\t\t} else if (list.size() > 1) {\n-\t\t\tthrow new InternalErrorException(\"Found more than one active \" +\n-\t\t\t\tEmpiConstants.CODE_HAPI_EMPI_MANAGED +\n-\t\t\t\t\" Person with EID \" +\n-\t\t\t\ttheEid +\n-\t\t\t\t\": \" +\n-\t\t\t\tlist.get(0).getIdElement().getValue() +\n-\t\t\t\t\", \" +\n-\t\t\t\tlist.get(1).getIdElement().getValue()\n-\t\t\t\t);\n-\t\t} else {\n-\t\t\treturn Optional.of((IAnyResource) list.get(0));\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Nzk1Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525377952", "body": "Fix S/R", "bodyText": "Fix S/R", "bodyHTML": "<p dir=\"auto\">Fix S/R</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:08:58Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java", "diffHunk": "@@ -22,96 +22,89 @@\n \n import ca.uhn.fhir.empi.api.EmpiConstants;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n+import ca.uhn.fhir.jpa.model.entity.TagTypeEnum;\n import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n import ca.uhn.fhir.rest.api.server.IBundleProvider;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n import ca.uhn.fhir.rest.param.TokenParam;\n import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n+import org.jetbrains.annotations.NotNull;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n-import javax.annotation.PostConstruct;\n import java.util.List;\n import java.util.Optional;\n-import java.util.stream.Collectors;\n \n @Service\n public class EmpiResourceDaoSvc {\n+\n \tprivate static final int MAX_MATCHING_PERSONS = 1000;\n+\n \t@Autowired\n \tDaoRegistry myDaoRegistry;\n \t@Autowired\n \tIEmpiSettings myEmpiConfig;\n \n-\tprivate IFhirResourceDao<IBaseResource> myPatientDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPersonDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPractitionerDao;\n-\n-\t@PostConstruct\n-\tpublic void postConstruct() {\n-\t\tmyPatientDao = myDaoRegistry.getResourceDao(\"Patient\");\n-\t\tmyPersonDao = myDaoRegistry.getResourceDao(\"Person\");\n-\t\tmyPractitionerDao = myDaoRegistry.getResourceDao(\"Practitioner\");\n-\t}\n-\n-\tpublic IAnyResource readPatient(IIdType theId) {\n-\t\treturn (IAnyResource) myPatientDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPerson(IIdType theId) {\n-\t\treturn (IAnyResource) myPersonDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPractitioner(IIdType theId) {\n-\t\treturn (IAnyResource) myPractitionerDao.read(theId);\n-\t}\n-\n-\tpublic DaoMethodOutcome updatePerson(IAnyResource thePerson) {\n-\t\tif (thePerson.getIdElement().hasIdPart()) {\n-\t\t\treturn myPersonDao.update(thePerson);\n+\tpublic DaoMethodOutcome upsertSourceResource(IAnyResource theSourceResource, String theResourceType) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\nsimilarity index 88%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\nindex 039b222c0e..3b8317597e 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\n", "chunk": "@@ -41,14 +41,14 @@ import java.util.List;\n import java.util.Optional;\n \n @Service\n-public class EmpiResourceDaoSvc {\n+public class MdmResourceDaoSvc {\n \n \tprivate static final int MAX_MATCHING_PERSONS = 1000;\n \n \t@Autowired\n \tDaoRegistry myDaoRegistry;\n \t@Autowired\n-\tIEmpiSettings myEmpiConfig;\n+\tIMdmSettings myMdmSettings;\n \n \tpublic DaoMethodOutcome upsertSourceResource(IAnyResource theSourceResource, String theResourceType) {\n \t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MDUzMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525380531", "body": "removeTargetLinks can be removed altogether?", "bodyText": "removeTargetLinks can be removed altogether?", "bodyHTML": "<p dir=\"auto\">removeTargetLinks can be removed altogether?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:12:52Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/GoldenResourceMergerSvcImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.MdmTransactionContext;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class GoldenResourceMergerSvcImpl implements IGoldenResourceMergerSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tPersonHelper myPersonHelper;\n+\t@Autowired\n+\tEmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tIEmpiLinkSvc myEmpiLinkSvc;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tEmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\n+\t@Override\n+\t@Transactional\n+\tpublic IAnyResource mergeGoldenResources(IAnyResource theFromGoldenResource, IAnyResource theToGoldenResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\tLong fromGoldenResourcePid = myIdHelperService.getPidOrThrowException(theFromGoldenResource);\n+\t\tLong toGoldenResourcePid = myIdHelperService.getPidOrThrowException(theToGoldenResource);\n+\t\tString resourceType = theMdmTransactionContext.getResourceType();\n+\n+\t\t//Merge attributes, to be determined when survivorship is solved.\n+\t\tmyPersonHelper.mergeFields(theFromGoldenResource, theToGoldenResource);\n+\n+\t\t//Merge the links from the FROM to the TO resource. Clean up dangling links.\n+\t\tmergeGoldenResourceLinks(theFromGoldenResource, theToGoldenResource, toGoldenResourcePid, theMdmTransactionContext);\n+\n+\t\t//Create the new REDIRECT link\n+\t\taddMergeLink(toGoldenResourcePid, fromGoldenResourcePid, resourceType);\n+\n+\t\t//Strip the golden resource tag from the now-deprecated resource.\n+\t\tmyEmpiResourceDaoSvc.removeGoldenResourceTag(theFromGoldenResource, resourceType);\n+\n+\t\t//Add the REDIRECT tag to that same deprecated resource.\n+\t\tmyPersonHelper.deactivateResource(theFromGoldenResource);\n+\n+\t\t//Save the deprecated resource.\n+\t\tmyEmpiResourceDaoSvc.upsertSourceResource(theFromGoldenResource, resourceType);\n+\n+\t\tlog(theMdmTransactionContext, \"Merged \" + theFromGoldenResource.getIdElement().toVersionless() + \" into \" + theToGoldenResource.getIdElement().toVersionless());\n+\t\treturn theToGoldenResource;\n+\t}\n+\n+\t/**\n+\t * Removes non-manual links from source to target\n+\t *\n+\t * @param theFrom                   Target of the link\n+\t * @param theTo                     Source resource of the link\n+\t * @param theMdmTransactionContext Context to keep track of the deletions\n+\t */\n+\tprivate void removeTargetLinks(IAnyResource theFrom, IAnyResource theTo, MdmTransactionContext theMdmTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MDkzMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525380931", "body": "address S/R", "bodyText": "address S/R", "bodyHTML": "<p dir=\"auto\">address S/R</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:13:35Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java", "diffHunk": "@@ -35,11 +35,11 @@\n \n \tCandidateList findCandidates(IAnyResource theTarget) {\n \t\tCandidateList candidateList = new CandidateList(getStrategy());\n-\t\tcandidateList.addAll(findMatchPersonCandidates(theTarget));\n+\t\tcandidateList.addAll(findMatchSourceResourceCandidates(theTarget));", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/BaseCandidateFinder.java\nsimilarity index 91%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java\nrename to hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/BaseCandidateFinder.java\nindex c1e687d0f8..b5c7788b2e 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java\n+++ b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/BaseCandidateFinder.java\n", "chunk": "@@ -31,7 +31,7 @@ public abstract class BaseCandidateFinder {\n \t@Autowired\n \tIdHelperService myIdHelperService;\n \t@Autowired\n-\tEmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tMdmLinkDaoSvc myMdmLinkDaoSvc;\n \n \tCandidateList findCandidates(IAnyResource theTarget) {\n \t\tCandidateList candidateList = new CandidateList(getStrategy());\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MTEwMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525381102", "body": "Rename to MdmGoldenResourceFindingSvc", "bodyText": "Rename to MdmGoldenResourceFindingSvc", "bodyHTML": "<p dir=\"auto\">Rename to MdmGoldenResourceFindingSvc</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:13:53Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/EmpiSourceResourceFindingSvc.java", "diffHunk": "@@ -30,7 +30,7 @@\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiPersonFindingSvc {\n+public class EmpiSourceResourceFindingSvc {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MTg0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525381848", "body": "Rename to MatchedGoldenResourceCandidate", "bodyText": "Rename to MatchedGoldenResourceCandidate", "bodyHTML": "<p dir=\"auto\">Rename to MatchedGoldenResourceCandidate</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:15:01Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java", "diffHunk": "@@ -24,22 +24,23 @@\n import ca.uhn.fhir.jpa.entity.EmpiLink;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n \n-public class MatchedPersonCandidate {\n-\tprivate final ResourcePersistentId myCandidatePersonPid;\n+public class MatchedSourceResourceCandidate {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MjE0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525382148", "body": "Fix person / empi", "bodyText": "Fix person / empi", "bodyHTML": "<p dir=\"auto\">Fix person / empi</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:15:26Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java", "diffHunk": "@@ -24,22 +24,23 @@\n import ca.uhn.fhir.jpa.entity.EmpiLink;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n \n-public class MatchedPersonCandidate {\n-\tprivate final ResourcePersistentId myCandidatePersonPid;\n+public class MatchedSourceResourceCandidate {\n+\n+\tprivate final ResourcePersistentId myCandidateSourceResourcePid;\n \tprivate final EmpiMatchOutcome myEmpiMatchOutcome;\n \n-\tpublic MatchedPersonCandidate(ResourcePersistentId theCandidate, EmpiMatchOutcome theEmpiMatchOutcome) {\n-\t\tmyCandidatePersonPid = theCandidate;\n+\tpublic MatchedSourceResourceCandidate(ResourcePersistentId theCandidate, EmpiMatchOutcome theEmpiMatchOutcome) {\n+\t\tmyCandidateSourceResourcePid = theCandidate;\n \t\tmyEmpiMatchOutcome = theEmpiMatchOutcome;\n \t}\n \n-\tpublic MatchedPersonCandidate(ResourcePersistentId thePersonPid, EmpiLink theEmpiLink) {\n-\t\tmyCandidatePersonPid = thePersonPid;\n+\tpublic MatchedSourceResourceCandidate(ResourcePersistentId thePersonPid, EmpiLink theEmpiLink) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MjcwNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525382707", "body": "fix S/R", "bodyText": "fix S/R", "bodyHTML": "<p dir=\"auto\">fix S/R</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:16:13Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java", "diffHunk": "@@ -269,71 +316,91 @@ protected void assertLinkCount(long theExpectedCount) {\n \t\tassertEquals(theExpectedCount, myEmpiLinkDao.count());\n \t}\n \n-\tprotected Person getPersonFromTarget(IAnyResource theBaseResource) {\n+\tprotected IAnyResource getGoldenResourceFromTargetResource(IAnyResource theBaseResource) {\n+\t\tString resourceType = theBaseResource.getIdElement().getResourceType();\n+\t\tIFhirResourceDao relevantDao = myDaoRegistry.getResourceDao(resourceType);\n+\n \t\tOptional<EmpiLink> matchedLinkForTargetPid = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(theBaseResource));\n \t\tif (matchedLinkForTargetPid.isPresent()) {\n-\t\t\tLong personPid = matchedLinkForTargetPid.get().getPersonPid();\n-\t\t\treturn (Person) myPersonDao.readByPid(new ResourcePersistentId(personPid));\n+\t\t\tLong sourceResourcePid = matchedLinkForTargetPid.get().getSourceResourcePid();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/BaseMdmR4Test.java\nsimilarity index 74%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/BaseMdmR4Test.java\nindex 948708481b..ccff716833 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/BaseMdmR4Test.java\n", "chunk": "@@ -313,40 +313,40 @@ abstract public class BaseEmpiR4Test extends BaseJpaR4Test {\n \t}\n \n \tprotected void assertLinkCount(long theExpectedCount) {\n-\t\tassertEquals(theExpectedCount, myEmpiLinkDao.count());\n+\t\tassertEquals(theExpectedCount, myMdmLinkDao.count());\n \t}\n \n \tprotected IAnyResource getGoldenResourceFromTargetResource(IAnyResource theBaseResource) {\n \t\tString resourceType = theBaseResource.getIdElement().getResourceType();\n \t\tIFhirResourceDao relevantDao = myDaoRegistry.getResourceDao(resourceType);\n \n-\t\tOptional<EmpiLink> matchedLinkForTargetPid = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(theBaseResource));\n+\t\tOptional<MdmLink> matchedLinkForTargetPid = myMdmLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(theBaseResource));\n \t\tif (matchedLinkForTargetPid.isPresent()) {\n-\t\t\tLong sourceResourcePid = matchedLinkForTargetPid.get().getSourceResourcePid();\n+\t\t\tLong sourceResourcePid = matchedLinkForTargetPid.get().getGoldenResourcePid();\n \t\t\treturn (IAnyResource) relevantDao.readByPid(new ResourcePersistentId(sourceResourcePid));\n \t\t} else {\n \t\t\treturn null;\n \t\t}\n \t}\n \n-\tprotected <T extends IBaseResource> T getTargetResourceFromEmpiLink(EmpiLink theEmpiLink, String theResourceType) {\n+\tprotected <T extends IBaseResource> T getTargetResourceFromEmpiLink(MdmLink theMdmLink, String theResourceType) {\n \t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n-\t\treturn (T) resourceDao.readByPid(new ResourcePersistentId(theEmpiLink.getSourceResourcePid()));\n+\t\treturn (T) resourceDao.readByPid(new ResourcePersistentId(theMdmLink.getGoldenResourcePid()));\n \t}\n \n \tprotected Patient addExternalEID(Patient thePatient, String theEID) {\n-\t\tthePatient.addIdentifier().setSystem(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()).setValue(theEID);\n+\t\tthePatient.addIdentifier().setSystem(myMdmSettings.getMdmRules().getEnterpriseEIDSystem()).setValue(theEID);\n \t\treturn thePatient;\n \t}\n \n \tprotected Patient clearExternalEIDs(Patient thePatient) {\n-\t\tthePatient.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\tthePatient.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myMdmSettings.getMdmRules().getEnterpriseEIDSystem()));\n \t\treturn thePatient;\n \t}\n \n \tprotected Patient createPatientAndUpdateLinks(Patient thePatient) {\n \t\tthePatient = createPatient(thePatient);\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(thePatient, createContextForCreate(\"Patient\"));\n+\t\tmyMdmMatchLinkSvc.updateMdmLinksForMdmTarget(thePatient, createContextForCreate(\"Patient\"));\n \t\treturn thePatient;\n \t}\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NjIzMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525386232", "body": "Rename S/R -> Golden?", "bodyText": "Rename S/R -> Golden?", "bodyHTML": "<p dir=\"auto\">Rename S/R -&gt; Golden?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:21:28Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BaseSourceResourceMatcher.java", "diffHunk": "@@ -16,40 +18,41 @@\n import java.util.List;\n import java.util.stream.Collectors;\n \n-public abstract class BasePersonMatcher extends TypeSafeMatcher<IAnyResource> {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(BasePersonMatcher.class);\n+public abstract class BaseSourceResourceMatcher extends TypeSafeMatcher<IAnyResource> {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NjQ5MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525386491", "body": "S/R to Golden?", "bodyText": "S/R to Golden?", "bodyHTML": "<p dir=\"auto\">S/R to Golden?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:21:52Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java", "diffHunk": "@@ -14,7 +14,7 @@\n  * is linked to a set of patients/practitioners via a person.\n  *\n  */\n-public class IsLinkedTo extends BasePersonMatcher {\n+public class IsLinkedTo extends BaseSourceResourceMatcher {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/matcher/IsLinkedTo.java\nsimilarity index 73%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/matcher/IsLinkedTo.java\nindex 6d6097a5d8..f06713f06d 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/matcher/IsLinkedTo.java\n", "chunk": "@@ -19,8 +19,8 @@ public class IsLinkedTo extends BaseSourceResourceMatcher {\n \tprivate List<Long> baseResourcePersonPids;\n \tprivate Long incomingResourcePersonPid;\n \n-\tprotected IsLinkedTo(IdHelperService theIdHelperService, EmpiLinkDaoSvc theEmpiLinkDaoSvc, IAnyResource... theBaseResource) {\n-\t\tsuper(theIdHelperService, theEmpiLinkDaoSvc, theBaseResource);\n+\tprotected IsLinkedTo(IdHelperService theIdHelperService, MdmLinkDaoSvc theMdmLinkDaoSvc, IAnyResource... theBaseResource) {\n+\t\tsuper(theIdHelperService, theMdmLinkDaoSvc, theBaseResource);\n \t}\n \n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4Njc0Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525386743", "body": "S/R to Golden?", "bodyText": "S/R to Golden?", "bodyHTML": "<p dir=\"auto\">S/R to Golden?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:22:14Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsSameSourceResourceAs.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package ca.uhn.fhir.jpa.empi.matcher;\n+\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class IsSameSourceResourceAs extends BaseSourceResourceMatcher {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzE1OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525387159", "body": "S/R to Golden?", "bodyText": "S/R to Golden?", "bodyHTML": "<p dir=\"auto\">S/R to Golden?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:22:53Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java", "diffHunk": "@@ -29,16 +32,16 @@\n public class EmpiProviderClearLinkR4Test extends BaseLinkR4Test {\n \tprotected Practitioner myPractitioner;\n \tprotected StringType myPractitionerId;\n-\tprotected Person myPractitionerPerson;\n-\tprotected StringType myPractitionerPersonId;\n+\tprotected IAnyResource myPractitionerSourceResource;", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nsimilarity index 83%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nindex e3e279928d..7bae41b46f 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\n", "chunk": "@@ -29,7 +29,7 @@ import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.junit.jupiter.api.Assertions.fail;\n \n-public class EmpiProviderClearLinkR4Test extends BaseLinkR4Test {\n+public class MdmProviderClearLinkR4Test extends BaseLinkR4Test {\n \tprotected Practitioner myPractitioner;\n \tprotected StringType myPractitionerId;\n \tprotected IAnyResource myPractitionerSourceResource;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzQ5Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525387497", "body": "can be removed", "bodyText": "can be removed", "bodyHTML": "<p dir=\"auto\">can be removed</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:23:27Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java", "diffHunk": "@@ -124,29 +135,31 @@ public void testPersonsWithCircularReferenceCanBeCleared() {\n \n \t\t//SUT\n \t\tParameters parameters = myEmpiProviderR4.clearEmpiLinks(null, myRequestDetails);\n+\n+\t\tprintLinks();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nsimilarity index 83%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nindex e3e279928d..7bae41b46f 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\n", "chunk": "@@ -134,7 +134,7 @@ public class EmpiProviderClearLinkR4Test extends BaseLinkR4Test {\n \t\tlinkPersons(personFromTarget2, personFromTarget);\n \n \t\t//SUT\n-\t\tParameters parameters = myEmpiProviderR4.clearEmpiLinks(null, myRequestDetails);\n+\t\tParameters parameters = myMdmProviderR4.clearMdmLinks(null, myRequestDetails);\n \n \t\tprintLinks();\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzgxMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525387813", "body": "clean up comments", "bodyText": "clean up comments", "bodyHTML": "<p dir=\"auto\">clean up comments</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:23:59Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java", "diffHunk": "@@ -3,132 +3,164 @@\n import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n+import ca.uhn.fhir.empi.util.EmpiUtil;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n-import org.hl7.fhir.r4.model.Person;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Identifier;\n+import org.hl7.fhir.r4.model.Patient;\n import org.hl7.fhir.r4.model.StringType;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n import java.util.List;\n+import java.util.Optional;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.endsWith;\n-import static org.hamcrest.Matchers.hasSize;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertTrue;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\n \n public class EmpiProviderMergePersonsR4Test extends BaseProviderR4Test {\n \n-\tprivate Person myFromPerson;\n-\tprivate StringType myFromPersonId;\n-\tprivate Person myToPerson;\n-\tprivate StringType myToPersonId;\n+\tprivate Patient myFromSourcePatient;\n+\tprivate StringType myFromSourcePatientId;\n+\tprivate Patient myToSourcePatient;\n+\tprivate StringType myToSourcePatientId;\n \n \t@Override\n \t@BeforeEach\n \tpublic void before() {\n \t\tsuper.before();\n \t\tsuper.loadEmpiSearchParameters();\n \n-\t\tmyFromPerson = createPerson();\n-\t\tmyFromPersonId = new StringType(myFromPerson.getIdElement().getValue());\n-\t\tmyToPerson = createPerson();\n-\t\tmyToPersonId = new StringType(myToPerson.getIdElement().getValue());\n+\t\tmyFromSourcePatient = createGoldenPatient();\n+\t\tmyFromSourcePatientId = new StringType(myFromSourcePatient.getIdElement().getValue());\n+\t\tmyToSourcePatient = createGoldenPatient();\n+\t\tmyToSourcePatientId = new StringType(myToSourcePatient.getIdElement().getValue());\n \t}\n \n \t@Test\n \tpublic void testMerge() {\n-\t\tPerson mergedPerson = myEmpiProviderR4.mergePersons(myFromPersonId, myToPersonId, myRequestDetails);\n-\t\tassertEquals(myToPerson.getIdElement(), mergedPerson.getIdElement());\n-\t\tassertThat(mergedPerson, is(samePersonAs(myToPerson)));\n-\t\tassertEquals(2, getAllPersons().size());\n-\t\tassertEquals(1, getAllActivePersons().size());\n-\n-\t\tPerson fromPerson = myPersonDao.read(myFromPerson.getIdElement().toUnqualifiedVersionless());\n-\t\tassertThat(fromPerson.getActive(), is(false));\n-\t\tList<Person.PersonLinkComponent> links = fromPerson.getLink();\n+\t\tPatient mergedSourcePatient = (Patient) myEmpiProviderR4.mergeGoldenResources(myFromSourcePatientId,\n+\t\t\tmyToSourcePatientId, myRequestDetails);\n+\n+\t\tassertTrue(EmpiUtil.isGoldenRecord(myFromSourcePatient));\n+\t\tassertEquals(myToSourcePatient.getIdElement(), mergedSourcePatient.getIdElement());\n+\t\tassertThat(mergedSourcePatient, is(sameSourceResourceAs(myToSourcePatient)));\n+\t\tassertEquals(1, getAllRedirectedGoldenPatients().size());\n+\t\tassertEquals(1, getAllGoldenPatients().size());\n+\n+\t\tPatient fromSourcePatient = myPatientDao.read(myFromSourcePatient.getIdElement().toUnqualifiedVersionless());\n+\t\tassertThat(fromSourcePatient.getActive(), is(false));\n+\t\tassertTrue(EmpiUtil.isGoldenRecordRedirected(fromSourcePatient));\n+\n+\t\t//TODO GGG eventually this will need to check a redirect... this is a hack which doesnt work\n+\t\t// Optional<Identifier> redirect = fromSourcePatient.getIdentifier().stream().filter(theIdentifier -> theIdentifier.getSystem().equals(\"REDIRECT\")).findFirst();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderMergePersonsR4Test.java\nsimilarity index 75%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderMergePersonsR4Test.java\nindex bb9b92217c..97aee62637 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderMergePersonsR4Test.java\n", "chunk": "@@ -56,20 +51,20 @@ public class EmpiProviderMergePersonsR4Test extends BaseProviderR4Test {\n \n \t\tPatient fromSourcePatient = myPatientDao.read(myFromSourcePatient.getIdElement().toUnqualifiedVersionless());\n \t\tassertThat(fromSourcePatient.getActive(), is(false));\n-\t\tassertTrue(EmpiUtil.isGoldenRecordRedirected(fromSourcePatient));\n+\t\tassertTrue(MdmUtil.isGoldenRecordRedirected(fromSourcePatient));\n \n \t\t//TODO GGG eventually this will need to check a redirect... this is a hack which doesnt work\n \t\t// Optional<Identifier> redirect = fromSourcePatient.getIdentifier().stream().filter(theIdentifier -> theIdentifier.getSystem().equals(\"REDIRECT\")).findFirst();\n \t\t// assertThat(redirect.get().getValue(), is(equalTo(myToSourcePatient.getIdElement().toUnqualified().getValue())));\n \n-\t\tList<EmpiLink> links = myEmpiLinkDaoSvc.findEmpiLinksByTarget(myFromSourcePatient);\n+\t\tList<MdmLink> links = myMdmLinkDaoSvc.findMdmLinksByTarget(myFromSourcePatient);\n \t\tassertThat(links, hasSize(1));\n \n-\t\tEmpiLink link = links.get(0);\n+\t\tMdmLink link = links.get(0);\n \t\tassertEquals(link.getTargetPid(), myFromSourcePatient.getIdElement().toUnqualifiedVersionless().getIdPartAsLong());\n-\t\tassertEquals(link.getSourceResourcePid(), myToSourcePatient.getIdElement().toUnqualifiedVersionless().getIdPartAsLong());\n-\t\tassertEquals(link.getMatchResult(), EmpiMatchResultEnum.REDIRECT);\n-\t\tassertEquals(link.getLinkSource(), EmpiLinkSourceEnum.MANUAL);\n+\t\tassertEquals(link.getGoldenResourcePid(), myToSourcePatient.getIdElement().toUnqualifiedVersionless().getIdPartAsLong());\n+\t\tassertEquals(link.getMatchResult(), MdmMatchResultEnum.REDIRECT);\n+\t\tassertEquals(link.getLinkSource(), MdmLinkSourceEnum.MANUAL);\n \t\t// assertThat(links.get(0).getAssurance(), is (AssuranceLevelUtil.getAssuranceLevel(EmpiMatchResultEnum.REDIRECT, EmpiLinkSourceEnum.MANUAL).toR4()));\n \t\t//List<Person.PersonLinkComponent> links = fromSourcePatient.getLink();\n \t\t//assertThat(links, hasSize(1));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4ODU2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525388565", "body": "rename S/R to Golden", "bodyText": "rename S/R to Golden", "bodyHTML": "<p dir=\"auto\">rename S/R to Golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:25:07Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java", "diffHunk": "@@ -49,91 +50,114 @@ public void testUpdateLinkMatch() {\n \n \t@Test\n \tpublic void testUpdateLinkTwiceFailsDueToWrongVersion() {\n-\t\tmyEmpiProviderR4.updateLink(myPersonId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\n+\t\tmateriallyChangeGoldenPatient();\n+\n \t\ttry {\n-\t\t\tmyEmpiProviderR4.updateLink(myPersonId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n+\t\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderUpdateLinkR4Test.java\nsimilarity index 57%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderUpdateLinkR4Test.java\nindex 51181bd3b3..d321438186 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderUpdateLinkR4Test.java\n", "chunk": "@@ -26,36 +26,36 @@ public class EmpiProviderUpdateLinkR4Test extends BaseLinkR4Test {\n \t@Test\n \tpublic void testUpdateLinkNoMatch() {\n \t\tassertLinkCount(1);\n-\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n+\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n \t\tassertLinkCount(2);\n \n-\t\tList<EmpiLink> links = getPatientLinks();\n-\t\tassertEquals(EmpiLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n-\t\tassertEquals(EmpiMatchResultEnum.NO_MATCH, links.get(0).getMatchResult());\n-\t\tassertEquals(EmpiLinkSourceEnum.AUTO, links.get(1).getLinkSource());\n-\t\tassertEquals(EmpiMatchResultEnum.MATCH, links.get(1).getMatchResult());\n-\t\tassertNotEquals(links.get(0).getSourceResourcePid(), links.get(1).getSourceResourcePid());\n+\t\tList<MdmLink> links = getPatientLinks();\n+\t\tassertEquals(MdmLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n+\t\tassertEquals(MdmMatchResultEnum.NO_MATCH, links.get(0).getMatchResult());\n+\t\tassertEquals(MdmLinkSourceEnum.AUTO, links.get(1).getLinkSource());\n+\t\tassertEquals(MdmMatchResultEnum.MATCH, links.get(1).getMatchResult());\n+\t\tassertNotEquals(links.get(0).getGoldenResourcePid(), links.get(1).getGoldenResourcePid());\n \t}\n \n \t@Test\n \tpublic void testUpdateLinkMatch() {\n \t\tassertLinkCount(1);\n-\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n \t\tassertLinkCount(1);\n \n-\t\tList<EmpiLink> links = getPatientLinks();\n-\t\tassertEquals(EmpiLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n-\t\tassertEquals(EmpiMatchResultEnum.MATCH, links.get(0).getMatchResult());\n+\t\tList<MdmLink> links = getPatientLinks();\n+\t\tassertEquals(MdmLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n+\t\tassertEquals(MdmMatchResultEnum.MATCH, links.get(0).getMatchResult());\n \t}\n \n \t@Test\n \tpublic void testUpdateLinkTwiceFailsDueToWrongVersion() {\n-\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n \n \t\tmateriallyChangeGoldenPatient();\n \n \t\ttry {\n-\t\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n+\t\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n \t\t\tfail();\n \t\t} catch (ResourceVersionConflictException e) {\n \t\t\tassertThat(e.getMessage(), matchesPattern(\"Requested resource Patient/\\\\d+/_history/1 is not the latest version.  Latest version is Patient/\\\\d+/_history/2\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5MDUyMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525390523", "body": "clean up comments", "bodyText": "clean up comments", "bodyHTML": "<p dir=\"auto\">clean up comments</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:27:53Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java", "diffHunk": "@@ -47,76 +53,78 @@ public void compareEmptyPatients() {\n \t@Test\n \tpublic void testCreateRemoveLink() {\n \t\tassertLinkCount(0);\n-\t\tPerson person = createPerson();\n-\t\tIdType personId = person.getIdElement().toUnqualifiedVersionless();\n-\t\tassertEquals(0, person.getLink().size());\n+\t\tPatient goldenPatient = createGoldenPatient();\n+\t\tIdType sourcePatientId = goldenPatient.getIdElement().toUnqualifiedVersionless();\n+\t\t// TODO NG should be ok to remove - assertEquals(0, goldenPatient.getLink().size());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\nsimilarity index 53%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\nindex c57faa9d0f..6ed6c29a86 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\n", "chunk": "@@ -46,8 +42,8 @@ public class EmpiLinkSvcTest extends BaseEmpiR4Test {\n \tpublic void compareEmptyPatients() {\n \t\tPatient patient = new Patient();\n \t\tpatient.setId(\"Patient/1\");\n-\t\tEmpiMatchResultEnum result = myEmpiResourceMatcherSvc.getMatchResult(patient, patient).getMatchResultEnum();\n-\t\tassertEquals(EmpiMatchResultEnum.NO_MATCH, result);\n+\t\tMdmMatchResultEnum result = myMdmResourceMatcherSvc.getMatchResult(patient, patient).getMatchResultEnum();\n+\t\tassertEquals(MdmMatchResultEnum.NO_MATCH, result);\n \t}\n \n \t@Test\n", "next_change": null}, {"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\nsimilarity index 53%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java\nrename to hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\nindex c57faa9d0f..6ed6c29a86 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\n", "chunk": "@@ -59,7 +55,7 @@ public class EmpiLinkSvcTest extends BaseEmpiR4Test {\n \t\tPatient patient = createPatient();\n \n \t\t{\n-\t\t\tmyEmpiLinkSvc.updateLink(goldenPatient, patient, POSSIBLE_MATCH, EmpiLinkSourceEnum.AUTO, createContextForCreate(\"Patient\"));\n+\t\t\tmyMdmLinkSvc.updateLink(goldenPatient, patient, POSSIBLE_MATCH, MdmLinkSourceEnum.AUTO, createContextForCreate(\"Patient\"));\n \t\t\tassertLinkCount(1);\n \t\t\t// TODO NG should be ok to remove\n \t\t\t// Patient newSourcePatient = myPatientDao.read(sourcePatientId);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5MjE2Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525392162", "body": "S/R to Golden", "bodyText": "S/R to Golden", "bodyHTML": "<p dir=\"auto\">S/R to Golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T18:30:32Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java", "diffHunk": "@@ -87,54 +110,54 @@ public void testAddPatientLinksToExistingPersonIfMatch() {\n \t\tPatient patient2 = createPatientAndUpdateLinks(buildJanePatient());\n \t\tassertLinkCount(2);\n \n-\t\tassertThat(patient1, is(samePersonAs(patient2)));\n+\t\tassertThat(patient1, is(sameSourceResourceAs(patient2)));", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\nindex c43bc7faef..948b5c86ae 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\n+++ b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\n", "chunk": "@@ -110,54 +87,54 @@ public class EmpiMatchLinkSvcTest extends BaseEmpiR4Test {\n \t\tPatient patient2 = createPatientAndUpdateLinks(buildJanePatient());\n \t\tassertLinkCount(2);\n \n-\t\tassertThat(patient1, is(sameSourceResourceAs(patient2)));\n+\t\tassertThat(patient1, is(samePersonAs(patient2)));\n \t\tassertLinksMatchResult(MATCH, MATCH);\n-\t\tassertLinksCreatedNewResource(true, false);\n+\t\tassertLinksNewPerson(true, false);\n \t\tassertLinksMatchedByEid(false, false);\n \t}\n \n \t@Test\n \tpublic void testWhenMatchOccursOnPersonThatHasBeenManuallyNOMATCHedThatItIsBlocked() {\n \t\tPatient originalJane = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tIAnyResource janePerson = getGoldenResourceFromTargetResource(originalJane);\n+\t\tIBundleProvider search = myPersonDao.search(new SearchParameterMap());\n+\t\tIAnyResource janePerson = (IAnyResource) search.getResources(0, 1).get(0);\n \n \t\t//Create a manual NO_MATCH between janePerson and unmatchedJane.\n \t\tPatient unmatchedJane = createPatient(buildJanePatient());\n-\t\tmyEmpiLinkSvc.updateLink(janePerson, unmatchedJane, EmpiMatchOutcome.NO_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate(\"Patient\"));\n+\t\tmyEmpiLinkSvc.updateLink(janePerson, unmatchedJane, EmpiMatchOutcome.NO_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate());\n \n \t\t//rerun EMPI rules against unmatchedJane.\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(unmatchedJane, createContextForCreate(\"Patient\"));\n+\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(unmatchedJane, createContextForCreate());\n \n-\t\tassertThat(unmatchedJane, is(not(sameSourceResourceAs(janePerson))));\n+\t\tassertThat(unmatchedJane, is(not(samePersonAs(janePerson))));\n \t\tassertThat(unmatchedJane, is(not(linkedTo(originalJane))));\n \n \t\tassertLinksMatchResult(MATCH, NO_MATCH, MATCH);\n-\t\tassertLinksCreatedNewResource(true, false, true);\n+\t\tassertLinksNewPerson(true, false, true);\n \t\tassertLinksMatchedByEid(false, false, false);\n \t}\n \n \t@Test\n \tpublic void testWhenPOSSIBLE_MATCHOccursOnPersonThatHasBeenManuallyNOMATCHedThatItIsBlocked() {\n \t\tPatient originalJane = createPatientAndUpdateLinks(buildJanePatient());\n-\n-\t\tIBundleProvider search = myPatientDao.search(buildGoldenRecordSearchParameterMap());\n+\t\tIBundleProvider search = myPersonDao.search(new SearchParameterMap());\n \t\tIAnyResource janePerson = (IAnyResource) search.getResources(0, 1).get(0);\n \n \t\tPatient unmatchedPatient = createPatient(buildJanePatient());\n \n-\t\t// This simulates an admin specifically saying that unmatchedPatient does NOT match janePerson.\n-\t\tmyEmpiLinkSvc.updateLink(janePerson, unmatchedPatient, EmpiMatchOutcome.NO_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate(\"Patient\"));\n-\t\t// TODO change this so that it will only partially match.\n+\t\t//This simulates an admin specifically saying that unmatchedPatient does NOT match janePerson.\n+\t\tmyEmpiLinkSvc.updateLink(janePerson, unmatchedPatient, EmpiMatchOutcome.NO_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate());\n+\t\t//TODO change this so that it will only partially match.\n \n \t\t//Now normally, when we run update links, it should link to janePerson. However, this manual NO_MATCH link\n \t\t//should cause a whole new Person to be created.\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(unmatchedPatient, createContextForCreate(\"Patient\"));\n+\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(unmatchedPatient, createContextForCreate());\n \n-\t\tassertThat(unmatchedPatient, is(not(sameSourceResourceAs(janePerson))));\n+\t\tassertThat(unmatchedPatient, is(not(samePersonAs(janePerson))));\n \t\tassertThat(unmatchedPatient, is(not(linkedTo(originalJane))));\n \n \t\tassertLinksMatchResult(MATCH, NO_MATCH, MATCH);\n-\t\tassertLinksCreatedNewResource(true, false, true);\n+\t\tassertLinksNewPerson(true, false, true);\n \t\tassertLinksMatchedByEid(false, false, false);\n \t}\n \n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\ndeleted file mode 100644\nindex 948b5c86ae..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\n+++ /dev/null\n", "chunk": "@@ -1,588 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.empi.BaseEmpiR4Test;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n-import ca.uhn.fhir.rest.api.server.IBundleProvider;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.r4.model.Enumerations;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static ca.uhn.fhir.empi.api.EmpiMatchResultEnum.MATCH;\n-import static ca.uhn.fhir.empi.api.EmpiMatchResultEnum.NO_MATCH;\n-import static ca.uhn.fhir.empi.api.EmpiMatchResultEnum.POSSIBLE_DUPLICATE;\n-import static ca.uhn.fhir.empi.api.EmpiMatchResultEnum.POSSIBLE_MATCH;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.blankOrNullString;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.equalToIgnoringCase;\n-import static org.hamcrest.Matchers.hasSize;\n-import static org.hamcrest.Matchers.in;\n-import static org.hamcrest.Matchers.is;\n-import static org.hamcrest.Matchers.not;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.slf4j.LoggerFactory.getLogger;\n-\n-public class EmpiMatchLinkSvcTest extends BaseEmpiR4Test {\n-\tprivate static final Logger ourLog = getLogger(EmpiMatchLinkSvcTest.class);\n-\t@Autowired\n-\tIEmpiLinkSvc myEmpiLinkSvc;\n-\t@Autowired\n-\tprivate EIDHelper myEidHelper;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\n-\t@BeforeEach\n-\tpublic void before() {\n-\t\tsuper.loadEmpiSearchParameters();\n-\t}\n-\n-\t@Test\n-\tpublic void testAddPatientLinksToNewPersonIfNoneFound() {\n-\t\tcreatePatientAndUpdateLinks(buildJanePatient());\n-\t\tassertLinkCount(1);\n-\t\tassertLinksMatchResult(MATCH);\n-\t\tassertLinksNewPerson(true);\n-\t\tassertLinksMatchedByEid(false);\n-\t}\n-\n-\t@Test\n-\tpublic void testAddPatientLinksToNewPersonIfNoMatch() {\n-\t\tPatient patient1 = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPatient patient2 = createPatientAndUpdateLinks(buildPaulPatient());\n-\n-\t\tassertLinkCount(2);\n-\t\tassertThat(patient1, is(not(samePersonAs(patient2))));\n-\t\tassertLinksMatchResult(MATCH, MATCH);\n-\t\tassertLinksNewPerson(true, true);\n-\t\tassertLinksMatchedByEid(false, false);\n-\t}\n-\n-\t@Test\n-\tpublic void testAddPatientLinksToExistingPersonIfMatch() {\n-\t\tPatient patient1 = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tassertLinkCount(1);\n-\n-\t\tPatient patient2 = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tassertLinkCount(2);\n-\n-\t\tassertThat(patient1, is(samePersonAs(patient2)));\n-\t\tassertLinksMatchResult(MATCH, MATCH);\n-\t\tassertLinksNewPerson(true, false);\n-\t\tassertLinksMatchedByEid(false, false);\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenMatchOccursOnPersonThatHasBeenManuallyNOMATCHedThatItIsBlocked() {\n-\t\tPatient originalJane = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tIBundleProvider search = myPersonDao.search(new SearchParameterMap());\n-\t\tIAnyResource janePerson = (IAnyResource) search.getResources(0, 1).get(0);\n-\n-\t\t//Create a manual NO_MATCH between janePerson and unmatchedJane.\n-\t\tPatient unmatchedJane = createPatient(buildJanePatient());\n-\t\tmyEmpiLinkSvc.updateLink(janePerson, unmatchedJane, EmpiMatchOutcome.NO_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate());\n-\n-\t\t//rerun EMPI rules against unmatchedJane.\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(unmatchedJane, createContextForCreate());\n-\n-\t\tassertThat(unmatchedJane, is(not(samePersonAs(janePerson))));\n-\t\tassertThat(unmatchedJane, is(not(linkedTo(originalJane))));\n-\n-\t\tassertLinksMatchResult(MATCH, NO_MATCH, MATCH);\n-\t\tassertLinksNewPerson(true, false, true);\n-\t\tassertLinksMatchedByEid(false, false, false);\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenPOSSIBLE_MATCHOccursOnPersonThatHasBeenManuallyNOMATCHedThatItIsBlocked() {\n-\t\tPatient originalJane = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tIBundleProvider search = myPersonDao.search(new SearchParameterMap());\n-\t\tIAnyResource janePerson = (IAnyResource) search.getResources(0, 1).get(0);\n-\n-\t\tPatient unmatchedPatient = createPatient(buildJanePatient());\n-\n-\t\t//This simulates an admin specifically saying that unmatchedPatient does NOT match janePerson.\n-\t\tmyEmpiLinkSvc.updateLink(janePerson, unmatchedPatient, EmpiMatchOutcome.NO_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate());\n-\t\t//TODO change this so that it will only partially match.\n-\n-\t\t//Now normally, when we run update links, it should link to janePerson. However, this manual NO_MATCH link\n-\t\t//should cause a whole new Person to be created.\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(unmatchedPatient, createContextForCreate());\n-\n-\t\tassertThat(unmatchedPatient, is(not(samePersonAs(janePerson))));\n-\t\tassertThat(unmatchedPatient, is(not(linkedTo(originalJane))));\n-\n-\t\tassertLinksMatchResult(MATCH, NO_MATCH, MATCH);\n-\t\tassertLinksNewPerson(true, false, true);\n-\t\tassertLinksMatchedByEid(false, false, false);\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenPatientIsCreatedWithEIDThatItPropagatesToNewPerson() {\n-\t\tString sampleEID = \"sample-eid\";\n-\t\tPatient janePatient = addExternalEID(buildJanePatient(), sampleEID);\n-\t\tjanePatient = createPatientAndUpdateLinks(janePatient);\n-\n-\t\tOptional<EmpiLink> empiLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(janePatient.getIdElement().getIdPartAsLong());\n-\t\tassertThat(empiLink.isPresent(), is(true));\n-\n-\t\tPerson person = getPersonFromEmpiLink(empiLink.get());\n-\t\tList<CanonicalEID> externalEid = myEidHelper.getExternalEid(person);\n-\n-\t\tassertThat(externalEid.get(0).getSystem(), is(equalTo(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem())));\n-\t\tassertThat(externalEid.get(0).getValue(), is(equalTo(sampleEID)));\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenPatientIsCreatedWithoutAnEIDThePersonGetsAutomaticallyAssignedOne() {\n-\t\tPatient patient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tEmpiLink empiLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(patient.getIdElement().getIdPartAsLong()).get();\n-\n-\t\tPerson person = getPersonFromEmpiLink(empiLink);\n-\t\tIdentifier identifierFirstRep = person.getIdentifierFirstRep();\n-\t\tassertThat(identifierFirstRep.getSystem(), is(equalTo(EmpiConstants.HAPI_ENTERPRISE_IDENTIFIER_SYSTEM)));\n-\t\tassertThat(identifierFirstRep.getValue(), not(blankOrNullString()));\n-\t}\n-\n-\t@Test\n-\tpublic void testPatientAttributesAreCopiedOverWhenPersonIsCreatedFromPatient() {\n-\t\tPatient patient = createPatientAndUpdateLinks(buildPatientWithNameIdAndBirthday(\"Gary\", \"GARY_ID\", new Date()));\n-\n-\t\tOptional<EmpiLink> empiLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(patient.getIdElement().getIdPartAsLong());\n-\t\tPerson read = getPersonFromEmpiLink(empiLink.get());\n-\n-\t\tassertThat(read.getNameFirstRep().getFamily(), is(equalTo(patient.getNameFirstRep().getFamily())));\n-\t\tassertThat(read.getNameFirstRep().getGivenAsSingleString(), is(equalTo(patient.getNameFirstRep().getGivenAsSingleString())));\n-\t\tassertThat(read.getBirthDateElement().toHumanDisplay(), is(equalTo(patient.getBirthDateElement().toHumanDisplay())));\n-\t\tassertThat(read.getTelecomFirstRep().getValue(), is(equalTo(patient.getTelecomFirstRep().getValue())));\n-\t\tassertThat(read.getPhoto().getData(), is(equalTo(patient.getPhotoFirstRep().getData())));\n-\t\tassertThat(read.getGender(), is(equalTo(patient.getGender())));\n-\t}\n-\n-\t@Test\n-\tpublic void testPatientMatchingAnotherPatientLinksToSamePerson() {\n-\t\tPatient janePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPatient sameJanePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tassertThat(janePatient, is(samePersonAs(sameJanePatient)));\n-\t}\n-\n-\t@Test\n-\tpublic void testIncomingPatientWithEIDThatMatchesPersonWithHapiEidAddsExternalEidToPerson() {\n-\t\t// Existing Person with system-assigned EID found linked from matched Patient.  incoming Patient has EID.  Replace Person system-assigned EID with Patient EID.\n-\t\tPatient patient = createPatientAndUpdateLinks(buildJanePatient());\n-\n-\t\tPerson janePerson = getPersonFromTarget(patient);\n-\t\tList<CanonicalEID> hapiEid = myEidHelper.getHapiEid(janePerson);\n-\t\tString foundHapiEid = hapiEid.get(0).getValue();\n-\n-\t\tPatient janePatient = addExternalEID(buildJanePatient(), \"12345\");\n-\t\tcreatePatientAndUpdateLinks(janePatient);\n-\n-\t\t//We want to make sure the patients were linked to the same person.\n-\t\tassertThat(patient, is(samePersonAs(janePatient)));\n-\n-\t\tPerson person = getPersonFromTarget(patient);\n-\n-\t\tList<Identifier> identifier = person.getIdentifier();\n-\n-\t\t//The collision should have kept the old identifier\n-\t\tIdentifier firstIdentifier = identifier.get(0);\n-\t\tassertThat(firstIdentifier.getSystem(), is(equalTo(EmpiConstants.HAPI_ENTERPRISE_IDENTIFIER_SYSTEM)));\n-\t\tassertThat(firstIdentifier.getValue(), is(equalTo(foundHapiEid)));\n-\n-\t\t//The collision should have added a new identifier with the external system.\n-\t\tIdentifier secondIdentifier = identifier.get(1);\n-\t\tassertThat(secondIdentifier.getSystem(), is(equalTo(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem())));\n-\t\tassertThat(secondIdentifier.getValue(), is(equalTo(\"12345\")));\n-\t}\n-\n-\t@Test\n-\tpublic void testIncomingPatientWithEidMatchesAnotherPatientWithSameEIDAreLinked() {\n-\t\tPatient patient1 = addExternalEID(buildJanePatient(), \"uniqueid\");\n-\t\tcreatePatientAndUpdateLinks(patient1);\n-\n-\t\tPatient patient2 = addExternalEID(buildPaulPatient(), \"uniqueid\");\n-\t\tcreatePatientAndUpdateLinks(patient2);\n-\n-\t\tassertThat(patient1, is(samePersonAs(patient2)));\n-\t}\n-\n-\t@Test\n-\tpublic void testHavingMultipleEIDsOnIncomingPatientMatchesCorrectly() {\n-\n-\t\tPatient patient1 = buildJanePatient();\n-\t\taddExternalEID(patient1, \"id_1\");\n-\t\taddExternalEID(patient1, \"id_2\");\n-\t\taddExternalEID(patient1, \"id_3\");\n-\t\taddExternalEID(patient1, \"id_4\");\n-\t\tcreatePatientAndUpdateLinks(patient1);\n-\n-\t\tPatient patient2 = buildPaulPatient();\n-\t\taddExternalEID(patient2, \"id_5\");\n-\t\taddExternalEID(patient2, \"id_1\");\n-\t\tcreatePatientAndUpdateLinks(patient2);\n-\n-\t\tassertThat(patient1, is(samePersonAs(patient2)));\n-\t}\n-\n-\t@Test\n-\tpublic void testDuplicatePersonLinkIsCreatedWhenAnIncomingPatientArrivesWithEIDThatMatchesAnotherEIDPatient() {\n-\n-\t\tPatient patient1 = addExternalEID(buildJanePatient(), \"eid-1\");\n-\t\tpatient1 = createPatientAndUpdateLinks(patient1);\n-\n-\t\tPatient patient2 = addExternalEID(buildJanePatient(), \"eid-2\");\n-\t\tpatient2 = createPatientAndUpdateLinks(patient2);\n-\n-\t\tList<EmpiLink> possibleDuplicates = myEmpiLinkDaoSvc.getPossibleDuplicates();\n-\t\tassertThat(possibleDuplicates, hasSize(1));\n-\n-\n-\t\tList<Long> duplicatePids = Stream.of(patient1, patient2)\n-\t\t\t.map(this::getPersonFromTarget)\n-\t\t\t.map(myIdHelperService::getPidOrNull)\n-\t\t\t.collect(Collectors.toList());\n-\n-\t\t//The two Persons related to the patients should both show up in the only existing POSSIBLE_DUPLICATE EmpiLink.\n-\t\tEmpiLink empiLink = possibleDuplicates.get(0);\n-\t\tassertThat(empiLink.getPersonPid(), is(in(duplicatePids)));\n-\t\tassertThat(empiLink.getTargetPid(), is(in(duplicatePids)));\n-\t}\n-\n-\t@Test\n-\tpublic void testPatientWithNoEmpiTagIsNotMatched() {\n-\t\t// Patient with \"no-empi\" tag is not matched\n-\t\tPatient janePatient = buildJanePatient();\n-\t\tjanePatient.getMeta().addTag(EmpiConstants.SYSTEM_EMPI_MANAGED, EmpiConstants.CODE_NO_EMPI_MANAGED, \"Don't EMPI on me!\");\n-\t\tcreatePatientAndUpdateLinks(janePatient);\n-\t\tassertLinkCount(0);\n-\t}\n-\n-\t@Test\n-\tpublic void testPractitionersDoNotMatchToPatients() {\n-\t\tPatient janePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPractitioner janePractitioner = createPractitionerAndUpdateLinks(buildJanePractitioner());\n-\n-\t\tassertLinkCount(2);\n-\t\tassertThat(janePatient, is(not(samePersonAs(janePractitioner))));\n-\t}\n-\n-\t@Test\n-\tpublic void testPractitionersThatMatchShouldLink() {\n-\t\tPractitioner janePractitioner = createPractitionerAndUpdateLinks(buildJanePractitioner());\n-\t\tPractitioner anotherJanePractitioner = createPractitionerAndUpdateLinks(buildJanePractitioner());\n-\n-\t\tassertLinkCount(2);\n-\t\tassertThat(anotherJanePractitioner, is(samePersonAs(janePractitioner)));\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenThereAreNoMATCHOrPOSSIBLE_MATCHOutcomesThatANewPersonIsCreated() {\n-\t\t/**\n-\t\t * CASE 1: No MATCHED and no PROBABLE_MATCHED outcomes -> a new Person resource\n-\t\t * is created and linked to that Pat/Prac.\n-\t\t */\n-\t\tassertLinkCount(0);\n-\t\tPatient janePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tassertLinkCount(1);\n-\t\tassertThat(janePatient, is(matchedToAPerson()));\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenAllMATCHResultsAreToSamePersonThatTheyAreLinked() {\n-\t\t/**\n-\t\t * CASE 2: All of the MATCHED Pat/Prac resources are already linked to the same Person ->\n-\t\t * a new Link is created between the new Pat/Prac and that Person and is set to MATCHED.\n-\t\t */\n-\t\tPatient janePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPatient janePatient2 = createPatientAndUpdateLinks(buildJanePatient());\n-\n-\t\tassertLinkCount(2);\n-\t\tassertThat(janePatient, is(samePersonAs(janePatient2)));\n-\n-\t\tPatient incomingJanePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tassertThat(incomingJanePatient, is(samePersonAs(janePatient, janePatient2)));\n-\t\tassertThat(incomingJanePatient, is(linkedTo(janePatient, janePatient2)));\n-\t}\n-\n-\t@Test\n-\tpublic void testMATCHResultWithMultipleCandidatesCreatesPOSSIBLE_DUPLICATELinksAndNoPersonIsCreated() {\n-\t\t/**\n-\t\t * CASE 3: The MATCHED Pat/Prac resources link to more than one Person -> Mark all links as POSSIBLE_MATCH.\n-\t\t * All other Person resources are marked as POSSIBLE_DUPLICATE of this first Person.\n-\t\t */\n-\t\tPatient janePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\n-\t\tPatient janePatient2 = createPatient(buildJanePatient());\n-\n-\t\t//In a normal situation, janePatient2 would just match to jane patient, but here we need to hack it so they are their\n-\t\t//own individual Persons for the purpose of this test.\n-\t\tIAnyResource person = myPersonHelper.createPersonFromEmpiTarget(janePatient2);\n-\t\tmyEmpiLinkSvc.updateLink(person, janePatient2, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, createContextForCreate());\n-\t\tassertThat(janePatient, is(not(samePersonAs(janePatient2))));\n-\n-\t\t//In theory, this will match both Persons!\n-\t\tPatient incomingJanePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\n-\t\t//There should now be a single POSSIBLE_DUPLICATE link with\n-\t\tassertThat(janePatient, is(possibleDuplicateOf(janePatient2)));\n-\n-\t\t//There should now be 2 POSSIBLE_MATCH links with this person.\n-\t\tassertThat(incomingJanePatient, is(possibleMatchWith(janePatient, janePatient2)));\n-\n-\t\t//Ensure there is no successful MATCH links for incomingJanePatient\n-\t\tOptional<EmpiLink> matchedLinkForTargetPid = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(incomingJanePatient));\n-\t\tassertThat(matchedLinkForTargetPid.isPresent(), is(false));\n-\n-\t\tlogAllLinks();\n-\t\tassertLinksMatchResult(MATCH, MATCH, POSSIBLE_MATCH, POSSIBLE_MATCH, POSSIBLE_DUPLICATE);\n-\t\tassertLinksNewPerson(true, true, false, false, false);\n-\t\tassertLinksMatchedByEid(false, false, false, false, false);\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenAllMatchResultsArePOSSIBLE_MATCHThattheyAreLinkedAndNoPersonIsCreated() {\n-\t\t/**\n-\t\t * CASE 4: Only POSSIBLE_MATCH outcomes -> In this case, empi-link records are created with POSSIBLE_MATCH\n-\t\t * outcome and await manual assignment to either NO_MATCH or MATCHED. Person link is added.\n-\t\t */\n-\t\tPatient patient = buildJanePatient();\n-\t\tpatient.getNameFirstRep().setFamily(\"familyone\");\n-\t\tpatient = createPatientAndUpdateLinks(patient);\n-\t\tassertThat(patient, is(samePersonAs(patient)));\n-\n-\t\tPatient patient2 = buildJanePatient();\n-\t\tpatient2.getNameFirstRep().setFamily(\"pleasedonotmatchatall\");\n-\t\tpatient2 = createPatientAndUpdateLinks(patient2);\n-\n-\t\tassertThat(patient2, is(possibleMatchWith(patient)));\n-\n-\t\tPatient patient3 = buildJanePatient();\n-\t\tpatient3.getNameFirstRep().setFamily(\"pleasedonotmatchatall\");\n-\t\tpatient3 = createPatientAndUpdateLinks(patient3);\n-\n-\t\tassertThat(patient3, is(possibleMatchWith(patient2)));\n-\t\tassertThat(patient3, is(possibleMatchWith(patient)));\n-\n-\t\tIBundleProvider bundle = myPersonDao.search(new SearchParameterMap());\n-\t\tassertEquals(1, bundle.size());\n-\t\tPerson person = (Person) bundle.getResources(0, 1).get(0);\n-\t\tassertEquals(Person.IdentityAssuranceLevel.LEVEL2, person.getLink().get(0).getAssurance());\n-\t\tassertEquals(Person.IdentityAssuranceLevel.LEVEL1, person.getLink().get(1).getAssurance());\n-\t\tassertEquals(Person.IdentityAssuranceLevel.LEVEL1, person.getLink().get(2).getAssurance());\n-\n-\t\tassertLinksMatchResult(MATCH, POSSIBLE_MATCH, POSSIBLE_MATCH);\n-\t\tassertLinksNewPerson(true, false, false);\n-\t\tassertLinksMatchedByEid(false, false, false);\n-\t}\n-\n-\t@Test\n-\tpublic void testWhenAnIncomingResourceHasMatchesAndPossibleMatchesThatItLinksToMatch() {\n-\t\tPatient patient = buildJanePatient();\n-\t\tpatient.getNameFirstRep().setFamily(\"familyone\");\n-\t\tpatient = createPatientAndUpdateLinks(patient);\n-\t\tassertThat(patient, is(samePersonAs(patient)));\n-\n-\t\tPatient patient2 = buildJanePatient();\n-\t\tpatient2.getNameFirstRep().setFamily(\"pleasedonotmatchatall\");\n-\t\tpatient2 = createPatientAndUpdateLinks(patient2);\n-\n-\t\tPatient patient3 = buildJanePatient();\n-\t\tpatient3.getNameFirstRep().setFamily(\"familyone\");\n-\t\tpatient3 = createPatientAndUpdateLinks(patient3);\n-\n-\t\tassertThat(patient2, is(not(samePersonAs(patient))));\n-\t\tassertThat(patient2, is(possibleMatchWith(patient)));\n-\t\tassertThat(patient3, is(samePersonAs(patient)));\n-\t}\n-\n-\t@Test\n-\tpublic void testAutoMatchesGenerateAssuranceLevel3() {\n-\t\tPatient patient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPerson janePerson = getPersonFromTarget(patient);\n-\t\tPerson.PersonLinkComponent linkFirstRep = janePerson.getLinkFirstRep();\n-\n-\t\tassertThat(linkFirstRep.getTarget().getReference(), is(equalTo(patient.getIdElement().toVersionless().toString())));\n-\t\tassertThat(linkFirstRep.getAssurance(), is(equalTo(Person.IdentityAssuranceLevel.LEVEL2)));\n-\t}\n-\n-\t@Test\n-\tpublic void testManualMatchesGenerateAssuranceLevel4() {\n-\t\tPatient patient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPerson janePerson = getPersonFromTarget(patient);\n-\t\tmyEmpiLinkSvc.updateLink(janePerson, patient, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.MANUAL, createContextForCreate());\n-\n-\t\tjanePerson = getPersonFromTarget(patient);\n-\t\tPerson.PersonLinkComponent linkFirstRep = janePerson.getLinkFirstRep();\n-\n-\t\tassertThat(linkFirstRep.getTarget().getReference(), is(equalTo(patient.getIdElement().toVersionless().toString())));\n-\t\tassertThat(linkFirstRep.getAssurance(), is(equalTo(Person.IdentityAssuranceLevel.LEVEL3)));\n-\t}\n-\n-\t//Case #1\n-\t@Test\n-\tpublic void testPatientUpdateOverwritesPersonDataOnChanges() {\n-\t\tPatient janePatient = createPatientAndUpdateLinks(buildJanePatient());\n-\t\tPerson janePerson = getPersonFromTarget(janePatient);\n-\n-\t\t//Change Jane's name to paul.\n-\t\tPatient patient1 = buildPaulPatient();\n-\t\tpatient1.setId(janePatient.getId());\n-\t\tPatient janePaulPatient = updatePatientAndUpdateLinks(patient1);\n-\n-\t\tassertThat(janePerson, is(samePersonAs(janePaulPatient)));\n-\n-\t\t//Ensure the related person was updated with new info.\n-\t\tPerson personFromTarget = getPersonFromTarget(janePaulPatient);\n-\t\tHumanName nameFirstRep = personFromTarget.getNameFirstRep();\n-\t\tassertThat(nameFirstRep.getGivenAsSingleString(), is(equalToIgnoringCase(\"paul\")));\n-\t}\n-\n-\t@Test\n-\tpublic void testPatientCreateDoesNotOverwritePersonAttributesThatAreInvolvedInLinking() {\n-\t\tPatient paul = buildPaulPatient();\n-\t\tpaul.setGender(Enumerations.AdministrativeGender.MALE);\n-\t\tpaul = createPatientAndUpdateLinks(paul);\n-\n-\t\tPerson personFromTarget = getPersonFromTarget(paul);\n-\t\tassertThat(personFromTarget.getGender(), is(equalTo(Enumerations.AdministrativeGender.MALE)));\n-\n-\t\tPatient paul2 = buildPaulPatient();\n-\t\tpaul2.setGender(Enumerations.AdministrativeGender.FEMALE);\n-\t\tpaul2 = createPatientAndUpdateLinks(paul2);\n-\n-\t\tassertThat(paul2, is(samePersonAs(paul)));\n-\n-\t\t//Newly matched patients aren't allowed to overwrite Person Attributes unless they are empty, so gender should still be set to male.\n-\t\tPerson paul2Person = getPersonFromTarget(paul2);\n-\t\tassertThat(paul2Person.getGender(), is(equalTo(Enumerations.AdministrativeGender.MALE)));\n-\t}\n-\n-\t@Test\n-\t//Test Case #1\n-\tpublic void testPatientUpdatesOverwritePersonData() {\n-\t\tPatient paul = buildPaulPatient();\n-\t\tString incorrectBirthdate = \"1980-06-27\";\n-\t\tpaul.getBirthDateElement().setValueAsString(incorrectBirthdate);\n-\t\tpaul = createPatientAndUpdateLinks(paul);\n-\n-\t\tPerson personFromTarget = getPersonFromTarget(paul);\n-\t\tassertThat(personFromTarget.getBirthDateElement().getValueAsString(), is(incorrectBirthdate));\n-\n-\t\tString correctBirthdate = \"1990-06-28\";\n-\t\tpaul.getBirthDateElement().setValueAsString(correctBirthdate);\n-\n-\t\tpaul = updatePatientAndUpdateLinks(paul);\n-\n-\t\tpersonFromTarget = getPersonFromTarget(paul);\n-\t\tassertThat(personFromTarget.getBirthDateElement().getValueAsString(), is(equalTo(correctBirthdate)));\n-\t\tassertLinkCount(1);\n-\t}\n-\n-\t@Test\n-\t// Test Case #3\n-\tpublic void testUpdatedEidThatWouldRelinkAlsoCausesPossibleDuplicate() {\n-\t\tString EID_1 = \"123\";\n-\t\tString EID_2 = \"456\";\n-\n-\t\tPatient paul = createPatientAndUpdateLinks(addExternalEID(buildPaulPatient(), EID_1));\n-\t\tPerson originalPaulPerson = getPersonFromTarget(paul);\n-\n-\t\tPatient jane = createPatientAndUpdateLinks(addExternalEID(buildJanePatient(), EID_2));\n-\t\tPerson originalJanePerson = getPersonFromTarget(jane);\n-\n-\t\tclearExternalEIDs(paul);\n-\t\taddExternalEID(paul, EID_2);\n-\t\tupdatePatientAndUpdateLinks(paul);\n-\n-\t\tassertThat(originalJanePerson, is(possibleDuplicateOf(originalPaulPerson)));\n-\t\tassertThat(jane, is(samePersonAs(paul)));\n-\t}\n-\n-\t@Test\n-\t//Test Case #2\n-\tpublic void testSinglyLinkedPersonThatGetsAnUpdatedEidSimplyUpdatesEID() {\n-\t\tString EID_1 = \"123\";\n-\t\tString EID_2 = \"456\";\n-\n-\t\tPatient paul = createPatientAndUpdateLinks(addExternalEID(buildPaulPatient(), EID_1));\n-\t\tPerson originalPaulPerson = getPersonFromTarget(paul);\n-\t\tString oldEid = myEidHelper.getExternalEid(originalPaulPerson).get(0).getValue();\n-\t\tassertThat(oldEid, is(equalTo(EID_1)));\n-\n-\t\tclearExternalEIDs(paul);\n-\t\taddExternalEID(paul, EID_2);\n-\n-\t\tpaul = updatePatientAndUpdateLinks(paul);\n-\n-\t\tassertNoDuplicates();\n-\n-\t\tPerson newlyFoundPaulPerson = getPersonFromTarget(paul);\n-\t\tassertThat(originalPaulPerson, is(samePersonAs(newlyFoundPaulPerson)));\n-\t\tString newEid = myEidHelper.getExternalEid(newlyFoundPaulPerson).get(0).getValue();\n-\t\tassertThat(newEid, is(equalTo(EID_2)));\n-\t}\n-\n-\tprivate void assertNoDuplicates() {\n-\t\tList<EmpiLink> possibleDuplicates = myEmpiLinkDaoSvc.getPossibleDuplicates();\n-\t\tassertThat(possibleDuplicates, hasSize(0));\n-\t}\n-\n-\t@Test\n-\t//Test Case #3\n-\tpublic void testWhenAnEidChangeWouldCauseARelinkingThatAPossibleDuplicateIsCreated() {\n-\t\tPatient patient1 = buildJanePatient();\n-\t\taddExternalEID(patient1, \"eid-1\");\n-\t\tpatient1 = createPatientAndUpdateLinks(patient1);\n-\n-\t\tPatient patient2 = buildPaulPatient();\n-\t\taddExternalEID(patient2, \"eid-2\");\n-\t\tpatient2 = createPatientAndUpdateLinks(patient2);\n-\n-\t\tPatient patient3 = buildPaulPatient();\n-\t\taddExternalEID(patient3, \"eid-2\");\n-\t\tpatient3 = createPatientAndUpdateLinks(patient3);\n-\n-\t\t//Now, Patient 2 and 3 are linked, and the person has 2 eids.\n-\t\tassertThat(patient2, is(samePersonAs(patient3)));\n-\t\tassertNoDuplicates();\n-\t\t//\tPerson A -> {P1}\n-\t\t//\tPerson B -> {P2, P3}\n-\n-\t\tpatient2.getIdentifier().clear();\n-\t\taddExternalEID(patient2, \"eid-1\");\n-\t\tpatient2 = updatePatientAndUpdateLinks(patient2);\n-\n-\t\t// Person A -> {P1, P2}\n-\t\t// Person B -> {P3}\n-\t\t// Possible duplicates A<->B\n-\n-\t\tassertThat(patient2, is(samePersonAs(patient1)));\n-\n-\t\tList<EmpiLink> possibleDuplicates = myEmpiLinkDaoSvc.getPossibleDuplicates();\n-\t\tassertThat(possibleDuplicates, hasSize(1));\n-\t\tassertThat(patient3, is(possibleDuplicateOf(patient1)));\n-\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyMjY1Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525422656", "body": "Do we need to adjust those to use MDM terminology?", "bodyText": "Do we need to adjust those to use MDM terminology?", "bodyHTML": "<p dir=\"auto\">Do we need to adjust those to use MDM terminology?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:16:23Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java", "diffHunk": "@@ -25,13 +25,20 @@\n \t * TAG system for Person resources which are managed by HAPI EMPI.\n \t */\n \n-\tpublic static final String SYSTEM_EMPI_MANAGED = \"https://hapifhir.org/NamingSystem/managing-empi-system\";\n-\tpublic static final String CODE_HAPI_EMPI_MANAGED = \"HAPI-EMPI\";\n+\tpublic static final String SYSTEM_MDM_MANAGED = \"https://hapifhir.org/NamingSystem/managing-mdm-system\";\n+\tpublic static final String CODE_HAPI_MDM_MANAGED = \"HAPI-MDM\";\n \tpublic static final String DISPLAY_HAPI_EMPI_MANAGED = \"This Person can only be modified by Smile CDR's EMPI system.\";\n \tpublic static final String CODE_NO_EMPI_MANAGED = \"NO-EMPI\";", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/api/MdmConstants.java\nsimilarity index 81%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java\nrename to hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/api/MdmConstants.java\nindex 05d9dbcf93..eb87ff629d 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/api/MdmConstants.java\n", "chunk": "@@ -20,16 +20,16 @@ package ca.uhn.fhir.empi.api;\n  * #L%\n  */\n \n-public class EmpiConstants {\n+public class MdmConstants {\n \t/**\n-\t * TAG system for Person resources which are managed by HAPI EMPI.\n+\t * TAG system for Person resources which are managed by HAPI MDM.\n \t */\n \n \tpublic static final String SYSTEM_MDM_MANAGED = \"https://hapifhir.org/NamingSystem/managing-mdm-system\";\n \tpublic static final String CODE_HAPI_MDM_MANAGED = \"HAPI-MDM\";\n-\tpublic static final String DISPLAY_HAPI_EMPI_MANAGED = \"This Person can only be modified by Smile CDR's EMPI system.\";\n-\tpublic static final String CODE_NO_EMPI_MANAGED = \"NO-EMPI\";\n-\tpublic static final String HAPI_ENTERPRISE_IDENTIFIER_SYSTEM = \"http://hapifhir.io/fhir/NamingSystem/empi-person-enterprise-id\";\n+\tpublic static final String DISPLAY_HAPI_MDM_MANAGED = \"This Person can only be modified by Smile CDR's MDM system.\";\n+\tpublic static final String CODE_NO_MDM_MANAGED = \"NO-MDM\";\n+\tpublic static final String HAPI_ENTERPRISE_IDENTIFIER_SYSTEM = \"http://hapifhir.io/fhir/NamingSystem/mdm-golden-resource-enterprise-id\";\n \tpublic static final String ALL_RESOURCE_SEARCH_PARAM_TYPE = \"*\";\n \n \tpublic static final String FIHR_STRUCTURE_DEF_MATCH_GRADE_URL_NAMESPACE = \"http://hl7.org/fhir/StructureDefinition/match-grade\";\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyMzM3MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525423370", "body": "Reaming to MDM?", "bodyText": "Reaming to MDM?", "bodyHTML": "<p dir=\"auto\">Reaming to MDM?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:17:34Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java", "diffHunk": "@@ -22,6 +22,8 @@\n \n import ca.uhn.fhir.empi.rules.json.EmpiRulesJson;\n \n+import java.util.stream.Collectors;\n+\n public interface IEmpiSettings {\n \tString EMPI_CHANNEL_NAME = \"empi\";", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/api/IMdmSettings.java\nsimilarity index 68%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java\nrename to hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/api/IMdmSettings.java\nindex 9a742809c1..6362ca5522 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/api/IMdmSettings.java\n", "chunk": "@@ -20,20 +20,20 @@ package ca.uhn.fhir.empi.api;\n  * #L%\n  */\n \n-import ca.uhn.fhir.empi.rules.json.EmpiRulesJson;\n+import ca.uhn.fhir.mdm.rules.json.MdmRulesJson;\n \n import java.util.stream.Collectors;\n \n-public interface IEmpiSettings {\n-\tString EMPI_CHANNEL_NAME = \"empi\";\n-\t// Parallel processing of EMPI can result in missed matches.  Best to single-thread.\n-\tint EMPI_DEFAULT_CONCURRENT_CONSUMERS = 1;\n+public interface IMdmSettings {\n+\tString MDM_CHANNEL_NAME = \"empi\";\n+\t// Parallel processing of MDM can result in missed matches.  Best to single-thread.\n+\tint MDM_DEFAULT_CONCURRENT_CONSUMERS = 1;\n \n \tboolean isEnabled();\n \n \tint getConcurrentConsumers();\n \n-\tEmpiRulesJson getEmpiRules();\n+\tMdmRulesJson getMdmRules();\n \n \tboolean isPreventEidUpdates();\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNDIwMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525424202", "body": "Move to MessageHelper and change to use proper terminology", "bodyText": "Move to MessageHelper and change to use proper terminology", "bodyHTML": "<p dir=\"auto\">Move to MessageHelper and change to use proper terminology</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:19:10Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java", "diffHunk": "@@ -43,43 +43,48 @@ public BaseEmpiProvider(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n-\tprotected void validateMergeParameters(IPrimitiveType<String> theFromPersonId, IPrimitiveType<String> theToPersonId) {\n-\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n-\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n-\t\tif (theFromPersonId.getValue().equals(theToPersonId.getValue())) {\n+\tprotected void validateMergeParameters(IPrimitiveType<String> theFromGoldenResourceId, IPrimitiveType<String> theToGoldenResourceId) {\n+\t\t// TODO NG - Add validation to check that types are the same?\n+\t\tvalidateNotNull(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromGoldenResourceId);\n+\t\tvalidateNotNull(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToGoldenResourceId);\n+\t\tif (theFromGoldenResourceId.getValue().equals(theToGoldenResourceId.getValue())) {\n \t\t\tthrow new InvalidRequestException(\"fromPersonId must be different from toPersonId\");", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\nindex 9fd42ac5c1..89c6d1281e 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\n", "chunk": "@@ -43,14 +43,13 @@ public abstract class BaseEmpiProvider {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n-\tprotected void validateMergeParameters(IPrimitiveType<String> theFromGoldenResourceId, IPrimitiveType<String> theToGoldenResourceId) {\n-\t\t// TODO NG - Add validation to check that types are the same?\n-\t\tvalidateNotNull(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromGoldenResourceId);\n-\t\tvalidateNotNull(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToGoldenResourceId);\n-\t\tif (theFromGoldenResourceId.getValue().equals(theToGoldenResourceId.getValue())) {\n+\tprotected void validateMergeParameters(IPrimitiveType<String> theFromPersonId, IPrimitiveType<String> theToPersonId) {\n+\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n+\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n+\t\tif (theFromPersonId.getValue().equals(theToPersonId.getValue())) {\n \t\t\tthrow new InvalidRequestException(\"fromPersonId must be different from toPersonId\");\n \t\t}\n-\t}\n+ \t}\n \n \tprivate void validateNotNull(String theName, IPrimitiveType<String> theString) {\n \t\tif (theString == null || theString.getValue() == null) {\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\ndeleted file mode 100644\nindex 89c6d1281e..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,110 +0,0 @@\n-package ca.uhn.fhir.empi.provider;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkJson;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import ca.uhn.fhir.rest.api.server.RequestDetails;\n-import ca.uhn.fhir.rest.server.TransactionLogMessages;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.util.ParametersUtil;\n-import org.hl7.fhir.instance.model.api.IBase;\n-import org.hl7.fhir.instance.model.api.IBaseParameters;\n-import org.hl7.fhir.instance.model.api.IPrimitiveType;\n-\n-import java.util.stream.Stream;\n-\n-public abstract class BaseEmpiProvider {\n-\n-\tprotected final FhirContext myFhirContext;\n-\n-\tpublic BaseEmpiProvider(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\tprotected void validateMergeParameters(IPrimitiveType<String> theFromPersonId, IPrimitiveType<String> theToPersonId) {\n-\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n-\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n-\t\tif (theFromPersonId.getValue().equals(theToPersonId.getValue())) {\n-\t\t\tthrow new InvalidRequestException(\"fromPersonId must be different from toPersonId\");\n-\t\t}\n- \t}\n-\n-\tprivate void validateNotNull(String theName, IPrimitiveType<String> theString) {\n-\t\tif (theString == null || theString.getValue() == null) {\n-\t\t\tthrow new InvalidRequestException(theName + \" cannot be null\");\n-\t\t}\n-\t}\n-\n-\tprotected void validateUpdateLinkParameters(IPrimitiveType<String> thePersonId, IPrimitiveType<String> theTargetId, IPrimitiveType<String> theMatchResult) {\n-\t\tvalidateNotNull(ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, thePersonId);\n-\t\tvalidateNotNull(ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, theTargetId);\n-\t\tvalidateNotNull(ProviderConstants.EMPI_UPDATE_LINK_MATCH_RESULT, theMatchResult);\n-\t\tEmpiMatchResultEnum matchResult = EmpiMatchResultEnum.valueOf(theMatchResult.getValue());\n-\t\tswitch (matchResult) {\n-\t\t\tcase NO_MATCH:\n-\t\t\tcase MATCH:\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_UPDATE_LINK + \" illegal \" + ProviderConstants.EMPI_UPDATE_LINK_MATCH_RESULT +\n-\t\t\t\t\t\" value '\" + matchResult + \"'.  Must be \" + EmpiMatchResultEnum.NO_MATCH + \" or \" + EmpiMatchResultEnum.MATCH);\n-\t\t}\n-\t}\n-\n-\tprotected void validateNotDuplicateParameters(IPrimitiveType<String> thePersonId, IPrimitiveType<String> theTargetId) {\n-\t\tvalidateNotNull(ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, thePersonId);\n-\t\tvalidateNotNull(ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, theTargetId);\n-\t}\n-\n-\tprotected EmpiTransactionContext createEmpiContext(RequestDetails theRequestDetails, EmpiTransactionContext.OperationType theOperationType) {\n-\t\tTransactionLogMessages transactionLogMessages = TransactionLogMessages.createFromTransactionGuid(theRequestDetails.getTransactionGuid());\n-\t\treturn new EmpiTransactionContext(transactionLogMessages, theOperationType);\n-\t}\n-\n-\tprotected String extractStringOrNull(IPrimitiveType<String> theString) {\n-\t\tif (theString == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn theString.getValue();\n-\t}\n-\n-\tprotected IBaseParameters parametersFromEmpiLinks(Stream<EmpiLinkJson> theEmpiLinkStream, boolean includeResultAndSource) {\n-\t\tIBaseParameters retval = ParametersUtil.newInstance(myFhirContext);\n-\n-\t\ttheEmpiLinkStream.forEach(empiLink -> {\n-\t\t\tIBase resultPart = ParametersUtil.addParameterToParameters(myFhirContext, retval, \"link\");\n-\t\t\tParametersUtil.addPartString(myFhirContext, resultPart, \"personId\", empiLink.getPersonId());\n-\t\t\tParametersUtil.addPartString(myFhirContext, resultPart, \"targetId\", empiLink.getTargetId());\n-\n-\t\t\tif (includeResultAndSource) {\n-\t\t\t\tParametersUtil.addPartString(myFhirContext, resultPart, \"matchResult\", empiLink.getMatchResult().name());\n-\t\t\t\tParametersUtil.addPartString(myFhirContext, resultPart, \"linkSource\", empiLink.getLinkSource().name());\n-\t\t\t\tParametersUtil.addPartBoolean(myFhirContext, resultPart, \"eidMatch\", empiLink.getEidMatch());\n-\t\t\t\tParametersUtil.addPartBoolean(myFhirContext, resultPart, \"newPerson\", empiLink.getNewPerson());\n-\t\t\t\tParametersUtil.addPartDecimal(myFhirContext, resultPart, \"score\", empiLink.getScore());\n-\t\t\t}\n-\t\t});\n-\t\treturn retval;\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNTIwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525425209", "body": "rename to validateIsMdmManaged", "bodyText": "rename to validateIsMdmManaged", "bodyHTML": "<p dir=\"auto\">rename to validateIsMdmManaged</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:20:41Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java", "diffHunk": "@@ -73,20 +84,24 @@ protected IAnyResource loadResource(IIdType theResourceId) {\n \t}\n \n \tpublic void validateMergeResources(IAnyResource theFromPerson, IAnyResource theToPerson) {\n-\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPerson);\n-\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPerson);\n+\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPerson);\n+\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPerson);\n \t}\n \n \tpublic String toJson(IAnyResource theAnyResource) {\n \t\treturn myFhirContext.newJsonParser().encodeResourceToString(theAnyResource);\n \t}\n \n-\tprivate void validateIsEmpiManaged(String theName, IAnyResource thePerson) {\n-\t\tif (!\"Person\".equals(myFhirContext.getResourceType(thePerson))) {\n-\t\t\tthrow new InvalidRequestException(\"Only Person resources can be merged.  The \" + theName + \" points to a \" + myFhirContext.getResourceType(thePerson));\n+\tpublic void validateIsEmpiManaged(String theName, IAnyResource theResource) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\nindex 358dcfdddc..0cb9bd3595 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\n", "chunk": "@@ -84,24 +73,20 @@ public class EmpiControllerHelper {\n \t}\n \n \tpublic void validateMergeResources(IAnyResource theFromPerson, IAnyResource theToPerson) {\n-\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPerson);\n-\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPerson);\n+\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPerson);\n+\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPerson);\n \t}\n \n \tpublic String toJson(IAnyResource theAnyResource) {\n \t\treturn myFhirContext.newJsonParser().encodeResourceToString(theAnyResource);\n \t}\n \n-\tpublic void validateIsEmpiManaged(String theName, IAnyResource theResource) {\n-\t\tString resourceType = myFhirContext.getResourceType(theResource);\n-\t\tif (!myEmpiSettings.isSupportedMdmType(resourceType)) {\n-\t\t\tthrow new InvalidRequestException(\n-\t\t\t\tmyMessageHelper.getMessageForUnsupportedResource(theName, resourceType)\n-\t\t\t);\n+\tprivate void validateIsEmpiManaged(String theName, IAnyResource thePerson) {\n+\t\tif (!\"Person\".equals(myFhirContext.getResourceType(thePerson))) {\n+\t\t\tthrow new InvalidRequestException(\"Only Person resources can be merged.  The \" + theName + \" points to a \" + myFhirContext.getResourceType(thePerson));\n \t\t}\n-\n-\t\tif (!EmpiUtil.isEmpiManaged(theResource)) {\n-\t\t\tthrow new InvalidRequestException(myMessageHelper.getMessageForUnmanagedResource());\n+\t\tif (!EmpiUtil.isEmpiManaged(thePerson)) {\n+\t\t\tthrow new InvalidRequestException(\"Only EMPI managed resources can be merged.  Empi managed resource have the \" + EmpiConstants.CODE_HAPI_EMPI_MANAGED + \" tag.\");\n \t\t}\n \t}\n }\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmControllerHelper.java\nsimilarity index 55%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmControllerHelper.java\nindex 0cb9bd3595..12f1feda2a 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmControllerHelper.java\n", "chunk": "@@ -72,21 +77,25 @@ public class EmpiControllerHelper {\n \t\treturn (IAnyResource) myResourceLoader.load(resourceClass, theResourceId);\n \t}\n \n-\tpublic void validateMergeResources(IAnyResource theFromPerson, IAnyResource theToPerson) {\n-\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPerson);\n-\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPerson);\n+\tpublic void validateMergeResources(IAnyResource theFromGoldenResource, IAnyResource theToGoldenResource) {\n+\t\tvalidateIsMdmManaged(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromGoldenResource);\n+\t\tvalidateIsMdmManaged(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToGoldenResource);\n \t}\n \n \tpublic String toJson(IAnyResource theAnyResource) {\n \t\treturn myFhirContext.newJsonParser().encodeResourceToString(theAnyResource);\n \t}\n \n-\tprivate void validateIsEmpiManaged(String theName, IAnyResource thePerson) {\n-\t\tif (!\"Person\".equals(myFhirContext.getResourceType(thePerson))) {\n-\t\t\tthrow new InvalidRequestException(\"Only Person resources can be merged.  The \" + theName + \" points to a \" + myFhirContext.getResourceType(thePerson));\n+\tpublic void validateIsMdmManaged(String theName, IAnyResource theResource) {\n+\t\tString resourceType = myFhirContext.getResourceType(theResource);\n+\t\tif (!myMdmSettings.isSupportedMdmType(resourceType)) {\n+\t\t\tthrow new InvalidRequestException(\n+\t\t\t\tmyMessageHelper.getMessageForUnsupportedResource(theName, resourceType)\n+\t\t\t);\n \t\t}\n-\t\tif (!EmpiUtil.isEmpiManaged(thePerson)) {\n-\t\t\tthrow new InvalidRequestException(\"Only EMPI managed resources can be merged.  Empi managed resource have the \" + EmpiConstants.CODE_HAPI_EMPI_MANAGED + \" tag.\");\n+\n+\t\tif (!MdmResourceUtil.isMdmManaged(theResource)) {\n+\t\t\tthrow new InvalidRequestException(myMessageHelper.getMessageForUnmanagedResource());\n \t\t}\n \t}\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNjEwMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525426100", "body": "rename Empi to MDM", "bodyText": "rename Empi to MDM", "bodyHTML": "<p dir=\"auto\">rename Empi to MDM</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:22:13Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -79,107 +79,100 @@ public EmpiProviderDstu3(FhirContext theFhirContext, IEmpiControllerSvc theEmpiC\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.MDM_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n-\t\tmatches.sort(Comparator.comparing((MatchedTarget m) -> m.getMatchResult().getNormalizedScore()).reversed());\n-\n-\t\tBundle retVal = new Bundle();\n-\t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n-\t\tretVal.setId(UUID.randomUUID().toString());\n-\t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n-\n-\t\tfor (MatchedTarget next : matches) {\n-\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n-\t\t\tif (!shouldKeepThisEntry) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n-\t\t\tentry.setResource((Resource) next.getTarget());\n-\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\t\treturn getMatchesAndPossibleMatchesForResource(thePatient, \"Patient\");\n+\t}\n \n-\t\t\tretVal.addEntry(entry);\n+\t@Operation(name = ProviderConstants.MDM_MATCH)\n+\tpublic Bundle serverMatch(@OperationParam(name = ProviderConstants.MDM_MATCH_RESOURCE, min = 1, max = 1) IAnyResource theResource,\n+\t\t\t\t\t\t\t\t\t  @OperationParam(name = ProviderConstants.MDM_RESOURCE_TYPE, min = 1, max = 1) StringType theResourceType\n+\t) {\n+\t\tif (theResource == null) {\n+\t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n+\t\treturn getMatchesAndPossibleMatchesForResource(theResource, theResourceType.getValueNotNull());\n \n-\t\treturn retVal;\n \t}\n \n \tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget theMatchedTarget) {\n \t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n \t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n \t\tsearchComponent.setScore(theMatchedTarget.getMatchResult().getNormalizedScore());\n \n-\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n-\t\tif (theMatchedTarget.isMatch()) {\n-\t\t\tmatchGrade = MatchGrade.CERTAIN;\n-\t\t} else if (theMatchedTarget.isPossibleMatch()) {\n-\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n-\t\t}\n+\t\tMatchGrade matchGrade = getMatchGrade(theMatchedTarget);\n \n \t\tsearchComponent.addExtension(EmpiConstants.FIHR_STRUCTURE_DEF_MATCH_GRADE_URL_NAMESPACE, new CodeType(matchGrade.toCode()));\n \t\treturn searchComponent;\n \t}\n \n-\t@Operation(name = ProviderConstants.EMPI_MERGE_PERSONS, type = Person.class)\n-\tpublic Person mergePerson(@OperationParam(name=ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, min = 1, max = 1) StringType theFromPersonId,\n-\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, min = 1, max = 1) StringType theToPersonId,\n-\t\t\t\t\t\t\t\t\t  RequestDetails theRequestDetails) {\n-\t\tvalidateMergeParameters(theFromPersonId, theToPersonId);\n+\t@Operation(name = ProviderConstants.MDM_MERGE_GOLDEN_RESOURCES)\n+\tpublic IBaseResource mergeGoldenResource(@OperationParam(name=ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, min = 1, max = 1) StringType theFromGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, min = 1, max = 1) StringType theToGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  RequestDetails theRequestDetails) {\n+\t\tvalidateMergeParameters(theFromGoldenResourceId, theToGoldenResourceId);\n \n-\t\treturn (Person) myEmpiControllerSvc.mergePersons(theFromPersonId.getValue(), theToPersonId.getValue(), createEmpiContext(theRequestDetails, EmpiTransactionContext.OperationType.MERGE_PERSONS));\n+\t\tString resourceType = getResourceType(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromGoldenResourceId);\n+\n+\t\treturn myEmpiControllerSvc.mergeGoldenResources(theFromGoldenResourceId.getValue(), theToGoldenResourceId.getValue(),\n+\t\t\tcreateMdmContext(theRequestDetails, MdmTransactionContext.OperationType.MERGE_PERSONS, resourceType));\n \t}\n \n-\t@Operation(name = ProviderConstants.EMPI_UPDATE_LINK, type = Person.class)\n-\tpublic Person updateLink(@OperationParam(name=ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, min = 1, max = 1) StringType thePersonId,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, min = 1, max = 1) StringType theTargetId,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_UPDATE_LINK_MATCH_RESULT, min = 1, max = 1) StringType theMatchResult,\n+\t@Operation(name = ProviderConstants.MDM_UPDATE_LINK)\n+\tpublic IBaseResource updateLink(@OperationParam(name=ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, min = 1, max = 1) StringType theGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_UPDATE_LINK_RESOURCE_ID, min = 1, max = 1) StringType theTargetId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_UPDATE_LINK_MATCH_RESULT, min = 1, max = 1) StringType theMatchResult,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ServletRequestDetails theRequestDetails) {\n \n-\t\tvalidateUpdateLinkParameters(thePersonId, theTargetId, theMatchResult);\n+\t\tvalidateUpdateLinkParameters(theGoldenResourceId, theTargetId, theMatchResult);\n \n-\t\treturn (Person) myEmpiControllerSvc.updateLink(thePersonId.getValue(), theTargetId.getValue(), theMatchResult.getValue(), createEmpiContext(theRequestDetails, EmpiTransactionContext.OperationType.UPDATE_LINK));\n+\t\treturn myEmpiControllerSvc.updateLink(theGoldenResourceId.getValue(), theTargetId.getValue(), theMatchResult.getValue(),\n+\t\t\tcreateMdmContext(theRequestDetails, MdmTransactionContext.OperationType.UPDATE_LINK,\n+\t\t\t\tgetResourceType(ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, theGoldenResourceId)));\n \t}\n \n-\t@Operation(name = ProviderConstants.EMPI_QUERY_LINKS)\n-\tpublic Parameters queryLinks(@OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_PERSON_ID, min = 0, max = 1) StringType thePersonId,\n-\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_TARGET_ID, min = 0, max = 1) StringType theTargetId,\n+\t@Operation(name = ProviderConstants.MDM_QUERY_LINKS)\n+\tpublic Parameters queryLinks(@OperationParam(name=ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, min = 0, max = 1) StringType theGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_QUERY_LINKS_RESOURCE_ID, min = 0, max = 1) StringType theTargetResourceId,\n \t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_MATCH_RESULT, min = 0, max = 1) StringType theMatchResult,\n \t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_MATCH_RESULT, min = 0, max = 1) StringType theLinkSource,\n \t\t\t\t\t\t\t\t\t\t  ServletRequestDetails theRequestDetails) {\n \n-\t\tStream<EmpiLinkJson> empiLinkJson = myEmpiControllerSvc.queryLinks(extractStringOrNull(thePersonId), extractStringOrNull(theTargetId), extractStringOrNull(theMatchResult), extractStringOrNull(theLinkSource), createEmpiContext(theRequestDetails, EmpiTransactionContext.OperationType.QUERY_LINKS));\n+\t\tStream<EmpiLinkJson> empiLinkJson = myEmpiControllerSvc.queryLinks(extractStringOrNull(theGoldenResourceId), extractStringOrNull(theTargetResourceId),\n+\t\t\textractStringOrNull(theMatchResult), extractStringOrNull(theLinkSource), createMdmContext(theRequestDetails,\n+\t\t\t\tMdmTransactionContext.OperationType.QUERY_LINKS, getResourceType(ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, theGoldenResourceId)));\n \t\treturn (Parameters) parametersFromEmpiLinks(empiLinkJson, true);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderDstu3.java\nsimilarity index 81%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java\nrename to hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderDstu3.java\nindex 8c91751707..759ec67913 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderDstu3.java\n", "chunk": "@@ -141,16 +141,16 @@ public class EmpiProviderDstu3 extends BaseEmpiProvider {\n \t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_MATCH_RESULT, min = 0, max = 1) StringType theLinkSource,\n \t\t\t\t\t\t\t\t\t\t  ServletRequestDetails theRequestDetails) {\n \n-\t\tStream<EmpiLinkJson> empiLinkJson = myEmpiControllerSvc.queryLinks(extractStringOrNull(theGoldenResourceId), extractStringOrNull(theTargetResourceId),\n+\t\tStream<MdmLinkJson> empiLinkJson = myMdmControllerSvc.queryLinks(extractStringOrNull(theGoldenResourceId), extractStringOrNull(theTargetResourceId),\n \t\t\textractStringOrNull(theMatchResult), extractStringOrNull(theLinkSource), createMdmContext(theRequestDetails,\n \t\t\t\tMdmTransactionContext.OperationType.QUERY_LINKS, getResourceType(ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, theGoldenResourceId)));\n-\t\treturn (Parameters) parametersFromEmpiLinks(empiLinkJson, true);\n+\t\treturn (Parameters) parametersFromMdmLinks(empiLinkJson, true);\n \t}\n \n \t@Operation(name = ProviderConstants.MDM_DUPLICATE_GOLDEN_RESOURCES)\n \tpublic Parameters getDuplicateGoldenResources(ServletRequestDetails theRequestDetails) {\n-\t\tStream<EmpiLinkJson> possibleDuplicates = myEmpiControllerSvc.getDuplicateGoldenResources(createMdmContext(theRequestDetails, MdmTransactionContext.OperationType.QUERY_LINKS, (String) null));\n-\t\treturn (Parameters) parametersFromEmpiLinks(possibleDuplicates, false);\n+\t\tStream<MdmLinkJson> possibleDuplicates = myMdmControllerSvc.getDuplicateGoldenResources(createMdmContext(theRequestDetails, MdmTransactionContext.OperationType.QUERY_LINKS, (String) null));\n+\t\treturn (Parameters) parametersFromMdmLinks(possibleDuplicates, false);\n \t}\n \n \t@Operation(name = ProviderConstants.MDM_NOT_DUPLICATE)\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNjk5OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525426999", "body": "MdmProviderR4?", "bodyText": "MdmProviderR4?", "bodyHTML": "<p dir=\"auto\">MdmProviderR4?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:23:45Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -63,30 +62,54 @@\n public class EmpiProviderR4 extends BaseEmpiProvider {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderR4.java\nsimilarity index 84%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java\nrename to hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderR4.java\nindex ab25e0435b..8879244cdc 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderR4.java\n", "chunk": "@@ -59,11 +59,11 @@ import java.util.List;\n import java.util.UUID;\n import java.util.stream.Stream;\n \n-public class EmpiProviderR4 extends BaseEmpiProvider {\n-\tprivate final IEmpiControllerSvc myEmpiControllerSvc;\n-\tprivate final IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n-\tprivate final IEmpiExpungeSvc myMdmExpungeSvc;\n-\tprivate final IEmpiSubmitSvc myMdmSubmitSvc;\n+public class MdmProviderR4 extends BaseMdmProvider {\n+\tprivate final IMdmControllerSvc myMdmControllerSvc;\n+\tprivate final IMdmMatchFinderSvc myMdmMatchFinderSvc;\n+\tprivate final IMdmExpungeSvc myMdmExpungeSvc;\n+\tprivate final IMdmSubmitSvc myMdmSubmitSvc;\n \n \t/**\n \t * Constructor\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODk4NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525428985", "body": "Empi -> MDM", "bodyText": "Empi -> MDM", "bodyHTML": "<p dir=\"auto\">Empi -&gt; MDM</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:26:54Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java", "diffHunk": "@@ -55,7 +56,70 @@ public static boolean isEmpiAccessible(IBaseResource theBaseResource) {\n \t * @return a boolean indicating whether or not EMPI manages this Person.\n \t */\n \tpublic static boolean isEmpiManaged(IBaseResource theBaseResource) {\n-\t\treturn theBaseResource.getMeta().getTag(EmpiConstants.SYSTEM_EMPI_MANAGED, EmpiConstants.CODE_HAPI_EMPI_MANAGED) != null;\n+\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_HAPI_MDM_MANAGED);\n+\t}\n+\n+\tpublic static boolean isGoldenRecord(IBaseResource theBaseResource) {\n+\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD);\n+\t}\n+\n+\tpublic static boolean isGoldenRecordRedirected(IBaseResource theBaseResource) {\n+\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD_REDIRECTED);\n+\t}\n+\n+\tprivate static boolean resourceHasTag(IBaseResource theTheBaseResource, String theSystem, String theCode) {\n+\t\treturn theTheBaseResource.getMeta().getTag(theSystem, theCode) != null;\n+\t}\n+\n+\tprivate static Optional<? extends IBaseCoding> getTagWithSystem(IBaseResource theResource, String theSystem) {\n+\t\treturn theResource.getMeta().getTag().stream().filter(tag -> tag.getSystem().equalsIgnoreCase(theSystem)).findFirst();\n+\t}\n+\n+\tpublic static void removeTagWithSystem(IBaseResource theResource, String theSystem) {\n+\t\ttheResource.getMeta().getTag().removeIf(tag -> tag.getSystem().equalsIgnoreCase(theSystem));\n+\t}\n+\n+\n+\t/**\n+\t * Sets the EMPI-managed tag, indicating the EMPI system has ownership of this\n+\t * Resource. No changes are made if resource is already maanged by EMPI.\n+\t *\n+\t * @param theBaseResource resource to set the tag for\n+\t * @return\n+\t * \t\tReturns resource with the tag set.\n+\t */\n+\tpublic static IBaseResource setEmpiManaged(IBaseResource theBaseResource) {\n+\t\treturn setTagOnResource(theBaseResource, EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_HAPI_MDM_MANAGED, EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\nsimilarity index 67%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java\nrename to hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\nindex 8128d69d12..31e5ad8f0b 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\n", "chunk": "@@ -89,15 +101,15 @@ public final class EmpiUtil {\n \t * \t\tReturns resource with the tag set.\n \t */\n \tpublic static IBaseResource setEmpiManaged(IBaseResource theBaseResource) {\n-\t\treturn setTagOnResource(theBaseResource, EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_HAPI_MDM_MANAGED, EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\treturn setTagOnResource(theBaseResource, MdmConstants.SYSTEM_MDM_MANAGED, MdmConstants.CODE_HAPI_MDM_MANAGED, MdmConstants.DISPLAY_HAPI_MDM_MANAGED);\n \t}\n \n \tpublic static IBaseResource setGoldenResource(IBaseResource theBaseResource) {\n-\t\treturn setTagOnResource(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD, EmpiConstants.DISPLAY_GOLDEN_RECORD);\n+\t\treturn setTagOnResource(theBaseResource, MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS, MdmConstants.CODE_GOLDEN_RECORD, MdmConstants.DISPLAY_GOLDEN_RECORD);\n \t}\n \n \tpublic static IBaseResource setGoldenResourceRedirected(IBaseResource theBaseResource) {\n-\t\treturn setTagOnResource(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD_REDIRECTED, EmpiConstants.DISPLAY_GOLDEN_REDIRECT);\n+\t\treturn setTagOnResource(theBaseResource, MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS, MdmConstants.CODE_GOLDEN_RECORD_REDIRECTED, MdmConstants.DISPLAY_GOLDEN_REDIRECT);\n \t}\n \n \t/**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyOTg2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525429869", "body": "rename S/R to Golden", "bodyText": "rename S/R to Golden", "bodyHTML": "<p dir=\"auto\">rename S/R to Golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:28:19Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -73,374 +82,261 @@ public PersonHelper(FhirContext theFhirContext) {\n \t}\n \n \t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n \n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n \n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nindex 46f2a8c4b7..675dc6c4cf 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n", "chunk": "@@ -82,261 +73,375 @@ public class PersonHelper {\n \t}\n \n \t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n+\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n \t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t * @param thePerson the Person to extract link IDs from.\n+\t * @return a Stream of {@link IIdType}.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n-\n-\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n-\n-\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n-\t\tEmpiUtil.setGoldenResource(newSourceResource);\n+\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\treturn personR4.getLink().stream()\n+\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n+\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n+\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\treturn personStu3.getLink().stream()\n+\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n+\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n+\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\treturn (T) newSourceResource;\n+\t/**\n+\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t *\n+\t * @param thePerson     The person to check\n+\t * @param theResourceId The ID to check.\n+\t * @return A boolean indicating whether or not there was a contained link.\n+\t */\n+\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n+\t\tStream<IIdType> links = getLinkIds(thePerson);\n+\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n \t}\n \n \t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n+\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n+\t * @param thePerson The person who's link needs to be updated.\n+\t * @param theResourceId The target of the link\n+\t * @param canonicalAssuranceLevel The level of certainty of this link.\n+\t * @param theEmpiTransactionContext\n \t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewSourceResource, BaseRuntimeChildDefinition theSourceResourceIdentifier, IAnyResource theTargetResource) {\n+\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewSourceResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n+\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n+\t\tif (theCanonicalAssuranceLevel == null) {\n+\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n \t\t\treturn;\n \t\t}\n \n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheSourceResourceIdentifier.getMutator().addValue(theNewSourceResource, toId(hapiEid));\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n+\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n+\t\t} else {\n+\t\t\tperson.getLink().stream()\n+\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.ifPresent(link -> {\n+\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n+\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n+\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n+\t}\n \n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n \t}\n \n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (canonicalAssuranceLevel == null) {\n+\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tPerson person = (Person) thePerson;\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n+\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\tperson.getLink().stream()\n+\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.ifPresent(link -> {\n+\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n+\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n+\t\t\t\t});\n+\t\t}\n \t}\n \n+\n \t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n+\t * @param thePerson The person to remove the link from.\n+\t * @param theResourceId The target ID to remove.\n+\t * @param theEmpiTransactionContext\n \t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson person = (Person) thePerson;\n+\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n+\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n \t}\n \n \t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n+\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo Resource to clone the specified filed to\n-\t * @param field Field name to be copied\n+\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n+\t * @return the Person that is created.\n \t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue: theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n+\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (eidsToApply.isEmpty()) {\n+\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n+\t\t}\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = new Person();\n+\t\t\t\tpersonR4.setActive(true);\n+\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n+\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n+\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n+\t\t\t\treturn personR4;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n+\t\t\t\tpersonDstu3.setActive(true);\n+\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n+\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n+\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n+\t\t\t\treturn personDstu3;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\t\ttheToFieldValues.add(newFieldValue);\n+\t/**\n+\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n+\t *\n+\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n+\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n+\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n+\t *\n+\t */\n+\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n \t}\n \n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n+\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n+\t\tPerson person = (Person) thePerson;\n+\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n+\t\t\tcase \"Patient\":\n+\t\t\t\tPatient patient = (Patient) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(patient.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(patient.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase \"Practitioner\":\n+\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(practitioner.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(practitioner.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n+\t\t}\n \t}\n \n-\tprivate void cloneAllExternalEidsIntoNewSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource, IBase theNewSourceResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n+\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n+\t\t\tcase \"Patient\":\n+\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n \n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tcloneEidIntoResource(theSourceResourceIdentifier, base, theNewSourceResource);\n-\t\t\t\t} else if (ourLog.isDebugEnabled()) {\n-\t\t\t\t\tourLog.debug(String.format(\"System %s differs from system in the EMPI rules %s\", baseSystem, empiSystem));\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(patient.getName());\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(patient.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n+\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n+\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase \"Practitioner\":\n+\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(practitioner.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(practitioner.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n \t\t}\n \t}\n \n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n+\tprivate IBaseCoding buildEmpiManagedTag() {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tCoding empiManagedCoding = new Coding();\n+\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n+\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n+\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\t\t\treturn empiManagedCoding;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n+\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n+\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n+\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\t\t\treturn empiManagedCodingDstu3;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\n \t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n \t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n \t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n+\t *\n \t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n \t *\n-\t * @param theSourceResource The person to update the external EID on.\n-\t * @param theTargetResource The target we will retrieve the external EID from.\n+\t * @param thePerson     The person to update the external EID on.\n+\t * @param theEmpiTarget The target we will retrieve the external EID from.\n \t * @return the modified {@link IBaseResource} representing the person.\n \t */\n-\tpublic IAnyResource updateSourceResourceExternalEidFromTargetResource(IAnyResource theSourceResource, IAnyResource\n-\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n \t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n+\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n+\n \n \t\tif (!incomingTargetEid.isEmpty()) {\n \t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, incomingTargetEid);\n+\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n+\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n \t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite person, as this EID is already present\");\n+\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n \t\t\t} else {\n \t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n \t\t\t}\n \t\t}\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theSourceResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theSourceResource);\n-\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, theNewEid);\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tif (ourLog.isDebugEnabled()) {\n-\t\t\t\t\t\tourLog.debug(String.format(\"Found EID confirming to EMPI rules %s. It should not be copied, skipping\", baseSystem));\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\t\ttheSourceResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase sourceResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, sourceResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(sourceResourceNewIdentifier);\n-\t\t}\n-\n-\t\tsourceResourceIdentifiers.clear();\n-\t\tsourceResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theSourceResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theSourceResource);\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheSourceResource(sourceResourceIdentifier, theSourceResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Source Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToSourceResourceIfAbsent(IBaseResource theSourceResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n-\t\tList<CanonicalEID> sourceResourceExternalEids = myEIDHelper.getExternalEid(theSourceResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n-\t\t\tif (sourceResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tcloneEidIntoResource(theSourceResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n+\t\treturn thePerson;\n \t}\n \n-\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) eid.toR4();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) eid.toDSTU3();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(thePerson);\n+\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n+\t\treturn thePerson;\n \t}\n \n-\n-\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n+\tprivate void clearExternalEids(IBaseResource thePerson) {\n \t\tswitch (myFhirContext.getVersion().getVersion()) {\n \t\t\tcase R4:\n-\t\t\t\treturn (T) new BooleanType(theFlag);\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\t\t\tbreak;\n \t\t\tcase DSTU3:\n-\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n \t}\n \n-\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n+\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n \t\tswitch (myFhirContext.getVersion().getVersion()) {\n \t\t\tcase R4:\n-\t\t\t\treturn ((BooleanType)theFlag).booleanValue();\n+\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n+\t\t\t\tbreak;\n \t\t\tcase DSTU3:\n-\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType)theFlag).booleanValue();\n+\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\ndeleted file mode 100644\nindex 675dc6c4cf..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,660 +0,0 @@\n-package ca.uhn.fhir.empi.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n-import org.hl7.fhir.r4.model.ContactPoint;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.Nonnull;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-@Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n-\t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n-\t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n-\n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\treturn;\n-\t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n-\t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n-\t *\n-\t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n-\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n-\t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the person.\n-\t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n-\n-\n-\t\tif (!incomingTargetEid.isEmpty()) {\n-\t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n-\t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n-\t\t\t}\n-\t\t}\n-\t\treturn thePerson;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(thePerson);\n-\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n-\t\treturn thePerson;\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * To avoid adding duplicate\n-\t *\n-\t * @param thePerson\n-\t * @param theIdentifier\n-\t */\n-\tprivate void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, org.hl7.fhir.dstu3.model.Identifier theIdentifier) {\n-\t\tOptional<org.hl7.fhir.dstu3.model.Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tpublic void mergePersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tPerson fromPerson = (Person) theFromPerson;\n-\t\tPerson toPerson = (Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, HumanName.class, Person::getName, HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Identifier.class, Person::getIdentifier, Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Address.class, Person::getAddress, Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, ContactPoint.class, Person::getTelecom, ContactPoint::equalsDeep);\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\tprivate <P,T> void mergeElementList(P fromPerson, P toPerson, Class<T> theBase, Function<P, List<T>> theGetList, BiPredicate<T, T> theEquals) {\n-\t\tList<T> fromList = theGetList.apply(fromPerson);\n-\t\tList<T> toList = theGetList.apply(toPerson);\n-\t\tList<T> itemsToAdd = new ArrayList<>();\n-\n-\t\tfor (T fromItem : fromList) {\n-\t\t\tif (toList.stream().noneMatch(t -> theEquals.test(fromItem, t))) {\n-\t\t\t\titemsToAdd.add(fromItem);\n-\t\t\t}\n-\t\t}\n-\t\ttoList.addAll(itemsToAdd);\n-\t}\n-\n-\tprivate void mergeDstu3PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\torg.hl7.fhir.dstu3.model.Person fromPerson = (org.hl7.fhir.dstu3.model.Person) theFromPerson;\n-\t\torg.hl7.fhir.dstu3.model.Person toPerson = (org.hl7.fhir.dstu3.model.Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.HumanName.class, org.hl7.fhir.dstu3.model.Person::getName, org.hl7.fhir.dstu3.model.HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Identifier.class, org.hl7.fhir.dstu3.model.Person::getIdentifier, org.hl7.fhir.dstu3.model.Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Address.class, org.hl7.fhir.dstu3.model.Person::getAddress, org.hl7.fhir.dstu3.model.Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.ContactPoint.class, org.hl7.fhir.dstu3.model.Person::getTelecom, org.hl7.fhir.dstu3.model.ContactPoint::equalsDeep);\n-\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a Patient that has a Person with an official EID, but\n-\t * the incoming resource also has an EID that does not match.\n-\t *\n-\t * @param theExistingPerson\n-\t * @param theComparingPerson\n-\t * @return\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingPerson, IAnyResource theComparingPerson) {\n-\t\tList<CanonicalEID> externalEidsPerson = myEIDHelper.getExternalEid(theExistingPerson);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingPerson);\n-\t\treturn !externalEidsPerson.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsPerson);\n-\t}\n-\n-\tpublic IBaseBackboneElement newPersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn newR4PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn newDstu3PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement newR4PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tPerson.PersonLinkComponent retval = new Person.PersonLinkComponent();\n-\t\tretval.setTarget(new Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toR4());\n-\t\treturn retval;\n-\t}\n-\n-\tprivate IBaseBackboneElement newDstu3PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\torg.hl7.fhir.dstu3.model.Person.PersonLinkComponent retval = new org.hl7.fhir.dstu3.model.Person.PersonLinkComponent();\n-\t\tretval.setTarget(new org.hl7.fhir.dstu3.model.Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toDstu3());\n-\t\treturn retval;\n-\t}\n-\n-\tpublic void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement> theNewLinks) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tsetLinksR4(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tsetLinksDstu3(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person)thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person)thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-   public void updatePersonFromNewlyCreatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, false);\n-   }\n-\n-\tpublic void updatePersonFromUpdatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, true);\n-\t}\n-\n-\tpublic int getLinkCount(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().size();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().size();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdatePersonExternalEidFromEmpiTarget(thePerson, theResource, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivatePerson(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonStu3.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn !personR4.getActive();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn !personStu3.getActive();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMDE0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525430148", "body": "S/R to Golden\r\n", "bodyText": "S/R to Golden", "bodyHTML": "<p dir=\"auto\">S/R to Golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:28:46Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -73,374 +82,261 @@ public PersonHelper(FhirContext theFhirContext) {\n \t}\n \n \t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n \n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n \n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n \n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n+\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n \n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n+\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n \n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n+\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n \n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n+\t\tEmpiUtil.setGoldenResource(newSourceResource);\n \n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n+\t\treturn (T) newSourceResource;\n \t}\n \n-\n \t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n \t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nindex 46f2a8c4b7..675dc6c4cf 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n", "chunk": "@@ -82,261 +73,375 @@ public class PersonHelper {\n \t}\n \n \t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n+\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n \t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t * @param thePerson the Person to extract link IDs from.\n+\t * @return a Stream of {@link IIdType}.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n-\n-\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n-\n-\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n-\t\tEmpiUtil.setGoldenResource(newSourceResource);\n+\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\treturn personR4.getLink().stream()\n+\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n+\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n+\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\treturn personStu3.getLink().stream()\n+\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n+\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n+\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\treturn (T) newSourceResource;\n+\t/**\n+\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t *\n+\t * @param thePerson     The person to check\n+\t * @param theResourceId The ID to check.\n+\t * @return A boolean indicating whether or not there was a contained link.\n+\t */\n+\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n+\t\tStream<IIdType> links = getLinkIds(thePerson);\n+\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n \t}\n \n \t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n+\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n+\t * @param thePerson The person who's link needs to be updated.\n+\t * @param theResourceId The target of the link\n+\t * @param canonicalAssuranceLevel The level of certainty of this link.\n+\t * @param theEmpiTransactionContext\n \t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewSourceResource, BaseRuntimeChildDefinition theSourceResourceIdentifier, IAnyResource theTargetResource) {\n+\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewSourceResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n+\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n+\t\tif (theCanonicalAssuranceLevel == null) {\n+\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n \t\t\treturn;\n \t\t}\n \n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheSourceResourceIdentifier.getMutator().addValue(theNewSourceResource, toId(hapiEid));\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n+\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n+\t\t} else {\n+\t\t\tperson.getLink().stream()\n+\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.ifPresent(link -> {\n+\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n+\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n+\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n+\t}\n \n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n \t}\n \n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (canonicalAssuranceLevel == null) {\n+\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tPerson person = (Person) thePerson;\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n+\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\tperson.getLink().stream()\n+\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.ifPresent(link -> {\n+\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n+\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n+\t\t\t\t});\n+\t\t}\n \t}\n \n+\n \t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n+\t * @param thePerson The person to remove the link from.\n+\t * @param theResourceId The target ID to remove.\n+\t * @param theEmpiTransactionContext\n \t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson person = (Person) thePerson;\n+\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n+\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n \t}\n \n \t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n+\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo Resource to clone the specified filed to\n-\t * @param field Field name to be copied\n+\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n+\t * @return the Person that is created.\n \t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue: theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n+\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (eidsToApply.isEmpty()) {\n+\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n+\t\t}\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = new Person();\n+\t\t\t\tpersonR4.setActive(true);\n+\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n+\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n+\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n+\t\t\t\treturn personR4;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n+\t\t\t\tpersonDstu3.setActive(true);\n+\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n+\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n+\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n+\t\t\t\treturn personDstu3;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\t\ttheToFieldValues.add(newFieldValue);\n+\t/**\n+\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n+\t *\n+\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n+\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n+\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n+\t *\n+\t */\n+\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n \t}\n \n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n+\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n+\t\tPerson person = (Person) thePerson;\n+\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n+\t\t\tcase \"Patient\":\n+\t\t\t\tPatient patient = (Patient) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(patient.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(patient.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase \"Practitioner\":\n+\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(practitioner.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(practitioner.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n+\t\t}\n \t}\n \n-\tprivate void cloneAllExternalEidsIntoNewSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource, IBase theNewSourceResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n+\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n+\t\t\tcase \"Patient\":\n+\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n \n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tcloneEidIntoResource(theSourceResourceIdentifier, base, theNewSourceResource);\n-\t\t\t\t} else if (ourLog.isDebugEnabled()) {\n-\t\t\t\t\tourLog.debug(String.format(\"System %s differs from system in the EMPI rules %s\", baseSystem, empiSystem));\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(patient.getName());\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(patient.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n+\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n+\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase \"Practitioner\":\n+\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(practitioner.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(practitioner.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n \t\t}\n \t}\n \n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n+\tprivate IBaseCoding buildEmpiManagedTag() {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tCoding empiManagedCoding = new Coding();\n+\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n+\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n+\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\t\t\treturn empiManagedCoding;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n+\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n+\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n+\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\t\t\treturn empiManagedCodingDstu3;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\n \t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n \t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n \t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n+\t *\n \t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n \t *\n-\t * @param theSourceResource The person to update the external EID on.\n-\t * @param theTargetResource The target we will retrieve the external EID from.\n+\t * @param thePerson     The person to update the external EID on.\n+\t * @param theEmpiTarget The target we will retrieve the external EID from.\n \t * @return the modified {@link IBaseResource} representing the person.\n \t */\n-\tpublic IAnyResource updateSourceResourceExternalEidFromTargetResource(IAnyResource theSourceResource, IAnyResource\n-\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n \t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n+\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n+\n \n \t\tif (!incomingTargetEid.isEmpty()) {\n \t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, incomingTargetEid);\n+\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n+\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n \t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite person, as this EID is already present\");\n+\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n \t\t\t} else {\n \t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n \t\t\t}\n \t\t}\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theSourceResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theSourceResource);\n-\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, theNewEid);\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tif (ourLog.isDebugEnabled()) {\n-\t\t\t\t\t\tourLog.debug(String.format(\"Found EID confirming to EMPI rules %s. It should not be copied, skipping\", baseSystem));\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\t\ttheSourceResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase sourceResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, sourceResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(sourceResourceNewIdentifier);\n-\t\t}\n-\n-\t\tsourceResourceIdentifiers.clear();\n-\t\tsourceResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theSourceResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theSourceResource);\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheSourceResource(sourceResourceIdentifier, theSourceResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Source Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToSourceResourceIfAbsent(IBaseResource theSourceResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n-\t\tList<CanonicalEID> sourceResourceExternalEids = myEIDHelper.getExternalEid(theSourceResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n-\t\t\tif (sourceResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tcloneEidIntoResource(theSourceResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n+\t\treturn thePerson;\n \t}\n \n-\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) eid.toR4();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) eid.toDSTU3();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(thePerson);\n+\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n+\t\treturn thePerson;\n \t}\n \n-\n-\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n+\tprivate void clearExternalEids(IBaseResource thePerson) {\n \t\tswitch (myFhirContext.getVersion().getVersion()) {\n \t\t\tcase R4:\n-\t\t\t\treturn (T) new BooleanType(theFlag);\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\t\t\tbreak;\n \t\t\tcase DSTU3:\n-\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n \t}\n \n-\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n+\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n \t\tswitch (myFhirContext.getVersion().getVersion()) {\n \t\t\tcase R4:\n-\t\t\t\treturn ((BooleanType)theFlag).booleanValue();\n+\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n+\t\t\t\tbreak;\n \t\t\tcase DSTU3:\n-\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType)theFlag).booleanValue();\n+\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\ndeleted file mode 100644\nindex 675dc6c4cf..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,660 +0,0 @@\n-package ca.uhn.fhir.empi.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n-import org.hl7.fhir.r4.model.ContactPoint;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.Nonnull;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-@Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n-\t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n-\t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n-\n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\treturn;\n-\t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n-\t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n-\t *\n-\t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n-\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n-\t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the person.\n-\t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n-\n-\n-\t\tif (!incomingTargetEid.isEmpty()) {\n-\t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n-\t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n-\t\t\t}\n-\t\t}\n-\t\treturn thePerson;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(thePerson);\n-\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n-\t\treturn thePerson;\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * To avoid adding duplicate\n-\t *\n-\t * @param thePerson\n-\t * @param theIdentifier\n-\t */\n-\tprivate void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, org.hl7.fhir.dstu3.model.Identifier theIdentifier) {\n-\t\tOptional<org.hl7.fhir.dstu3.model.Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tpublic void mergePersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tPerson fromPerson = (Person) theFromPerson;\n-\t\tPerson toPerson = (Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, HumanName.class, Person::getName, HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Identifier.class, Person::getIdentifier, Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Address.class, Person::getAddress, Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, ContactPoint.class, Person::getTelecom, ContactPoint::equalsDeep);\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\tprivate <P,T> void mergeElementList(P fromPerson, P toPerson, Class<T> theBase, Function<P, List<T>> theGetList, BiPredicate<T, T> theEquals) {\n-\t\tList<T> fromList = theGetList.apply(fromPerson);\n-\t\tList<T> toList = theGetList.apply(toPerson);\n-\t\tList<T> itemsToAdd = new ArrayList<>();\n-\n-\t\tfor (T fromItem : fromList) {\n-\t\t\tif (toList.stream().noneMatch(t -> theEquals.test(fromItem, t))) {\n-\t\t\t\titemsToAdd.add(fromItem);\n-\t\t\t}\n-\t\t}\n-\t\ttoList.addAll(itemsToAdd);\n-\t}\n-\n-\tprivate void mergeDstu3PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\torg.hl7.fhir.dstu3.model.Person fromPerson = (org.hl7.fhir.dstu3.model.Person) theFromPerson;\n-\t\torg.hl7.fhir.dstu3.model.Person toPerson = (org.hl7.fhir.dstu3.model.Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.HumanName.class, org.hl7.fhir.dstu3.model.Person::getName, org.hl7.fhir.dstu3.model.HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Identifier.class, org.hl7.fhir.dstu3.model.Person::getIdentifier, org.hl7.fhir.dstu3.model.Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Address.class, org.hl7.fhir.dstu3.model.Person::getAddress, org.hl7.fhir.dstu3.model.Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.ContactPoint.class, org.hl7.fhir.dstu3.model.Person::getTelecom, org.hl7.fhir.dstu3.model.ContactPoint::equalsDeep);\n-\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a Patient that has a Person with an official EID, but\n-\t * the incoming resource also has an EID that does not match.\n-\t *\n-\t * @param theExistingPerson\n-\t * @param theComparingPerson\n-\t * @return\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingPerson, IAnyResource theComparingPerson) {\n-\t\tList<CanonicalEID> externalEidsPerson = myEIDHelper.getExternalEid(theExistingPerson);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingPerson);\n-\t\treturn !externalEidsPerson.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsPerson);\n-\t}\n-\n-\tpublic IBaseBackboneElement newPersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn newR4PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn newDstu3PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement newR4PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tPerson.PersonLinkComponent retval = new Person.PersonLinkComponent();\n-\t\tretval.setTarget(new Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toR4());\n-\t\treturn retval;\n-\t}\n-\n-\tprivate IBaseBackboneElement newDstu3PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\torg.hl7.fhir.dstu3.model.Person.PersonLinkComponent retval = new org.hl7.fhir.dstu3.model.Person.PersonLinkComponent();\n-\t\tretval.setTarget(new org.hl7.fhir.dstu3.model.Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toDstu3());\n-\t\treturn retval;\n-\t}\n-\n-\tpublic void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement> theNewLinks) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tsetLinksR4(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tsetLinksDstu3(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person)thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person)thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-   public void updatePersonFromNewlyCreatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, false);\n-   }\n-\n-\tpublic void updatePersonFromUpdatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, true);\n-\t}\n-\n-\tpublic int getLinkCount(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().size();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().size();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdatePersonExternalEidFromEmpiTarget(thePerson, theResource, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivatePerson(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonStu3.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn !personR4.getActive();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn !personStu3.getActive();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMDQ2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525430469", "body": "s/r to golden", "bodyText": "s/r to golden", "bodyHTML": "<p dir=\"auto\">s/r to golden</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:29:17Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -73,374 +82,261 @@ public PersonHelper(FhirContext theFhirContext) {\n \t}\n \n \t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n \n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n \n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n \n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n+\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n \n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n+\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n \n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n+\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n \n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n+\t\tEmpiUtil.setGoldenResource(newSourceResource);\n \n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n+\t\treturn (T) newSourceResource;\n \t}\n \n-\n \t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n \t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewSourceResource, BaseRuntimeChildDefinition theSourceResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewSourceResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n \t\t\treturn;\n \t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheSourceResourceIdentifier.getMutator().addValue(theNewSourceResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n \t}\n \n \t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n \t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n \n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n \t}\n \n \t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n \t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo Resource to clone the specified filed to\n+\t * @param field Field name to be copied\n \t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue: theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n \t\t}\n \t}\n \n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n+\t\treturn theItems.stream().filter(i -> {\n+\t\t\treturn predicate.test(i, theItem);\n+\t\t}).findFirst().isPresent();\n \t}\n \n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n+\tprivate void cloneAllExternalEidsIntoNewSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource, IBase theNewSourceResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n \n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\tfor (IBase base : sourceResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n+\t\t\t\t\tcloneEidIntoResource(theSourceResourceIdentifier, base, theNewSourceResource);\n+\t\t\t\t} else if (ourLog.isDebugEnabled()) {\n+\t\t\t\t\tourLog.debug(String.format(\"System %s differs from system in the EMPI rules %s\", baseSystem, empiSystem));\n \t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n \t\t}\n \t}\n \n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n \t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n \t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n \t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n+\t * <p>\n \t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n \t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n+\t * @param theSourceResource The person to update the external EID on.\n+\t * @param theTargetResource The target we will retrieve the external EID from.\n \t * @return the modified {@link IBaseResource} representing the person.\n \t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n+\tpublic IAnyResource updateSourceResourceExternalEidFromTargetResource(IAnyResource theSourceResource, IAnyResource", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nindex 46f2a8c4b7..675dc6c4cf 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n", "chunk": "@@ -82,261 +73,375 @@ public class PersonHelper {\n \t}\n \n \t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n+\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n \t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t * @param thePerson the Person to extract link IDs from.\n+\t * @return a Stream of {@link IIdType}.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n-\n-\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n-\n-\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n-\t\tEmpiUtil.setGoldenResource(newSourceResource);\n+\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\treturn personR4.getLink().stream()\n+\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n+\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n+\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\treturn personStu3.getLink().stream()\n+\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n+\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n+\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\treturn (T) newSourceResource;\n+\t/**\n+\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t *\n+\t * @param thePerson     The person to check\n+\t * @param theResourceId The ID to check.\n+\t * @return A boolean indicating whether or not there was a contained link.\n+\t */\n+\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n+\t\tStream<IIdType> links = getLinkIds(thePerson);\n+\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n \t}\n \n \t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n+\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n+\t * @param thePerson The person who's link needs to be updated.\n+\t * @param theResourceId The target of the link\n+\t * @param canonicalAssuranceLevel The level of certainty of this link.\n+\t * @param theEmpiTransactionContext\n \t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewSourceResource, BaseRuntimeChildDefinition theSourceResourceIdentifier, IAnyResource theTargetResource) {\n+\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewSourceResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n+\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n+\t\tif (theCanonicalAssuranceLevel == null) {\n+\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n \t\t\treturn;\n \t\t}\n \n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheSourceResourceIdentifier.getMutator().addValue(theNewSourceResource, toId(hapiEid));\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n+\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n+\t\t} else {\n+\t\t\tperson.getLink().stream()\n+\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.ifPresent(link -> {\n+\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n+\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n+\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n+\t}\n \n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n \t}\n \n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (canonicalAssuranceLevel == null) {\n+\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tPerson person = (Person) thePerson;\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n+\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n+\t\t} else {\n+\t\t\tperson.getLink().stream()\n+\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.ifPresent(link -> {\n+\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n+\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n+\t\t\t\t});\n+\t\t}\n \t}\n \n+\n \t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n+\t * @param thePerson The person to remove the link from.\n+\t * @param theResourceId The target ID to remove.\n+\t * @param theEmpiTransactionContext\n \t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson person = (Person) thePerson;\n+\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n+\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n \t}\n \n \t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n+\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo Resource to clone the specified filed to\n-\t * @param field Field name to be copied\n+\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n+\t * @return the Person that is created.\n \t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue: theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n+\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tif (eidsToApply.isEmpty()) {\n+\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n+\t\t}\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = new Person();\n+\t\t\t\tpersonR4.setActive(true);\n+\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n+\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n+\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n+\t\t\t\treturn personR4;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n+\t\t\t\tpersonDstu3.setActive(true);\n+\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n+\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n+\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n+\t\t\t\treturn personDstu3;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n \n-\t\t\ttheToFieldValues.add(newFieldValue);\n+\t/**\n+\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n+\t *\n+\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n+\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n+\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n+\t *\n+\t */\n+\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n \t}\n \n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n+\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n+\t\tPerson person = (Person) thePerson;\n+\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n+\t\t\tcase \"Patient\":\n+\t\t\t\tPatient patient = (Patient) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(patient.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(patient.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase \"Practitioner\":\n+\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(practitioner.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(practitioner.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n+\t\t}\n \t}\n \n-\tprivate void cloneAllExternalEidsIntoNewSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource, IBase theNewSourceResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n+\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n+\t\t\tcase \"Patient\":\n+\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n \n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tcloneEidIntoResource(theSourceResourceIdentifier, base, theNewSourceResource);\n-\t\t\t\t} else if (ourLog.isDebugEnabled()) {\n-\t\t\t\t\tourLog.debug(String.format(\"System %s differs from system in the EMPI rules %s\", baseSystem, empiSystem));\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(patient.getName());\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(patient.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n+\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n+\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase \"Practitioner\":\n+\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n+\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n+\t\t\t\t\tperson.setName(practitioner.getName());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n+\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n+\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n+\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n+\t\t\t\t\tperson.setGender(practitioner.getGender());\n+\t\t\t\t}\n+\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n+\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n \t\t}\n \t}\n \n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n+\tprivate IBaseCoding buildEmpiManagedTag() {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tCoding empiManagedCoding = new Coding();\n+\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n+\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n+\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\t\t\treturn empiManagedCoding;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n+\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n+\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n+\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n+\t\t\t\treturn empiManagedCodingDstu3;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\n \t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n \t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n \t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n+\t *\n \t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n \t *\n-\t * @param theSourceResource The person to update the external EID on.\n-\t * @param theTargetResource The target we will retrieve the external EID from.\n+\t * @param thePerson     The person to update the external EID on.\n+\t * @param theEmpiTarget The target we will retrieve the external EID from.\n \t * @return the modified {@link IBaseResource} representing the person.\n \t */\n-\tpublic IAnyResource updateSourceResourceExternalEidFromTargetResource(IAnyResource theSourceResource, IAnyResource\n-\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n \t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(theSourceResource);\n+\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n+\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n+\n \n \t\tif (!incomingTargetEid.isEmpty()) {\n \t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, incomingTargetEid);\n+\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n+\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n \t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite person, as this EID is already present\");\n+\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n \t\t\t} else {\n \t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n \t\t\t}\n \t\t}\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theSourceResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theSourceResource);\n-\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, theNewEid);\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tif (ourLog.isDebugEnabled()) {\n-\t\t\t\t\t\tourLog.debug(String.format(\"Found EID confirming to EMPI rules %s. It should not be copied, skipping\", baseSystem));\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\t\ttheSourceResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase sourceResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, sourceResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(sourceResourceNewIdentifier);\n-\t\t}\n-\n-\t\tsourceResourceIdentifiers.clear();\n-\t\tsourceResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theSourceResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theSourceResource);\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheSourceResource(sourceResourceIdentifier, theSourceResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Source Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToSourceResourceIfAbsent(IBaseResource theSourceResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n-\t\tList<CanonicalEID> sourceResourceExternalEids = myEIDHelper.getExternalEid(theSourceResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n-\t\t\tif (sourceResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tcloneEidIntoResource(theSourceResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n+\t\treturn thePerson;\n \t}\n \n-\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) eid.toR4();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) eid.toDSTU3();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(thePerson);\n+\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n+\t\treturn thePerson;\n \t}\n \n-\n-\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n+\tprivate void clearExternalEids(IBaseResource thePerson) {\n \t\tswitch (myFhirContext.getVersion().getVersion()) {\n \t\t\tcase R4:\n-\t\t\t\treturn (T) new BooleanType(theFlag);\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\t\t\tbreak;\n \t\t\tcase DSTU3:\n-\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n \t}\n \n-\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n+\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n \t\tswitch (myFhirContext.getVersion().getVersion()) {\n \t\t\tcase R4:\n-\t\t\t\treturn ((BooleanType)theFlag).booleanValue();\n+\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n+\t\t\t\tbreak;\n \t\t\tcase DSTU3:\n-\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType)theFlag).booleanValue();\n+\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\ndeleted file mode 100644\nindex 675dc6c4cf..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,660 +0,0 @@\n-package ca.uhn.fhir.empi.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n-import org.hl7.fhir.r4.model.ContactPoint;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.Nonnull;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-@Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n-\t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n-\t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n-\n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\treturn;\n-\t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n-\t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n-\t *\n-\t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n-\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n-\t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the person.\n-\t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n-\n-\n-\t\tif (!incomingTargetEid.isEmpty()) {\n-\t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n-\t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n-\t\t\t}\n-\t\t}\n-\t\treturn thePerson;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(thePerson);\n-\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n-\t\treturn thePerson;\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * To avoid adding duplicate\n-\t *\n-\t * @param thePerson\n-\t * @param theIdentifier\n-\t */\n-\tprivate void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, org.hl7.fhir.dstu3.model.Identifier theIdentifier) {\n-\t\tOptional<org.hl7.fhir.dstu3.model.Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tpublic void mergePersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tPerson fromPerson = (Person) theFromPerson;\n-\t\tPerson toPerson = (Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, HumanName.class, Person::getName, HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Identifier.class, Person::getIdentifier, Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Address.class, Person::getAddress, Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, ContactPoint.class, Person::getTelecom, ContactPoint::equalsDeep);\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\tprivate <P,T> void mergeElementList(P fromPerson, P toPerson, Class<T> theBase, Function<P, List<T>> theGetList, BiPredicate<T, T> theEquals) {\n-\t\tList<T> fromList = theGetList.apply(fromPerson);\n-\t\tList<T> toList = theGetList.apply(toPerson);\n-\t\tList<T> itemsToAdd = new ArrayList<>();\n-\n-\t\tfor (T fromItem : fromList) {\n-\t\t\tif (toList.stream().noneMatch(t -> theEquals.test(fromItem, t))) {\n-\t\t\t\titemsToAdd.add(fromItem);\n-\t\t\t}\n-\t\t}\n-\t\ttoList.addAll(itemsToAdd);\n-\t}\n-\n-\tprivate void mergeDstu3PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\torg.hl7.fhir.dstu3.model.Person fromPerson = (org.hl7.fhir.dstu3.model.Person) theFromPerson;\n-\t\torg.hl7.fhir.dstu3.model.Person toPerson = (org.hl7.fhir.dstu3.model.Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.HumanName.class, org.hl7.fhir.dstu3.model.Person::getName, org.hl7.fhir.dstu3.model.HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Identifier.class, org.hl7.fhir.dstu3.model.Person::getIdentifier, org.hl7.fhir.dstu3.model.Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Address.class, org.hl7.fhir.dstu3.model.Person::getAddress, org.hl7.fhir.dstu3.model.Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.ContactPoint.class, org.hl7.fhir.dstu3.model.Person::getTelecom, org.hl7.fhir.dstu3.model.ContactPoint::equalsDeep);\n-\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a Patient that has a Person with an official EID, but\n-\t * the incoming resource also has an EID that does not match.\n-\t *\n-\t * @param theExistingPerson\n-\t * @param theComparingPerson\n-\t * @return\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingPerson, IAnyResource theComparingPerson) {\n-\t\tList<CanonicalEID> externalEidsPerson = myEIDHelper.getExternalEid(theExistingPerson);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingPerson);\n-\t\treturn !externalEidsPerson.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsPerson);\n-\t}\n-\n-\tpublic IBaseBackboneElement newPersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn newR4PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn newDstu3PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement newR4PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tPerson.PersonLinkComponent retval = new Person.PersonLinkComponent();\n-\t\tretval.setTarget(new Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toR4());\n-\t\treturn retval;\n-\t}\n-\n-\tprivate IBaseBackboneElement newDstu3PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\torg.hl7.fhir.dstu3.model.Person.PersonLinkComponent retval = new org.hl7.fhir.dstu3.model.Person.PersonLinkComponent();\n-\t\tretval.setTarget(new org.hl7.fhir.dstu3.model.Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toDstu3());\n-\t\treturn retval;\n-\t}\n-\n-\tpublic void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement> theNewLinks) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tsetLinksR4(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tsetLinksDstu3(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person)thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person)thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-   public void updatePersonFromNewlyCreatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, false);\n-   }\n-\n-\tpublic void updatePersonFromUpdatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, true);\n-\t}\n-\n-\tpublic int getLinkCount(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().size();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().size();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdatePersonExternalEidFromEmpiTarget(thePerson, theResource, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivatePerson(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonStu3.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn !personR4.getActive();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn !personStu3.getActive();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMTU2Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525431567", "body": "Rename to ResourceHelper or GoldenResourceHelper?", "bodyText": "Rename to ResourceHelper or GoldenResourceHelper?", "bodyHTML": "<p dir=\"auto\">Rename to ResourceHelper or GoldenResourceHelper?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:31:05Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -20,51 +20,60 @@\n  * #L%\n  */\n \n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n import ca.uhn.fhir.empi.log.Logs;\n import ca.uhn.fhir.empi.model.CanonicalEID;\n import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n+import ca.uhn.fhir.empi.model.MdmTransactionContext;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.util.FhirTerser;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n+import org.hl7.fhir.r4.model.BooleanType;\n import org.hl7.fhir.r4.model.ContactPoint;\n import org.hl7.fhir.r4.model.HumanName;\n import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n import org.hl7.fhir.r4.model.Reference;\n import org.slf4j.Logger;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n-import javax.annotation.Nonnull;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.function.BiPredicate;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n \n @Service\n public class PersonHelper {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nsimilarity index 95%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nrename to hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 46f2a8c4b7..fa3d4d1c05 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n", "chunk": "@@ -62,22 +61,21 @@ import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n \n @Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class GoldenResourceHelper {\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n \n \t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \n-\tprivate IEmpiLinkQuerySvc queyr;\n \n \tprivate final FhirContext myFhirContext;\n \n \t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MzI0Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525443243", "body": "rename person to golden resource", "bodyText": "rename person to golden resource", "bodyHTML": "<p dir=\"auto\">rename person to golden resource</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:42:11Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -458,26 +355,20 @@ private void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, or\n \t\t}\n \t}\n \n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n+\tpublic void mergeFields(IBaseResource theFromPerson, IBaseResource theToPerson) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nindex 46f2a8c4b7..675dc6c4cf 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n", "chunk": "@@ -355,20 +459,26 @@ public class PersonHelper {\n \t\t}\n \t}\n \n-\tpublic void mergeFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\t//\tTODO NG - Revisit when merge rules are defined\n-\t\tcloneCompositeField(theFromPerson, theToPerson, FIELD_NAME_IDENTIFIER);\n+\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n+\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n+\t\tif (first.isPresent()) {\n+\t\t\treturn;\n+\t\t} else {\n+\t\t\tthePerson.addIdentifier(theIdentifier);\n+\t\t}\n+\t}\n \n-//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-//\t\t\tcase R4:\n-//\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-//\t\t\t\tbreak;\n-//\t\t\tcase DSTU3:\n-//\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-//\t\t\t\tbreak;\n-//\t\t\tdefault:\n-//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-//\t\t}\n+\tpublic void mergePersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n \t}\n \n \tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\ndeleted file mode 100644\nindex 675dc6c4cf..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,660 +0,0 @@\n-package ca.uhn.fhir.empi.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n-import org.hl7.fhir.r4.model.ContactPoint;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.Nonnull;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-@Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n-\t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n-\t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n-\n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\treturn;\n-\t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n-\t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n-\t *\n-\t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n-\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n-\t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the person.\n-\t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n-\n-\n-\t\tif (!incomingTargetEid.isEmpty()) {\n-\t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n-\t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n-\t\t\t}\n-\t\t}\n-\t\treturn thePerson;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(thePerson);\n-\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n-\t\treturn thePerson;\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * To avoid adding duplicate\n-\t *\n-\t * @param thePerson\n-\t * @param theIdentifier\n-\t */\n-\tprivate void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, org.hl7.fhir.dstu3.model.Identifier theIdentifier) {\n-\t\tOptional<org.hl7.fhir.dstu3.model.Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tpublic void mergePersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tPerson fromPerson = (Person) theFromPerson;\n-\t\tPerson toPerson = (Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, HumanName.class, Person::getName, HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Identifier.class, Person::getIdentifier, Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Address.class, Person::getAddress, Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, ContactPoint.class, Person::getTelecom, ContactPoint::equalsDeep);\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\tprivate <P,T> void mergeElementList(P fromPerson, P toPerson, Class<T> theBase, Function<P, List<T>> theGetList, BiPredicate<T, T> theEquals) {\n-\t\tList<T> fromList = theGetList.apply(fromPerson);\n-\t\tList<T> toList = theGetList.apply(toPerson);\n-\t\tList<T> itemsToAdd = new ArrayList<>();\n-\n-\t\tfor (T fromItem : fromList) {\n-\t\t\tif (toList.stream().noneMatch(t -> theEquals.test(fromItem, t))) {\n-\t\t\t\titemsToAdd.add(fromItem);\n-\t\t\t}\n-\t\t}\n-\t\ttoList.addAll(itemsToAdd);\n-\t}\n-\n-\tprivate void mergeDstu3PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\torg.hl7.fhir.dstu3.model.Person fromPerson = (org.hl7.fhir.dstu3.model.Person) theFromPerson;\n-\t\torg.hl7.fhir.dstu3.model.Person toPerson = (org.hl7.fhir.dstu3.model.Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.HumanName.class, org.hl7.fhir.dstu3.model.Person::getName, org.hl7.fhir.dstu3.model.HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Identifier.class, org.hl7.fhir.dstu3.model.Person::getIdentifier, org.hl7.fhir.dstu3.model.Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Address.class, org.hl7.fhir.dstu3.model.Person::getAddress, org.hl7.fhir.dstu3.model.Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.ContactPoint.class, org.hl7.fhir.dstu3.model.Person::getTelecom, org.hl7.fhir.dstu3.model.ContactPoint::equalsDeep);\n-\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a Patient that has a Person with an official EID, but\n-\t * the incoming resource also has an EID that does not match.\n-\t *\n-\t * @param theExistingPerson\n-\t * @param theComparingPerson\n-\t * @return\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingPerson, IAnyResource theComparingPerson) {\n-\t\tList<CanonicalEID> externalEidsPerson = myEIDHelper.getExternalEid(theExistingPerson);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingPerson);\n-\t\treturn !externalEidsPerson.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsPerson);\n-\t}\n-\n-\tpublic IBaseBackboneElement newPersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn newR4PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn newDstu3PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement newR4PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tPerson.PersonLinkComponent retval = new Person.PersonLinkComponent();\n-\t\tretval.setTarget(new Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toR4());\n-\t\treturn retval;\n-\t}\n-\n-\tprivate IBaseBackboneElement newDstu3PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\torg.hl7.fhir.dstu3.model.Person.PersonLinkComponent retval = new org.hl7.fhir.dstu3.model.Person.PersonLinkComponent();\n-\t\tretval.setTarget(new org.hl7.fhir.dstu3.model.Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toDstu3());\n-\t\treturn retval;\n-\t}\n-\n-\tpublic void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement> theNewLinks) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tsetLinksR4(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tsetLinksDstu3(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person)thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person)thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-   public void updatePersonFromNewlyCreatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, false);\n-   }\n-\n-\tpublic void updatePersonFromUpdatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, true);\n-\t}\n-\n-\tpublic int getLinkCount(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().size();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().size();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdatePersonExternalEidFromEmpiTarget(thePerson, theResource, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivatePerson(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonStu3.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn !personR4.getActive();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn !personStu3.getActive();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0Mzc3OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525443778", "body": "This can be removed?", "bodyText": "This can be removed?", "bodyHTML": "<p dir=\"auto\">This can be removed?</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:42:36Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -585,75 +479,35 @@ public void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement>\n \t}\n \n \tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nindex 46f2a8c4b7..675dc6c4cf 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n", "chunk": "@@ -479,35 +586,75 @@ public class PersonHelper {\n \t}\n \n \tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>) (List<?>) theLinks;\n+\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person)thePersonResource;\n+\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>)(List<?>)theLinks;\n \t\tperson.setLink(links);\n \t}\n \n \tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person) thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>) (List<?>) theLinks;\n+\t\tPerson person = (Person)thePersonResource;\n+\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>)(List<?>)theLinks;\n \t\tperson.setLink(links);\n \t}\n \n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+   public void updatePersonFromNewlyCreatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, false);\n+   }\n+\n+\tpublic void updatePersonFromUpdatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, true);\n+\t}\n+\n+\tpublic int getLinkCount(IAnyResource thePerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\treturn personR4.getLink().size();\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\treturn personStu3.getLink().size();\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n+\t}\n+\n+\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n \t\tourLog.debug(theMessage);\n \t}\n \n-\tpublic void handleExternalEidAddition(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext\n-\t\t\t  theMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n+\tpublic void handleExternalEidAddition(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateSourceResourceExternalEidFromTargetResource(theSourceResource, theTargetResource, theMdmTransactionContext);\n+\t\t\tupdatePersonExternalEidFromEmpiTarget(thePerson, theResource, theEmpiTransactionContext);\n \t\t}\n \t}\n \n-\tpublic void deactivateResource(IAnyResource theResource) {\n-\t\tEmpiUtil.setGoldenResourceRedirected(theResource);\n+\tpublic void deactivatePerson(IAnyResource thePerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\tpersonR4.setActive(false);\n+\t\t\t\tbreak;\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\tpersonStu3.setActive(false);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n \t}\n \n-\tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n-\t\treturn EmpiUtil.isGoldenRecordRedirected(theGoldenResource);\n+\tpublic boolean isDeactivated(IBaseResource thePerson) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\tPerson personR4 = (Person) thePerson;\n+\t\t\t\treturn !personR4.getActive();\n+\t\t\tcase DSTU3:\n+\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n+\t\t\t\treturn !personStu3.getActive();\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t\t}\n \t}\n }\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\ndeleted file mode 100644\nindex 675dc6c4cf..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,660 +0,0 @@\n-package ca.uhn.fhir.empi.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n-import org.hl7.fhir.r4.model.ContactPoint;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.annotation.Nonnull;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-@Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n-\t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n-\t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n-\n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n-\n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\treturn;\n-\t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n-\t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tString eidSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n-\t *\n-\t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n-\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n-\t}\n-\n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n-\t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the person.\n-\t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theEmpiTarget);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(thePerson);\n-\n-\n-\t\tif (!incomingTargetEid.isEmpty()) {\n-\t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"Incoming resource:\" + theEmpiTarget.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Person, as this person does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToPersonIfAbsent(thePerson, incomingTargetEid);\n-\t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theEmpiTransactionContext, \"incoming resource:\" + theEmpiTarget.getIdElement().toVersionless() + \" with EIDs \"+incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))  +\" does not need to overwrite person, as this EID is already present\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n-\t\t\t}\n-\t\t}\n-\t\treturn thePerson;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource thePerson, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(thePerson);\n-\t\taddCanonicalEidsToPersonIfAbsent(thePerson, theNewEid);\n-\t\treturn thePerson;\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void addCanonicalEidsToPersonIfAbsent(IBaseResource thePerson, List<CanonicalEID> theIncomingTargetEid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((Person) thePerson, eid.toR4()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\ttheIncomingTargetEid.forEach(eid -> addIdentifierIfAbsent((org.hl7.fhir.dstu3.model.Person) thePerson, eid.toDSTU3()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * To avoid adding duplicate\n-\t *\n-\t * @param thePerson\n-\t * @param theIdentifier\n-\t */\n-\tprivate void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, org.hl7.fhir.dstu3.model.Identifier theIdentifier) {\n-\t\tOptional<org.hl7.fhir.dstu3.model.Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tpublic void mergePersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tPerson fromPerson = (Person) theFromPerson;\n-\t\tPerson toPerson = (Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, HumanName.class, Person::getName, HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Identifier.class, Person::getIdentifier, Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Address.class, Person::getAddress, Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, ContactPoint.class, Person::getTelecom, ContactPoint::equalsDeep);\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\tprivate <P,T> void mergeElementList(P fromPerson, P toPerson, Class<T> theBase, Function<P, List<T>> theGetList, BiPredicate<T, T> theEquals) {\n-\t\tList<T> fromList = theGetList.apply(fromPerson);\n-\t\tList<T> toList = theGetList.apply(toPerson);\n-\t\tList<T> itemsToAdd = new ArrayList<>();\n-\n-\t\tfor (T fromItem : fromList) {\n-\t\t\tif (toList.stream().noneMatch(t -> theEquals.test(fromItem, t))) {\n-\t\t\t\titemsToAdd.add(fromItem);\n-\t\t\t}\n-\t\t}\n-\t\ttoList.addAll(itemsToAdd);\n-\t}\n-\n-\tprivate void mergeDstu3PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\torg.hl7.fhir.dstu3.model.Person fromPerson = (org.hl7.fhir.dstu3.model.Person) theFromPerson;\n-\t\torg.hl7.fhir.dstu3.model.Person toPerson = (org.hl7.fhir.dstu3.model.Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.HumanName.class, org.hl7.fhir.dstu3.model.Person::getName, org.hl7.fhir.dstu3.model.HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Identifier.class, org.hl7.fhir.dstu3.model.Person::getIdentifier, org.hl7.fhir.dstu3.model.Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Address.class, org.hl7.fhir.dstu3.model.Person::getAddress, org.hl7.fhir.dstu3.model.Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.ContactPoint.class, org.hl7.fhir.dstu3.model.Person::getTelecom, org.hl7.fhir.dstu3.model.ContactPoint::equalsDeep);\n-\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a Patient that has a Person with an official EID, but\n-\t * the incoming resource also has an EID that does not match.\n-\t *\n-\t * @param theExistingPerson\n-\t * @param theComparingPerson\n-\t * @return\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingPerson, IAnyResource theComparingPerson) {\n-\t\tList<CanonicalEID> externalEidsPerson = myEIDHelper.getExternalEid(theExistingPerson);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingPerson);\n-\t\treturn !externalEidsPerson.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsPerson);\n-\t}\n-\n-\tpublic IBaseBackboneElement newPersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn newR4PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn newDstu3PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement newR4PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tPerson.PersonLinkComponent retval = new Person.PersonLinkComponent();\n-\t\tretval.setTarget(new Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toR4());\n-\t\treturn retval;\n-\t}\n-\n-\tprivate IBaseBackboneElement newDstu3PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\torg.hl7.fhir.dstu3.model.Person.PersonLinkComponent retval = new org.hl7.fhir.dstu3.model.Person.PersonLinkComponent();\n-\t\tretval.setTarget(new org.hl7.fhir.dstu3.model.Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toDstu3());\n-\t\treturn retval;\n-\t}\n-\n-\tpublic void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement> theNewLinks) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tsetLinksR4(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tsetLinksDstu3(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person)thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person)thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>)(List<?>)theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-   public void updatePersonFromNewlyCreatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, false);\n-   }\n-\n-\tpublic void updatePersonFromUpdatedEmpiTarget(IBaseResource thePerson, IBaseResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tcopyEmpiTargetDataIntoPerson(theResource, thePerson, true);\n-\t}\n-\n-\tpublic int getLinkCount(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().size();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().size();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void log(EmpiTransactionContext theEmpiTransactionContext, String theMessage) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdatePersonExternalEidFromEmpiTarget(thePerson, theResource, theEmpiTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivatePerson(IAnyResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\tpersonR4.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonStu3.setActive(false);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn !personR4.getActive();\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn !personStu3.getActive();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0OTg4Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525449883", "body": "This test can be removed - linking is done via EmpiLink class ", "bodyText": "This test can be removed - linking is done via EmpiLink class", "bodyHTML": "<p dir=\"auto\">This test can be removed - linking is done via EmpiLink class</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:47:25Z", "path": "hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java", "diffHunk": "@@ -33,52 +35,55 @@ public void testGetLinks() {\n \t\tperson.addLink().setTarget(new Reference(PATIENT_1));\n \t\tperson.addLink().setTarget(new Reference(PATIENT_2));\n \n-\t\t{\n-\t\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-\t\t\tassertEquals(2, links.size());\n-\t\t\tassertEquals(PATIENT_1, links.get(0).getValue());\n-\t\t\tassertEquals(PATIENT_2, links.get(1).getValue());\n-\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_1)));\n-\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_2)));\n-\t\t\tassertFalse(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_BAD)));\n-\t\t}\n-\n-\t\t{\n-\t\t\tMY_PERSON_HELPER.removeLink(person, new IdDt(PATIENT_1), createDummyContext());\n-\t\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-\t\t\tassertEquals(1, links.size());\n-\t\t\tassertEquals(PATIENT_2, links.get(0).getValue());\n+\t\t// TODO NG - check if we need similar functionality in JPA DAO", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java b/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/mdm/svc/GoldenResourceHelperDSTU3Test.java\nsimilarity index 86%\nrename from hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java\nrename to hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/mdm/svc/GoldenResourceHelperDSTU3Test.java\nindex 98ef7a6f26..175e78b70d 100644\n--- a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java\n+++ b/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/mdm/svc/GoldenResourceHelperDSTU3Test.java\n", "chunk": "@@ -11,23 +9,20 @@ import org.junit.jupiter.api.Test;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n-import static ca.uhn.fhir.empi.util.TestUtils.createDummyContext;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.core.Is.is;\n-import static org.hamcrest.core.IsEqual.equalTo;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-public class PersonHelperDSTU3Test {\n+public class GoldenResourceHelperDSTU3Test {\n \n \tpublic static final FhirContext ourFhirContext = FhirContext.forDstu3();\n \tpublic static final String PATIENT_1 = \"Patient/1\";\n \tpublic static final String PATIENT_2 = \"Patient/2\";\n \tpublic static final String PATIENT_BAD = \"Patient/BAD\";\n-\tpublic static final PersonHelper MY_PERSON_HELPER = new PersonHelper(ourFhirContext);\n+\tpublic static final GoldenResourceHelper MY_PERSON_HELPER = new GoldenResourceHelper(ourFhirContext);\n \n \t@Test\n \tpublic void testGetLinks() {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MDI0NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525450245", "body": "Obsolete test", "bodyText": "Obsolete test", "bodyHTML": "<p dir=\"auto\">Obsolete test</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:47:44Z", "path": "hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java", "diffHunk": "@@ -30,52 +30,61 @@\n \n \t@Test\n \tpublic void testGetLinks() {\n+\t\t// TODO NG - Revisit this code checking if we need to keep it - if yes - push to the JPA level, delete otherwise", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "changed_code": [{"header": "diff --git a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java b/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/mdm/svc/GoldenResourceHelperR4Test.java\nsimilarity index 85%\nrename from hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java\nrename to hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/mdm/svc/GoldenResourceHelperR4Test.java\nindex 1dff85a5fd..9f89314151 100644\n--- a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java\n+++ b/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/mdm/svc/GoldenResourceHelperR4Test.java\n", "chunk": "@@ -20,13 +13,13 @@ import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-public class PersonHelperR4Test {\n+public class GoldenResourceHelperR4Test {\n \tpublic static final FhirContext ourFhirContext = FhirContext.forR4();\n \tpublic static final String PATIENT_1 = \"Patient/1\";\n \tpublic static final String PATIENT_2 = \"Patient/2\";\n \tpublic static final String PATIENT_BAD = \"Patient/BAD\";\n \n-\tpublic static final PersonHelper MY_PERSON_HELPER = new PersonHelper(ourFhirContext);\n+\tpublic static final GoldenResourceHelper MY_PERSON_HELPER = new GoldenResourceHelper(ourFhirContext);\n \n \t@Test\n \tpublic void testGetLinks() {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MTIyNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525451226", "body": "Rename to MDM", "bodyText": "Rename to MDM", "bodyHTML": "<p dir=\"auto\">Rename to MDM</p>", "author": "nvg-smile", "createdAt": "2020-11-17T19:48:38Z", "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java", "diffHunk": "@@ -62,30 +62,35 @@\n \t * EMPI Operations\n \t */\n \tpublic static final String EMPI_MATCH = \"$match\";\n-\tpublic static final String EMPI_MATCH_RESOURCE = \"resource\";\n+\t//TODO GGG MDM: implement a server-level MDM match to complement the FHIR-spec $match for /Patient\n+\tpublic static final String MDM_MATCH = \"$mdm-match\";\n+\tpublic static final String MDM_MATCH_RESOURCE = \"resource\";\n+\tpublic static final String MDM_RESOURCE_TYPE = \"resourceType\";\n \n-\tpublic static final String EMPI_MERGE_PERSONS = \"$empi-merge-persons\";\n-\tpublic static final String EMPI_MERGE_PERSONS_FROM_PERSON_ID = \"fromPersonId\";\n-\tpublic static final String EMPI_MERGE_PERSONS_TO_PERSON_ID = \"toPersonId\";\n+\t//TODO GGG MDM: rename all these vars\n+\tpublic static final String MDM_MERGE_GOLDEN_RESOURCES = \"$mdm-merge-golden-resources\";\n+\tpublic static final String MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID = \"fromGoldenResourceId\";\n+\tpublic static final String MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID = \"toGoldenResourceId\";\n \n-\tpublic static final String EMPI_UPDATE_LINK = \"$empi-update-link\";\n-\tpublic static final String EMPI_UPDATE_LINK_PERSON_ID = \"personId\";\n-\tpublic static final String EMPI_UPDATE_LINK_TARGET_ID = \"targetId\";\n-\tpublic static final String EMPI_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String MDM_UPDATE_LINK = \"$mdm-update-link\";\n+\tpublic static final String MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n+\tpublic static final String MDM_UPDATE_LINK_RESOURCE_ID = \"resourceId\";\n+\tpublic static final String MDM_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n \n-\tpublic static final String EMPI_QUERY_LINKS = \"$empi-query-links\";\n-\tpublic static final String EMPI_QUERY_LINKS_PERSON_ID = \"personId\";\n-\tpublic static final String EMPI_QUERY_LINKS_TARGET_ID = \"targetId\";\n+\tpublic static final String MDM_QUERY_LINKS = \"$mdm-query-links\";\n+\tpublic static final String MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n+\tpublic static final String MDM_QUERY_LINKS_RESOURCE_ID = \"resourceId\";\n \tpublic static final String EMPI_QUERY_LINKS_MATCH_RESULT = \"matchResult\";", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3209faf2fb2090b3590431dba77c27db8a1a4baa", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 05a52cea31..3de765c250 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -80,11 +80,11 @@ public class ProviderConstants {\n \tpublic static final String MDM_QUERY_LINKS = \"$mdm-query-links\";\n \tpublic static final String MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n \tpublic static final String MDM_QUERY_LINKS_RESOURCE_ID = \"resourceId\";\n-\tpublic static final String EMPI_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n-\tpublic static final String EMPI_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n+\tpublic static final String MDM_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String MDM_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n \n-\tpublic static final String MDM_DUPLICATE_GOLDEN_RESOURCES = \"$empi-duplicate-golden-resources\";\n-\tpublic static final String MDM_NOT_DUPLICATE = \"$empi-not-duplicate\";\n+\tpublic static final String MDM_DUPLICATE_GOLDEN_RESOURCES = \"$mdm-duplicate-golden-resources\";\n+\tpublic static final String MDM_NOT_DUPLICATE = \"$mdm-not-duplicate\";\n \n \tpublic static final String MDM_CLEAR = \"$mdm-clear\";\n \tpublic static final String MDM_CLEAR_TARGET_TYPE = \"targetType\";\n", "next_change": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 3de765c250..7a9f9304d4 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -87,7 +87,7 @@ public class ProviderConstants {\n \tpublic static final String MDM_NOT_DUPLICATE = \"$mdm-not-duplicate\";\n \n \tpublic static final String MDM_CLEAR = \"$mdm-clear\";\n-\tpublic static final String MDM_CLEAR_TARGET_TYPE = \"targetType\";\n+\tpublic static final String MDM_CLEAR_SOURCE_TYPE = \"sourceType\";\n \tpublic static final String OPERATION_MDM_SUBMIT = \"$mdm-submit\";\n \tpublic static final String MDM_BATCH_RUN_CRITERIA = \"criteria\" ;\n \tpublic static final String OPERATION_MDM_BATCH_RUN_OUT_PARAM_SUBMIT_COUNT = \"submitted\" ;\n", "next_change": {"commit": "0938d72b51c72ff5b0fe2aaf497ab985c8a20f3e", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 7a9f9304d4..011cd35a8a 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -62,35 +62,30 @@ public class ProviderConstants {\n \t * EMPI Operations\n \t */\n \tpublic static final String EMPI_MATCH = \"$match\";\n-\t//TODO GGG MDM: implement a server-level MDM match to complement the FHIR-spec $match for /Patient\n-\tpublic static final String MDM_MATCH = \"$mdm-match\";\n-\tpublic static final String MDM_MATCH_RESOURCE = \"resource\";\n-\tpublic static final String MDM_RESOURCE_TYPE = \"resourceType\";\n+\tpublic static final String EMPI_MATCH_RESOURCE = \"resource\";\n \n-\t//TODO GGG MDM: rename all these vars\n-\tpublic static final String MDM_MERGE_GOLDEN_RESOURCES = \"$mdm-merge-golden-resources\";\n-\tpublic static final String MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID = \"fromGoldenResourceId\";\n-\tpublic static final String MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID = \"toGoldenResourceId\";\n+\tpublic static final String EMPI_MERGE_PERSONS = \"$empi-merge-persons\";\n+\tpublic static final String EMPI_MERGE_PERSONS_FROM_PERSON_ID = \"fromPersonId\";\n+\tpublic static final String EMPI_MERGE_PERSONS_TO_PERSON_ID = \"toPersonId\";\n \n-\tpublic static final String MDM_UPDATE_LINK = \"$mdm-update-link\";\n-\tpublic static final String MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n-\tpublic static final String MDM_UPDATE_LINK_RESOURCE_ID = \"resourceId\";\n-\tpublic static final String MDM_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String EMPI_UPDATE_LINK = \"$empi-update-link\";\n+\tpublic static final String EMPI_UPDATE_LINK_PERSON_ID = \"personId\";\n+\tpublic static final String EMPI_UPDATE_LINK_TARGET_ID = \"targetId\";\n+\tpublic static final String EMPI_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n \n-\tpublic static final String MDM_QUERY_LINKS = \"$mdm-query-links\";\n-\tpublic static final String MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n-\tpublic static final String MDM_QUERY_LINKS_RESOURCE_ID = \"resourceId\";\n-\tpublic static final String MDM_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n-\tpublic static final String MDM_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n+\tpublic static final String EMPI_QUERY_LINKS = \"$empi-query-links\";\n+\tpublic static final String EMPI_QUERY_LINKS_PERSON_ID = \"personId\";\n+\tpublic static final String EMPI_QUERY_LINKS_TARGET_ID = \"targetId\";\n+\tpublic static final String EMPI_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String EMPI_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n \n-\tpublic static final String MDM_DUPLICATE_GOLDEN_RESOURCES = \"$mdm-duplicate-golden-resources\";\n-\tpublic static final String MDM_NOT_DUPLICATE = \"$mdm-not-duplicate\";\n+\tpublic static final String EMPI_DUPLICATE_PERSONS = \"$empi-duplicate-persons\";\n+\tpublic static final String EMPI_NOT_DUPLICATE = \"$empi-not-duplicate\";\n \n-\tpublic static final String MDM_CLEAR = \"$mdm-clear\";\n-\tpublic static final String MDM_CLEAR_SOURCE_TYPE = \"sourceType\";\n-\tpublic static final String OPERATION_MDM_SUBMIT = \"$mdm-submit\";\n-\tpublic static final String MDM_BATCH_RUN_CRITERIA = \"criteria\" ;\n-\tpublic static final String OPERATION_MDM_BATCH_RUN_OUT_PARAM_SUBMIT_COUNT = \"submitted\" ;\n-   public static final String OPERATION_MDM_CLEAR_OUT_PARAM_DELETED_COUNT = \"deleted\";\n-\tpublic static final String MDM_BATCH_RUN_RESOURCE_TYPE = \"resourceType\";\n+\tpublic static final String EMPI_CLEAR = \"$empi-clear\";\n+\tpublic static final String EMPI_CLEAR_TARGET_TYPE = \"targetType\";\n+\tpublic static final String OPERATION_EMPI_SUBMIT = \"$empi-submit\";\n+\tpublic static final String EMPI_BATCH_RUN_CRITERIA= \"criteria\" ;\n+\tpublic static final String OPERATION_EMPI_BATCH_RUN_OUT_PARAM_SUBMIT_COUNT = \"submitted\" ;\n+   public static final String OPERATION_EMPI_CLEAR_OUT_PARAM_DELETED_COUNT = \"deleted\";\n }\n", "next_change": {"commit": "e79114e2ecd2966226886bc0dafdd48009a1ebcc", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 011cd35a8a..7a9f9304d4 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -62,30 +62,35 @@ public class ProviderConstants {\n \t * EMPI Operations\n \t */\n \tpublic static final String EMPI_MATCH = \"$match\";\n-\tpublic static final String EMPI_MATCH_RESOURCE = \"resource\";\n+\t//TODO GGG MDM: implement a server-level MDM match to complement the FHIR-spec $match for /Patient\n+\tpublic static final String MDM_MATCH = \"$mdm-match\";\n+\tpublic static final String MDM_MATCH_RESOURCE = \"resource\";\n+\tpublic static final String MDM_RESOURCE_TYPE = \"resourceType\";\n \n-\tpublic static final String EMPI_MERGE_PERSONS = \"$empi-merge-persons\";\n-\tpublic static final String EMPI_MERGE_PERSONS_FROM_PERSON_ID = \"fromPersonId\";\n-\tpublic static final String EMPI_MERGE_PERSONS_TO_PERSON_ID = \"toPersonId\";\n+\t//TODO GGG MDM: rename all these vars\n+\tpublic static final String MDM_MERGE_GOLDEN_RESOURCES = \"$mdm-merge-golden-resources\";\n+\tpublic static final String MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID = \"fromGoldenResourceId\";\n+\tpublic static final String MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID = \"toGoldenResourceId\";\n \n-\tpublic static final String EMPI_UPDATE_LINK = \"$empi-update-link\";\n-\tpublic static final String EMPI_UPDATE_LINK_PERSON_ID = \"personId\";\n-\tpublic static final String EMPI_UPDATE_LINK_TARGET_ID = \"targetId\";\n-\tpublic static final String EMPI_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String MDM_UPDATE_LINK = \"$mdm-update-link\";\n+\tpublic static final String MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n+\tpublic static final String MDM_UPDATE_LINK_RESOURCE_ID = \"resourceId\";\n+\tpublic static final String MDM_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n \n-\tpublic static final String EMPI_QUERY_LINKS = \"$empi-query-links\";\n-\tpublic static final String EMPI_QUERY_LINKS_PERSON_ID = \"personId\";\n-\tpublic static final String EMPI_QUERY_LINKS_TARGET_ID = \"targetId\";\n-\tpublic static final String EMPI_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n-\tpublic static final String EMPI_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n+\tpublic static final String MDM_QUERY_LINKS = \"$mdm-query-links\";\n+\tpublic static final String MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n+\tpublic static final String MDM_QUERY_LINKS_RESOURCE_ID = \"resourceId\";\n+\tpublic static final String MDM_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String MDM_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n \n-\tpublic static final String EMPI_DUPLICATE_PERSONS = \"$empi-duplicate-persons\";\n-\tpublic static final String EMPI_NOT_DUPLICATE = \"$empi-not-duplicate\";\n+\tpublic static final String MDM_DUPLICATE_GOLDEN_RESOURCES = \"$mdm-duplicate-golden-resources\";\n+\tpublic static final String MDM_NOT_DUPLICATE = \"$mdm-not-duplicate\";\n \n-\tpublic static final String EMPI_CLEAR = \"$empi-clear\";\n-\tpublic static final String EMPI_CLEAR_TARGET_TYPE = \"targetType\";\n-\tpublic static final String OPERATION_EMPI_SUBMIT = \"$empi-submit\";\n-\tpublic static final String EMPI_BATCH_RUN_CRITERIA= \"criteria\" ;\n-\tpublic static final String OPERATION_EMPI_BATCH_RUN_OUT_PARAM_SUBMIT_COUNT = \"submitted\" ;\n-   public static final String OPERATION_EMPI_CLEAR_OUT_PARAM_DELETED_COUNT = \"deleted\";\n+\tpublic static final String MDM_CLEAR = \"$mdm-clear\";\n+\tpublic static final String MDM_CLEAR_SOURCE_TYPE = \"sourceType\";\n+\tpublic static final String OPERATION_MDM_SUBMIT = \"$mdm-submit\";\n+\tpublic static final String MDM_BATCH_RUN_CRITERIA = \"criteria\" ;\n+\tpublic static final String OPERATION_MDM_BATCH_RUN_OUT_PARAM_SUBMIT_COUNT = \"submitted\" ;\n+   public static final String OPERATION_MDM_CLEAR_OUT_PARAM_DELETED_COUNT = \"deleted\";\n+\tpublic static final String MDM_BATCH_RUN_RESOURCE_TYPE = \"resourceType\";\n }\n", "next_change": {"commit": "ca28a4fe6cbb21d16241608da2ac07c85369ff19", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 7a9f9304d4..4dfe76fd69 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -93,4 +91,10 @@ public class ProviderConstants {\n \tpublic static final String OPERATION_MDM_BATCH_RUN_OUT_PARAM_SUBMIT_COUNT = \"submitted\" ;\n    public static final String OPERATION_MDM_CLEAR_OUT_PARAM_DELETED_COUNT = \"deleted\";\n \tpublic static final String MDM_BATCH_RUN_RESOURCE_TYPE = \"resourceType\";\n+\n+\t/**\n+\t * CQL Operations\n+\t */\n+\tpublic static final String CQL_EVALUATE_MEASURE = \"$evaluate-measure\";\n+\n }\n", "next_change": {"commit": "d6252526c35d247f7b0a0c6683aaa61eb2242299", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 4dfe76fd69..dc0e24d64d 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -97,4 +97,8 @@ public class ProviderConstants {\n \t */\n \tpublic static final String CQL_EVALUATE_MEASURE = \"$evaluate-measure\";\n \n+\t/**\n+\t*  Operation name for the $meta operation\n+\t* */\n+\tpublic static final String OPERATION_META = \"$meta\";\n }\n", "next_change": {"commit": "134631fdeee15497093c9489ee4a07ad6b12b733", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex dc0e24d64d..45891fcac2 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -98,7 +98,53 @@ public class ProviderConstants {\n \tpublic static final String CQL_EVALUATE_MEASURE = \"$evaluate-measure\";\n \n \t/**\n-\t*  Operation name for the $meta operation\n-\t* */\n+\t *  Operation name for the $meta operation\n+\t */\n \tpublic static final String OPERATION_META = \"$meta\";\n+\n+\t/**\n+\t *  Operation name for the $expunge operation\n+\t */\n+\tpublic static final String OPERATION_EXPUNGE = \"$expunge\";\n+\n+\t/**\n+\t * Parameter name for the $expunge operation\n+\t */\n+\tpublic static final String OPERATION_EXPUNGE_PARAM_LIMIT = \"limit\";\n+\t/**\n+\t * Parameter name for the $expunge operation\n+\t */\n+\tpublic static final String OPERATION_EXPUNGE_PARAM_EXPUNGE_DELETED_RESOURCES = \"expungeDeletedResources\";\n+\t/**\n+\t * Parameter name for the $expunge operation\n+\t */\n+\tpublic static final String OPERATION_EXPUNGE_PARAM_EXPUNGE_PREVIOUS_VERSIONS = \"expungePreviousVersions\";\n+\t/**\n+\t * Parameter name for the $expunge operation\n+\t */\n+\tpublic static final String OPERATION_EXPUNGE_PARAM_EXPUNGE_EVERYTHING = \"expungeEverything\";\n+\t/**\n+\t * Output parameter name for the $expunge operation\n+\t */\n+\tpublic static final String OPERATION_EXPUNGE_OUT_PARAM_EXPUNGE_COUNT = \"count\";\n+\n+\t/**\n+\t * Operation name for the $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_DELETE_EXPUNGE = \"$delete-expunge\";\n+\n+\t/**\n+\t * url of resources to delete for the $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_DELETE_EXPUNGE_URL = \"url\";\n+\n+\t/**\n+\t * Number of resources to delete at a time for the $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_DELETE_BATCH_SIZE = \"batchSize\";\n+\n+\t/**\n+\t * The Spring Batch job id of the delete expunge job created by a $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_DELETE_EXPUNGE_RESPONSE_JOB_ID = \"jobId\";\n }\n", "next_change": {"commit": "f5dfc3a5ed05329b7d7c0cd89227204705cca277", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 45891fcac2..ffbe7d04e6 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -147,4 +147,29 @@ public class ProviderConstants {\n \t * The Spring Batch job id of the delete expunge job created by a $delete-expunge operation\n \t */\n \tpublic static final String OPERATION_DELETE_EXPUNGE_RESPONSE_JOB_ID = \"jobId\";\n+\n+\t/**\n+\t * Operation name for the $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_REINDEX = \"$reindex\";\n+\n+\t/**\n+\t * url of resources to delete for the $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_REINDEX_PARAM_URL = \"url\";\n+\n+\t/**\n+\t * Number of resources to delete at a time for the $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_REINDEX_PARAM_BATCH_SIZE = \"batchSize\";\n+\n+\t/**\n+\t * Whether all resource types should be reindexed\n+\t */\n+\tpublic static final String OPERATION_REINDEX_PARAM_EVERYTHING = \"everything\";\n+\n+\t/**\n+\t * The Spring Batch job id of the delete expunge job created by a $delete-expunge operation\n+\t */\n+\tpublic static final String OPERATION_REINDEX_RESPONSE_JOB_ID = \"jobId\";\n }\n", "next_change": {"commit": "060791aeb4f098c81a4beb1cd914dd24de9a8238", "changed_code": [{"header": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex ffbe7d04e6..365393697c 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n", "chunk": "@@ -172,4 +170,13 @@ public class ProviderConstants {\n \t * The Spring Batch job id of the delete expunge job created by a $delete-expunge operation\n \t */\n \tpublic static final String OPERATION_REINDEX_RESPONSE_JOB_ID = \"jobId\";\n+\n+\t@Deprecated\n+\tpublic static final String MARK_ALL_RESOURCES_FOR_REINDEXING = \"$mark-all-resources-for-reindexing\";\n+\t/**\n+\t * @see ProviderConstants#OPERATION_REINDEX\n+\t * @deprecated\n+\t */\n+\t@Deprecated\n+\tpublic static final String PERFORM_REINDEXING_PASS = \"$perform-reindexing-pass\";\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "f470c343c56603f4a4ea803f4833267c51c75da8", "url": "https://github.com/hapifhir/hapi-fhir/commit/f470c343c56603f4a4ea803f4833267c51c75da8", "message": "Docs - first pass", "committedDate": "2020-11-17T22:22:06Z", "type": "commit"}, {"oid": "6d50687d4c8f11ecd8db3330a8401b47c633cc49", "url": "https://github.com/hapifhir/hapi-fhir/commit/6d50687d4c8f11ecd8db3330a8401b47c633cc49", "message": "Renamed EMPI to MDM in the docs", "committedDate": "2020-11-18T18:49:17Z", "type": "commit"}, {"oid": "1f21220e398e128256dc46aa8ece471daf7f7797", "url": "https://github.com/hapifhir/hapi-fhir/commit/1f21220e398e128256dc46aa8ece471daf7f7797", "message": "Updated MDM create use cases", "committedDate": "2020-11-18T20:57:05Z", "type": "commit"}, {"oid": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "url": "https://github.com/hapifhir/hapi-fhir/commit/75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "message": "remove references to EMPI", "committedDate": "2020-11-19T00:50:00Z", "type": "commit"}, {"oid": "d97d4b63a0800a479fd152729b2269f84c1721ef", "url": "https://github.com/hapifhir/hapi-fhir/commit/d97d4b63a0800a479fd152729b2269f84c1721ef", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-19T00:53:21Z", "type": "commit"}, {"oid": "3209faf2fb2090b3590431dba77c27db8a1a4baa", "url": "https://github.com/hapifhir/hapi-fhir/commit/3209faf2fb2090b3590431dba77c27db8a1a4baa", "message": "Rename package and module", "committedDate": "2020-11-19T02:55:29Z", "type": "commit"}, {"oid": "b44ae49dd288af7bb42484bbdb3b99c6a88825ed", "url": "https://github.com/hapifhir/hapi-fhir/commit/b44ae49dd288af7bb42484bbdb3b99c6a88825ed", "message": "Removed hardcoded references to the supported MDM types", "committedDate": "2020-11-19T18:37:45Z", "type": "commit"}, {"oid": "f11f8a38ac3b54d2efa843fe0616a1a77d4b3bd4", "url": "https://github.com/hapifhir/hapi-fhir/commit/f11f8a38ac3b54d2efa843fe0616a1a77d4b3bd4", "message": "Add licenses", "committedDate": "2020-11-19T19:23:47Z", "type": "commit"}, {"oid": "3ad0fa8fda380fa004476a34cb2775f0e2bd5768", "url": "https://github.com/hapifhir/hapi-fhir/commit/3ad0fa8fda380fa004476a34cb2775f0e2bd5768", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-19T19:23:50Z", "type": "commit"}, {"oid": "b62ebe7bd5c9026e117cbef1ab454c1345d9e2d1", "url": "https://github.com/hapifhir/hapi-fhir/commit/b62ebe7bd5c9026e117cbef1ab454c1345d9e2d1", "message": "Merge remote-tracking branch 'origin/master' into 2161-refactor-empi", "committedDate": "2020-11-19T19:24:26Z", "type": "commit"}, {"oid": "953b662827439bd8de93a718687e034226066ffa", "url": "https://github.com/hapifhir/hapi-fhir/commit/953b662827439bd8de93a718687e034226066ffa", "message": "Merge branch '2161-refactor-empi' into gg_20201105-remove-person-references", "committedDate": "2020-11-19T19:24:51Z", "type": "commit"}, {"oid": "4378df7dcb00762269628f995f065204dd7d5e03", "url": "https://github.com/hapifhir/hapi-fhir/commit/4378df7dcb00762269628f995f065204dd7d5e03", "message": "Removed more EMPI refs from the docs", "committedDate": "2020-11-19T19:56:18Z", "type": "commit"}, {"oid": "4bbe4a3ef733f036fa7136628f193d4bebe7dab5", "url": "https://github.com/hapifhir/hapi-fhir/commit/4bbe4a3ef733f036fa7136628f193d4bebe7dab5", "message": "Merge branch 'gg_20201105-remove-person-references' of https://github.com/jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-19T19:56:31Z", "type": "commit"}, {"oid": "5f97428d38b0aec2a5bc5927e5907726f9d4f93e", "url": "https://github.com/hapifhir/hapi-fhir/commit/5f97428d38b0aec2a5bc5927e5907726f9d4f93e", "message": "Added schema migration steps for MDM", "committedDate": "2020-11-24T20:50:56Z", "type": "commit"}, {"oid": "03643a7b3cf394c9627a7ec8046db514f1794997", "url": "https://github.com/hapifhir/hapi-fhir/commit/03643a7b3cf394c9627a7ec8046db514f1794997", "message": "Fix for bean scope inconsistenices", "committedDate": "2020-11-25T22:37:37Z", "type": "commit"}, {"oid": "8a7dc4e80b9c22532519fff921daeeba99e69949", "url": "https://github.com/hapifhir/hapi-fhir/commit/8a7dc4e80b9c22532519fff921daeeba99e69949", "message": "EMPI to MDM", "committedDate": "2020-11-27T20:12:21Z", "type": "commit"}, {"oid": "36ce84335a175ab2106d380ad6c154e2720f7dbf", "url": "https://github.com/hapifhir/hapi-fhir/commit/36ce84335a175ab2106d380ad6c154e2720f7dbf", "message": "Renamed sourceResource to goldenResource", "committedDate": "2020-11-27T21:53:21Z", "type": "commit"}, {"oid": "dc2a9e55c550f1764d6538f90797acd2eb0d99b5", "url": "https://github.com/hapifhir/hapi-fhir/commit/dc2a9e55c550f1764d6538f90797acd2eb0d99b5", "message": "Renamed sourceResource to goldenResource", "committedDate": "2020-11-27T21:53:47Z", "type": "commit"}, {"oid": "2a3b72db17a3a2ad3a03df89be42272a62c5e971", "url": "https://github.com/hapifhir/hapi-fhir/commit/2a3b72db17a3a2ad3a03df89be42272a62c5e971", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-11-27T21:54:04Z", "type": "commit"}]}