{"pr_number": 825, "pr_title": "KOGITO-3073 Kafka persistence addon", "pr_author": "cristianonicolai", "pr_createdAt": "2020-10-14T06:32:00Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/825", "merge_commit": "8b29d15280535b78eafebbd5f760da085177a666", "timeline": [{"oid": "9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2020-10-14T06:42:31Z", "type": "forcePushed"}, {"oid": "6d9939fc38d86843a5f4b78d3ad3926766b36c99", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d9939fc38d86843a5f4b78d3ad3926766b36c99", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2020-11-26T14:43:39Z", "type": "forcePushed"}, {"oid": "8affe25c07610759435303d251cfb993f73c0483", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8affe25c07610759435303d251cfb993f73c0483", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-21T02:48:25Z", "type": "forcePushed"}, {"oid": "9e90fbc5bac886986406040e8b072a83c808e486", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9e90fbc5bac886986406040e8b072a83c808e486", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-21T05:33:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562173672", "body": "This method returns all the protos (+ list JSON) used by the operator to export them to data index so I think we should move this code outside single persistence types and bind it to the add-on that produce data index events.\r\nWdyt?\r\nSide note this change is in conflict with https://github.com/kiegroup/kogito-runtimes/pull/967\r\n/cc @r00ta ", "bodyText": "This method returns all the protos (+ list JSON) used by the operator to export them to data index so I think we should move this code outside single persistence types and bind it to the add-on that produce data index events.\nWdyt?\nSide note this change is in conflict with #967\n/cc @r00ta", "bodyHTML": "<p dir=\"auto\">This method returns all the protos (+ list JSON) used by the operator to export them to data index so I think we should move this code outside single persistence types and bind it to the add-on that produce data index events.<br>\nWdyt?<br>\nSide note this change is in conflict with <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"782253015\" data-permission-text=\"Title is private\" data-url=\"https://github.com/kiegroup/kogito-runtimes/issues/967\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/kiegroup/kogito-runtimes/pull/967/hovercard\" href=\"https://github.com/kiegroup/kogito-runtimes/pull/967\">#967</a><br>\n/cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/r00ta/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/r00ta\">@r00ta</a></p>", "author": "danielezonca", "createdAt": "2021-01-21T20:23:51Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +144,46 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java\"));\n+\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        \n+        MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n+\n+        protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n+        producer.getFieldByName(\"processes\").get().getVariable(0).setInitializer(asListOfProcesses);\n+\n+        String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n+        generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n+                                             clazzName.replace('.', '/') + \".java\",\n+                                             parsedClazzFile.toString()));\n+        return generatedFiles;\n+    }\n+    \n+    private Collection<GeneratedFile> protobufBasedPersistence(ClassOrInterfaceDeclaration persistenceProviderClazz){\n+        CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n+        compilationUnit.getTypes().add(persistenceProviderClazz);\n+\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjU2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436560", "bodyText": "@danielezonca agree I did a minor tweak now to have the proto always generated, and we review and further enhance later.", "author": "cristianonicolai", "createdAt": "2021-01-22T07:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQxNDAwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r564414004", "bodyText": "Hi, I was about to start working on #967 for the proto files. But since the changes are already in this PR I'll close it fyi", "author": "r00ta", "createdAt": "2021-01-26T10:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "changed_code": [{"header": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 4d4d46b982..571501ee9b 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -180,8 +182,6 @@ public class PersistenceGenerator extends AbstractGenerator {\n         CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n         compilationUnit.getTypes().add(persistenceProviderClazz);\n \n-        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n-\n         Proto proto = protoGenerator.protoOfDataClasses(context().getPackageName(), \"import \\\"kogito-types.proto\\\";\");\n \n         List<String> variableMarshallers = new ArrayList<>();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nsimilarity index 86%\nrename from kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nrename to kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 4d4d46b982..37c569cb30 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -180,8 +197,6 @@ public class PersistenceGenerator extends AbstractGenerator {\n         CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n         compilationUnit.getTypes().add(persistenceProviderClazz);\n \n-        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n-\n         Proto proto = protoGenerator.protoOfDataClasses(context().getPackageName(), \"import \\\"kogito-types.proto\\\";\");\n \n         List<String> variableMarshallers = new ArrayList<>();\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562183336", "body": "I think you can use existing `generatedAnnotation` field", "bodyText": "I think you can use existing generatedAnnotation field", "bodyHTML": "<p dir=\"auto\">I think you can use existing <code>generatedAnnotation</code> field</p>", "author": "danielezonca", "createdAt": "2021-01-21T20:41:10Z", "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java", "diffHunk": "@@ -102,6 +106,18 @@ public Proto generate(String messageComment, String fieldComment, String package\n         return parameters;\n     }\n \n+    @Override\n+    public Set<String> getProcessIds() {\n+        return modelClasses.stream().map(c -> {\n+            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjEwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436105", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2021-01-22T07:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg=="}], "type": "inlineReview", "revised_code": {"commit": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "changed_code": [{"header": "diff --git a/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java b/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\nindex 0c0d0d257c..4530a2f9ec 100644\n--- a/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\n+++ b/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\n", "chunk": "@@ -109,7 +109,7 @@ public class JandexProtoGenerator extends AbstractProtoGenerator<ClassInfo> {\n     @Override\n     public Set<String> getProcessIds() {\n         return modelClasses.stream().map(c -> {\n-            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));\n+            AnnotationInstance instance = c.classAnnotation(generatedAnnotation);\n             if(instance == null){\n                 return null;\n             }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java b/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\nindex 0c0d0d257c..f0a0449d67 100644\n--- a/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\n+++ b/kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java\n", "chunk": "@@ -109,7 +108,7 @@ public class JandexProtoGenerator extends AbstractProtoGenerator<ClassInfo> {\n     @Override\n     public Set<String> getProcessIds() {\n         return modelClasses.stream().map(c -> {\n-            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));\n+            AnnotationInstance instance = c.classAnnotation(generatedAnnotation);\n             if(instance == null){\n                 return null;\n             }\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "3b3dc689846591422480de0c8467886a650f05e0", "committedDate": "2021-02-15 15:47:59 +1000", "message": "KOGITO-4376 Copyright reformat to match expected format (#1065)"}, {"oid": "f980f6bbcc2784dda98f6d6ad75fc256b4bc6c6c", "committedDate": "2021-02-24 20:51:04 +0100", "message": "[KOGITO-4425] Split quarkus extension for decisions, rules and predictions (#1073)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562184235", "body": "Can you please describe in the ticket what a kafka topology is and the relation with ktable?", "bodyText": "Can you please describe in the ticket what a kafka topology is and the relation with ktable?", "bodyHTML": "<p dir=\"auto\">Can you please describe in the ticket what a kafka topology is and the relation with ktable?</p>", "author": "danielezonca", "createdAt": "2021-01-21T20:42:56Z", "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsTopologyProducer.class);\n+\n+    private List<String> processes = Arrays.asList();\n+\n+    @Produces\n+    public Topology buildTopology() {", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjA5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436094", "bodyText": "working on a doc for that", "author": "cristianonicolai", "createdAt": "2021-01-22T07:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwODQ4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562608483", "bodyText": "Great thanks \ud83d\udc4d", "author": "danielezonca", "createdAt": "2021-01-22T12:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}]}, {"oid": "970d8591278df327a508211eea0fcdd42b826144", "url": "https://github.com/kiegroup/kogito-runtimes/commit/970d8591278df327a508211eea0fcdd42b826144", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T02:16:12Z", "type": "forcePushed"}, {"oid": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T08:40:27Z", "type": "forcePushed"}, {"oid": "cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T10:47:49Z", "type": "forcePushed"}, {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/68c1854e5ed94fa96ad8296153f08f8f08da011e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T11:58:59Z", "type": "forcePushed"}, {"oid": "7cb3890af384c1abbb28fafa5622c7c794af5765", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7cb3890af384c1abbb28fafa5622c7c794af5765", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-01T06:07:44Z", "type": "forcePushed"}, {"oid": "1f3cb4a037745998c7d3e05c24500971e812526a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f3cb4a037745998c7d3e05c24500971e812526a", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T02:05:02Z", "type": "forcePushed"}, {"oid": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T04:30:44Z", "type": "forcePushed"}, {"oid": "72c4b39fec40aa5d1882ee3c89c59a613e434474", "url": "https://github.com/kiegroup/kogito-runtimes/commit/72c4b39fec40aa5d1882ee3c89c59a613e434474", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T11:34:12Z", "type": "forcePushed"}, {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T11:39:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844033", "body": "If `new KafkaProcessInstancesFactory()` fails this could be `null`", "bodyText": "If new KafkaProcessInstancesFactory() fails this could be null", "bodyHTML": "<p dir=\"auto\">If <code>new KafkaProcessInstancesFactory()</code> fails this could be <code>null</code></p>", "author": "danielezonca", "createdAt": "2021-01-29T14:05:59Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();", "originalCommit": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjc0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816748", "bodyText": "fixed", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 0a8051e6dc..7b2b83097e 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -80,6 +80,7 @@ public class KafkaProcessInstancesIT {\n         factory.stop();\n         if (factory.getKafkaStreams() != null) {\n             factory.getKafkaStreams().close();\n+            factory.getKafkaStreams().cleanUp();\n         }\n     }\n \n", "next_change": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 7b2b83097e..9b872a2bf1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -77,29 +72,23 @@ public class KafkaProcessInstancesIT {\n \n     @AfterEach\n     void stop() {\n-        factory.stop();\n-        if (factory.getKafkaStreams() != null) {\n-            factory.getKafkaStreams().close();\n-            factory.getKafkaStreams().cleanUp();\n+        if (factory != null) {\n+            factory.stop();\n+            if (factory.getKafkaStreams() != null) {\n+                factory.getKafkaStreams().close();\n+                factory.getKafkaStreams().cleanUp();\n+            }\n         }\n     }\n \n     @Test\n     void testFindByIdReadMode() {\n         BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n-        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n-        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n-            if (node instanceof ActionNode) {\n-                DroolsAction a = ((ActionNode) node).getAction();\n-                a.setMetaData(\"Action\", (Action) kcontext -> {\n-                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n-                    kcontext.getVariable(\"s\").toString();\n-                });\n-            }\n-        }\n+\n         factory.setKafkaStreams(createStreams(process));\n         process.setProcessInstancesFactory(factory);\n         process.configure();\n+        factory.getKafkaStreams().start();\n \n         ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n \n", "next_change": {"commit": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 9b872a2bf1..8ed95049b4 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -90,6 +91,9 @@ public class KafkaProcessInstancesIT {\n         process.configure();\n         factory.getKafkaStreams().start();\n \n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n         ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n \n         mutablePi.start();\n", "next_change": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -86,10 +89,10 @@ public class KafkaProcessInstancesIT {\n     void testFindByIdReadMode() {\n         BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n \n-        factory.setKafkaStreams(createStreams(process));\n+        listener.setKafkaStreams(createStreams(process));\n         process.setProcessInstancesFactory(factory);\n         process.configure();\n-        factory.getKafkaStreams().start();\n+        listener.getKafkaStreams().start();\n \n         ProcessInstances<BpmnVariables> instances = process.instances();\n         assertThat(instances.size()).isZero();\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 0a8051e6dc..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -69,36 +65,37 @@ public class KafkaProcessInstancesIT {\n \n     KafkaProcessInstancesFactory factory;\n \n+    KafkaStreamsStateListener listener = new KafkaStreamsStateListener();\n+\n     @BeforeEach\n     void start() {\n         factory = new KafkaProcessInstancesFactory();\n         factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+        factory.setStateListener(listener);\n     }\n \n     @AfterEach\n     void stop() {\n-        factory.stop();\n-        if (factory.getKafkaStreams() != null) {\n-            factory.getKafkaStreams().close();\n+        if (factory != null) {\n+            factory.stop();\n+        }\n+        if (listener.getKafkaStreams() != null) {\n+            listener.getKafkaStreams().close();\n+            listener.getKafkaStreams().cleanUp();\n         }\n     }\n \n     @Test\n     void testFindByIdReadMode() {\n         BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n-        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n-        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n-            if (node instanceof ActionNode) {\n-                DroolsAction a = ((ActionNode) node).getAction();\n-                a.setMetaData(\"Action\", (Action) kcontext -> {\n-                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n-                    kcontext.getVariable(\"s\").toString();\n-                });\n-            }\n-        }\n-        factory.setKafkaStreams(createStreams(process));\n+\n+        listener.setKafkaStreams(createStreams(process));\n         process.setProcessInstancesFactory(factory);\n         process.configure();\n+        listener.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n \n         ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844861", "body": "Can you please clarify why this workaround? What about (in another PR of course) convert scripts to lambdas?", "bodyText": "Can you please clarify why this workaround? What about (in another PR of course) convert scripts to lambdas?", "bodyHTML": "<p dir=\"auto\">Can you please clarify why this workaround? What about (in another PR of course) convert scripts to lambdas?</p>", "author": "danielezonca", "createdAt": "2021-01-29T14:07:18Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();\n+        if (factory.getKafkaStreams() != null) {\n+            factory.getKafkaStreams().close();\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n+        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n+            if (node instanceof ActionNode) {\n+                DroolsAction a = ((ActionNode) node).getAction();\n+                a.setMetaData(\"Action\", (Action) kcontext -> {\n+                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n+                    kcontext.getVariable(\"s\").toString();\n+                });\n+            }\n+        }", "originalCommit": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjc2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816768", "bodyText": "its not needed anymore", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 0a8051e6dc..9b872a2bf1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -77,28 +72,23 @@ public class KafkaProcessInstancesIT {\n \n     @AfterEach\n     void stop() {\n-        factory.stop();\n-        if (factory.getKafkaStreams() != null) {\n-            factory.getKafkaStreams().close();\n+        if (factory != null) {\n+            factory.stop();\n+            if (factory.getKafkaStreams() != null) {\n+                factory.getKafkaStreams().close();\n+                factory.getKafkaStreams().cleanUp();\n+            }\n         }\n     }\n \n     @Test\n     void testFindByIdReadMode() {\n         BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n-        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n-        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n-            if (node instanceof ActionNode) {\n-                DroolsAction a = ((ActionNode) node).getAction();\n-                a.setMetaData(\"Action\", (Action) kcontext -> {\n-                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n-                    kcontext.getVariable(\"s\").toString();\n-                });\n-            }\n-        }\n+\n         factory.setKafkaStreams(createStreams(process));\n         process.setProcessInstancesFactory(factory);\n         process.configure();\n+        factory.getKafkaStreams().start();\n \n         ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n \n", "next_change": {"commit": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 9b872a2bf1..8ed95049b4 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -90,6 +91,9 @@ public class KafkaProcessInstancesIT {\n         process.configure();\n         factory.getKafkaStreams().start();\n \n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n         ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n \n         mutablePi.start();\n", "next_change": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -86,10 +89,10 @@ public class KafkaProcessInstancesIT {\n     void testFindByIdReadMode() {\n         BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n \n-        factory.setKafkaStreams(createStreams(process));\n+        listener.setKafkaStreams(createStreams(process));\n         process.setProcessInstancesFactory(factory);\n         process.configure();\n-        factory.getKafkaStreams().start();\n+        listener.getKafkaStreams().start();\n \n         ProcessInstances<BpmnVariables> instances = process.instances();\n         assertThat(instances.size()).isZero();\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 0a8051e6dc..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -69,36 +65,37 @@ public class KafkaProcessInstancesIT {\n \n     KafkaProcessInstancesFactory factory;\n \n+    KafkaStreamsStateListener listener = new KafkaStreamsStateListener();\n+\n     @BeforeEach\n     void start() {\n         factory = new KafkaProcessInstancesFactory();\n         factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+        factory.setStateListener(listener);\n     }\n \n     @AfterEach\n     void stop() {\n-        factory.stop();\n-        if (factory.getKafkaStreams() != null) {\n-            factory.getKafkaStreams().close();\n+        if (factory != null) {\n+            factory.stop();\n+        }\n+        if (listener.getKafkaStreams() != null) {\n+            listener.getKafkaStreams().close();\n+            listener.getKafkaStreams().cleanUp();\n         }\n     }\n \n     @Test\n     void testFindByIdReadMode() {\n         BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n-        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n-        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n-            if (node instanceof ActionNode) {\n-                DroolsAction a = ((ActionNode) node).getAction();\n-                a.setMetaData(\"Action\", (Action) kcontext -> {\n-                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n-                    kcontext.getVariable(\"s\").toString();\n-                });\n-            }\n-        }\n-        factory.setKafkaStreams(createStreams(process));\n+\n+        listener.setKafkaStreams(createStreams(process));\n         process.setProcessInstancesFactory(factory);\n         process.configure();\n+        listener.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n \n         ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568586865", "body": "Please use [`TemplatedGenerator`](https://github.com/kiegroup/kogito-runtimes/blob/master/kogito-codegen-modules/kogito-codegen-api/src/main/java/org/kie/kogito/codegen/api/template/TemplatedGenerator.java)\r\n```suggestion\r\n        TemplatedGenerator generator = TemplatedGenerator.builder()\r\n                    .withTemplateBasePath(\"/class-templates/persistence/\")\r\n                    .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\r\n                    .build(context(), \"KafkaStreamsTopologyProducer\");\r\n        CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();\r\n```", "bodyText": "Please use TemplatedGenerator\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n          \n          \n            \n                    TemplatedGenerator generator = TemplatedGenerator.builder()\n          \n          \n            \n                                .withTemplateBasePath(\"/class-templates/persistence/\")\n          \n          \n            \n                                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n          \n          \n            \n                                .build(context(), \"KafkaStreamsTopologyProducer\");\n          \n          \n            \n                    CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();", "bodyHTML": "<p dir=\"auto\">Please use <a href=\"https://github.com/kiegroup/kogito-runtimes/blob/master/kogito-codegen-modules/kogito-codegen-api/src/main/java/org/kie/kogito/codegen/api/template/TemplatedGenerator.java\"><code>TemplatedGenerator</code></a></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi x x-first\">CompilationUnit</span><span class=\"x x-last\"> parsedClazzFile</span> <span class=\"pl-k\">=</span> <span class=\"x x-first\">parse(</span><span class=\"pl-c1 x\">this</span><span class=\"pl-k x\">.</span><span class=\"x\">getClass()</span><span class=\"pl-k x\">.</span><span class=\"x\">getResourceAsStream(</span><span class=\"pl-s\"><span class=\"pl-pds x\">\"</span><span class=\"x\">/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java</span><span class=\"pl-pds x\">\"</span></span><span class=\"x x-last\">));</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi x x-first\">TemplatedGenerator</span><span class=\"x x-last\"> generator</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi x x-first\">TemplatedGenerator</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">builder()</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .withTemplateBasePath(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/class-templates/persistence/<span class=\"pl-pds\">\"</span></span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .withFallbackContext(<span class=\"pl-smi\">JavaKogitoBuildContext</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>CONTEXT_NAME</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .build(context(), <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>KafkaStreamsTopologyProducer<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">CompilationUnit</span> parsedClazzFile <span class=\"pl-k\">=</span> generator<span class=\"pl-k\">.</span>compilationUnitOrThrow();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "danielezonca", "createdAt": "2021-02-02T13:07:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +155,44 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjgwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816809", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "changed_code": [{"header": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex a501d4b9a3..7998985fbe 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -171,9 +172,13 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n \n-        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n-\n-        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        TemplatedGenerator generator = TemplatedGenerator.builder().withTemplateBasePath(\"/class-templates/persistence/\")\n+                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n+                .build(context(), \"KafkaStreamsTopologyProducer\");\n+        CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.findFirst(ClassOrInterfaceDeclaration.class).orElseThrow(() -> new InvalidTemplateException(\n+                generator,\n+                \"Failed to find template for KafkaStreamsTopologyProducer\"));\n         \n         MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n \n", "next_change": {"commit": "27327e054b73b72e065a160fe42059ba4776df71", "changed_code": [{"header": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 7998985fbe..0c71f9158c 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -183,7 +183,9 @@ public class PersistenceGenerator extends AbstractGenerator {\n         MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n \n         protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n-        producer.getFieldByName(\"processes\").get().getVariable(0).setInitializer(asListOfProcesses);\n+        producer.getFieldByName(\"processes\")\n+                .orElseThrow(() -> new InvalidTemplateException(generator, \"Failed to find field 'processes' in KafkaStreamsTopologyProducer template\"))\n+                .getVariable(0).setInitializer(asListOfProcesses);\n \n         String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n         generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n", "next_change": {"commit": "eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "changed_code": [{"header": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 0c71f9158c..3a68a47a4a 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -189,7 +190,7 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n         generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n-                                             clazzName.replace('.', '/') + \".java\",\n+                                             clazzName.replace('.', '/') + JAVA,\n                                              parsedClazzFile.toString()));\n         return generatedFiles;\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nsimilarity index 87%\nrename from kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nrename to kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex a501d4b9a3..37c569cb30 100644\n--- a/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -171,18 +171,24 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n \n-        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n-\n-        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        TemplatedGenerator generator = TemplatedGenerator.builder().withTemplateBasePath(\"/class-templates/persistence/\")\n+                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n+                .build(context(), \"KafkaStreamsTopologyProducer\");\n+        CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.findFirst(ClassOrInterfaceDeclaration.class).orElseThrow(() -> new InvalidTemplateException(\n+                generator,\n+                \"Failed to find template for KafkaStreamsTopologyProducer\"));\n         \n         MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n \n         protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n-        producer.getFieldByName(\"processes\").get().getVariable(0).setInitializer(asListOfProcesses);\n+        producer.getFieldByName(\"processes\")\n+                .orElseThrow(() -> new InvalidTemplateException(generator, \"Failed to find field 'processes' in KafkaStreamsTopologyProducer template\"))\n+                .getVariable(0).setInitializer(asListOfProcesses);\n \n         String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n         generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n-                                             clazzName.replace('.', '/') + \".java\",\n+                                             clazzName.replace('.', '/') + JAVA,\n                                              parsedClazzFile.toString()));\n         return generatedFiles;\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568589969", "body": "This class is a `*JavaTemplate` but it seems to be a Quarkus one (it uses CDI). I think we need also a `*SpringTemplate`", "bodyText": "This class is a *JavaTemplate but it seems to be a Quarkus one (it uses CDI). I think we need also a *SpringTemplate", "bodyHTML": "<p dir=\"auto\">This class is a <code>*JavaTemplate</code> but it seems to be a Quarkus one (it uses CDI). I think we need also a <code>*SpringTemplate</code></p>", "author": "danielezonca", "createdAt": "2021-02-02T13:12:48Z", "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5NTMyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568895320", "bodyText": "and do we really need a template? or this could be a static class? I mean what is injected during codegen?", "author": "tiagodolphine", "createdAt": "2021-02-02T20:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjg2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816867", "bodyText": "@danielezonca there is no support for spring at this stage, will need to be done later one if we think there is need to\n@tiagodolphine I needed to inject ( statically ) the process ids in order to create the topics needed for kafka. I cant inject @Process as it would cause a circle dependency, so decided to do a build time generation.", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568591196", "body": "What about add checks on proto in this test too ([like this](https://github.com/kiegroup/kogito-runtimes/blob/master/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/InfinispanPersistenceGeneratorTest.java#L57-L58))?\r\n```suggestion\r\n        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\r\n        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\r\n\r\n        assertThat(generatedFiles).hasSize(3);\r\n```", "bodyText": "What about add checks on proto in this test too (like this)?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(generatedFiles).hasSize(3);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n          \n          \n            \n            \n          \n          \n            \n                    assertThat(generatedFiles).hasSize(3);", "bodyHTML": "<p dir=\"auto\">What about add checks on proto in this test too (<a href=\"https://github.com/kiegroup/kogito-runtimes/blob/master/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/InfinispanPersistenceGeneratorTest.java#L57-L58\">like this</a>)?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        assertThat(generatedFiles<span class=\"x x-first\">)</span><span class=\"pl-k x\">.</span><span class=\"x\">hasSize(</span><span class=\"pl-c1 x x-last\">3</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(generatedFiles<span class=\"pl-k x x-first\">.</span><span class=\"x\">stream()</span><span class=\"pl-k x\">.</span><span class=\"x\">filter(gf </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x\"> gf</span><span class=\"pl-k x\">.</span><span class=\"x\">type()</span><span class=\"pl-k x\">.</span><span class=\"x\">equals(</span><span class=\"pl-smi x\">ProtoGenerator</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">PROTO_TYPE</span></span><span class=\"x\">))</span><span class=\"pl-k x\">.</span><span class=\"x\">count())</span><span class=\"pl-k x\">.</span><span class=\"x\">isEqualTo(</span><span class=\"pl-c1 x x-last\">2</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(generatedFiles<span class=\"pl-k\">.</span>stream()<span class=\"pl-k\">.</span>filter(gf <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> gf<span class=\"pl-k\">.</span>type()<span class=\"pl-k\">.</span>equals(<span class=\"pl-smi\">ProtoGenerator</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>PROTO_TYPE</span>) <span class=\"pl-k\">&amp;&amp;</span> gf<span class=\"pl-k\">.</span>relativePath()<span class=\"pl-k\">.</span>endsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>.json<span class=\"pl-pds\">\"</span></span>))<span class=\"pl-k\">.</span>count())<span class=\"pl-k\">.</span>isEqualTo(<span class=\"pl-c1\">1</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(generatedFiles)<span class=\"pl-k\">.</span>hasSize(<span class=\"pl-c1\">3</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "danielezonca", "createdAt": "2021-02-02T13:14:52Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java", "diffHunk": "@@ -57,7 +57,7 @@ void test() {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n-        assertThat(generatedFiles).hasSize(1);\n+        assertThat(generatedFiles).hasSize(3);", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjkzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816935", "bodyText": "done, thanks", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "changed_code": [{"header": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java b/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\nindex 78cff8c227..2cd1d77102 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\n+++ b/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\n", "chunk": "@@ -57,6 +58,8 @@ class FileSystemPersistenceGeneratorTest {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n+        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n+        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n         assertThat(generatedFiles).hasSize(3);\n \n         Optional<GeneratedFile> persistenceFactoryImpl = generatedFiles.stream()\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java b/kogito-codegen-modules/kogito-codegen-processes/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\nsimilarity index 90%\nrename from kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\nrename to kogito-codegen-modules/kogito-codegen-processes/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\nindex 78cff8c227..009c1dc22a 100644\n--- a/kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java\n", "chunk": "@@ -57,6 +58,8 @@ class FileSystemPersistenceGeneratorTest {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n+        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n+        assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n         assertThat(generatedFiles).hasSize(3);\n \n         Optional<GeneratedFile> persistenceFactoryImpl = generatedFiles.stream()\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568878173", "body": "remove commented code?", "bodyText": "remove commented code?", "bodyHTML": "<p dir=\"auto\">remove commented code?</p>", "author": "tiagodolphine", "createdAt": "2021-02-02T19:38:02Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjk2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816962", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..f301330981 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -79,31 +74,13 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n             KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n             producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            return new KafkaProcessInstances(process, topicName(process.id()), streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n         } catch (Exception ex) {\n-            ex.printStackTrace();\n+            LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n             throw new RuntimeException(ex);\n         }\n     }\n \n-    //Store can only be accessed after the Kafka Streams has started \n-    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n-//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n-        return () -> {\n-//            if (store != null) {\n-//                return store;\n-//            }\n-            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {\n-                try {\n-                    Thread.sleep(500);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            return streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore()));\n-//            return store;\n-        };\n-    }\n-\n     public String proto() {\n         return null;\n     }\n", "next_change": {"commit": "27327e054b73b72e065a160fe42059ba4776df71", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex f301330981..a7ab4e52fc 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -66,26 +64,30 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(p -> p.close());\n+        producers.forEach(KafkaProducer::close);\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n             producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            return new KafkaProcessInstances(process, streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n         } catch (Exception ex) {\n             LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n-            throw new RuntimeException(ex);\n+            throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n+    protected KafkaProducer<String, byte[]> getProducer() {\n+        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+    }\n+\n     public String proto() {\n         return null;\n     }\n \n-    public List<BaseMarshaller<?>> marshallers() {\n+    public List<BaseMarshaller> marshallers() {\n         return Collections.emptyList();\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..0109771c8b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -50,65 +42,44 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n \n-    Map<String, Object> kafkaConfig;\n-    KafkaStreams streams;\n-    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+    KafkaStreamsStateListener stateListener;\n+    KafkaProducer<String, byte[]> producer;\n \n     @Inject\n-    @Named(\"default-kafka-broker\")\n-    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n-        this.kafkaConfig = kafkaConfig;\n-    }\n-\n-    public KafkaStreams getKafkaStreams() {\n-        return streams;\n+    public void setStateListener(KafkaStreamsStateListener stateListener) {\n+        this.stateListener = stateListener;\n     }\n \n     @Inject\n-    public void setKafkaStreams(KafkaStreams streams) {\n-        this.streams = streams;\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n     }\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(p -> p.close());\n+        if (producer != null) {\n+            producer.close();\n+        }\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n-            producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            KafkaProcessInstances pi = new KafkaProcessInstances(process, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            stateListener.addProcessInstances(pi);\n+            return pi;\n         } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex);\n+            LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n+            throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n-    //Store can only be accessed after the Kafka Streams has started \n-    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n-//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n-        return () -> {\n-//            if (store != null) {\n-//                return store;\n-//            }\n-            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {\n-                try {\n-                    Thread.sleep(500);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            return streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore()));\n-//            return store;\n-        };\n-    }\n-\n     public String proto() {\n         return null;\n     }\n \n-    public List<BaseMarshaller<?>> marshallers() {\n+    public List<BaseMarshaller> marshallers() {\n         return Collections.emptyList();\n     }\n }\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex 0109771c8b..f2c56961ab 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -75,11 +71,4 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n         }\n     }\n \n-    public String proto() {\n-        return null;\n-    }\n-\n-    public List<BaseMarshaller> marshallers() {\n-        return Collections.emptyList();\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880541", "body": "what about using a listerner for the state? for example `streams.setStateListener(....)` in this way we can get rid of the Thread.sleep", "bodyText": "what about using a listerner for the state? for example streams.setStateListener(....) in this way we can get rid of the Thread.sleep", "bodyHTML": "<p dir=\"auto\">what about using a listerner for the state? for example <code>streams.setStateListener(....)</code> in this way we can get rid of the Thread.sleep</p>", "author": "tiagodolphine", "createdAt": "2021-02-02T19:42:00Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n+        return () -> {\n+//            if (store != null) {\n+//                return store;\n+//            }\n+            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjk5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816994", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..f301330981 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -79,31 +74,13 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n             KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n             producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            return new KafkaProcessInstances(process, topicName(process.id()), streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n         } catch (Exception ex) {\n-            ex.printStackTrace();\n+            LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n             throw new RuntimeException(ex);\n         }\n     }\n \n-    //Store can only be accessed after the Kafka Streams has started \n-    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n-//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n-        return () -> {\n-//            if (store != null) {\n-//                return store;\n-//            }\n-            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {\n-                try {\n-                    Thread.sleep(500);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            return streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore()));\n-//            return store;\n-        };\n-    }\n-\n     public String proto() {\n         return null;\n     }\n", "next_change": {"commit": "27327e054b73b72e065a160fe42059ba4776df71", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex f301330981..a7ab4e52fc 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -66,26 +64,30 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(p -> p.close());\n+        producers.forEach(KafkaProducer::close);\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n             producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            return new KafkaProcessInstances(process, streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n         } catch (Exception ex) {\n             LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n-            throw new RuntimeException(ex);\n+            throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n+    protected KafkaProducer<String, byte[]> getProducer() {\n+        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+    }\n+\n     public String proto() {\n         return null;\n     }\n \n-    public List<BaseMarshaller<?>> marshallers() {\n+    public List<BaseMarshaller> marshallers() {\n         return Collections.emptyList();\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..0109771c8b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -50,65 +42,44 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n \n-    Map<String, Object> kafkaConfig;\n-    KafkaStreams streams;\n-    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+    KafkaStreamsStateListener stateListener;\n+    KafkaProducer<String, byte[]> producer;\n \n     @Inject\n-    @Named(\"default-kafka-broker\")\n-    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n-        this.kafkaConfig = kafkaConfig;\n-    }\n-\n-    public KafkaStreams getKafkaStreams() {\n-        return streams;\n+    public void setStateListener(KafkaStreamsStateListener stateListener) {\n+        this.stateListener = stateListener;\n     }\n \n     @Inject\n-    public void setKafkaStreams(KafkaStreams streams) {\n-        this.streams = streams;\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n     }\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(p -> p.close());\n+        if (producer != null) {\n+            producer.close();\n+        }\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n-            producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            KafkaProcessInstances pi = new KafkaProcessInstances(process, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            stateListener.addProcessInstances(pi);\n+            return pi;\n         } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex);\n+            LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n+            throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n-    //Store can only be accessed after the Kafka Streams has started \n-    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n-//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n-        return () -> {\n-//            if (store != null) {\n-//                return store;\n-//            }\n-            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {\n-                try {\n-                    Thread.sleep(500);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            return streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore()));\n-//            return store;\n-        };\n-    }\n-\n     public String proto() {\n         return null;\n     }\n \n-    public List<BaseMarshaller<?>> marshallers() {\n+    public List<BaseMarshaller> marshallers() {\n         return Collections.emptyList();\n     }\n }\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex 0109771c8b..f2c56961ab 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -75,11 +71,4 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n         }\n     }\n \n-    public String proto() {\n-        return null;\n-    }\n-\n-    public List<BaseMarshaller> marshallers() {\n-        return Collections.emptyList();\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880955", "body": "log instead of printStackTrace would be bettter", "bodyText": "log instead of printStackTrace would be bettter", "bodyHTML": "<p dir=\"auto\">log instead of printStackTrace would be bettter</p>", "author": "tiagodolphine", "createdAt": "2021-02-02T19:42:43Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzAxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817011", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..f301330981 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -79,31 +74,13 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n             KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n             producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            return new KafkaProcessInstances(process, topicName(process.id()), streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n         } catch (Exception ex) {\n-            ex.printStackTrace();\n+            LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n             throw new RuntimeException(ex);\n         }\n     }\n \n-    //Store can only be accessed after the Kafka Streams has started \n-    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n-//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n-        return () -> {\n-//            if (store != null) {\n-//                return store;\n-//            }\n-            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {\n-                try {\n-                    Thread.sleep(500);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            return streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore()));\n-//            return store;\n-        };\n-    }\n-\n     public String proto() {\n         return null;\n     }\n", "next_change": {"commit": "27327e054b73b72e065a160fe42059ba4776df71", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex f301330981..a7ab4e52fc 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -66,26 +64,30 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(p -> p.close());\n+        producers.forEach(KafkaProducer::close);\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n             producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            return new KafkaProcessInstances(process, streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n         } catch (Exception ex) {\n             LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n-            throw new RuntimeException(ex);\n+            throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n+    protected KafkaProducer<String, byte[]> getProducer() {\n+        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+    }\n+\n     public String proto() {\n         return null;\n     }\n \n-    public List<BaseMarshaller<?>> marshallers() {\n+    public List<BaseMarshaller> marshallers() {\n         return Collections.emptyList();\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex b399b61599..0109771c8b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -50,65 +42,44 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n \n-    Map<String, Object> kafkaConfig;\n-    KafkaStreams streams;\n-    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+    KafkaStreamsStateListener stateListener;\n+    KafkaProducer<String, byte[]> producer;\n \n     @Inject\n-    @Named(\"default-kafka-broker\")\n-    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n-        this.kafkaConfig = kafkaConfig;\n-    }\n-\n-    public KafkaStreams getKafkaStreams() {\n-        return streams;\n+    public void setStateListener(KafkaStreamsStateListener stateListener) {\n+        this.stateListener = stateListener;\n     }\n \n     @Inject\n-    public void setKafkaStreams(KafkaStreams streams) {\n-        this.streams = streams;\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n     }\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(p -> p.close());\n+        if (producer != null) {\n+            producer.close();\n+        }\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n-            producers.add(producer);\n-            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            KafkaProcessInstances pi = new KafkaProcessInstances(process, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            stateListener.addProcessInstances(pi);\n+            return pi;\n         } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex);\n+            LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n+            throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n-    //Store can only be accessed after the Kafka Streams has started \n-    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n-//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n-        return () -> {\n-//            if (store != null) {\n-//                return store;\n-//            }\n-            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {\n-                try {\n-                    Thread.sleep(500);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            return streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore()));\n-//            return store;\n-        };\n-    }\n-\n     public String proto() {\n         return null;\n     }\n \n-    public List<BaseMarshaller<?>> marshallers() {\n+    public List<BaseMarshaller> marshallers() {\n         return Collections.emptyList();\n     }\n }\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex 0109771c8b..f2c56961ab 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -75,11 +71,4 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n         }\n     }\n \n-    public String proto() {\n-        return null;\n-    }\n-\n-    public List<BaseMarshaller> marshallers() {\n-        return Collections.emptyList();\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568889834", "body": "maybe using `store.approximateNumEntries()` would be better in this way it is not necessary to fetch all entries to sum, wdyt?\r\n", "bodyText": "maybe using store.approximateNumEntries() would be better in this way it is not necessary to fetch all entries to sum, wdyt?", "bodyHTML": "<p dir=\"auto\">maybe using <code>store.approximateNumEntries()</code> would be better in this way it is not necessary to fetch all entries to sum, wdyt?</p>", "author": "tiagodolphine", "createdAt": "2021-02-02T19:57:43Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        int size = 0;\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzQxNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817417", "bodyText": "I changed to use that, but isnt reliable, or it does get updated from time to time, so in order to use this way, I removed it from the tests.", "author": "cristianonicolai", "createdAt": "2021-02-08T07:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 2fe3ff6391..6e7d29e7c6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -133,7 +177,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     @Override\n     public Integer size() {\n         int size = 0;\n-        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n             while (iterator.hasNext()) {\n                 iterator.next();\n                 size++;\n", "next_change": {"commit": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 6e7d29e7c6..43685b0b81 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -176,14 +161,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n \n     @Override\n     public Integer size() {\n-        int size = 0;\n-        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n-            while (iterator.hasNext()) {\n-                iterator.next();\n-                size++;\n-            }\n-        }\n-        return size;\n+        return Long.valueOf(getStore().approximateNumEntries()).intValue();\n     }\n \n     protected void disconnect(ProcessInstance instance) {\n", "next_change": {"commit": "27327e054b73b72e065a160fe42059ba4776df71", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 43685b0b81..7e0ae5ac00 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -161,7 +167,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n \n     @Override\n     public Integer size() {\n-        return Long.valueOf(getStore().approximateNumEntries()).intValue();\n+        return (int) getStore().approximateNumEntries();\n     }\n \n     protected void disconnect(ProcessInstance instance) {\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 2fe3ff6391..25b1ff52a6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -132,21 +171,14 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n \n     @Override\n     public Integer size() {\n-        int size = 0;\n-        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n-            while (iterator.hasNext()) {\n-                iterator.next();\n-                size++;\n-            }\n-        }\n-        return size;\n+        return (int) getStore().approximateNumEntries();\n     }\n \n     protected void disconnect(ProcessInstance instance) {\n         ((AbstractProcessInstance<?>) instance).internalRemoveProcessInstance(() -> {\n \n             try {\n-                byte[] reloaded = store.get(instance.id());\n+                byte[] reloaded = getStore().get(instance.id());\n                 return marshaller.unmarshallWorkflowProcessInstance(reloaded, process);\n             } catch (RuntimeException e) {\n                 LOGGER.error(\"Unexpected exception thrown when reloading process instance {}\", instance.id(), e);\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 25b1ff52a6..b2caecd20a 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -175,15 +167,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     }\n \n     protected void disconnect(ProcessInstance instance) {\n-        ((AbstractProcessInstance<?>) instance).internalRemoveProcessInstance(() -> {\n-\n-            try {\n-                byte[] reloaded = getStore().get(instance.id());\n-                return marshaller.unmarshallWorkflowProcessInstance(reloaded, process);\n-            } catch (RuntimeException e) {\n-                LOGGER.error(\"Unexpected exception thrown when reloading process instance {}\", instance.id(), e);\n-                return null;\n-            }\n-        });\n+        Supplier<byte[]> supplier = () -> getStore().get(instance.id());\n+        ((AbstractProcessInstance<?>) instance).internalRemoveProcessInstance(marshaller.createdReloadFunction(supplier));\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568892436", "body": "I already said that but every time I see `all()` it hurts me :P  at some point we need to revisit this `values()` method in runtimes, anyway just saying.", "bodyText": "I already said that but every time I see all() it hurts me :P  at some point we need to revisit this values() method in runtimes, anyway just saying.", "bodyHTML": "<p dir=\"auto\">I already said that but every time I see <code>all()</code> it hurts me :P  at some point we need to revisit this <code>values()</code> method in runtimes, anyway just saying.</p>", "author": "tiagodolphine", "createdAt": "2021-02-02T20:02:00Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzY3Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817677", "bodyText": "+1, not happy about this either :) but its the same for all persistence types, should really be used for tests only", "author": "cristianonicolai", "createdAt": "2021-02-08T07:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "633430c163438bed2b8989df88c4fcbc93e82871", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 2fe3ff6391..6e7d29e7c6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -117,7 +161,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     @Override\n     public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n         final List<ProcessInstance> instances = new ArrayList<>();\n-        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n             while (iterator.hasNext()) {\n                 instances.add(mode == MUTABLE ?\n                                       marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 2fe3ff6391..25b1ff52a6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -117,7 +156,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     @Override\n     public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n         final List<ProcessInstance> instances = new ArrayList<>();\n-        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n             while (iterator.hasNext()) {\n                 instances.add(mode == MUTABLE ?\n                                       marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n", "next_change": {"commit": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 25b1ff52a6..fb72d0ae58 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -158,10 +154,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n         final List<ProcessInstance> instances = new ArrayList<>();\n         try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n             while (iterator.hasNext()) {\n-                instances.add(mode == MUTABLE ?\n-                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n-                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n-                );\n+                instances.add(mode == MUTABLE ? marshaller.unmarshallProcessInstance(iterator.next().value, process) : marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process));\n             }\n             return instances;\n         } catch (Exception e) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"oid": "633430c163438bed2b8989df88c4fcbc93e82871", "url": "https://github.com/kiegroup/kogito-runtimes/commit/633430c163438bed2b8989df88c4fcbc93e82871", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-03T03:58:22Z", "type": "forcePushed"}, {"oid": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T01:01:28Z", "type": "forcePushed"}, {"oid": "ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T08:33:25Z", "type": "forcePushed"}, {"oid": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9cecb263d0ebb610ae1d54509cb9561437d3e33e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T09:18:08Z", "type": "forcePushed"}, {"oid": "27327e054b73b72e065a160fe42059ba4776df71", "url": "https://github.com/kiegroup/kogito-runtimes/commit/27327e054b73b72e065a160fe42059ba4776df71", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-05T06:09:56Z", "type": "forcePushed"}, {"oid": "eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "url": "https://github.com/kiegroup/kogito-runtimes/commit/eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-05T07:35:25Z", "type": "forcePushed"}, {"oid": "494bee99defc436f1c88fb00356bb81095ac1865", "url": "https://github.com/kiegroup/kogito-runtimes/commit/494bee99defc436f1c88fb00356bb81095ac1865", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T03:47:19Z", "type": "forcePushed"}, {"oid": "29159a9f025be375f7d1dde948732c6b8951f6ff", "url": "https://github.com/kiegroup/kogito-runtimes/commit/29159a9f025be375f7d1dde948732c6b8951f6ff", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T07:40:32Z", "type": "forcePushed"}, {"oid": "8291208a7fdbc2b9e2c5c89702060eccd1181a82", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8291208a7fdbc2b9e2c5c89702060eccd1181a82", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T11:55:10Z", "type": "forcePushed"}, {"oid": "95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T11:56:08Z", "type": "forcePushed"}, {"oid": "c1b58ae3e223447875d6dde4127472a981e15fb0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c1b58ae3e223447875d6dde4127472a981e15fb0", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T15:17:25Z", "type": "forcePushed"}, {"oid": "04f611739e7cf099fd05e3b4aa3ecfd485e93318", "url": "https://github.com/kiegroup/kogito-runtimes/commit/04f611739e7cf099fd05e3b4aa3ecfd485e93318", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T15:24:58Z", "type": "forcePushed"}, {"oid": "0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-09T05:37:29Z", "type": "forcePushed"}, {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-09T06:40:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572780046", "body": "Can't this be called in parallel during injection and initialization of the process endpoints?", "bodyText": "Can't this be called in parallel during injection and initialization of the process endpoints?", "bodyHTML": "<p dir=\"auto\">Can't this be called in parallel during injection and initialization of the process endpoints?</p>", "author": "MarianMacik", "createdAt": "2021-02-09T10:46:56Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(KafkaProducer::close);\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n+            producers.add(producer);", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDQ0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484445", "bodyText": "true, but I changed the logic now, the producer is not created here anymore.", "author": "cristianonicolai", "createdAt": "2021-02-10T06:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex a7ab4e52fc..0109771c8b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -43,46 +42,39 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n \n-    Map<String, Object> kafkaConfig;\n-    KafkaStreams streams;\n-    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+    KafkaStreamsStateListener stateListener;\n+    KafkaProducer<String, byte[]> producer;\n \n     @Inject\n-    @Named(\"default-kafka-broker\")\n-    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n-        this.kafkaConfig = kafkaConfig;\n-    }\n-\n-    public KafkaStreams getKafkaStreams() {\n-        return streams;\n+    public void setStateListener(KafkaStreamsStateListener stateListener) {\n+        this.stateListener = stateListener;\n     }\n \n     @Inject\n-    public void setKafkaStreams(KafkaStreams streams) {\n-        this.streams = streams;\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n     }\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(KafkaProducer::close);\n+        if (producer != null) {\n+            producer.close();\n+        }\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = getProducer();\n-            producers.add(producer);\n-            return new KafkaProcessInstances(process, streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            KafkaProcessInstances pi = new KafkaProcessInstances(process, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            stateListener.addProcessInstances(pi);\n+            return pi;\n         } catch (Exception ex) {\n             LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n             throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n-    protected KafkaProducer<String, byte[]> getProducer() {\n-        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n-    }\n-\n     public String proto() {\n         return null;\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex a7ab4e52fc..0109771c8b 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -43,46 +42,39 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n \n-    Map<String, Object> kafkaConfig;\n-    KafkaStreams streams;\n-    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+    KafkaStreamsStateListener stateListener;\n+    KafkaProducer<String, byte[]> producer;\n \n     @Inject\n-    @Named(\"default-kafka-broker\")\n-    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n-        this.kafkaConfig = kafkaConfig;\n-    }\n-\n-    public KafkaStreams getKafkaStreams() {\n-        return streams;\n+    public void setStateListener(KafkaStreamsStateListener stateListener) {\n+        this.stateListener = stateListener;\n     }\n \n     @Inject\n-    public void setKafkaStreams(KafkaStreams streams) {\n-        this.streams = streams;\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n     }\n \n     @PreDestroy\n     public void stop() {\n-        producers.forEach(KafkaProducer::close);\n+        if (producer != null) {\n+            producer.close();\n+        }\n     }\n \n     public KafkaProcessInstances createProcessInstances(Process<?> process) {\n         try {\n             LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n-            KafkaProducer<String, byte[]> producer = getProducer();\n-            producers.add(producer);\n-            return new KafkaProcessInstances(process, streams, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            KafkaProcessInstances pi = new KafkaProcessInstances(process, producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+            stateListener.addProcessInstances(pi);\n+            return pi;\n         } catch (Exception ex) {\n             LOGGER.error(\"Error creating KafkaProcessInstances for process: {}\", process.id(), ex);\n             throw new RuntimeException(\"Error creating KafkaProcessInstances for process: \" + process.id(), ex);\n         }\n     }\n \n-    protected KafkaProducer<String, byte[]> getProducer() {\n-        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n-    }\n-\n     public String proto() {\n         return null;\n     }\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\nindex 0109771c8b..f2c56961ab 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java\n", "chunk": "@@ -75,11 +71,4 @@ public abstract class KogitoProcessInstancesFactory implements ProcessInstancesF\n         }\n     }\n \n-    public String proto() {\n-        return null;\n-    }\n-\n-    public List<BaseMarshaller> marshallers() {\n-        return Collections.emptyList();\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572794286", "body": "This means that `KafkaStreams` can already be injected, but not started? So we have to wait in all store manipulation methods until it is running?", "bodyText": "This means that KafkaStreams can already be injected, but not started? So we have to wait in all store manipulation methods until it is running?", "bodyHTML": "<p dir=\"auto\">This means that <code>KafkaStreams</code> can already be injected, but not started? So we have to wait in all store manipulation methods until it is running?</p>", "author": "MarianMacik", "createdAt": "2021-02-09T11:06:25Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;\n+        this.streams.setStateListener((newState, oldState) -> {\n+            if (store == null && newState == KafkaStreams.State.RUNNING) {\n+                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n+                latch.countDown();\n+            }\n+        });", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDY4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484687", "bodyText": "yep, KafkaStream get injected but is in CREATED state, a store can only be retrieved once it is on RUNNING state.", "author": "cristianonicolai", "createdAt": "2021-02-10T06:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex e6144573a8..30318b42c9 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -55,40 +51,42 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     private String topic;\n     private ReadOnlyKeyValueStore<String, byte[]> store;\n     private ProcessInstanceMarshaller marshaller;\n-    private KafkaStreams streams;\n     private CountDownLatch latch = new CountDownLatch(1);\n \n-    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n         this.process = process;\n         this.topic = topicName(process.id());\n         this.producer = producer;\n-        this.streams = streams;\n-        this.streams.setStateListener((newState, oldState) -> {\n-            if (store == null && newState == KafkaStreams.State.RUNNING) {\n-                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n-                latch.countDown();\n-            }\n-        });\n         setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n     }\n \n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n     protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n-        if (store == null && latch.getCount() != 0) {\n-            try {\n-                latch.await(1, TimeUnit.MINUTES);\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n-            }\n-        }\n-        if (store == null) {\n-            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n-        } else {\n+        if (store != null) {\n             return store;\n         }\n+\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if(store == null){\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n     }\n \n     protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n         this.store = store;\n+        this.latch.countDown();\n     }\n \n     protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n", "next_change": {"commit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 30318b42c9..25b1ff52a6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -84,11 +93,6 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n         }\n     }\n \n-    protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n-        this.store = store;\n-        this.latch.countDown();\n-    }\n-\n     protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n         this.marshaller = marshaller;\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex e6144573a8..25b1ff52a6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -55,40 +51,46 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     private String topic;\n     private ReadOnlyKeyValueStore<String, byte[]> store;\n     private ProcessInstanceMarshaller marshaller;\n-    private KafkaStreams streams;\n     private CountDownLatch latch = new CountDownLatch(1);\n \n-    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n         this.process = process;\n         this.topic = topicName(process.id());\n         this.producer = producer;\n-        this.streams = streams;\n-        this.streams.setStateListener((newState, oldState) -> {\n-            if (store == null && newState == KafkaStreams.State.RUNNING) {\n-                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n-                latch.countDown();\n-            }\n-        });\n         setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n     }\n \n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n     protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n-        if (store == null && latch.getCount() != 0) {\n-            try {\n-                latch.await(1, TimeUnit.MINUTES);\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n-            }\n-        }\n-        if (store == null) {\n-            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n-        } else {\n+        if (store != null) {\n             return store;\n         }\n+\n+        return getStoreAwait();\n     }\n \n     protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n         this.store = store;\n+        this.latch.countDown();\n+    }\n+\n+    private ReadOnlyKeyValueStore<String, byte[]> getStoreAwait() {\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if (store == null) {\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n     }\n \n     protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 25b1ff52a6..b2caecd20a 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -93,7 +91,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n         }\n     }\n \n-    protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n+    protected void setMarshaller(ProcessInstanceMarshallerService marshaller) {\n         this.marshaller = marshaller;\n     }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572809653", "body": "Daniele said that this can happen, but I don't see how would `new KafkaProcessInstancesFactory();` fail. Maybe in older code it could happen?", "bodyText": "Daniele said that this can happen, but I don't see how would new KafkaProcessInstancesFactory(); fail. Maybe in older code it could happen?", "bodyHTML": "<p dir=\"auto\">Daniele said that this can happen, but I don't see how would <code>new KafkaProcessInstancesFactory();</code> fail. Maybe in older code it could happen?</p>", "author": "MarianMacik", "createdAt": "2021-02-09T11:30:33Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIyOTcyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573229727", "bodyText": "My comment was mainly for general stability and avoid problem in the future :)", "author": "danielezonca", "createdAt": "2021-02-09T20:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDgyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484827", "bodyText": "yep, just more defensive style, just in case :)", "author": "cristianonicolai", "createdAt": "2021-02-10T06:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -65,20 +65,23 @@ public class KafkaProcessInstancesIT {\n \n     KafkaProcessInstancesFactory factory;\n \n+    KafkaStreamsStateListener listener = new KafkaStreamsStateListener();\n+\n     @BeforeEach\n     void start() {\n         factory = new KafkaProcessInstancesFactory();\n         factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+        factory.setStateListener(listener);\n     }\n \n     @AfterEach\n     void stop() {\n         if (factory != null) {\n             factory.stop();\n-            if (factory.getKafkaStreams() != null) {\n-                factory.getKafkaStreams().close();\n-                factory.getKafkaStreams().cleanUp();\n-            }\n+        }\n+        if (listener.getKafkaStreams() != null) {\n+            listener.getKafkaStreams().close();\n+            listener.getKafkaStreams().cleanUp();\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..ee607d63e1 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -65,20 +65,23 @@ public class KafkaProcessInstancesIT {\n \n     KafkaProcessInstancesFactory factory;\n \n+    KafkaStreamsStateListener listener = new KafkaStreamsStateListener();\n+\n     @BeforeEach\n     void start() {\n         factory = new KafkaProcessInstancesFactory();\n         factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+        factory.setStateListener(listener);\n     }\n \n     @AfterEach\n     void stop() {\n         if (factory != null) {\n             factory.stop();\n-            if (factory.getKafkaStreams() != null) {\n-                factory.getKafkaStreams().close();\n-                factory.getKafkaStreams().cleanUp();\n-            }\n+        }\n+        if (listener.getKafkaStreams() != null) {\n+            listener.getKafkaStreams().close();\n+            listener.getKafkaStreams().cleanUp();\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572812900", "body": "Just curious, I have always thought that Kafka Streams also support producers and consumers, meaning it is the \"superset\" of the traditional Consumer/Producer API. Or this is just in case we receive something from Kafka and then want to push it again to Kafka (\"streams\")? Not sure about the clear distinction between Kafka Streams and Kafka here.", "bodyText": "Just curious, I have always thought that Kafka Streams also support producers and consumers, meaning it is the \"superset\" of the traditional Consumer/Producer API. Or this is just in case we receive something from Kafka and then want to push it again to Kafka (\"streams\")? Not sure about the clear distinction between Kafka Streams and Kafka here.", "bodyHTML": "<p dir=\"auto\">Just curious, I have always thought that Kafka Streams also support producers and consumers, meaning it is the \"superset\" of the traditional Consumer/Producer API. Or this is just in case we receive something from Kafka and then want to push it again to Kafka (\"streams\")? Not sure about the clear distinction between Kafka Streams and Kafka here.</p>", "author": "MarianMacik", "createdAt": "2021-02-09T11:35:57Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NjE1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573486154", "bodyText": "KafkaStreams is building a table ( key value store ) representation of the data ( process state ). The way it does it is key storing the latest value of certain message key as the current state. That means, I can read the current state of process from KafkaStreams table abstraction, but if I want to manipulate it ( delete/create/update ) the process, I need to send a message to a Kafka topic.\nSee https://docs.confluent.io/platform/current/streams/concepts.html#duality-of-streams-and-tables", "author": "cristianonicolai", "createdAt": "2021-02-10T06:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "730a8254ba0855f4a904091a1306a0599df22613", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex e6144573a8..30318b42c9 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -55,40 +51,42 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     private String topic;\n     private ReadOnlyKeyValueStore<String, byte[]> store;\n     private ProcessInstanceMarshaller marshaller;\n-    private KafkaStreams streams;\n     private CountDownLatch latch = new CountDownLatch(1);\n \n-    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n         this.process = process;\n         this.topic = topicName(process.id());\n         this.producer = producer;\n-        this.streams = streams;\n-        this.streams.setStateListener((newState, oldState) -> {\n-            if (store == null && newState == KafkaStreams.State.RUNNING) {\n-                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n-                latch.countDown();\n-            }\n-        });\n         setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n     }\n \n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n     protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n-        if (store == null && latch.getCount() != 0) {\n-            try {\n-                latch.await(1, TimeUnit.MINUTES);\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n-            }\n-        }\n-        if (store == null) {\n-            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n-        } else {\n+        if (store != null) {\n             return store;\n         }\n+\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if(store == null){\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n     }\n \n     protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n         this.store = store;\n+        this.latch.countDown();\n     }\n \n     protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n", "next_change": {"commit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 30318b42c9..25b1ff52a6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -84,11 +93,6 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n         }\n     }\n \n-    protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n-        this.store = store;\n-        this.latch.countDown();\n-    }\n-\n     protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n         this.marshaller = marshaller;\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex e6144573a8..25b1ff52a6 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -55,40 +51,46 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     private String topic;\n     private ReadOnlyKeyValueStore<String, byte[]> store;\n     private ProcessInstanceMarshaller marshaller;\n-    private KafkaStreams streams;\n     private CountDownLatch latch = new CountDownLatch(1);\n \n-    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n         this.process = process;\n         this.topic = topicName(process.id());\n         this.producer = producer;\n-        this.streams = streams;\n-        this.streams.setStateListener((newState, oldState) -> {\n-            if (store == null && newState == KafkaStreams.State.RUNNING) {\n-                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n-                latch.countDown();\n-            }\n-        });\n         setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n     }\n \n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n     protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n-        if (store == null && latch.getCount() != 0) {\n-            try {\n-                latch.await(1, TimeUnit.MINUTES);\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n-            }\n-        }\n-        if (store == null) {\n-            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n-        } else {\n+        if (store != null) {\n             return store;\n         }\n+\n+        return getStoreAwait();\n     }\n \n     protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n         this.store = store;\n+        this.latch.countDown();\n+    }\n+\n+    private ReadOnlyKeyValueStore<String, byte[]> getStoreAwait() {\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if (store == null) {\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n     }\n \n     protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n", "next_change": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 25b1ff52a6..b2caecd20a 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -93,7 +91,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n         }\n     }\n \n-    protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n+    protected void setMarshaller(ProcessInstanceMarshallerService marshaller) {\n         this.marshaller = marshaller;\n     }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572815823", "body": "Do all of these methods have to be package-private?", "bodyText": "Do all of these methods have to be package-private?", "bodyHTML": "<p dir=\"auto\">Do all of these methods have to be package-private?</p>", "author": "MarianMacik", "createdAt": "2021-02-09T11:40:46Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {\n+            factory.stop();\n+            if (factory.getKafkaStreams() != null) {\n+                factory.getKafkaStreams().close();\n+                factory.getKafkaStreams().cleanUp();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n+\n+        mutablePi.start();\n+        assertThat(mutablePi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(mutablePi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(mutablePi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+\n+        await().until(() -> instances.values().size() == 1);\n+        \n+        ProcessInstance<BpmnVariables> pi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+\n+        ProcessInstance<BpmnVariables> readOnlyPi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThat(readOnlyPi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(readOnlyPi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(readOnlyPi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> readOnlyPi.abort());\n+\n+        instances.findById(mutablePi.id()).get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testValuesReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        ProcessInstance<BpmnVariables> pi = instances.values().stream().findFirst().get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+        instances.values(ProcessInstanceReadMode.MUTABLE).stream().findFirst().get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testBasicFlow() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+        \n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+        assertEquals(STATE_ACTIVE, processInstance.status());\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        SecurityPolicy asJohn = SecurityPolicy.of(IdentityProviders.of(\"john\"));\n+\n+        assertThat(instances.values().iterator().next().workItems(asJohn)).hasSize(1);\n+\n+        List<WorkItem> workItems = processInstance.workItems(asJohn);\n+        assertThat(workItems).hasSize(1);\n+        WorkItem workItem = workItems.get(0);\n+        assertEquals(\"john\", workItem.getParameters().get(\"ActorId\"));\n+        processInstance.completeWorkItem(workItem.getId(), null, asJohn);\n+        assertEquals(STATE_COMPLETED, processInstance.status());\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    KafkaStreams createStreams(Process process) {\n+        Topology topology = createTopologyForProcesses(Arrays.asList(process.id()));\n+        KafkaStreams streams = new KafkaStreams(topology, getStreamsConfig());\n+        streams.setUncaughtExceptionHandler((Thread thread, Throwable throwable) ->\n+                                                    LOGGER.error(\"Kafka persistence error: \" + throwable.getMessage(), throwable)\n+        );\n+        streams.cleanUp();\n+        return streams;\n+    }\n+\n+    Properties getStreamsConfig() {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NjMzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573486330", "bodyText": "not really, but this is just an IT test anyway, didn't see much of a need to do it differently", "author": "cristianonicolai", "createdAt": "2021-02-10T06:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\nindex 8ed95049b4..b857f4f2c2 100644\n--- a/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n+++ b/addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java\n", "chunk": "@@ -179,9 +181,7 @@ public class KafkaProcessInstancesIT {\n     KafkaStreams createStreams(Process process) {\n         Topology topology = createTopologyForProcesses(Arrays.asList(process.id()));\n         KafkaStreams streams = new KafkaStreams(topology, getStreamsConfig());\n-        streams.setUncaughtExceptionHandler((Thread thread, Throwable throwable) ->\n-                                                    LOGGER.error(\"Kafka persistence error: \" + throwable.getMessage(), throwable)\n-        );\n+        streams.setUncaughtExceptionHandler((Thread thread, Throwable throwable) -> LOGGER.error(\"Kafka persistence error: \" + throwable.getMessage(), throwable));\n         streams.cleanUp();\n         return streams;\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572877680", "body": "Isn't this already `true` because of the check at the beginning of the method?", "bodyText": "Isn't this already true because of the check at the beginning of the method?", "bodyHTML": "<p dir=\"auto\">Isn't this already <code>true</code> because of the check at the beginning of the method?</p>", "author": "MarianMacik", "createdAt": "2021-02-09T13:21:07Z", "path": "kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -94,34 +99,39 @@ public PersistenceGenerator(KogitoBuildContext context, ProtoGenerator protoGene\n             return Collections.emptyList();\n         }\n \n-        switch (persistenceType()) {\n-            case INFINISPAN_PERSISTENCE_TYPE:\n-                return infinispanBasedPersistence();\n-            case FILESYSTEM_PERSISTENCE_TYPE:\n-                return fileSystemBasedPersistence();\n-            case MONGODB_PERSISTENCE_TYPE:\n-                return mongodbBasedPersistence();\n-            default:\n-                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n+        \n+        if (context().getAddonsConfig().usePersistence()) {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NzIzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573487237", "bodyText": "true, that was a bad merge, fixed now", "author": "cristianonicolai", "createdAt": "2021-02-10T06:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 3a68a47a4a..cc6bf851ea 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -101,23 +101,21 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n         \n-        if (context().getAddonsConfig().usePersistence()) {\n-            switch (persistenceType()) {\n-                case INFINISPAN_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(infinispanBasedPersistence());\n-                    break;\n-                case FILESYSTEM_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(fileSystemBasedPersistence());\n-                    break;\n-                case MONGODB_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(mongodbBasedPersistence());\n-                    break;\n-                case KAFKA_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(kafkaBasedPersistence());\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n-            }\n+        switch (persistenceType()) {\n+            case INFINISPAN_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(infinispanBasedPersistence());\n+                break;\n+            case FILESYSTEM_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(fileSystemBasedPersistence());\n+                break;\n+            case MONGODB_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(mongodbBasedPersistence());\n+                break;\n+            case KAFKA_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(kafkaBasedPersistence());\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n         }\n \n         return generatedFiles;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 3a68a47a4a..37c569cb30 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -101,23 +101,21 @@ public class PersistenceGenerator extends AbstractGenerator {\n \n         Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n         \n-        if (context().getAddonsConfig().usePersistence()) {\n-            switch (persistenceType()) {\n-                case INFINISPAN_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(infinispanBasedPersistence());\n-                    break;\n-                case FILESYSTEM_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(fileSystemBasedPersistence());\n-                    break;\n-                case MONGODB_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(mongodbBasedPersistence());\n-                    break;\n-                case KAFKA_PERSISTENCE_TYPE:\n-                    generatedFiles.addAll(kafkaBasedPersistence());\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n-            }\n+        switch (persistenceType()) {\n+            case INFINISPAN_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(infinispanBasedPersistence());\n+                break;\n+            case FILESYSTEM_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(fileSystemBasedPersistence());\n+                break;\n+            case MONGODB_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(mongodbBasedPersistence());\n+                break;\n+            case KAFKA_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(kafkaBasedPersistence());\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n         }\n \n         return generatedFiles;\n", "next_change": {"commit": "c2eb2a63a38a1941d69281a1d8bc40319ec7833b", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 37c569cb30..4ee92838f2 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -114,6 +121,9 @@ public class PersistenceGenerator extends AbstractGenerator {\n             case KAFKA_PERSISTENCE_TYPE:\n                 generatedFiles.addAll(kafkaBasedPersistence());\n                 break;\n+            case POSTGRESQL_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(postgresqlBasedPersistence());\n+                break;\n             default:\n                 throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n         }\n", "next_change": {"commit": "cd771ff34f845d9c809b051f86ce8a96e2042dec", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 4ee92838f2..cb583c23d5 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -124,6 +132,9 @@ public class PersistenceGenerator extends AbstractGenerator {\n             case POSTGRESQL_PERSISTENCE_TYPE:\n                 generatedFiles.addAll(postgresqlBasedPersistence());\n                 break;\n+            case JDBC_PERSISTENCE_TYPE:\n+                generatedFiles.addAll(jdbcBasedPersistence());\n+                break;\n             default:\n                 throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n         }\n", "next_change": {"commit": "2794200490a3a23e6e8f1394d5a419022c48d536", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex cb583c23d5..59d37283c4 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -142,6 +150,12 @@ public class PersistenceGenerator extends AbstractGenerator {\n         return generatedFiles;\n     }\n \n+    @Override\n+    public boolean isEmpty() {\n+        // PersistenceGenerator is a different type of generator without specific resources\n+        return !context().getAddonsConfig().usePersistence();\n+    }\n+\n     public String persistenceType() {\n         return context().getApplicationProperty(\"kogito.persistence.type\").orElse(PersistenceGenerator.DEFAULT_PERSISTENCE_TYPE);\n     }\n", "next_change": {"commit": "a5452bec34ca61b20ca498cf91fb6714ea68f7b5", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 59d37283c4..43374b1d99 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -157,7 +189,7 @@ public class PersistenceGenerator extends AbstractGenerator {\n     }\n \n     public String persistenceType() {\n-        return context().getApplicationProperty(\"kogito.persistence.type\").orElse(PersistenceGenerator.DEFAULT_PERSISTENCE_TYPE);\n+        return context().getApplicationProperty(KOGITO_PERSISTENCE_TYPE).orElse(PersistenceGenerator.DEFAULT_PERSISTENCE_TYPE);\n     }\n \n     protected Collection<GeneratedFile> infinispanBasedPersistence() {\n", "next_change": {"commit": "cb40cae9b0d38f8986725bd8d82b22364bc9b2d2", "changed_code": [{"header": "diff --git a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\nindex 43374b1d99..4071fd745c 100644\n--- a/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n+++ b/kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java\n", "chunk": "@@ -192,83 +138,6 @@ public class PersistenceGenerator extends AbstractGenerator {\n         return context().getApplicationProperty(KOGITO_PERSISTENCE_TYPE).orElse(PersistenceGenerator.DEFAULT_PERSISTENCE_TYPE);\n     }\n \n-    protected Collection<GeneratedFile> infinispanBasedPersistence() {\n-        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration().setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n-\n-        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n-\n-        ConstructorDeclaration constructor = createConstructorForClazz(persistenceProviderClazz);\n-\n-        if (context().hasDI()) {\n-            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n-            context().getDependencyInjectionAnnotator().withInjection(constructor);\n-\n-            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n-                    .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n-                    .setName(TEMPLATE_NAME));\n-            context().getDependencyInjectionAnnotator().withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n-            // allow to inject template name for the cache\n-            BlockStmt templateMethodBody = new BlockStmt();\n-            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), OR_ELSE).addArgument(new StringLiteralExpr(\"\"))));\n-\n-            MethodDeclaration templateNameMethod = new MethodDeclaration()\n-                    .addModifier(Keyword.PUBLIC)\n-                    .setName(\"template\")\n-                    .setType(String.class)\n-                    .setBody(templateMethodBody);\n-\n-            persistenceProviderClazz.addMember(templateNameField);\n-            persistenceProviderClazz.addMember(templateNameMethod);\n-        }\n-\n-        Collection<GeneratedFile> generatedFiles = new ArrayList<>();\n-        CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n-        compilationUnit.getTypes().add(persistenceProviderClazz);\n-        addOptimisticLockFlag(persistenceProviderClazz);\n-        generatePersistenceProviderClazz(persistenceProviderClazz, compilationUnit).ifPresent(generatedFiles::add);\n-        return generatedFiles;\n-    }\n-\n-    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n-        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n-                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n-\n-        if (context().hasDI()) {\n-            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n-        }\n-\n-        Collection<GeneratedFile> generatedFiles = new ArrayList<>();\n-        TemplatedGenerator generator = TemplatedGenerator.builder().withTemplateBasePath(CLASS_TEMPLATES_PERSISTENCE)\n-                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n-                .withPackageName(KOGITO_PROCESS_INSTANCE_PACKAGE)\n-                .build(context(), \"KafkaStreamsTopologyProducer\");\n-        CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();\n-        ClassOrInterfaceDeclaration producer = parsedClazzFile.findFirst(ClassOrInterfaceDeclaration.class).orElseThrow(() -> new InvalidTemplateException(\n-                generator,\n-                \"Failed to find template for KafkaStreamsTopologyProducer\"));\n-\n-        MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n-\n-        protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n-        producer.getFieldByName(\"processes\")\n-                .orElseThrow(() -> new InvalidTemplateException(generator, \"Failed to find field 'processes' in KafkaStreamsTopologyProducer template\"))\n-                .getVariable(0).setInitializer(asListOfProcesses);\n-\n-        String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n-        generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n-                clazzName.replace('.', '/') + JAVA,\n-                parsedClazzFile.toString()));\n-\n-        CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n-        compilationUnit.getTypes().add(persistenceProviderClazz);\n-        generatePersistenceProviderClazz(persistenceProviderClazz, compilationUnit).ifPresent(generatedFiles::add);\n-        return generatedFiles;\n-    }\n-\n     protected Collection<GeneratedFile> generateProtoMarshaller() {\n         if (!hasProtoMarshaller(context())) {\n             // TODO implement a validation check to verify that data classes implement Serializable\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "3b3dc689846591422480de0c8467886a650f05e0", "committedDate": "2021-02-15 15:47:59 +1000", "message": "KOGITO-4376 Copyright reformat to match expected format (#1065)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "72aee2ec92d6efd6290400589444aacd4c8b1513", "committedDate": "2021-03-26 20:55:34 +0100", "message": "Bump kie7 to 7.52.0.Beta1 (#1177)"}, {"oid": "c2eb2a63a38a1941d69281a1d8bc40319ec7833b", "committedDate": "2021-04-01 08:30:35 -0300", "message": "[KOGITO-4335] PostgreSQL Persistence Addon (#1103)"}, {"oid": "d0abe2b7e3384777a566f2c6eaa21c3f7b7f28b8", "committedDate": "2021-04-08 09:44:07 +0200", "message": "[KOGITO-4833] Make REST generation optional (#1185)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "b1651cc826e27aecb0a53b668e1d4a827c672df4", "committedDate": "2021-05-26 23:11:13 +1000", "message": "KOGITO-5170 - Allow using environment variables to define connection options (#1324)"}, {"oid": "cd771ff34f845d9c809b051f86ce8a96e2042dec", "committedDate": "2021-05-29 18:50:13 +1000", "message": "[KOGITO-4611] - Generic and tradicional JDBC implementation addon for SQL databases (PostgreSQL first) (#1249)"}, {"oid": "dddb004008396f6629351f5c2e1c6e6e10e08247", "committedDate": "2021-06-02 22:43:45 +1000", "message": "[KOGITO-4438] PostgreSQL research about doing optmistic locking (#1212)"}, {"oid": "8b8d35813064ca1f0e7905cb286448cc9c77ec64", "committedDate": "2021-06-17 10:02:45 +1000", "message": "[KOGITO-5196] - JDBC addon with optmistic locking (#1357)"}, {"oid": "3e11c79b046ac00d5e82b8f591d708163b4b834a", "committedDate": "2021-06-17 18:59:06 +1000", "message": "KOGITO-3759: Implement plugable transaction for MongoDB persistence (#987)"}, {"oid": "7862158b7620876778a3ac111886b3c56c4fa702", "committedDate": "2021-06-21 21:23:04 +1000", "message": "[KOGITO-5197] - Infinispan addon with optmistic locking (#1356)"}, {"oid": "240c07f94cfb09365b2b7f42ef32d9e3f3913d73", "committedDate": "2021-06-22 00:43:57 +1000", "message": "[KOGITO-4006] - PoC around using optimistic locking with MongoDB (#1030)"}, {"oid": "87d96bbcf7af7a66ad5678b4b50a0358f99aa8c5", "committedDate": "2021-08-03 00:01:29 +1000", "message": "KOGITO-5564 Use Quarkus PgPool instead of creating a new one (#1472)"}, {"oid": "2794200490a3a23e6e8f1394d5a419022c48d536", "committedDate": "2021-08-04 17:23:38 -0300", "message": "[KOGITO-5622] Implement Generator.isEmpty() to skip generation when no resources are available (#1497)"}, {"oid": "579605c7727c73ab47a761376acb74014ba3759d", "committedDate": "2021-08-11 17:50:45 +1000", "message": "[KOGITO-5687] Fixing proto file path on windows (#1523)"}, {"oid": "b0d17e3aa23c02fdc6ba5816c16a552b502ff9fd", "committedDate": "2021-09-01 15:39:19 +1000", "message": "[KOGITO-5449] Fix JandexProtoGenerator StackOverflow and ProtoGenerator refactor (#1548)"}, {"oid": "a5452bec34ca61b20ca498cf91fb6714ea68f7b5", "committedDate": "2021-10-07 11:37:09 +0200", "message": "[KOGITO-5887] Proto generation improvements: optional data index proto generation (#1631)"}, {"oid": "4a7801f27b46790674cac7198e00c8d17f1c8bb6", "committedDate": "2021-11-22 13:13:39 +1000", "message": "[KOGITO-5863] Async process execution (#1639)"}, {"oid": "e487a71463542adf380aa01b9667505674e7f6a6", "committedDate": "2022-01-05 09:26:50 +0100", "message": "KOGITO-6131 Enable codegen when RESTEasy reactive is used (#1757)"}, {"oid": "2c5e9ebd8f3afb6b0b3ef2028dcbb79cdc360ec6", "committedDate": "2022-02-11 01:39:33 +1000", "message": "KOGITO-6756 Remove base marshallers from codegen (#1989)"}, {"oid": "37247af99d5aba4be9acd8e24b46d84300b8b66f", "committedDate": "2022-02-14 21:31:53 +1000", "message": "KOGITO-6756 Proto support for generic Serializable objects and Instant (#1996)"}, {"oid": "cfedd4ad7d8453050d9f7afbe904e3247b5f6948", "committedDate": "2022-02-23 10:37:57 +1000", "message": "KOGITO-6798 Support custom Array types in protobuf (#2018)"}, {"oid": "cb40cae9b0d38f8986725bd8d82b22364bc9b2d2", "committedDate": "2022-04-05 19:26:53 +1000", "message": "KOGITO-6905 Review persistence modules to be independent of codegen (#2106)"}, {"oid": "e661717a4f85c1e20953d085952fcfc3bbae170e", "committedDate": "2022-04-10 09:54:56 +0200", "message": "[KOGITO-6894] remove KieRuntimeBuilder duplication (#2136)"}, {"oid": "2b9cd61bc60947bd13598f77f4c5c788494e5769", "committedDate": "2022-08-24 13:13:52 +1000", "message": "KOGITO-4525 - Prevent generated protobuf to have data model type with the same name as the process (#2398)"}]}, {"oid": "730a8254ba0855f4a904091a1306a0599df22613", "url": "https://github.com/kiegroup/kogito-runtimes/commit/730a8254ba0855f4a904091a1306a0599df22613", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T06:34:15Z", "type": "forcePushed"}, {"oid": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T07:02:46Z", "type": "forcePushed"}, {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T10:20:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573728789", "body": "As I asked before, cannot this be called by multiple threads at the same time? Imagine having more processes and injecting them when the app starts. This calls this method then:\r\nhttps://github.com/kiegroup/kogito-runtimes/blob/17154e134593e5c41f5374621fac00ce0eb1e964/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java#L131-L139\r\n\r\nwhen the process is activated.\r\n\r\nNot sure if injection can happen in more threads, but if it can then we need to use concurrent collection here I think. Otherwise in case more than one process is activated at the same time, it won't work properly.", "bodyText": "As I asked before, cannot this be called by multiple threads at the same time? Imagine having more processes and injecting them when the app starts. This calls this method then:\n\n  \n    \n      kogito-runtimes/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java\n    \n    \n        Lines 131 to 139\n      in\n      17154e1\n    \n    \n    \n    \n\n        \n          \n           public Process<T> configure() { \n        \n\n        \n          \n            \n        \n\n        \n          \n               registerListeners(); \n        \n\n        \n          \n               if (isProcessFactorySet()) { \n        \n\n        \n          \n                   this.instances = (MutableProcessInstances<T>) processInstancesFactory.createProcessInstances(this); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               return this; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nwhen the process is activated.\nNot sure if injection can happen in more threads, but if it can then we need to use concurrent collection here I think. Otherwise in case more than one process is activated at the same time, it won't work properly.", "bodyHTML": "<p dir=\"auto\">As I asked before, cannot this be called by multiple threads at the same time? Imagine having more processes and injecting them when the app starts. This calls this method then:<br>\n<div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/kiegroup/kogito-runtimes/blob/17154e134593e5c41f5374621fac00ce0eb1e964/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java#L131-L139\">kogito-runtimes/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n        Lines 131 to 139\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/kiegroup/kogito-runtimes/commit/17154e134593e5c41f5374621fac00ce0eb1e964\">17154e1</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L131\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"131\"></td>\n          <td id=\"LC131\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">public</span> <span class=\"pl-k\">Process&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-en\">configure</span>() { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L132\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"132\"></td>\n          <td id=\"LC132\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L133\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"133\"></td>\n          <td id=\"LC133\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     registerListeners(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L134\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"134\"></td>\n          <td id=\"LC134\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (isProcessFactorySet()) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L135\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"135\"></td>\n          <td id=\"LC135\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>instances <span class=\"pl-k\">=</span> (<span class=\"pl-k\">MutableProcessInstances&lt;<span class=\"pl-smi\">T</span>&gt;</span>) processInstancesFactory<span class=\"pl-k\">.</span>createProcessInstances(<span class=\"pl-c1\">this</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L136\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"136\"></td>\n          <td id=\"LC136\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L137\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"137\"></td>\n          <td id=\"LC137\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L138\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"138\"></td>\n          <td id=\"LC138\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">return</span> <span class=\"pl-c1\">this</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L139\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"139\"></td>\n          <td id=\"LC139\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p dir=\"auto\">when the process is activated.</p>\n<p dir=\"auto\">Not sure if injection can happen in more threads, but if it can then we need to use concurrent collection here I think. Otherwise in case more than one process is activated at the same time, it won't work properly.</p>", "author": "MarianMacik", "createdAt": "2021-02-10T13:33:32Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });\n+        }\n+    }\n+\n+    public void addProcessInstances(KafkaProcessInstances pi) {\n+        LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n+        instances.add(pi);", "originalCommit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1MTQ3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574251472", "bodyText": "yep, makes sense. I changed the backing collection to support concurrent access now, thanks", "author": "cristianonicolai", "createdAt": "2021-02-11T04:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\nindex 8f214a8028..d090f2b3eb 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n", "chunk": "@@ -36,42 +37,49 @@ public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n \n-    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+    private Map<String, KafkaProcessInstances> instances = new ConcurrentHashMap<>();\n \n     private KafkaStreams streams;\n \n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n     @Inject\n     public void setKafkaStreams(KafkaStreams streams) {\n         this.streams = streams;\n         this.streams.setStateListener(this);\n     }\n \n-    protected KafkaStreams getKafkaStreams() {\n-        return streams;\n-    }\n-\n     @PreDestroy\n     public void close() {\n         instances.clear();\n     }\n \n-    protected List<KafkaProcessInstances> getInstances() {\n-        return instances;\n+    protected Collection<KafkaProcessInstances> getInstances() {\n+        return instances.values();\n     }\n \n     @Override\n     public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n         LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n         if (newState == KafkaStreams.State.RUNNING) {\n-            instances.forEach(pi -> {\n-                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n-                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            instances.forEach((id, pi) -> {\n+                LOGGER.info(\"Creating store for process: {}\", id);\n+                setStore(pi);\n             });\n         }\n     }\n \n+    private void setStore(KafkaProcessInstances pi) {\n+        pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+    }\n+\n     public void addProcessInstances(KafkaProcessInstances pi) {\n         LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n-        instances.add(pi);\n+        if (streams.state() == KafkaStreams.State.RUNNING) {\n+            setStore(pi);\n+        }\n+        instances.put(pi.getProcess().id(), pi);\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\nindex 8f214a8028..d090f2b3eb 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n", "chunk": "@@ -36,42 +37,49 @@ public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n \n-    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+    private Map<String, KafkaProcessInstances> instances = new ConcurrentHashMap<>();\n \n     private KafkaStreams streams;\n \n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n     @Inject\n     public void setKafkaStreams(KafkaStreams streams) {\n         this.streams = streams;\n         this.streams.setStateListener(this);\n     }\n \n-    protected KafkaStreams getKafkaStreams() {\n-        return streams;\n-    }\n-\n     @PreDestroy\n     public void close() {\n         instances.clear();\n     }\n \n-    protected List<KafkaProcessInstances> getInstances() {\n-        return instances;\n+    protected Collection<KafkaProcessInstances> getInstances() {\n+        return instances.values();\n     }\n \n     @Override\n     public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n         LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n         if (newState == KafkaStreams.State.RUNNING) {\n-            instances.forEach(pi -> {\n-                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n-                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            instances.forEach((id, pi) -> {\n+                LOGGER.info(\"Creating store for process: {}\", id);\n+                setStore(pi);\n             });\n         }\n     }\n \n+    private void setStore(KafkaProcessInstances pi) {\n+        pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+    }\n+\n     public void addProcessInstances(KafkaProcessInstances pi) {\n         LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n-        instances.add(pi);\n+        if (streams.state() == KafkaStreams.State.RUNNING) {\n+            setStore(pi);\n+        }\n+        instances.put(pi.getProcess().id(), pi);\n     }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573735392", "body": "What if KafkaStreams component is started earlier then all the `KafkaProcessInstances` are set up? Will it react also then? If not, we may permanently set state to running in the listener when we get that information and then set stores directly if the state is already running. That would mean, however, to sync it properly.", "bodyText": "What if KafkaStreams component is started earlier then all the KafkaProcessInstances are set up? Will it react also then? If not, we may permanently set state to running in the listener when we get that information and then set stores directly if the state is already running. That would mean, however, to sync it properly.", "bodyHTML": "<p dir=\"auto\">What if KafkaStreams component is started earlier then all the <code>KafkaProcessInstances</code> are set up? Will it react also then? If not, we may permanently set state to running in the listener when we get that information and then set stores directly if the state is already running. That would mean, however, to sync it properly.</p>", "author": "MarianMacik", "createdAt": "2021-02-10T13:43:03Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });", "originalCommit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1MTI2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574251266", "bodyText": "from what I seen that shouldnt happen, but I added a check anyway so we should be covered now.", "author": "cristianonicolai", "createdAt": "2021-02-11T04:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDQwMTgxNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574401814", "bodyText": "In theory it can still happen if the addProcessInstances passes the check and the streams are not running, but then the listener is triggered before a hash map is updated. But I agree, that this probably should be sorted out on the Kafka Streams/Quarkus side that they should wait until dependency injection is established so any listeners can be triggered only after that. I think it is fine for now.", "author": "MarianMacik", "createdAt": "2021-02-11T10:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\nindex 8f214a8028..d090f2b3eb 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n", "chunk": "@@ -36,42 +37,49 @@ public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n \n-    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+    private Map<String, KafkaProcessInstances> instances = new ConcurrentHashMap<>();\n \n     private KafkaStreams streams;\n \n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n     @Inject\n     public void setKafkaStreams(KafkaStreams streams) {\n         this.streams = streams;\n         this.streams.setStateListener(this);\n     }\n \n-    protected KafkaStreams getKafkaStreams() {\n-        return streams;\n-    }\n-\n     @PreDestroy\n     public void close() {\n         instances.clear();\n     }\n \n-    protected List<KafkaProcessInstances> getInstances() {\n-        return instances;\n+    protected Collection<KafkaProcessInstances> getInstances() {\n+        return instances.values();\n     }\n \n     @Override\n     public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n         LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n         if (newState == KafkaStreams.State.RUNNING) {\n-            instances.forEach(pi -> {\n-                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n-                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            instances.forEach((id, pi) -> {\n+                LOGGER.info(\"Creating store for process: {}\", id);\n+                setStore(pi);\n             });\n         }\n     }\n \n+    private void setStore(KafkaProcessInstances pi) {\n+        pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+    }\n+\n     public void addProcessInstances(KafkaProcessInstances pi) {\n         LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n-        instances.add(pi);\n+        if (streams.state() == KafkaStreams.State.RUNNING) {\n+            setStore(pi);\n+        }\n+        instances.put(pi.getProcess().id(), pi);\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8b29d15280535b78eafebbd5f760da085177a666", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\nindex 8f214a8028..d090f2b3eb 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java\n", "chunk": "@@ -36,42 +37,49 @@ public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n \n-    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+    private Map<String, KafkaProcessInstances> instances = new ConcurrentHashMap<>();\n \n     private KafkaStreams streams;\n \n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n     @Inject\n     public void setKafkaStreams(KafkaStreams streams) {\n         this.streams = streams;\n         this.streams.setStateListener(this);\n     }\n \n-    protected KafkaStreams getKafkaStreams() {\n-        return streams;\n-    }\n-\n     @PreDestroy\n     public void close() {\n         instances.clear();\n     }\n \n-    protected List<KafkaProcessInstances> getInstances() {\n-        return instances;\n+    protected Collection<KafkaProcessInstances> getInstances() {\n+        return instances.values();\n     }\n \n     @Override\n     public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n         LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n         if (newState == KafkaStreams.State.RUNNING) {\n-            instances.forEach(pi -> {\n-                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n-                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            instances.forEach((id, pi) -> {\n+                LOGGER.info(\"Creating store for process: {}\", id);\n+                setStore(pi);\n             });\n         }\n     }\n \n+    private void setStore(KafkaProcessInstances pi) {\n+        pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+    }\n+\n     public void addProcessInstances(KafkaProcessInstances pi) {\n         LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n-        instances.add(pi);\n+        if (streams.state() == KafkaStreams.State.RUNNING) {\n+            setStore(pi);\n+        }\n+        instances.put(pi.getProcess().id(), pi);\n     }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"oid": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c3aae5132acc313a6460afbfa28a8bb09057cc62", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T04:54:42Z", "type": "forcePushed"}, {"oid": "1cb72ee9575ad444bba155bc7610f9eaf168bce7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1cb72ee9575ad444bba155bc7610f9eaf168bce7", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T04:59:49Z", "type": "forcePushed"}, {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T05:43:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574831651", "body": "This is just an approximation, do we use this value anywhere? We should make sure an approximation works", "bodyText": "This is just an approximation, do we use this value anywhere? We should make sure an approximation works", "bodyHTML": "<p dir=\"auto\">This is just an approximation, do we use this value anywhere? We should make sure an approximation works</p>", "author": "danielezonca", "createdAt": "2021-02-11T21:15:50Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n+    }\n+\n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n+    protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n+        if (store != null) {\n+            return store;\n+        }\n+\n+        return getStoreAwait();\n+    }\n+\n+    protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n+        this.store = store;\n+        this.latch.countDown();\n+    }\n+\n+    private ReadOnlyKeyValueStore<String, byte[]> getStoreAwait() {\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if (store == null) {\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n+    }\n+\n+    protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n+        this.marshaller = marshaller;\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return getStore().get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (getStore().get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = getStore().get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        return (int) getStore().approximateNumEntries();", "originalCommit": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTE0MTgzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r575141832", "bodyText": "I added just to keep it somehow compatible with the other persistence impl. During my tests this is not reliable at all, or it doesn't update as frequently as it would need for a simple IT test. We will probably have to review this in the future, but size, values are methods used manly for tests.", "author": "cristianonicolai", "createdAt": "2021-02-12T10:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "ebd6814804324580527b52c664d1dc753c6a6ca4", "changed_code": [{"header": "diff --git a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\nindex 25b1ff52a6..b2caecd20a 100644\n--- a/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n+++ b/addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java\n", "chunk": "@@ -175,15 +167,7 @@ public class KafkaProcessInstances implements MutableProcessInstances {\n     }\n \n     protected void disconnect(ProcessInstance instance) {\n-        ((AbstractProcessInstance<?>) instance).internalRemoveProcessInstance(() -> {\n-\n-            try {\n-                byte[] reloaded = getStore().get(instance.id());\n-                return marshaller.unmarshallWorkflowProcessInstance(reloaded, process);\n-            } catch (RuntimeException e) {\n-                LOGGER.error(\"Unexpected exception thrown when reloading process instance {}\", instance.id(), e);\n-                return null;\n-            }\n-        });\n+        Supplier<byte[]> supplier = () -> getStore().get(instance.id());\n+        ((AbstractProcessInstance<?>) instance).internalRemoveProcessInstance(marshaller.createdReloadFunction(supplier));\n     }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "8b29d15280535b78eafebbd5f760da085177a666", "message": "Merge commit", "committedDate": null}, {"oid": "380c26ea25c242a0ed54c014797cb7fe2e6e831c", "committedDate": "2021-02-19 15:41:54 +1000", "message": "KOGITO-4376 Enable Copyright validation during maven build and fix invalid files (#1075)"}, {"oid": "f855f1d0d21e1f6c0fa1d4bfcf289fe5cb0956ec", "committedDate": "2021-02-25 13:55:16 +1000", "message": "KOGITO-4357 - Add formatter plugin + reformat codebase (#1039)"}, {"oid": "ebd6814804324580527b52c664d1dc753c6a6ca4", "committedDate": "2021-05-12 09:37:15 +1000", "message": "[KOGITO-4691] Process Marshalling refactor (#1266)"}, {"oid": "07bd4c9f75c5f3ef32e8e5772737204caaf90999", "committedDate": "2021-06-21 16:17:35 -0300", "message": "[KOGITO-5299] - Addons Restructure (#1367)"}]}, {"oid": "b9353cbdb6843b3584630fd4e77028e6c819a4bf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b9353cbdb6843b3584630fd4e77028e6c819a4bf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-12T13:03:01Z", "type": "forcePushed"}, {"oid": "d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-12T13:50:00Z", "type": "forcePushed"}, {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-15T02:33:44Z", "type": "commit"}, {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-15T02:33:44Z", "type": "forcePushed"}]}