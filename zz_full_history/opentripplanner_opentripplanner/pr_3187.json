{"pr_number": 3187, "pr_title": "Add support for flexible transit routing", "pr_author": "hannesj", "pr_createdAt": "2020-09-18T08:57:29Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187", "timeline": [{"oid": "b17ac1da6e5eb35553a53017e3f8c93d35acce01", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b17ac1da6e5eb35553a53017e3f8c93d35acce01", "message": "Add FLEXIBLE as transit mode", "committedDate": "2020-09-18T08:14:08Z", "type": "commit"}, {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0219bb8f2f795fc9f14b034210507e9722c58edd", "message": "Add DistanceCalculator", "committedDate": "2020-09-18T08:36:27Z", "type": "commit"}, {"oid": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "message": "Find flex locations when splitting streets for access/egress", "committedDate": "2020-09-18T08:37:52Z", "type": "commit"}, {"oid": "41d4f78595351387691e689a96c930c0940ce274", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/41d4f78595351387691e689a96c930c0940ce274", "message": "Add FlexRouter", "committedDate": "2020-09-18T08:46:51Z", "type": "commit"}, {"oid": "29145c7230a80f0c21fc25d5b541d8ad000758b3", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/29145c7230a80f0c21fc25d5b541d8ad000758b3", "message": "Make AccessEgressRouter return StopAtDistance", "committedDate": "2020-09-18T08:54:45Z", "type": "commit"}, {"oid": "2f40da1dc230a78dc355b6553cd62a759ce644e6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2f40da1dc230a78dc355b6553cd62a759ce644e6", "message": "Wire in FlexRouter", "committedDate": "2020-09-18T08:54:58Z", "type": "commit"}, {"oid": "0909081a57da212d4c88038c9f0c5a9c3f3acbf9", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0909081a57da212d4c88038c9f0c5a9c3f3acbf9", "message": "Improve mapping of ScheduledDeviatedTrip", "committedDate": "2020-09-18T11:12:13Z", "type": "commit"}, {"oid": "539086c387320c547b2fc9803d63f8d4ab98943c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/539086c387320c547b2fc9803d63f8d4ab98943c", "message": "Add progress tracker", "committedDate": "2020-09-22T08:15:38Z", "type": "commit"}, {"oid": "bd7128519bfff9685d732094996e2eb0ce18008d", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/bd7128519bfff9685d732094996e2eb0ce18008d", "message": "Fix accesses within no through traffic area", "committedDate": "2020-09-22T08:15:48Z", "type": "commit"}, {"oid": "681acd20acf9c56073616856d09c49f43668be45", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/681acd20acf9c56073616856d09c49f43668be45", "message": "Improve flex mapping", "committedDate": "2020-09-22T08:15:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTM5MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492591391", "body": "Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like `NearByStop`.", "bodyText": "Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like NearByStop.", "bodyHTML": "<p dir=\"auto\">Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like <code>NearByStop</code>.</p>", "author": "t2gran", "createdAt": "2020-09-22T09:20:30Z", "path": "src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java", "diffHunk": "@@ -55,6 +57,15 @@ public int compareTo(StopAtDistance that) {\n     return (int) (this.distance) - (int) (that.distance);\n   }\n \n+  public AccessEgress toAccessEgress(StopIndexForRaptor stopIndex, boolean fromTarget) {", "originalCommit": "29145c7230a80f0c21fc25d5b541d8ad000758b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java b/src/main/java/org/opentripplanner/routing/graphfinder/NearbyStop.java\nsimilarity index 81%\nrename from src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java\nrename to src/main/java/org/opentripplanner/routing/graphfinder/NearbyStop.java\nindex 40fc0ccff2..5aba971edc 100644\n--- a/src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java\n+++ b/src/main/java/org/opentripplanner/routing/graphfinder/NearbyStop.java\n", "chunk": "@@ -53,19 +50,10 @@ public class StopAtDistance implements Comparable<StopAtDistance> {\n   }\n \n   @Override\n-  public int compareTo(StopAtDistance that) {\n+  public int compareTo(NearbyStop that) {\n     return (int) (this.distance) - (int) (that.distance);\n   }\n \n-  public AccessEgress toAccessEgress(StopIndexForRaptor stopIndex, boolean fromTarget) {\n-    if (!(stop instanceof Stop)) { return null; }\n-    return new AccessEgress(\n-        stopIndex.indexByStop.get(stop),\n-        (int) state.getElapsedTimeSeconds(),\n-        fromTarget ? state.reverse() : state\n-    );\n-  }\n-\n   public String toString() {\n     return String.format(\"stop %s at %.1f meters\", stop, distance);\n   }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NDQzOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492594439", "body": "Rename parameters to fromStopIndex, toStopIndex", "bodyText": "Rename parameters to fromStopIndex, toStopIndex", "bodyHTML": "<p dir=\"auto\">Rename parameters to fromStopIndex, toStopIndex</p>", "author": "t2gran", "createdAt": "2020-09-22T09:25:17Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.routing.graph.Vertex;\n+\n+/**\n+ * DistanceCalculator is used to calculate the driving times and distances during flex routing\n+ */\n+public interface DistanceCalculator {\n+  DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex);", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjMxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492602317", "body": "Add the geometry here? And then the class name become `FlexPath`?", "bodyText": "Add the geometry here? And then the class name become FlexPath?", "bodyHTML": "<p dir=\"auto\">Add the geometry here? And then the class name become <code>FlexPath</code>?</p>", "author": "t2gran", "createdAt": "2020-09-22T09:38:30Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+/**\n+ * This class contains the results from a DistanceCalculator.\n+ */\n+public class DistanceAndDuration {\n+\n+  public int distanceMeters;\n+  public int durationSeconds;", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604217", "body": "get more than duration, rename `calculaeFlexPath`", "bodyText": "get more than duration, rename calculaeFlexPath", "bodyHTML": "<p dir=\"auto\">get more than duration, rename <code>calculaeFlexPath</code></p>", "author": "t2gran", "createdAt": "2020-09-22T09:41:46Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDc3Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604773", "body": "What happes if we can not find a path?", "bodyText": "What happes if we can not find a path?", "bodyHTML": "<p dir=\"auto\">What happes if we can not find a path?</p>", "author": "t2gran", "createdAt": "2020-09-22T09:42:49Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {\n+    T2<Vertex, Vertex> key = new T2<>(fromv, tov);\n+    DistanceAndDuration cacheValue = cache.get(key);\n+    if (cacheValue != null) return cacheValue;\n+\n+    RoutingRequest routingRequest = new RoutingRequest(TraverseMode.CAR);\n+    routingRequest.setNumItineraries(1);\n+\n+    routingRequest.setRoutingContext(graph, fromv, tov);\n+    routingRequest.dominanceFunction = new DominanceFunction.EarliestArrival();\n+    AStar search = new AStar();\n+    ShortestPathTree spt = search.getShortestPathTree(routingRequest);\n+\n+    GraphPath path = spt.getPaths().get(0);\n+\n+    int distance = (int) path.edges.stream().mapToDouble(Edge::getDistanceMeters).sum();\n+    int duration = path.getDuration();", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492607104", "body": "Use the `isEligibleForCarPickupDropOff()`  here instead.", "bodyText": "Use the isEligibleForCarPickupDropOff()  here instead.", "bodyHTML": "<p dir=\"auto\">Use the <code>isEligibleForCarPickupDropOff()</code>  here instead.</p>", "author": "t2gran", "createdAt": "2020-09-22T09:46:58Z", "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "diffHunk": "@@ -408,6 +412,22 @@ else if (ll.getSegmentIndex() == orig.getNumPoints() - 2 && ll.getSegmentFractio\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n+                Point p = GeometryUtils\n+                    .getGeometryFactory()\n+                    .createPoint(v0.getCoordinate());\n+                Envelope env = p.getEnvelopeInternal();\n+                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))", "originalCommit": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA4MzYwNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494083604", "bodyText": "Using StreetTraversalPermission.PEDESTRIAN_AND_CAR, as isEligibleForCarPickupDropOff() operates on vertices", "author": "hannesj", "createdAt": "2020-09-24T07:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java b/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\nindex 426905d626..20e4a3904b 100644\n--- a/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\n+++ b/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\n", "chunk": "@@ -412,18 +412,17 @@ public class SimpleStreetSplitter {\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n-            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n-                Point p = GeometryUtils\n-                    .getGeometryFactory()\n-                    .createPoint(v0.getCoordinate());\n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null\n+                && edge.getPermission().allows(StreetTraversalPermission.PEDESTRIAN_AND_CAR)\n+            ) {\n+                Point p = GeometryUtils.getGeometryFactory().createPoint(v0.getCoordinate());\n                 Envelope env = p.getEnvelopeInternal();\n-                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n-                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))\n-                        && !flexStopLocation.getGeometry().disjoint(p)) {\n+                for (FlexStopLocation location : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (!location.getGeometry().disjoint(p)) {\n                         if (v0.flexStopLocations == null) {\n                             v0.flexStopLocations = new HashSet<>();\n                         }\n-                        v0.flexStopLocations.add(flexStopLocation);\n+                        v0.flexStopLocations.add(location);\n                     }\n                 }\n             }\n", "next_change": {"commit": "ed3e736b3fa0c9a6b5da34c52578627d4d3b6d36", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java b/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\ndeleted file mode 100644\nindex 20e4a3904b..0000000000\n--- a/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\n+++ /dev/null\n", "chunk": "@@ -1,672 +0,0 @@\n-package org.opentripplanner.graph_builder.linking;\n-\n-import com.google.common.collect.Iterables;\n-import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Envelope;\n-import org.locationtech.jts.geom.GeometryFactory;\n-import org.locationtech.jts.geom.LineString;\n-import org.locationtech.jts.geom.Point;\n-import org.locationtech.jts.index.SpatialIndex;\n-import org.locationtech.jts.linearref.LinearLocation;\n-import org.locationtech.jts.linearref.LocationIndexedLine;\n-import org.opentripplanner.common.geometry.GeometryUtils;\n-import org.opentripplanner.common.geometry.HashGridSpatialIndex;\n-import org.opentripplanner.common.geometry.SphericalDistanceLibrary;\n-import org.opentripplanner.common.model.P2;\n-import org.opentripplanner.graph_builder.DataImportIssue;\n-import org.opentripplanner.graph_builder.DataImportIssueStore;\n-import org.opentripplanner.graph_builder.issues.BikeParkUnlinked;\n-import org.opentripplanner.graph_builder.issues.BikeRentalStationUnlinked;\n-import org.opentripplanner.graph_builder.issues.EntranceUnlinked;\n-import org.opentripplanner.graph_builder.issues.StopLinkedTooFar;\n-import org.opentripplanner.graph_builder.issues.StopUnlinked;\n-import org.opentripplanner.graph_builder.services.DefaultStreetEdgeFactory;\n-import org.opentripplanner.graph_builder.services.StreetEdgeFactory;\n-import org.opentripplanner.model.FlexStopLocation;\n-import org.opentripplanner.model.GenericLocation;\n-import org.opentripplanner.openstreetmap.model.OSMWithTags;\n-import org.opentripplanner.routing.api.request.RoutingRequest;\n-import org.opentripplanner.routing.core.TraverseMode;\n-import org.opentripplanner.routing.core.TraverseModeSet;\n-import org.opentripplanner.routing.edgetype.AreaEdge;\n-import org.opentripplanner.routing.edgetype.AreaEdgeList;\n-import org.opentripplanner.routing.edgetype.StreetBikeParkLink;\n-import org.opentripplanner.routing.edgetype.StreetBikeRentalLink;\n-import org.opentripplanner.routing.edgetype.StreetEdge;\n-import org.opentripplanner.routing.edgetype.StreetTransitLink;\n-import org.opentripplanner.routing.edgetype.StreetTraversalPermission;\n-import org.opentripplanner.routing.edgetype.TemporaryFreeEdge;\n-import org.opentripplanner.routing.edgetype.TransitEntranceLink;\n-import org.opentripplanner.routing.graph.Edge;\n-import org.opentripplanner.routing.graph.Graph;\n-import org.opentripplanner.routing.graph.Vertex;\n-import org.opentripplanner.routing.impl.StreetVertexIndex;\n-import org.opentripplanner.routing.location.TemporaryStreetLocation;\n-import org.opentripplanner.routing.vertextype.BikeParkVertex;\n-import org.opentripplanner.routing.vertextype.BikeRentalStationVertex;\n-import org.opentripplanner.routing.vertextype.IntersectionVertex;\n-import org.opentripplanner.routing.vertextype.SplitterVertex;\n-import org.opentripplanner.routing.vertextype.StreetVertex;\n-import org.opentripplanner.routing.vertextype.TemporarySplitterVertex;\n-import org.opentripplanner.routing.vertextype.TemporaryVertex;\n-import org.opentripplanner.routing.vertextype.TransitEntranceVertex;\n-import org.opentripplanner.routing.vertextype.TransitStopVertex;\n-import org.opentripplanner.util.I18NString;\n-import org.opentripplanner.util.LocalizedString;\n-import org.opentripplanner.util.NonLocalizedString;\n-import org.opentripplanner.util.OTPFeature;\n-import org.opentripplanner.util.ProgressTracker;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.UUID;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-/**\n- * This class links transit stops to streets by splitting the streets (unless the stop is extremely close to the street\n- * intersection).\n- *\n- * It is intended to eventually completely replace the existing stop linking code, which had been through so many\n- * revisions and adaptations to different street and turn representations that it was very glitchy. This new code is\n- * also intended to be deterministic in linking to streets, independent of the order in which the JVM decides to\n- * iterate over Maps and even in the presence of points that are exactly halfway between multiple candidate linking\n- * points.\n- *\n- * It would be wise to keep this new incarnation of the linking code relatively simple, considering what happened before.\n- *\n- * See discussion in pull request #1922, follow up issue #1934, and the original issue calling for replacement of\n- * the stop linker, #1305.\n- */\n-public class SimpleStreetSplitter {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(SimpleStreetSplitter.class);\n-\n-    private static final int INITIAL_SEARCH_RADIUS_METERS = 100;\n-\n-    private static final int MAX_SEARCH_RADIUS_METERS = 1000;\n-\n-    private static final int WARNING_DISTANCE_METERS = 20;\n-\n-    /** if there are two ways and the distances to them differ by less than this value, we link to both of them */\n-    private static final double DUPLICATE_WAY_EPSILON_METERS = 0.001;\n-\n-    private static final GeometryFactory GEOMETRY_FACTORY = GeometryUtils.getGeometryFactory();\n-\n-    private final DataImportIssueStore issueStore;\n-\n-    private final StreetEdgeFactory edgeFactory;\n-\n-    private final Graph graph;\n-\n-    private final HashGridSpatialIndex<Edge> idx;\n-\n-    private final SpatialIndex transitStopIndex;\n-\n-    // If true edges are split and new edges are created (used when linking transit stops etc. during graph building)\n-    // If false new temporary edges are created and no edges are deleted (Used when searching for origin/destination)\n-    private final boolean destructiveSplitting;\n-\n-    private Boolean addExtraEdgesToAreas = false;\n-\n-    /**\n-     * Construct a new SimpleStreetSplitter.\n-     * NOTE: Only one SimpleStreetSplitter should be active on a graph at any given time.\n-     *\n-     * @param hashGridSpatialIndex If not null this index is used instead of creating new one\n-     * @param transitStopIndex Index of all transitStops which is generated in {@link StreetVertexIndex}\n-     * @param destructiveSplitting If true splitting is permanent (Used when linking transit stops etc.) when false Splitting is only for duration of a request. Since they are made from temporary vertices and edges.\n-     */\n-    public SimpleStreetSplitter(Graph graph, HashGridSpatialIndex<Edge> hashGridSpatialIndex,\n-        SpatialIndex transitStopIndex, boolean destructiveSplitting, DataImportIssueStore issueStore\n-    ) {\n-        this.issueStore = issueStore;\n-        this.graph = graph;\n-        this.transitStopIndex = transitStopIndex;\n-        this.destructiveSplitting = destructiveSplitting;\n-        this.edgeFactory = new DefaultStreetEdgeFactory();\n-\n-        //We build a spatial index if it isn't provided\n-        if (hashGridSpatialIndex == null) {\n-            // build a nice private spatial index, since we're adding and removing edges\n-            idx = new HashGridSpatialIndex<>();\n-            for (StreetEdge se : Iterables.filter(graph.getEdges(), StreetEdge.class)) {\n-                idx.insert(se.getGeometry(), se);\n-            }\n-        } else {\n-            idx = hashGridSpatialIndex;\n-        }\n-    }\n-\n-    /**\n-     * Construct a new SimpleStreetSplitter. Be aware that only one SimpleStreetSplitter should be\n-     * active on a graph at any given time.\n-     *\n-     * SimpleStreetSplitter generates index on graph and splits destructively (used in transit splitter)\n-\n-     */\n-    public SimpleStreetSplitter(Graph graph, DataImportIssueStore issueStore) {\n-        this(graph, null, null, true, issueStore);\n-    }\n-\n-    public static SimpleStreetSplitter createForTest(Graph graph) {\n-        return new SimpleStreetSplitter(graph, null, null, true, new DataImportIssueStore(false));\n-    }\n-\n-    /** Link all relevant vertices to the street network */\n-    public void link () {\n-        link(TransitStopVertex.class, StopUnlinked::new);\n-        link(TransitEntranceVertex.class, EntranceUnlinked::new);\n-        link(BikeRentalStationVertex.class, BikeRentalStationUnlinked::new);\n-        link(BikeParkVertex.class, BikeParkUnlinked::new);\n-    }\n-\n-    @SuppressWarnings(\"Convert2MethodRef\")\n-    public <T extends Vertex> void link(\n-            Class<T> type,\n-            Function<T, DataImportIssue> unlinkedIssueMapper\n-    ) {\n-        @SuppressWarnings(\"unchecked\")\n-        List<T> vertices = graph.getVertices()\n-                .stream()\n-                .filter(type::isInstance)\n-                .map(it -> (T)it)\n-                .collect(Collectors.toList());\n-\n-        String actionName = \"Link \" + type.getSimpleName();\n-\n-        if(vertices.isEmpty()) {\n-            LOG.info(\"{} skiped. No such data exist.\", actionName);\n-            return;\n-        }\n-\n-        ProgressTracker progress = ProgressTracker.track(actionName, 500, vertices.size());\n-        LOG.info(progress.startMessage());\n-\n-        for (T v : vertices) {\n-            // Do not link vertices, which are already linked by TransitToTaggedStopsModule\n-            boolean alreadyLinked = v.getOutgoing().stream().anyMatch(e -> e instanceof StreetTransitLink);\n-            if (alreadyLinked) { continue; }\n-\n-            // Do not link stops connected by pathways\n-            if (v instanceof TransitStopVertex && ((TransitStopVertex) v).hasPathways()) {\n-                continue;\n-            }\n-\n-            if (!link(v)) {\n-                issueStore.add(unlinkedIssueMapper.apply(v));\n-            }\n-            // Keep lambda! A method-ref would cause incorrect class and line number to be logged\n-            progress.step(m -> LOG.info(m));\n-        }\n-        LOG.info(progress.completeMessage());\n-    }\n-\n-    /** Link this vertex into the graph to the closest walkable edge */\n-    public boolean link (Vertex vertex) {\n-        return link(vertex, TraverseMode.WALK, null);\n-    }\n-\n-    /**\n-     * Link the given vertex into the graph (expand on that...)\n-     * In OTP2 where the transit search can be quite fast, searching for a good linking point can be a significant\n-     * fraction of response time. Hannes Junnila has reported >70% speedups in searches by making the search radius\n-     * smaller. Therefore we use an expanding-envelope search, which is more efficient in dense areas.\n-     * @return whether linking succeeded (an edge or edges were found within range)\n-     */\n-    public boolean link(Vertex vertex, TraverseMode traverseMode, RoutingRequest options) {\n-        if (linkToStreetEdges(vertex, traverseMode, options, INITIAL_SEARCH_RADIUS_METERS)) {\n-            return true;\n-        }\n-        return linkToStreetEdges(vertex, traverseMode, options, MAX_SEARCH_RADIUS_METERS);\n-    }\n-\n-    private static class DistanceTo<T> {\n-        T item;\n-        // Possible optimization: store squared lat to skip thousands of sqrt operations\n-        // However we're using JTS distance functions that probably won't allow us to skip the final sqrt call.\n-        double distanceDegreesLat;\n-        public DistanceTo (T item, double distanceDegreesLat) {\n-            this.item = item;\n-            this.distanceDegreesLat = distanceDegreesLat;\n-        }\n-    }\n-\n-    public boolean linkToStreetEdges (Vertex vertex, TraverseMode traverseMode, RoutingRequest options, int radiusMeters) {\n-\n-        final double radiusDeg = SphericalDistanceLibrary.metersToDegrees(radiusMeters);\n-\n-        Envelope env = new Envelope(vertex.getCoordinate());\n-\n-        // Perform a simple local equirectangular projection, so distances are expressed in degrees latitude.\n-        final double xscale = Math.cos(vertex.getLat() * Math.PI / 180);\n-\n-        // Expand more in the longitude direction than the latitude direction to account for converging meridians.\n-        env.expandBy(radiusDeg / xscale, radiusDeg);\n-\n-        final double DUPLICATE_WAY_EPSILON_DEGREES = SphericalDistanceLibrary.metersToDegrees(DUPLICATE_WAY_EPSILON_METERS);\n-\n-        final TraverseModeSet traverseModeSet = new TraverseModeSet(traverseMode);\n-        if (traverseMode == TraverseMode.BICYCLE) {\n-            traverseModeSet.setWalk(true);\n-        }\n-        // Scope block to avoid confusing edge-related local variables with stop-related variables below.\n-        {\n-            // Perform several transformations at once on the edges returned by the index.\n-            // Only consider street edges traversable by the given mode and still present in the graph.\n-            // Calculate a distance to each of those edges, and keep only the ones within the search radius.\n-            List<DistanceTo<StreetEdge>> candidateEdges = idx.query(env).stream()\n-                    .filter(StreetEdge.class::isInstance)\n-                    .map(StreetEdge.class::cast)\n-                    .filter(e -> e.canTraverse(traverseModeSet) && edgeReachableFromGraph(e))\n-                    .map(e -> new DistanceTo<>(e, distance(vertex, e, xscale)))\n-                    .filter(ead -> ead.distanceDegreesLat < radiusDeg)\n-                    .collect(Collectors.toList());\n-\n-            // The following logic has gone through several different versions using different approaches.\n-            // The core idea is to find all edges that are roughly the same distance from the given vertex, which will\n-            // catch things like superimposed edges going in opposite directions.\n-            // First, all edges within DUPLICATE_WAY_EPSILON_METERS of of the best distance were selected.\n-            // More recently, the edges were sorted in order of increasing distance, and all edges in the list were selected\n-            // up to the point where a distance increase of DUPLICATE_WAY_EPSILON_DEGREES from one edge to the next.\n-            // This was in response to concerns about arbitrary cutoff distances: at any distance, it's always possible\n-            // one half of a dual carriageway (or any other pair of edges in opposite directions) will be caught and the\n-            // other half lost. It seems like this was based on some incorrect premises about floating point calculations\n-            // being non-deterministic.\n-            if (!candidateEdges.isEmpty()) {\n-                // There is at least one appropriate edge within range.\n-                double closestDistance = candidateEdges.stream()\n-                        .mapToDouble(ce -> ce.distanceDegreesLat)\n-                        .min().getAsDouble();\n-\n-                candidateEdges.stream()\n-                        .filter(ce -> ce.distanceDegreesLat <= closestDistance + DUPLICATE_WAY_EPSILON_DEGREES)\n-                        .forEach(ce -> link(vertex, ce.item, xscale, options));\n-\n-                // Warn if a linkage was made for a transit stop, but the linkage was suspiciously long.\n-                if (vertex instanceof TransitStopVertex) {\n-                    int distanceMeters = (int)SphericalDistanceLibrary.degreesLatitudeToMeters(closestDistance);\n-                    if (distanceMeters > WARNING_DISTANCE_METERS) {\n-                        issueStore.add(new StopLinkedTooFar((TransitStopVertex)vertex, distanceMeters));\n-                    }\n-                }\n-                return true;\n-            }\n-        }\n-        if (radiusMeters >= MAX_SEARCH_RADIUS_METERS) {\n-            // There were no candidate edges within the max linking distance, fall back on finding transit stops.\n-            // We only link to stops if we are searching for origin/destination and for that we need transitStopIndex.\n-            if (destructiveSplitting || transitStopIndex == null) {\n-                return false;\n-            }\n-            LOG.debug(\"No street edge was found for {}, checking transit stop vertices.\", vertex);\n-            List<TransitStopVertex> transitStopVertices = transitStopIndex.query(env);\n-            List<DistanceTo<TransitStopVertex>> candidateStops = transitStopVertices.stream()\n-                    .map(tsv -> new DistanceTo<>(tsv, distance(vertex, tsv, xscale)))\n-                    .filter(dts -> dts.distanceDegreesLat <= radiusDeg)\n-                    .collect(Collectors.toList());\n-\n-            if (candidateStops.isEmpty()) {\n-                LOG.debug(\"No stops nearby.\");\n-                return false;\n-            }\n-            // There is at least one stop within range.\n-            double closestDistance = candidateStops.stream()\n-                    .mapToDouble(c -> c.distanceDegreesLat)\n-                    .min().getAsDouble();\n-\n-            candidateStops.stream()\n-                    .filter(dts -> dts.distanceDegreesLat <= closestDistance + DUPLICATE_WAY_EPSILON_DEGREES)\n-                    .map(dts -> dts.item)\n-                    .forEach(sv -> {\n-                        LOG.debug(\"Linking vertex to stop: {}\", sv.getName());\n-                        makeTemporaryEdges((TemporaryStreetLocation)vertex, sv);\n-                    });\n-\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * While in destructive splitting mode (during graph construction rather than handling routing requests), we remove\n-     * edges that have been split and may then re-split the resulting segments recursively, so parts of them are also\n-     * removed. Newly created edge fragments are added to the spatial index; the edges that were split are removed\n-     * (disconnected) from the graph but were previously not removed from the spatial index, so for all subsequent\n-     * splitting operations we had to check whether any edge coming out of the spatial index had been \"soft deleted\".\n-     *\n-     * I believe this was compensating for the fact that STRTrees are optimized at construction and read-only. That\n-     * restriction no longer applies since we've been using our own hash grid spatial index instead of the STRTree.\n-     * So rather than filtering out soft deleted edges, this is now an assertion that the system behaves as intended,\n-     * and will log an error if the spatial index is returning edges that have been disconnected from the graph.\n-     */\n-    private static boolean edgeReachableFromGraph (Edge edge) {\n-        boolean edgeReachableFromGraph = edge.getToVertex().getIncoming().contains(edge);\n-        if (!edgeReachableFromGraph) {\n-            LOG.error(\"Edge returned from spatial index is no longer reachable from graph. That is not expected.\");\n-        }\n-        return edgeReachableFromGraph;\n-    }\n-\n-    // Link to all vertices in area/platform\n-    private void linkTransitToAreaVertices(Vertex splitterVertex, AreaEdgeList area) {\n-        List<Vertex> vertices = new ArrayList<>();\n-\n-        for (AreaEdge areaEdge : area.getEdges()) {\n-            if (!vertices.contains(areaEdge.getToVertex())) vertices.add(areaEdge.getToVertex());\n-            if (!vertices.contains(areaEdge.getFromVertex())) vertices.add(areaEdge.getFromVertex());\n-        }\n-\n-        for (Vertex vertex : vertices) {\n-            if (vertex instanceof  StreetVertex && !vertex.equals(splitterVertex)) {\n-                LineString line = GEOMETRY_FACTORY.createLineString(new Coordinate[] { splitterVertex.getCoordinate(), vertex.getCoordinate()});\n-                double length = SphericalDistanceLibrary.distance(splitterVertex.getCoordinate(),\n-                        vertex.getCoordinate());\n-                I18NString name = new LocalizedString(\"\", new OSMWithTags());\n-\n-                edgeFactory.createAreaEdge((IntersectionVertex) splitterVertex, (IntersectionVertex) vertex, line, name, length,StreetTraversalPermission.PEDESTRIAN_AND_BICYCLE, false, area);\n-                edgeFactory.createAreaEdge((IntersectionVertex) vertex, (IntersectionVertex) splitterVertex, line, name, length,StreetTraversalPermission.PEDESTRIAN_AND_BICYCLE, false, area);\n-            }\n-        }\n-    }\n-\n-    /** split the edge and link in the transit stop */\n-    private void link(Vertex tstop, StreetEdge edge, double xscale, RoutingRequest options) {\n-        // TODO: we've already built this line string, we should save it\n-        LineString orig = edge.getGeometry();\n-        LineString transformed = equirectangularProject(orig, xscale);\n-        LocationIndexedLine il = new LocationIndexedLine(transformed);\n-        LinearLocation ll = il.project(new Coordinate(tstop.getLon() * xscale, tstop.getLat()));\n-\n-        // if we're very close to one end of the line or the other, or endwise, don't bother to split,\n-        // cut to the chase and link directly\n-        // We use a really tiny epsilon here because we only want points that actually snap to exactly the same location on the\n-        // street to use the same vertices. Otherwise the order the stops are loaded in will affect where they are snapped.\n-        if (ll.getSegmentIndex() == 0 && ll.getSegmentFraction() < 1e-8) {\n-            makeLinkEdges(tstop, (StreetVertex) edge.getFromVertex());\n-        }\n-        // -1 converts from count to index. Because of the fencepost problem, npoints - 1 is the \"segment\"\n-        // past the last point\n-        else if (ll.getSegmentIndex() == orig.getNumPoints() - 1) {\n-            makeLinkEdges(tstop, (StreetVertex) edge.getToVertex());\n-        }\n-\n-        // nPoints - 2: -1 to correct for index vs count, -1 to account for fencepost problem\n-        else if (ll.getSegmentIndex() == orig.getNumPoints() - 2 && ll.getSegmentFraction() > 1 - 1e-8) {\n-            makeLinkEdges(tstop, (StreetVertex) edge.getToVertex());\n-        }\n-\n-        else {\n-\n-            TemporaryVertex temporaryVertex = null;\n-            boolean endVertex = false;\n-            if (tstop instanceof TemporaryVertex) {\n-                temporaryVertex = (TemporaryVertex) tstop;\n-                endVertex = temporaryVertex.isEndVertex();\n-\n-            }\n-            // split the edge, get the split vertex\n-            SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n-            makeLinkEdges(tstop, v0);\n-\n-            if (OTPFeature.FlexRouting.isOn() && graph.index != null\n-                && edge.getPermission().allows(StreetTraversalPermission.PEDESTRIAN_AND_CAR)\n-            ) {\n-                Point p = GeometryUtils.getGeometryFactory().createPoint(v0.getCoordinate());\n-                Envelope env = p.getEnvelopeInternal();\n-                for (FlexStopLocation location : graph.index.getFlexIndex().locationIndex.query(env)) {\n-                    if (!location.getGeometry().disjoint(p)) {\n-                        if (v0.flexStopLocations == null) {\n-                            v0.flexStopLocations = new HashSet<>();\n-                        }\n-                        v0.flexStopLocations.add(location);\n-                    }\n-                }\n-            }\n-\n-            // If splitter vertex is part of area; link splittervertex to all other vertexes in area, this creates\n-            // edges that were missed by WalkableAreaBuilder\n-            if (edge instanceof AreaEdge && tstop instanceof TransitStopVertex && this.addExtraEdgesToAreas) {\n-                linkTransitToAreaVertices(v0, ((AreaEdge) edge).getArea());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Split the street edge at the given fraction\n-     *\n-     * @param edge to be split\n-     * @param ll fraction at which to split the edge\n-     * @param temporarySplit if true this is temporary split at origin/destinations search and only temporary edges vertices are created\n-     * @param endVertex if this is temporary edge this is true if this is end vertex otherwise it doesn't matter\n-     * @return Splitter vertex with added new edges\n-     */\n-    private SplitterVertex split (StreetEdge edge, LinearLocation ll, boolean temporarySplit, boolean endVertex) {\n-        LineString geometry = edge.getGeometry();\n-\n-        // create the geometries\n-        Coordinate splitPoint = ll.getCoordinate(geometry);\n-\n-        SplitterVertex v;\n-        String uniqueSplitLabel = \"split_\" + graph.nextSplitNumber++;\n-        if (temporarySplit) {\n-            TemporarySplitterVertex tsv = new TemporarySplitterVertex(\n-                    uniqueSplitLabel, splitPoint.x, splitPoint.y, edge, endVertex);\n-            tsv.setWheelchairAccessible(edge.isWheelchairAccessible());\n-            v = tsv;\n-        } else {\n-            v = new SplitterVertex(graph, uniqueSplitLabel, splitPoint.x, splitPoint.y, edge);\n-        }\n-\n-        // Split the 'edge' at 'v' in 2 new edges and connect these 2 edges to the\n-        // existing vertices\n-        P2<StreetEdge> edges = edge.split(v, !temporarySplit);\n-\n-        if (destructiveSplitting) {\n-            // update indices of new edges\n-            idx.insert(edges.first.getGeometry(), edges.first);\n-            idx.insert(edges.second.getGeometry(), edges.second);\n-\n-            // remove original edge from the graph\n-            edge.getToVertex().removeIncoming(edge);\n-            edge.getFromVertex().removeOutgoing(edge);\n-            // remove original edges from the spatial index\n-            // This iterates over the entire rectangular envelope of the edge rather than the segments making it up.\n-            // It will be inefficient for very long edges, but creating a new remove method mirroring the more efficient\n-            // insert logic is not trivial and would require additional testing of the spatial index.\n-            idx.remove(edge.getGeometry().getEnvelopeInternal(), edge);\n-        }\n-\n-        return v;\n-    }\n-\n-    /** Make the appropriate type of link edges from a vertex */\n-    private void makeLinkEdges(Vertex from, StreetVertex to) {\n-        if (from instanceof TemporaryStreetLocation) {\n-            makeTemporaryEdges((TemporaryStreetLocation) from, to);\n-        } else if (from instanceof TransitStopVertex) {\n-            makeTransitLinkEdges((TransitStopVertex) from, to);\n-        } else if (from instanceof TransitEntranceVertex) {\n-            makeTransitLinkEdges((TransitEntranceVertex) from, to);\n-        } else if (from instanceof BikeRentalStationVertex) {\n-            makeBikeRentalLinkEdges((BikeRentalStationVertex) from, to);\n-        } else if (from instanceof BikeParkVertex) {\n-            makeBikeParkEdges((BikeParkVertex) from, to);\n-        }\n-    }\n-\n-    /** Make temporary edges to origin/destination vertex in origin/destination search **/\n-    private void makeTemporaryEdges(TemporaryStreetLocation from, Vertex to) {\n-        if (destructiveSplitting) {\n-            throw new RuntimeException(\"Destructive splitting is used on temporary edges. Something is wrong!\");\n-        }\n-        if (to instanceof TemporarySplitterVertex) {\n-            from.setWheelchairAccessible(((TemporarySplitterVertex) to).isWheelchairAccessible());\n-        }\n-        if (from.isEndVertex()) {\n-            LOG.debug(\"Linking end vertex to {} -> {}\", to, from);\n-            new TemporaryFreeEdge(to, from);\n-        } else {\n-            LOG.debug(\"Linking start vertex to {} -> {}\", from, to);\n-            new TemporaryFreeEdge(from, to);\n-        }\n-    }\n-\n-    /** Make bike park edges */\n-    private void makeBikeParkEdges(BikeParkVertex from, StreetVertex to) {\n-        if (!destructiveSplitting) {\n-            throw new RuntimeException(\"Bike park edges are created with non destructive splitting!\");\n-        }\n-        for (StreetBikeParkLink sbpl : Iterables.filter(from.getOutgoing(), StreetBikeParkLink.class)) {\n-            if (sbpl.getToVertex() == to)\n-                return;\n-        }\n-\n-        new StreetBikeParkLink(from, to);\n-        new StreetBikeParkLink(to, from);\n-    }\n-\n-    /** \n-     * Make street transit link edges, unless they already exist.\n-     */\n-    private void makeTransitLinkEdges (TransitStopVertex tstop, StreetVertex v) {\n-        if (!destructiveSplitting) {\n-            throw new RuntimeException(\"Transitedges are created with non destructive splitting!\");\n-        }\n-        // ensure that the requisite edges do not already exist\n-        // this can happen if we link to duplicate ways that have the same start/end vertices.\n-        for (StreetTransitLink e : Iterables.filter(tstop.getOutgoing(), StreetTransitLink.class)) {\n-            if (e.getToVertex() == v)\n-                return;\n-        }\n-\n-        new StreetTransitLink(tstop, v, tstop.hasWheelchairEntrance());\n-        new StreetTransitLink(v, tstop, tstop.hasWheelchairEntrance());\n-    }\n-\n-    /**\n-     * Make street transit link edges, unless they already exist.\n-     */\n-    private void makeTransitLinkEdges(TransitEntranceVertex entrance, StreetVertex v) {\n-        if (!destructiveSplitting) {\n-            throw new RuntimeException(\"Transitedges are created with non destructive splitting!\");\n-        }\n-        // ensure that the requisite edges do not already exist\n-        // this can happen if we link to duplicate ways that have the same start/end vertices.\n-        for (TransitEntranceLink e : Iterables.filter(entrance.getOutgoing(), TransitEntranceLink.class)) {\n-            if (e.getToVertex() == v) { return; }\n-        }\n-\n-        new TransitEntranceLink(entrance, v, entrance.isWheelchairEntrance());\n-        new TransitEntranceLink(v, entrance, entrance.isWheelchairEntrance());\n-    }\n-\n-    /** Make link edges for bike rental */\n-    private void makeBikeRentalLinkEdges (BikeRentalStationVertex from, StreetVertex to) {\n-        if (!destructiveSplitting) {\n-            throw new RuntimeException(\"Bike rental edges are created with non destructive splitting!\");\n-        }\n-        for (StreetBikeRentalLink sbrl : Iterables.filter(from.getOutgoing(), StreetBikeRentalLink.class)) {\n-            if (sbrl.getToVertex() == to)\n-                return;\n-        }\n-\n-        new StreetBikeRentalLink(from, to);\n-        new StreetBikeRentalLink(to, from);\n-    }\n-\n-    /** projected distance from stop to edge, in latitude degrees */\n-    private static double distance (Vertex tstop, StreetEdge edge, double xscale) {\n-        // Despite the fact that we want to use a fast somewhat inaccurate projection, still use JTS library tools\n-        // for the actual distance calculations.\n-        LineString transformed = equirectangularProject(edge.getGeometry(), xscale);\n-        return transformed.distance(GEOMETRY_FACTORY.createPoint(new Coordinate(tstop.getLon() * xscale, tstop.getLat())));\n-    }\n-\n-    /** projected distance from stop to another stop, in latitude degrees */\n-    private static double distance (Vertex tstop, Vertex tstop2, double xscale) {\n-        // use JTS internal tools wherever possible\n-        return new Coordinate(tstop.getLon() * xscale, tstop.getLat()).distance(new Coordinate(tstop2.getLon() * xscale, tstop2.getLat()));\n-    }\n-\n-    /** project this linestring to an equirectangular projection */\n-    private static LineString equirectangularProject(LineString geometry, double xscale) {\n-        Coordinate[] coords = new Coordinate[geometry.getNumPoints()];\n-\n-        for (int i = 0; i < coords.length; i++) {\n-            Coordinate c = geometry.getCoordinateN(i);\n-            c = (Coordinate) c.clone();\n-            c.x *= xscale;\n-            coords[i] = c;\n-        }\n-\n-        return GEOMETRY_FACTORY.createLineString(coords);\n-    }\n-\n-    /**\n-     * Used to link origin and destination points to graph non destructively.\n-     * Split edges don't replace existing ones and only temporary edges and vertices are created.\n-     * Will throw TrivialPathException if origin and destination Location are on the same edge\n-     *\n-     * @param endVertex true if this is destination vertex\n-     */\n-    public Vertex getClosestVertex(GenericLocation location, RoutingRequest options,\n-        boolean endVertex) {\n-        if (destructiveSplitting) {\n-            throw new RuntimeException(\"Origin and destination search is used with destructive splitting. Something is wrong!\");\n-        }\n-        if (endVertex) {\n-            LOG.debug(\"Finding end vertex for {}\", location);\n-        } else {\n-            LOG.debug(\"Finding start vertex for {}\", location);\n-        }\n-        Coordinate coord = location.getCoordinate();\n-        //TODO: add nice name\n-        String name;\n-\n-        if (location.label == null || location.label.isEmpty()) {\n-            if (endVertex) {\n-                name = \"Destination\";\n-            } else {\n-                name = \"Origin\";\n-            }\n-        } else {\n-            name = location.label;\n-        }\n-        TemporaryStreetLocation closest = new TemporaryStreetLocation(UUID.randomUUID().toString(),\n-            coord, new NonLocalizedString(name), endVertex);\n-\n-        TraverseMode nonTransitMode = TraverseMode.WALK;\n-        //It can be null in tests\n-        if (options != null) {\n-            TraverseModeSet modes = options.streetSubRequestModes;\n-            if (modes.getCar())\n-                if (options.carPickup) {\n-                    nonTransitMode = TraverseMode.WALK;\n-                }\n-                // for park and ride we will start in car mode and walk to the end vertex\n-                else if (endVertex && options.parkAndRide) {\n-                    nonTransitMode = TraverseMode.WALK;\n-                } else {\n-                    nonTransitMode = TraverseMode.CAR;\n-                }\n-            else if (modes.getWalk())\n-                nonTransitMode = TraverseMode.WALK;\n-            else if (modes.getBicycle())\n-                nonTransitMode = TraverseMode.BICYCLE;\n-        }\n-\n-        if(!link(closest, nonTransitMode, options)) {\n-            LOG.warn(\"Couldn't link {}\", location);\n-        }\n-        return closest;\n-\n-    }\n-\n-    public void setAddExtraEdgesToAreas(Boolean addExtraEdgesToAreas) {\n-        this.addExtraEdgesToAreas = addExtraEdgesToAreas;\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzA4MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492617080", "body": "Decuple the raptor API from Flex", "bodyText": "Decuple the raptor API from Flex", "bodyHTML": "<p dir=\"auto\">Decuple the raptor API from Flex</p>", "author": "t2gran", "createdAt": "2020-09-22T10:04:16Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.core.State;\n+\n+public class FlexAccessEgress extends AccessEgress {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java b/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\nindex 882e845ee6..4a966b76d0 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\n", "chunk": "@@ -1,22 +1,23 @@\n package org.opentripplanner.ext.flex;\n \n import org.opentripplanner.ext.flex.trip.FlexTrip;\n-import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.model.Stop;\n import org.opentripplanner.routing.core.State;\n \n-public class FlexAccessEgress extends AccessEgress {\n-\n-  private final int preFlexTime;\n-  private final int flexTime;\n-  private final int postFlexTime;\n+public class FlexAccessEgress {\n+  public final Stop stop;\n+  public final int preFlexTime;\n+  public final int flexTime;\n+  public final int postFlexTime;\n   private final int fromStopIndex;\n   private final int toStopIndex;\n   private final int differenceFromStartOfTime;\n   private final FlexTrip trip;\n-  private final boolean directToStop;\n+  public final State lastState;\n+  public final boolean directToStop;\n \n   public FlexAccessEgress(\n-      int toFromStop,\n+      Stop stop,\n       int preFlexTime,\n       int flexTime,\n       int postFlexTime,\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java b/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\nindex 4a966b76d0..63ff191272 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\n", "chunk": "@@ -17,16 +18,16 @@ public class FlexAccessEgress {\n   public final boolean directToStop;\n \n   public FlexAccessEgress(\n-      Stop stop,\n-      int preFlexTime,\n-      int flexTime,\n-      int postFlexTime,\n-      int fromStopIndex,\n-      int toStopIndex,\n-      int differenceFromStartOfTime,\n-      FlexTrip trip,\n-      State lastState,\n-      boolean directToStop\n+    Stop stop,\n+    int preFlexTime,\n+    int flexTime,\n+    int postFlexTime,\n+    int fromStopIndex,\n+    int toStopIndex,\n+    int differenceFromStartOfTime,\n+    FlexTrip trip,\n+    State lastState,\n+    boolean directToStop\n   ) {\n     this.stop = stop;\n     this.preFlexTime = preFlexTime;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyMDMwNQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492620305", "body": "Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.", "bodyText": "Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.", "bodyHTML": "<p dir=\"auto\">Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:10:14Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..fab89e0606 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -61,8 +60,8 @@ public class FlexRouter {\n       RoutingRequest request,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n-      Collection<StopAtDistance> streetAccesses,\n-      Collection<StopAtDistance> egressTransfers,\n+      Collection<NearbyStop> streetAccesses,\n+      Collection<NearbyStop> egressTransfers,\n       StopIndexForRaptor stopIndex\n   ) {\n     this.graph = request.rctx.graph;\n", "next_change": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e0606..af11c11c3d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -70,7 +70,7 @@ public class FlexRouter {\n     this.stopIndex = stopIndex;\n     this.transitTransfers = graph.getTransferTable().getTransfers();\n     this.flexIndex = graph.index.getFlexIndex();\n-    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+    this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n     Instant searchInstant = request.getDateTime().toInstant();\n", "next_change": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex af11c11c3d..32add64819 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -61,13 +59,11 @@ public class FlexRouter {\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n-      Collection<NearbyStop> egressTransfers,\n-      StopIndexForRaptor stopIndex\n+      Collection<NearbyStop> egressTransfers\n   ) {\n     this.graph = request.rctx.graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n-    this.stopIndex = stopIndex;\n     this.transitTransfers = graph.getTransferTable().getTransfers();\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 32add64819..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -64,7 +60,6 @@ public class FlexRouter {\n     this.graph = request.rctx.graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n-    this.transitTransfers = graph.getTransferTable().getTransfers();\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..0833d363c8 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,74 +43,50 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n", "next_change": {"commit": "1a2a37d101c18469a96fa0f15cca39b9cf00c9e9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 0833d363c8..15713bbcc5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -90,9 +93,9 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n+        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n", "next_change": {"commit": "aeae63c30a79d75451617085f25fdc010c65ea3a", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 15713bbcc5..1c5feb27b8 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -93,9 +90,8 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n-        .stream()\n-        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = HashMultimap.create();\n+    streetEgresses.forEach(it -> streetEgressByStop.put(it.stop, it));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n", "next_change": {"commit": "3cb1df099879826f53000c2d86f6485ff0a08b3c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1c5feb27b8..9ccbecb733 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -99,7 +101,7 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (egressStops.contains(transferStop)) {\n+      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n", "next_change": {"commit": "0f990150c1ac69edd30e4648d379277ef78e7092", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 9ccbecb733..4698522659 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -105,6 +116,11 @@ public class FlexRouter {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n+            var fareService = graph.getService(FareService.class);\n+            if(fareService != null) {\n+              var fare = fareService.getCost(itinerary);\n+              itinerary.fare = fare;\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "32e8f27154226ecd74e2eaaba6a46ef113d5deca", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 4698522659..c512325b91 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -118,8 +113,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n-              var fare = fareService.getCost(itinerary);\n-              itinerary.fare = fare;\n+              itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "6a5580f5d2419db059dcd15221a64f8054738fbe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex c512325b91..acd3f75161 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -109,8 +124,9 @@ public class FlexRouter {\n       StopLocation transferStop = template.getTransferStop();\n       if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-          if (itinerary != null) {\n+          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+          if (graphPath != null) {\n+            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex acd3f75161..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -122,13 +122,21 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n-        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+      if (\n+        this.flexEgressTemplates.stream()\n+          .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n+      ) {\n+        for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          GraphPath graphPath = template.createDirectGraphPath(\n+            egress,\n+            arriveBy,\n+            departureTime,\n+            startOfTime\n+          );\n           if (graphPath != null) {\n             Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n-            if(fareService != null) {\n+            if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n", "next_change": {"commit": "8203a7ab2da62914747234aa92eaffd66586eba8", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..e52dde5c6d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -127,14 +127,14 @@ public class FlexRouter {\n           .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n       ) {\n         for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(\n+          Itinerary itinerary = template.createDirectGraphPath(\n             egress,\n             arriveBy,\n             departureTime,\n-            startOfTime\n+            startOfTime,\n+            graphPathToItineraryMapper\n           );\n-          if (graphPath != null) {\n-            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n+          if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "17e16dc22573b3807a4d010261f9b5001597e455", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex e52dde5c6d..ccc8793024 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -137,7 +136,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n-              itinerary.fare = fareService.getCost(itinerary);\n+              itinerary.setFare(fareService.getCost(itinerary));\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "0629e8347623e28092f3de0cb361aea6a7fcd67e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex ccc8793024..75d1d5d776 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +133,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 75d1d5d776..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -133,6 +139,10 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n+            var fareService = transitModel.getService(FareService.class);\n+            if (fareService != null) {\n+              itinerary.setFare(fareService.getCost(itinerary));\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -139,7 +134,7 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = transitModel.getService(FareService.class);\n+            var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.setFare(fareService.getCost(itinerary));\n             }\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +136,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyNTQyNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492625426", "body": "Maybe something like this:\r\n\r\n```\r\nclass FlexServicesOnDate {\r\n  private final TIntSet servicesRunning;\r\n  private final int secondsFromStartOfTime;\r\n  private final ServiceDate serviceDate;\r\n}\r\n```", "bodyText": "Maybe something like this:\nclass FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}", "bodyHTML": "<p dir=\"auto\">Maybe something like this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"class FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}\"><pre><code>class FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}\n</code></pre></div>", "author": "t2gran", "createdAt": "2020-09-22T10:19:55Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -31,27 +28,23 @@ import java.util.Optional;\n import java.util.Set;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n \n public class FlexRouter {\n \n   /* Transit data */\n   private final Graph graph;\n-  private final Collection<StopAtDistance> streetAccesses;\n-  private final Collection<StopAtDistance> streetEgresses;\n-  private final StopIndexForRaptor stopIndex;\n-  private final Collection<Transfer> transitTransfers;\n+  private final Collection<NearbyStop> streetAccesses;\n+  private final Collection<NearbyStop> streetEgresses;\n   private final FlexIndex flexIndex;\n-  private final DistanceCalculator distanceCalculator;\n+  private final FlexPathCalculator flexPathCalculator;\n \n   /* Request data */\n   private final ZonedDateTime startOfTime;\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final TIntSet[] servicesRunning;\n-  private final int[] differenceFromStartOfTime;\n-  private final ServiceDate[] serviceDates;\n+  private final FlexServicesOnDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n", "next_change": {"commit": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..f59b84176e 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,7 +44,7 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex f59b84176e..0833d363c8 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -51,24 +50,25 @@ public class FlexRouter {\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 0833d363c8..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -50,21 +58,41 @@ public class FlexRouter {\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      Graph graph,\n-      Instant searchInstant,\n-      boolean arriveBy,\n-      int additionalPastSearchDays,\n-      int additionalFutureSearchDays,\n-      Collection<NearbyStop> streetAccesses,\n-      Collection<NearbyStop> egressTransfers\n+    Graph graph,\n+    TransitModel transitModel,\n+    FlexParameters config,\n+    Instant searchInstant,\n+    boolean arriveBy,\n+    int additionalPastSearchDays,\n+    int additionalFutureSearchDays,\n+    Collection<NearbyStop> streetAccesses,\n+    Collection<NearbyStop> egressTransfers\n   ) {\n     this.graph = graph;\n+    this.transitModel = transitModel;\n+    this.config = config;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n-    this.flexIndex = graph.index.getFlexIndex();\n-    this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n+    this.flexIndex = transitModel.index.getFlexIndex();\n+    this.graphPathToItineraryMapper =\n+      new GraphPathToItineraryMapper(\n+        transitModel.getTimeZone(),\n+        new AlertToLegMapper(transitModel.getTransitAlertService()),\n+        graph.streetNotesService,\n+        graph.ellipsoidToGeoidDifference\n+      );\n \n-    ZoneId tz = graph.getTimeZone().toZoneId();\n+    if (graph.hasStreets) {\n+      this.accessFlexPathCalculator = new StreetFlexPathCalculator(graph, false);\n+      this.egressFlexPathCalculator = new StreetFlexPathCalculator(graph, true);\n+    } else {\n+      // this is only really useful in tests. in real world scenarios you're unlikely to get useful\n+      // results if you don't have streets\n+      this.accessFlexPathCalculator = new DirectFlexPathCalculator();\n+      this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n+    }\n+\n+    ZoneId tz = transitModel.getTimeZone().toZoneId();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -92,7 +87,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = transitModel.getTimeZone().toZoneId();\n+    ZoneId tz = graph.getTimeZone();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -87,7 +89,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = graph.getTimeZone();\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "d7e78dd52dd5a9d10502a18b235bc0395b30d779", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 94fde5163f..07476e5188 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -89,7 +86,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = graph.getTimeZone().toZoneId();\n+    ZoneId tz = graph.getTimeZone();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "9a0a8ec47af5820494ffbe46fc258b86c7115219", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 07476e5188..1912c484fe 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -86,7 +91,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = graph.getTimeZone();\n+    ZoneId tz = transitModel.getTimeZone().toZoneId();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "104c707a268e954ea21e61645ce2f93b6c1acadc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1912c484fe..8f2cd8fe2d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -91,7 +91,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = transitModel.getTimeZone().toZoneId();\n+    ZoneId tz = transitModel.getTimeZone();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "d018fc35bbcaaa52cf517717504365c1eac53d1f", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 8f2cd8fe2d..55dacf49f5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -91,7 +94,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = transitModel.getTimeZone();\n+    ZoneId tz = transitModel.getTimeZone().toZoneId();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "42bdc151367d8a2e85e08be5d2d18b5e41239c00", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 55dacf49f5..633ba5773e 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -94,7 +94,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = transitModel.getTimeZone().toZoneId();\n+    ZoneId tz = transitModel.getTimeZone();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": {"commit": "d88723210fe6ecc4d8619b5424528334980319ad", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 633ba5773e..63c6b79ec2 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -96,8 +96,8 @@ public class FlexRouter {\n \n     ZoneId tz = transitModel.getTimeZone();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n-    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n-    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.startOfTime = ServiceDateUtils.asStartOfService(searchDate, tz);\n+    this.departureTime = ServiceDateUtils.secondsSinceStartOfTime(startOfTime, searchInstant);\n     this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n", "next_change": {"commit": "cc57d2d0a5597e481939d2f7446c9794fa73bf7a", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 63c6b79ec2..0075029422 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -94,7 +88,7 @@ public class FlexRouter {\n       this.egressFlexPathCalculator = new DirectFlexPathCalculator();\n     }\n \n-    ZoneId tz = transitModel.getTimeZone();\n+    ZoneId tz = transitService.getTimeZone();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = ServiceDateUtils.asStartOfService(searchDate, tz);\n     this.departureTime = ServiceDateUtils.secondsSinceStartOfTime(startOfTime, searchInstant);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMDM4Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492630383", "body": "Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.", "bodyText": "Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.", "bodyHTML": "<p dir=\"auto\">Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:29:40Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -82,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        StopAtDistance egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": {"commit": "1a2a37d101c18469a96fa0f15cca39b9cf00c9e9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..15713bbcc5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,93 +46,69 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n+        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-\n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = streetEgressByStop.get(transferStop);\n-        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-        if (itinerary != null) {\n-          itineraries.add(itinerary);\n+        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+          if (itinerary != null) {\n+            itineraries.add(itinerary);\n+          }\n         }\n       }\n     }\n", "next_change": {"commit": "0f990150c1ac69edd30e4648d379277ef78e7092", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 15713bbcc5..4698522659 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -93,20 +105,22 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n-        .stream()\n-        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n-\n-    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = HashMultimap.create();\n+    streetEgresses.forEach(it -> streetEgressByStop.put(it.stop, it));\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (egressStops.contains(transferStop)) {\n+      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n+            var fareService = graph.getService(FareService.class);\n+            if(fareService != null) {\n+              var fare = fareService.getCost(itinerary);\n+              itinerary.fare = fare;\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "32e8f27154226ecd74e2eaaba6a46ef113d5deca", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 4698522659..c512325b91 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -118,8 +113,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n-              var fare = fareService.getCost(itinerary);\n-              itinerary.fare = fare;\n+              itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "6a5580f5d2419db059dcd15221a64f8054738fbe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex c512325b91..acd3f75161 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -109,8 +124,9 @@ public class FlexRouter {\n       StopLocation transferStop = template.getTransferStop();\n       if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-          if (itinerary != null) {\n+          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+          if (graphPath != null) {\n+            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex acd3f75161..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -122,13 +122,21 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n-        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+      if (\n+        this.flexEgressTemplates.stream()\n+          .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n+      ) {\n+        for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          GraphPath graphPath = template.createDirectGraphPath(\n+            egress,\n+            arriveBy,\n+            departureTime,\n+            startOfTime\n+          );\n           if (graphPath != null) {\n             Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n-            if(fareService != null) {\n+            if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n", "next_change": {"commit": "8203a7ab2da62914747234aa92eaffd66586eba8", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..e52dde5c6d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -127,14 +127,14 @@ public class FlexRouter {\n           .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n       ) {\n         for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(\n+          Itinerary itinerary = template.createDirectGraphPath(\n             egress,\n             arriveBy,\n             departureTime,\n-            startOfTime\n+            startOfTime,\n+            graphPathToItineraryMapper\n           );\n-          if (graphPath != null) {\n-            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n+          if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "17e16dc22573b3807a4d010261f9b5001597e455", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex e52dde5c6d..ccc8793024 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -137,7 +136,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n-              itinerary.fare = fareService.getCost(itinerary);\n+              itinerary.setFare(fareService.getCost(itinerary));\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "0629e8347623e28092f3de0cb361aea6a7fcd67e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex ccc8793024..75d1d5d776 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +133,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 75d1d5d776..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -133,6 +139,10 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n+            var fareService = transitModel.getService(FareService.class);\n+            if (fareService != null) {\n+              itinerary.setFare(fareService.getCost(itinerary));\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -139,7 +134,7 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = transitModel.getService(FareService.class);\n+            var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.setFare(fareService.getCost(itinerary));\n             }\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +136,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMTQ1NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492631454", "body": "Make this a local varable.", "bodyText": "Make this a local varable.", "bodyHTML": "<p dir=\"auto\">Make this a local varable.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:31:40Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -82,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        StopAtDistance egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": {"commit": "1a2a37d101c18469a96fa0f15cca39b9cf00c9e9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..15713bbcc5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,93 +46,69 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n+        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-\n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = streetEgressByStop.get(transferStop);\n-        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-        if (itinerary != null) {\n-          itineraries.add(itinerary);\n+        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+          if (itinerary != null) {\n+            itineraries.add(itinerary);\n+          }\n         }\n       }\n     }\n", "next_change": {"commit": "0f990150c1ac69edd30e4648d379277ef78e7092", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 15713bbcc5..4698522659 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -93,20 +105,22 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n-        .stream()\n-        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n-\n-    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = HashMultimap.create();\n+    streetEgresses.forEach(it -> streetEgressByStop.put(it.stop, it));\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (egressStops.contains(transferStop)) {\n+      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n+            var fareService = graph.getService(FareService.class);\n+            if(fareService != null) {\n+              var fare = fareService.getCost(itinerary);\n+              itinerary.fare = fare;\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "32e8f27154226ecd74e2eaaba6a46ef113d5deca", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 4698522659..c512325b91 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -118,8 +113,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n-              var fare = fareService.getCost(itinerary);\n-              itinerary.fare = fare;\n+              itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "6a5580f5d2419db059dcd15221a64f8054738fbe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex c512325b91..acd3f75161 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -109,8 +124,9 @@ public class FlexRouter {\n       StopLocation transferStop = template.getTransferStop();\n       if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-          if (itinerary != null) {\n+          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+          if (graphPath != null) {\n+            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex acd3f75161..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -122,13 +122,21 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n-        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+      if (\n+        this.flexEgressTemplates.stream()\n+          .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n+      ) {\n+        for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          GraphPath graphPath = template.createDirectGraphPath(\n+            egress,\n+            arriveBy,\n+            departureTime,\n+            startOfTime\n+          );\n           if (graphPath != null) {\n             Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n-            if(fareService != null) {\n+            if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n", "next_change": {"commit": "8203a7ab2da62914747234aa92eaffd66586eba8", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..e52dde5c6d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -127,14 +127,14 @@ public class FlexRouter {\n           .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n       ) {\n         for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(\n+          Itinerary itinerary = template.createDirectGraphPath(\n             egress,\n             arriveBy,\n             departureTime,\n-            startOfTime\n+            startOfTime,\n+            graphPathToItineraryMapper\n           );\n-          if (graphPath != null) {\n-            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n+          if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "17e16dc22573b3807a4d010261f9b5001597e455", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex e52dde5c6d..ccc8793024 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -137,7 +136,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n-              itinerary.fare = fareService.getCost(itinerary);\n+              itinerary.setFare(fareService.getCost(itinerary));\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "0629e8347623e28092f3de0cb361aea6a7fcd67e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex ccc8793024..75d1d5d776 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +133,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 75d1d5d776..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -133,6 +139,10 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n+            var fareService = transitModel.getService(FareService.class);\n+            if (fareService != null) {\n+              itinerary.setFare(fareService.getCost(itinerary));\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -139,7 +134,7 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = transitModel.getService(FareService.class);\n+            var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.setFare(fareService.getCost(itinerary));\n             }\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +136,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjE3NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636174", "body": "Add the call of these methods to the beginning of the method.", "bodyText": "Add the call of these methods to the beginning of the method.", "bodyHTML": "<p dir=\"auto\">Add the call of these methods to the beginning of the method.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:40:58Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..fab89e0606 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -150,9 +149,9 @@ public class FlexRouter {\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n     Set<StopLocation> egressStops = egressTransferByStop.keySet();\n \n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e0606..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -81,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n         .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": {"commit": "1a2a37d101c18469a96fa0f15cca39b9cf00c9e9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..15713bbcc5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,93 +46,69 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n+        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-\n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = streetEgressByStop.get(transferStop);\n-        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-        if (itinerary != null) {\n-          itineraries.add(itinerary);\n+        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+          if (itinerary != null) {\n+            itineraries.add(itinerary);\n+          }\n         }\n       }\n     }\n", "next_change": {"commit": "0f990150c1ac69edd30e4648d379277ef78e7092", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 15713bbcc5..4698522659 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -93,20 +105,22 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n-        .stream()\n-        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n-\n-    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = HashMultimap.create();\n+    streetEgresses.forEach(it -> streetEgressByStop.put(it.stop, it));\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (egressStops.contains(transferStop)) {\n+      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n+            var fareService = graph.getService(FareService.class);\n+            if(fareService != null) {\n+              var fare = fareService.getCost(itinerary);\n+              itinerary.fare = fare;\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "32e8f27154226ecd74e2eaaba6a46ef113d5deca", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 4698522659..c512325b91 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -118,8 +113,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n-              var fare = fareService.getCost(itinerary);\n-              itinerary.fare = fare;\n+              itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "6a5580f5d2419db059dcd15221a64f8054738fbe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex c512325b91..acd3f75161 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -109,8 +124,9 @@ public class FlexRouter {\n       StopLocation transferStop = template.getTransferStop();\n       if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-          if (itinerary != null) {\n+          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+          if (graphPath != null) {\n+            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex acd3f75161..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -122,13 +122,21 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n-        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+      if (\n+        this.flexEgressTemplates.stream()\n+          .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n+      ) {\n+        for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          GraphPath graphPath = template.createDirectGraphPath(\n+            egress,\n+            arriveBy,\n+            departureTime,\n+            startOfTime\n+          );\n           if (graphPath != null) {\n             Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n-            if(fareService != null) {\n+            if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n", "next_change": {"commit": "8203a7ab2da62914747234aa92eaffd66586eba8", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..e52dde5c6d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -127,14 +127,14 @@ public class FlexRouter {\n           .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n       ) {\n         for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(\n+          Itinerary itinerary = template.createDirectGraphPath(\n             egress,\n             arriveBy,\n             departureTime,\n-            startOfTime\n+            startOfTime,\n+            graphPathToItineraryMapper\n           );\n-          if (graphPath != null) {\n-            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n+          if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "17e16dc22573b3807a4d010261f9b5001597e455", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex e52dde5c6d..ccc8793024 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -137,7 +136,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n-              itinerary.fare = fareService.getCost(itinerary);\n+              itinerary.setFare(fareService.getCost(itinerary));\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "0629e8347623e28092f3de0cb361aea6a7fcd67e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex ccc8793024..75d1d5d776 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +133,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 75d1d5d776..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -133,6 +139,10 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n+            var fareService = transitModel.getService(FareService.class);\n+            if (fareService != null) {\n+              itinerary.setFare(fareService.getCost(itinerary));\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -139,7 +134,7 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = transitModel.getService(FareService.class);\n+            var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.setFare(fareService.getCost(itinerary));\n             }\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +136,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjUwNQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636505", "body": "Maybe rename to `streetEgressByStop`", "bodyText": "Maybe rename to streetEgressByStop", "bodyHTML": "<p dir=\"auto\">Maybe rename to <code>streetEgressByStop</code></p>", "author": "t2gran", "createdAt": "2020-09-22T10:41:41Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..fab89e0606 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -150,9 +149,9 @@ public class FlexRouter {\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n     Set<StopLocation> egressStops = egressTransferByStop.keySet();\n \n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e0606..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -81,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n         .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": {"commit": "1a2a37d101c18469a96fa0f15cca39b9cf00c9e9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..15713bbcc5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,93 +46,69 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n+        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-\n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = streetEgressByStop.get(transferStop);\n-        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-        if (itinerary != null) {\n-          itineraries.add(itinerary);\n+        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+          if (itinerary != null) {\n+            itineraries.add(itinerary);\n+          }\n         }\n       }\n     }\n", "next_change": {"commit": "0f990150c1ac69edd30e4648d379277ef78e7092", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 15713bbcc5..4698522659 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -93,20 +105,22 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n-        .stream()\n-        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n-\n-    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = HashMultimap.create();\n+    streetEgresses.forEach(it -> streetEgressByStop.put(it.stop, it));\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (egressStops.contains(transferStop)) {\n+      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n+            var fareService = graph.getService(FareService.class);\n+            if(fareService != null) {\n+              var fare = fareService.getCost(itinerary);\n+              itinerary.fare = fare;\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "32e8f27154226ecd74e2eaaba6a46ef113d5deca", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 4698522659..c512325b91 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -118,8 +113,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n-              var fare = fareService.getCost(itinerary);\n-              itinerary.fare = fare;\n+              itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "6a5580f5d2419db059dcd15221a64f8054738fbe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex c512325b91..acd3f75161 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -109,8 +124,9 @@ public class FlexRouter {\n       StopLocation transferStop = template.getTransferStop();\n       if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-          if (itinerary != null) {\n+          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+          if (graphPath != null) {\n+            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex acd3f75161..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -122,13 +122,21 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n-        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+      if (\n+        this.flexEgressTemplates.stream()\n+          .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n+      ) {\n+        for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          GraphPath graphPath = template.createDirectGraphPath(\n+            egress,\n+            arriveBy,\n+            departureTime,\n+            startOfTime\n+          );\n           if (graphPath != null) {\n             Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n-            if(fareService != null) {\n+            if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n", "next_change": {"commit": "8203a7ab2da62914747234aa92eaffd66586eba8", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..e52dde5c6d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -127,14 +127,14 @@ public class FlexRouter {\n           .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n       ) {\n         for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(\n+          Itinerary itinerary = template.createDirectGraphPath(\n             egress,\n             arriveBy,\n             departureTime,\n-            startOfTime\n+            startOfTime,\n+            graphPathToItineraryMapper\n           );\n-          if (graphPath != null) {\n-            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n+          if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "17e16dc22573b3807a4d010261f9b5001597e455", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex e52dde5c6d..ccc8793024 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -137,7 +136,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n-              itinerary.fare = fareService.getCost(itinerary);\n+              itinerary.setFare(fareService.getCost(itinerary));\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "0629e8347623e28092f3de0cb361aea6a7fcd67e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex ccc8793024..75d1d5d776 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +133,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 75d1d5d776..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -133,6 +139,10 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n+            var fareService = transitModel.getService(FareService.class);\n+            if (fareService != null) {\n+              itinerary.setFare(fareService.getCost(itinerary));\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -139,7 +134,7 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = transitModel.getService(FareService.class);\n+            var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.setFare(fareService.getCost(itinerary));\n             }\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +136,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNzIxOA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492637218", "body": "Rename `getDirectItinerary` to `createDirectItinerary`", "bodyText": "Rename getDirectItinerary to createDirectItinerary", "bodyHTML": "<p dir=\"auto\">Rename <code>getDirectItinerary</code> to <code>createDirectItinerary</code></p>", "author": "t2gran", "createdAt": "2020-09-22T10:43:20Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..fab89e0606 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -164,7 +163,7 @@ public class FlexRouter {\n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        NearbyStop egress = egressTransferByStop.get(transferStop);\n         Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e0606..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -81,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n         .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": {"commit": "1a2a37d101c18469a96fa0f15cca39b9cf00c9e9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..15713bbcc5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,93 +46,69 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n+        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n \n     Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-\n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = streetEgressByStop.get(transferStop);\n-        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-        if (itinerary != null) {\n-          itineraries.add(itinerary);\n+        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+          if (itinerary != null) {\n+            itineraries.add(itinerary);\n+          }\n         }\n       }\n     }\n", "next_change": {"commit": "0f990150c1ac69edd30e4648d379277ef78e7092", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 15713bbcc5..4698522659 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -93,20 +105,22 @@ public class FlexRouter {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n-    Multimap<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n-        .stream()\n-        .collect(Multimaps.toMultimap(nearbyStop -> nearbyStop.stop, Function.identity(), HashMultimap::create));\n-\n-    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n+    Multimap<StopLocation, NearbyStop> streetEgressByStop = HashMultimap.create();\n+    streetEgresses.forEach(it -> streetEgressByStop.put(it.stop, it));\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (egressStops.contains(transferStop)) {\n+      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n           Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n           if (itinerary != null) {\n+            var fareService = graph.getService(FareService.class);\n+            if(fareService != null) {\n+              var fare = fareService.getCost(itinerary);\n+              itinerary.fare = fare;\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "32e8f27154226ecd74e2eaaba6a46ef113d5deca", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 4698522659..c512325b91 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -118,8 +113,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n-              var fare = fareService.getCost(itinerary);\n-              itinerary.fare = fare;\n+              itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "6a5580f5d2419db059dcd15221a64f8054738fbe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex c512325b91..acd3f75161 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -109,8 +124,9 @@ public class FlexRouter {\n       StopLocation transferStop = template.getTransferStop();\n       if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n         for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n-          if (itinerary != null) {\n+          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+          if (graphPath != null) {\n+            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n             if(fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex acd3f75161..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -122,13 +122,21 @@ public class FlexRouter {\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n-      if (this.flexEgressTemplates.stream().anyMatch(t -> t.getAccessEgressStop().equals(transferStop))) {\n-        for(NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(egress, arriveBy, departureTime, startOfTime);\n+      if (\n+        this.flexEgressTemplates.stream()\n+          .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n+      ) {\n+        for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n+          GraphPath graphPath = template.createDirectGraphPath(\n+            egress,\n+            arriveBy,\n+            departureTime,\n+            startOfTime\n+          );\n           if (graphPath != null) {\n             Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n             var fareService = graph.getService(FareService.class);\n-            if(fareService != null) {\n+            if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n             }\n             itineraries.add(itinerary);\n", "next_change": {"commit": "8203a7ab2da62914747234aa92eaffd66586eba8", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..e52dde5c6d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -127,14 +127,14 @@ public class FlexRouter {\n           .anyMatch(t -> t.getAccessEgressStop().equals(transferStop))\n       ) {\n         for (NearbyStop egress : streetEgressByStop.get(transferStop)) {\n-          GraphPath graphPath = template.createDirectGraphPath(\n+          Itinerary itinerary = template.createDirectGraphPath(\n             egress,\n             arriveBy,\n             departureTime,\n-            startOfTime\n+            startOfTime,\n+            graphPathToItineraryMapper\n           );\n-          if (graphPath != null) {\n-            Itinerary itinerary = graphPathToItineraryMapper.generateItinerary(graphPath);\n+          if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.fare = fareService.getCost(itinerary);\n", "next_change": {"commit": "17e16dc22573b3807a4d010261f9b5001597e455", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex e52dde5c6d..ccc8793024 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -137,7 +136,7 @@ public class FlexRouter {\n           if (itinerary != null) {\n             var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n-              itinerary.fare = fareService.getCost(itinerary);\n+              itinerary.setFare(fareService.getCost(itinerary));\n             }\n             itineraries.add(itinerary);\n           }\n", "next_change": {"commit": "0629e8347623e28092f3de0cb361aea6a7fcd67e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex ccc8793024..75d1d5d776 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +133,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 75d1d5d776..1dd3f57fee 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -133,6 +139,10 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n+            var fareService = transitModel.getService(FareService.class);\n+            if (fareService != null) {\n+              itinerary.setFare(fareService.getCost(itinerary));\n+            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1dd3f57fee..163c920b8a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -139,7 +134,7 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = transitModel.getService(FareService.class);\n+            var fareService = graph.getService(FareService.class);\n             if (fareService != null) {\n               itinerary.setFare(fareService.getCost(itinerary));\n             }\n", "next_change": {"commit": "259ddd10a0e41596527f1c7d43930cbba0a5cb1d", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 163c920b8a..94fde5163f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -134,10 +136,6 @@ public class FlexRouter {\n             graphPathToItineraryMapper\n           );\n           if (itinerary != null) {\n-            var fareService = graph.getService(FareService.class);\n-            if (fareService != null) {\n-              itinerary.setFare(fareService.getCost(itinerary));\n-            }\n             itineraries.add(itinerary);\n           }\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzODE3Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492638173", "body": "Not Base use template", "bodyText": "Not Base use template", "bodyHTML": "<p dir=\"auto\">Not Base use template</p>", "author": "t2gran", "createdAt": "2020-09-22T10:45:21Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        if (itinerary != null) {\n+          itineraries.add(itinerary);\n+        }\n+      }\n+    }\n+\n+    return itineraries;\n+  }\n+\n+  public Collection<FlexAccessEgress> getFlexAccesses() {\n+    calculateFlexAccessTemplates();\n+\n+    return this.flexAccessTemplates\n+        .stream()\n+        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph, stopIndex.indexByStop))", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3e..32add64819 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -180,7 +173,7 @@ public class FlexRouter {\n \n     return this.flexAccessTemplates\n         .stream()\n-        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph, stopIndex.indexByStop))\n+        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph))\n         .collect(Collectors.toList());\n   }\n \n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 32add64819..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -173,7 +143,7 @@ public class FlexRouter {\n \n     return this.flexAccessTemplates\n         .stream()\n-        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph))\n+        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n         .collect(Collectors.toList());\n   }\n \n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..0833d363c8 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -147,7 +121,7 @@ public class FlexRouter {\n         .collect(Collectors.toList());\n   }\n \n-  public Collection<FlexAccessEgress> getFlexEgresses() {\n+  public Collection<FlexAccessEgress> createFlexEgresses() {\n     calculateFlexEgressTemplates();\n \n     return this.flexEgressTemplates\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 0833d363c8..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -115,69 +151,92 @@ public class FlexRouter {\n   public Collection<FlexAccessEgress> createFlexAccesses() {\n     calculateFlexAccessTemplates();\n \n-    return this.flexAccessTemplates\n-        .stream()\n-        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n-        .collect(Collectors.toList());\n+    return this.flexAccessTemplates.stream()\n+      .flatMap(template -> template.createFlexAccessEgressStream(graph))\n+      .collect(Collectors.toList());\n   }\n \n   public Collection<FlexAccessEgress> createFlexEgresses() {\n     calculateFlexEgressTemplates();\n \n-    return this.flexEgressTemplates\n-        .stream()\n-        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n-        .collect(Collectors.toList());\n+    return this.flexEgressTemplates.stream()\n+      .flatMap(template -> template.createFlexAccessEgressStream(graph))\n+      .collect(Collectors.toList());\n   }\n \n   private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n+    if (this.flexAccessTemplates != null) {\n+      return;\n+    }\n \n     // Fetch the closest flexTrips reachable from the access stops\n-    this.flexAccessTemplates = getClosestFlexTrips(streetAccesses)\n+    this.flexAccessTemplates =\n+      getClosestFlexTrips(streetAccesses, true)\n         // For each date the router has data for\n-        .flatMap(t2 -> Arrays.stream(dates)\n+        .flatMap(t2 ->\n+          Arrays\n+            .stream(dates)\n             // Discard if service is not running on date\n             .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n             // Create templates from trip, boarding at the nearbyStop\n-            .flatMap(date -> t2.second.getFlexAccessTemplates(t2.first, date, flexPathCalculator)))\n+            .flatMap(date ->\n+              t2.second.getFlexAccessTemplates(t2.first, date, accessFlexPathCalculator, config)\n+            )\n+        )\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n+    if (this.flexEgressTemplates != null) {\n+      return;\n+    }\n \n     // Fetch the closest flexTrips reachable from the egress stops\n-    this.flexEgressTemplates = getClosestFlexTrips(streetEgresses)\n+    this.flexEgressTemplates =\n+      getClosestFlexTrips(streetEgresses, false)\n         // For each date the router has data for\n-        .flatMap(t2 -> Arrays.stream(dates)\n+        .flatMap(t2 ->\n+          Arrays\n+            .stream(dates)\n             // Discard if service is not running on date\n             .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n             // Create templates from trip, alighting at the nearbyStop\n-            .flatMap(date -> t2.second.getFlexEgressTemplates(t2.first, date, flexPathCalculator)))\n-        .collect(Collectors.toList());;\n+            .flatMap(date ->\n+              t2.second.getFlexEgressTemplates(t2.first, date, egressFlexPathCalculator, config)\n+            )\n+        )\n+        .collect(Collectors.toList());\n   }\n \n-  private Stream<T2<NearbyStop, FlexTrip>> getClosestFlexTrips(Collection<NearbyStop> nearbyStops) {\n+  private Stream<T2<NearbyStop, FlexTrip>> getClosestFlexTrips(\n+    Collection<NearbyStop> nearbyStops,\n+    boolean pickup\n+  ) {\n     // Find all trips reachable from the nearbyStops\n     Stream<T2<NearbyStop, FlexTrip>> flexTripsReachableFromNearbyStops = nearbyStops\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)));\n+      .stream()\n+      .flatMap(accessEgress ->\n+        flexIndex\n+          .getFlexTripsByStop(accessEgress.stop)\n+          .filter(flexTrip ->\n+            pickup\n+              ? flexTrip.isBoardingPossible(accessEgress)\n+              : flexTrip.isAlightingPossible(accessEgress)\n+          )\n+          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n+      );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n     Collection<List<T2<NearbyStop, FlexTrip>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values();\n+      .collect(Collectors.groupingBy(t2 -> t2.second))\n+      .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n-        .stream()\n-        .map(t2s -> t2s\n-            .stream()\n-            .min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream);\n+      .stream()\n+      .map(t2s ->\n+        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n+      )\n+      .flatMap(Optional::stream);\n   }\n-\n }\n", "next_change": {"commit": "644dfb3fa605ffb00ae56d6eb45f26b4a2292d88", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..1228789ff1 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -195,48 +189,55 @@ public class FlexRouter {\n     this.flexEgressTemplates =\n       getClosestFlexTrips(streetEgresses, false)\n         // For each date the router has data for\n-        .flatMap(t2 ->\n+        .flatMap(it ->\n           Arrays\n             .stream(dates)\n             // Discard if service is not running on date\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .filter(date -> date.isFlexTripRunning(it.flexTrip(), this.transitService))\n             // Create templates from trip, alighting at the nearbyStop\n             .flatMap(date ->\n-              t2.second.getFlexEgressTemplates(t2.first, date, egressFlexPathCalculator, config)\n+              it\n+                .flexTrip()\n+                .getFlexEgressTemplates(it.accessEgress(), date, egressFlexPathCalculator, config)\n             )\n         )\n         .collect(Collectors.toList());\n   }\n \n-  private Stream<T2<NearbyStop, FlexTrip>> getClosestFlexTrips(\n+  private Stream<AccessEgressAndNearbyStop> getClosestFlexTrips(\n     Collection<NearbyStop> nearbyStops,\n     boolean pickup\n   ) {\n     // Find all trips reachable from the nearbyStops\n-    Stream<T2<NearbyStop, FlexTrip>> flexTripsReachableFromNearbyStops = nearbyStops\n+    Stream<AccessEgressAndNearbyStop> flexTripsReachableFromNearbyStops = nearbyStops\n       .stream()\n       .flatMap(accessEgress ->\n         flexIndex\n           .getFlexTripsByStop(accessEgress.stop)\n+          .stream()\n           .filter(flexTrip ->\n             pickup\n               ? flexTrip.isBoardingPossible(accessEgress)\n               : flexTrip.isAlightingPossible(accessEgress)\n           )\n-          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n+          .map(flexTrip -> new AccessEgressAndNearbyStop(accessEgress, flexTrip))\n       );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n-    Collection<List<T2<NearbyStop, FlexTrip>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-      .collect(Collectors.groupingBy(t2 -> t2.second))\n+    Collection<List<AccessEgressAndNearbyStop>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+      .collect(Collectors.groupingBy(AccessEgressAndNearbyStop::flexTrip))\n       .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n       .stream()\n       .map(t2s ->\n-        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n+        t2s\n+          .stream()\n+          .min(Comparator.comparingLong(t2 -> t2.accessEgress().state.getElapsedTimeSeconds()))\n       )\n       .flatMap(Optional::stream);\n   }\n+\n+  private record AccessEgressAndNearbyStop(NearbyStop accessEgress, FlexTrip<?, ?> flexTrip) {}\n }\n", "next_change": {"commit": "91d95559cd6a000a02b52a3aa6ed69be7d78ba56", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1228789ff1..aca010219e 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -220,24 +223,20 @@ public class FlexRouter {\n               ? flexTrip.isBoardingPossible(accessEgress)\n               : flexTrip.isAlightingPossible(accessEgress)\n           )\n-          .map(flexTrip -> new AccessEgressAndNearbyStop(accessEgress, flexTrip))\n+          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n       );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n-    Collection<List<AccessEgressAndNearbyStop>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-      .collect(Collectors.groupingBy(AccessEgressAndNearbyStop::flexTrip))\n+    Collection<List<T2<NearbyStop, FlexTrip<?, ?>>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+      .collect(Collectors.groupingBy(t2 -> t2.second))\n       .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n       .stream()\n       .map(t2s ->\n-        t2s\n-          .stream()\n-          .min(Comparator.comparingLong(t2 -> t2.accessEgress().state.getElapsedTimeSeconds()))\n+        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n       )\n       .flatMap(Optional::stream);\n   }\n-\n-  private record AccessEgressAndNearbyStop(NearbyStop accessEgress, FlexTrip<?, ?> flexTrip) {}\n }\n", "next_change": {"commit": "71aa29c6408b97d10eea005119cd54dd848c8e72", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex aca010219e..9964c9ab17 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -223,20 +234,24 @@ public class FlexRouter {\n               ? flexTrip.isBoardingPossible(accessEgress)\n               : flexTrip.isAlightingPossible(accessEgress)\n           )\n-          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n+          .map(flexTrip -> new AccessEgressAndNearbyStop(accessEgress, flexTrip))\n       );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n-    Collection<List<T2<NearbyStop, FlexTrip<?, ?>>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-      .collect(Collectors.groupingBy(t2 -> t2.second))\n+    Collection<List<AccessEgressAndNearbyStop>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+      .collect(Collectors.groupingBy(AccessEgressAndNearbyStop::flexTrip))\n       .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n       .stream()\n       .map(t2s ->\n-        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n+        t2s\n+          .stream()\n+          .min(Comparator.comparingLong(t2 -> t2.accessEgress().state.getElapsedTimeSeconds()))\n       )\n       .flatMap(Optional::stream);\n   }\n+\n+  private record AccessEgressAndNearbyStop(NearbyStop accessEgress, FlexTrip<?, ?> flexTrip) {}\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 32add64819..a599beff9d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -182,12 +152,32 @@ public class FlexRouter {\n \n     return this.flexEgressTemplates\n         .stream()\n-        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph))\n+        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n         .collect(Collectors.toList());\n   }\n \n-  private boolean isFlexTripRunning(TIntSet services, FlexTrip flexTrip) {\n-    return services.contains(graph.getServiceCodes().get(flexTrip.getTrip().getServiceId()));\n+  private Stream<T2<NearbyStop, FlexTrip>> getReachableFlexTrips(Collection<NearbyStop> nearbyStops) {\n+    // Find all trips reachable from the nearbyStops\n+    Stream<T2<NearbyStop, FlexTrip>> flexTripsReachableFromNearbyStops = nearbyStops\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)));\n+\n+    // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n+    Collection<List<T2<NearbyStop, FlexTrip>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values();\n+\n+    // Get the tuple with least walking time from each group\n+    Stream<T2<NearbyStop, FlexTrip>> nearestFlexibleTrips = groupedReachableFlexTrips\n+        .stream()\n+        .map(t2s -> t2s\n+            .stream()\n+            .min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream);\n+\n+    return nearestFlexibleTrips;\n   }\n \n }\n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9d..0833d363c8 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -170,14 +172,12 @@ public class FlexRouter {\n         .values();\n \n     // Get the tuple with least walking time from each group\n-    Stream<T2<NearbyStop, FlexTrip>> nearestFlexibleTrips = groupedReachableFlexTrips\n+    return groupedReachableFlexTrips\n         .stream()\n         .map(t2s -> t2s\n             .stream()\n             .min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n         .flatMap(Optional::stream);\n-\n-    return nearestFlexibleTrips;\n   }\n \n }\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 0833d363c8..66b1b9ea5b 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -115,69 +151,92 @@ public class FlexRouter {\n   public Collection<FlexAccessEgress> createFlexAccesses() {\n     calculateFlexAccessTemplates();\n \n-    return this.flexAccessTemplates\n-        .stream()\n-        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n-        .collect(Collectors.toList());\n+    return this.flexAccessTemplates.stream()\n+      .flatMap(template -> template.createFlexAccessEgressStream(graph))\n+      .collect(Collectors.toList());\n   }\n \n   public Collection<FlexAccessEgress> createFlexEgresses() {\n     calculateFlexEgressTemplates();\n \n-    return this.flexEgressTemplates\n-        .stream()\n-        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n-        .collect(Collectors.toList());\n+    return this.flexEgressTemplates.stream()\n+      .flatMap(template -> template.createFlexAccessEgressStream(graph))\n+      .collect(Collectors.toList());\n   }\n \n   private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n+    if (this.flexAccessTemplates != null) {\n+      return;\n+    }\n \n     // Fetch the closest flexTrips reachable from the access stops\n-    this.flexAccessTemplates = getClosestFlexTrips(streetAccesses)\n+    this.flexAccessTemplates =\n+      getClosestFlexTrips(streetAccesses, true)\n         // For each date the router has data for\n-        .flatMap(t2 -> Arrays.stream(dates)\n+        .flatMap(t2 ->\n+          Arrays\n+            .stream(dates)\n             // Discard if service is not running on date\n             .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n             // Create templates from trip, boarding at the nearbyStop\n-            .flatMap(date -> t2.second.getFlexAccessTemplates(t2.first, date, flexPathCalculator)))\n+            .flatMap(date ->\n+              t2.second.getFlexAccessTemplates(t2.first, date, accessFlexPathCalculator, config)\n+            )\n+        )\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n+    if (this.flexEgressTemplates != null) {\n+      return;\n+    }\n \n     // Fetch the closest flexTrips reachable from the egress stops\n-    this.flexEgressTemplates = getClosestFlexTrips(streetEgresses)\n+    this.flexEgressTemplates =\n+      getClosestFlexTrips(streetEgresses, false)\n         // For each date the router has data for\n-        .flatMap(t2 -> Arrays.stream(dates)\n+        .flatMap(t2 ->\n+          Arrays\n+            .stream(dates)\n             // Discard if service is not running on date\n             .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n             // Create templates from trip, alighting at the nearbyStop\n-            .flatMap(date -> t2.second.getFlexEgressTemplates(t2.first, date, flexPathCalculator)))\n-        .collect(Collectors.toList());;\n+            .flatMap(date ->\n+              t2.second.getFlexEgressTemplates(t2.first, date, egressFlexPathCalculator, config)\n+            )\n+        )\n+        .collect(Collectors.toList());\n   }\n \n-  private Stream<T2<NearbyStop, FlexTrip>> getClosestFlexTrips(Collection<NearbyStop> nearbyStops) {\n+  private Stream<T2<NearbyStop, FlexTrip>> getClosestFlexTrips(\n+    Collection<NearbyStop> nearbyStops,\n+    boolean pickup\n+  ) {\n     // Find all trips reachable from the nearbyStops\n     Stream<T2<NearbyStop, FlexTrip>> flexTripsReachableFromNearbyStops = nearbyStops\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)));\n+      .stream()\n+      .flatMap(accessEgress ->\n+        flexIndex\n+          .getFlexTripsByStop(accessEgress.stop)\n+          .filter(flexTrip ->\n+            pickup\n+              ? flexTrip.isBoardingPossible(accessEgress)\n+              : flexTrip.isAlightingPossible(accessEgress)\n+          )\n+          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n+      );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n     Collection<List<T2<NearbyStop, FlexTrip>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values();\n+      .collect(Collectors.groupingBy(t2 -> t2.second))\n+      .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n-        .stream()\n-        .map(t2s -> t2s\n-            .stream()\n-            .min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream);\n+      .stream()\n+      .map(t2s ->\n+        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n+      )\n+      .flatMap(Optional::stream);\n   }\n-\n }\n", "next_change": {"commit": "644dfb3fa605ffb00ae56d6eb45f26b4a2292d88", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 66b1b9ea5b..1228789ff1 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -195,48 +189,55 @@ public class FlexRouter {\n     this.flexEgressTemplates =\n       getClosestFlexTrips(streetEgresses, false)\n         // For each date the router has data for\n-        .flatMap(t2 ->\n+        .flatMap(it ->\n           Arrays\n             .stream(dates)\n             // Discard if service is not running on date\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .filter(date -> date.isFlexTripRunning(it.flexTrip(), this.transitService))\n             // Create templates from trip, alighting at the nearbyStop\n             .flatMap(date ->\n-              t2.second.getFlexEgressTemplates(t2.first, date, egressFlexPathCalculator, config)\n+              it\n+                .flexTrip()\n+                .getFlexEgressTemplates(it.accessEgress(), date, egressFlexPathCalculator, config)\n             )\n         )\n         .collect(Collectors.toList());\n   }\n \n-  private Stream<T2<NearbyStop, FlexTrip>> getClosestFlexTrips(\n+  private Stream<AccessEgressAndNearbyStop> getClosestFlexTrips(\n     Collection<NearbyStop> nearbyStops,\n     boolean pickup\n   ) {\n     // Find all trips reachable from the nearbyStops\n-    Stream<T2<NearbyStop, FlexTrip>> flexTripsReachableFromNearbyStops = nearbyStops\n+    Stream<AccessEgressAndNearbyStop> flexTripsReachableFromNearbyStops = nearbyStops\n       .stream()\n       .flatMap(accessEgress ->\n         flexIndex\n           .getFlexTripsByStop(accessEgress.stop)\n+          .stream()\n           .filter(flexTrip ->\n             pickup\n               ? flexTrip.isBoardingPossible(accessEgress)\n               : flexTrip.isAlightingPossible(accessEgress)\n           )\n-          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n+          .map(flexTrip -> new AccessEgressAndNearbyStop(accessEgress, flexTrip))\n       );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n-    Collection<List<T2<NearbyStop, FlexTrip>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-      .collect(Collectors.groupingBy(t2 -> t2.second))\n+    Collection<List<AccessEgressAndNearbyStop>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+      .collect(Collectors.groupingBy(AccessEgressAndNearbyStop::flexTrip))\n       .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n       .stream()\n       .map(t2s ->\n-        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n+        t2s\n+          .stream()\n+          .min(Comparator.comparingLong(t2 -> t2.accessEgress().state.getElapsedTimeSeconds()))\n       )\n       .flatMap(Optional::stream);\n   }\n+\n+  private record AccessEgressAndNearbyStop(NearbyStop accessEgress, FlexTrip<?, ?> flexTrip) {}\n }\n", "next_change": {"commit": "91d95559cd6a000a02b52a3aa6ed69be7d78ba56", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 1228789ff1..aca010219e 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -220,24 +223,20 @@ public class FlexRouter {\n               ? flexTrip.isBoardingPossible(accessEgress)\n               : flexTrip.isAlightingPossible(accessEgress)\n           )\n-          .map(flexTrip -> new AccessEgressAndNearbyStop(accessEgress, flexTrip))\n+          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n       );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n-    Collection<List<AccessEgressAndNearbyStop>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-      .collect(Collectors.groupingBy(AccessEgressAndNearbyStop::flexTrip))\n+    Collection<List<T2<NearbyStop, FlexTrip<?, ?>>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+      .collect(Collectors.groupingBy(t2 -> t2.second))\n       .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n       .stream()\n       .map(t2s ->\n-        t2s\n-          .stream()\n-          .min(Comparator.comparingLong(t2 -> t2.accessEgress().state.getElapsedTimeSeconds()))\n+        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n       )\n       .flatMap(Optional::stream);\n   }\n-\n-  private record AccessEgressAndNearbyStop(NearbyStop accessEgress, FlexTrip<?, ?> flexTrip) {}\n }\n", "next_change": {"commit": "71aa29c6408b97d10eea005119cd54dd848c8e72", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex aca010219e..9964c9ab17 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -223,20 +234,24 @@ public class FlexRouter {\n               ? flexTrip.isBoardingPossible(accessEgress)\n               : flexTrip.isAlightingPossible(accessEgress)\n           )\n-          .map(flexTrip -> new T2<>(accessEgress, flexTrip))\n+          .map(flexTrip -> new AccessEgressAndNearbyStop(accessEgress, flexTrip))\n       );\n \n     // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n-    Collection<List<T2<NearbyStop, FlexTrip<?, ?>>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n-      .collect(Collectors.groupingBy(t2 -> t2.second))\n+    Collection<List<AccessEgressAndNearbyStop>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+      .collect(Collectors.groupingBy(AccessEgressAndNearbyStop::flexTrip))\n       .values();\n \n     // Get the tuple with least walking time from each group\n     return groupedReachableFlexTrips\n       .stream()\n       .map(t2s ->\n-        t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds()))\n+        t2s\n+          .stream()\n+          .min(Comparator.comparingLong(t2 -> t2.accessEgress().state.getElapsedTimeSeconds()))\n       )\n       .flatMap(Optional::stream);\n   }\n+\n+  private record AccessEgressAndNearbyStop(NearbyStop accessEgress, FlexTrip<?, ?> flexTrip) {}\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzOTc2MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492639761", "body": "create/generate not get, maybe?", "bodyText": "create/generate not get, maybe?", "bodyHTML": "<p dir=\"auto\">create/generate not get, maybe?</p>", "author": "t2gran", "createdAt": "2020-09-22T10:48:38Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9df667f4d9..a66dadbca1 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -73,33 +72,29 @@ public abstract class FlexAccessEgressTemplate {\n \n   abstract protected boolean isRouteable(Vertex flexVertex);\n \n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n-      Graph graph, Map<Stop, Integer> indexByStop\n-  ) {\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n       if (isRouteable(flexVertex)) {\n-        return Stream.of(\n-            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n-        );\n+        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n       }\n       return Stream.empty();\n     } else {\n       return getTransfersFromTransferStop(graph)\n           .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) instanceof Stop)\n+          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n           .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n           .map(simpleTransfer -> {\n             List<Edge> edges = getTransferEdges(simpleTransfer);\n             return getFlexAccessEgress(edges,\n                 getFlexVertex(edges.get(0)),\n-                indexByStop.get(getFinalStop(simpleTransfer))\n+                getFinalStop(simpleTransfer)\n             );\n           });\n     }\n   }\n \n-  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, int stopIndex) {\n+  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n     State state = flexEdge.traverse(accessEgress.state);\n", "next_change": {"commit": "2f2fe4a58a545f70215f360ea8d9938cbd9136b9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex a66dadbca1..a4cf6ca411 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -54,52 +64,88 @@ public abstract class FlexAccessEgressTemplate {\n     return transferStop;\n   }\n \n+  public StopLocation getAccessEgressStop() {\n+    return accessEgress.stop;\n+  }\n+\n   public FlexTrip getFlexTrip() {\n     return trip;\n   }\n \n-  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n-\n-  abstract protected Stop getFinalStop(SimpleTransfer simpleTransfer);\n-\n-  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n-\n+  /**\n+   * Get a list of edges used for transferring to and from the scheduled transit network. The edges\n+   * should be in the order of traversal of the state in the NearbyStop\n+   * */\n+  abstract protected List<Edge> getTransferEdges(PathTransfer transfer);\n+\n+  /**\n+   * Get the {@Link Stop} where the connection to the scheduled transit network is made.\n+   */\n+  abstract protected Stop getFinalStop(PathTransfer transfer);\n+\n+  /**\n+   * Get the transfers to/from stops in the scheduled transit network from the beginning/end of the\n+   * flex ride for the access/egress.\n+   */\n+  abstract protected Collection<PathTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  /**\n+   * Get the {@Link Vertex} where the flex ride ends/begins for the access/egress.\n+   */\n   abstract protected Vertex getFlexVertex(Edge edge);\n \n+  /**\n+   * Get the times in seconds, before during and after the flex ride.\n+   */\n   abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n \n+  /**\n+   * Get the FlexTripEdge for the flex ride.\n+   */\n   abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n \n-  abstract protected boolean isRouteable(Vertex flexVertex);\n-\n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(Graph graph) {\n+  /**\n+   * This method is very much the hot code path in the flex access/egress search so any optimization\n+   * here will lead to noticeable speedups.\n+   */\n+  public Stream<FlexAccessEgress> createFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n-      if (isRouteable(flexVertex)) {\n-        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n-      }\n-      return Stream.empty();\n-    } else {\n+      return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop))\n+              .filter(Objects::nonNull);\n+    }\n+    // transferStop is Location Area/Line\n+    else {\n       return getTransfersFromTransferStop(graph)\n-          .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n-          .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n-          .map(simpleTransfer -> {\n-            List<Edge> edges = getTransferEdges(simpleTransfer);\n-            return getFlexAccessEgress(edges,\n-                getFlexVertex(edges.get(0)),\n-                getFinalStop(simpleTransfer)\n-            );\n-          });\n+              .stream()\n+              .filter(transfer -> getFinalStop(transfer) != null)\n+              .map(transfer -> {\n+                List<Edge> edges = getTransferEdges(transfer);\n+                return getFlexAccessEgress(\n+                        edges,\n+                        getFlexVertex(edges.get(0)),\n+                        getFinalStop(transfer)\n+                );\n+              })\n+              .filter(Objects::nonNull);\n     }\n   }\n \n   protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n+    // this code is a little repetitive but needed as a performance improvement. previously\n+    // the flex path was checked before this method was called. this meant that every path\n+    // was traversed twice leading to a noticeable slowdown.\n     State state = flexEdge.traverse(accessEgress.state);\n+    if (state == null) {\n+      return null;\n+    }\n     for (Edge e : transferEdges) {\n       state = e.traverse(state);\n+      if (state == null) {\n+        return null;\n+      }\n     }\n \n     int[] times = getFlexTimes(flexEdge, state);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex a4cf6ca411..9880f9fdd3 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -151,16 +159,32 @@ public abstract class FlexAccessEgressTemplate {\n     int[] times = getFlexTimes(flexEdge, state);\n \n     return new FlexAccessEgress(\n-        stop,\n-        times[0],\n-        times[1],\n-        times[2],\n-        fromStopIndex,\n-        toStopIndex, secondsFromStartOfTime,\n-        trip,\n-        state,\n-        transferEdges.isEmpty()\n+      stop,\n+      times[0],\n+      times[1],\n+      times[2],\n+      fromStopIndex,\n+      toStopIndex,\n+      secondsFromStartOfTime,\n+      trip,\n+      state,\n+      transferEdges.isEmpty()\n     );\n   }\n \n+  @Override\n+  public String toString() {\n+    return MoreObjects\n+      .toStringHelper(this)\n+      .add(\"accessEgress\", accessEgress)\n+      .add(\"trip\", trip)\n+      .add(\"fromStopIndex\", fromStopIndex)\n+      .add(\"toStopIndex\", toStopIndex)\n+      .add(\"transferStop\", transferStop)\n+      .add(\"secondsFromStartOfTime\", secondsFromStartOfTime)\n+      .add(\"serviceDate\", serviceDate)\n+      .add(\"calculator\", calculator)\n+      .add(\"flexParams\", flexParams)\n+      .toString();\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9880f9fdd3..8c66b0e4ba 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -171,20 +186,4 @@ public abstract class FlexAccessEgressTemplate {\n       transferEdges.isEmpty()\n     );\n   }\n-\n-  @Override\n-  public String toString() {\n-    return MoreObjects\n-      .toStringHelper(this)\n-      .add(\"accessEgress\", accessEgress)\n-      .add(\"trip\", trip)\n-      .add(\"fromStopIndex\", fromStopIndex)\n-      .add(\"toStopIndex\", toStopIndex)\n-      .add(\"transferStop\", transferStop)\n-      .add(\"secondsFromStartOfTime\", secondsFromStartOfTime)\n-      .add(\"serviceDate\", serviceDate)\n-      .add(\"calculator\", calculator)\n-      .add(\"flexParams\", flexParams)\n-      .toString();\n-  }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg4Mg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492640882", "body": "}\r\n// Location Area/Line\r\nelse {", "bodyText": "}\n// Location Area/Line\nelse {", "bodyHTML": "<p dir=\"auto\">}<br>\n// Location Area/Line<br>\nelse {</p>", "author": "t2gran", "createdAt": "2020-09-22T10:50:53Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n+      Graph graph, Map<Stop, Integer> indexByStop\n+  ) {\n+    if (transferStop instanceof Stop) {\n+      TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n+      if (isRouteable(flexVertex)) {\n+        return Stream.of(\n+            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n+        );\n+      }\n+      return Stream.empty();\n+    } else {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9df667f4d9..a66dadbca1 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -73,33 +72,29 @@ public abstract class FlexAccessEgressTemplate {\n \n   abstract protected boolean isRouteable(Vertex flexVertex);\n \n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n-      Graph graph, Map<Stop, Integer> indexByStop\n-  ) {\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n       if (isRouteable(flexVertex)) {\n-        return Stream.of(\n-            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n-        );\n+        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n       }\n       return Stream.empty();\n     } else {\n       return getTransfersFromTransferStop(graph)\n           .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) instanceof Stop)\n+          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n           .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n           .map(simpleTransfer -> {\n             List<Edge> edges = getTransferEdges(simpleTransfer);\n             return getFlexAccessEgress(edges,\n                 getFlexVertex(edges.get(0)),\n-                indexByStop.get(getFinalStop(simpleTransfer))\n+                getFinalStop(simpleTransfer)\n             );\n           });\n     }\n   }\n \n-  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, int stopIndex) {\n+  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n     State state = flexEdge.traverse(accessEgress.state);\n", "next_change": {"commit": "2f2fe4a58a545f70215f360ea8d9938cbd9136b9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex a66dadbca1..a4cf6ca411 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -54,52 +64,88 @@ public abstract class FlexAccessEgressTemplate {\n     return transferStop;\n   }\n \n+  public StopLocation getAccessEgressStop() {\n+    return accessEgress.stop;\n+  }\n+\n   public FlexTrip getFlexTrip() {\n     return trip;\n   }\n \n-  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n-\n-  abstract protected Stop getFinalStop(SimpleTransfer simpleTransfer);\n-\n-  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n-\n+  /**\n+   * Get a list of edges used for transferring to and from the scheduled transit network. The edges\n+   * should be in the order of traversal of the state in the NearbyStop\n+   * */\n+  abstract protected List<Edge> getTransferEdges(PathTransfer transfer);\n+\n+  /**\n+   * Get the {@Link Stop} where the connection to the scheduled transit network is made.\n+   */\n+  abstract protected Stop getFinalStop(PathTransfer transfer);\n+\n+  /**\n+   * Get the transfers to/from stops in the scheduled transit network from the beginning/end of the\n+   * flex ride for the access/egress.\n+   */\n+  abstract protected Collection<PathTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  /**\n+   * Get the {@Link Vertex} where the flex ride ends/begins for the access/egress.\n+   */\n   abstract protected Vertex getFlexVertex(Edge edge);\n \n+  /**\n+   * Get the times in seconds, before during and after the flex ride.\n+   */\n   abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n \n+  /**\n+   * Get the FlexTripEdge for the flex ride.\n+   */\n   abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n \n-  abstract protected boolean isRouteable(Vertex flexVertex);\n-\n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(Graph graph) {\n+  /**\n+   * This method is very much the hot code path in the flex access/egress search so any optimization\n+   * here will lead to noticeable speedups.\n+   */\n+  public Stream<FlexAccessEgress> createFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n-      if (isRouteable(flexVertex)) {\n-        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n-      }\n-      return Stream.empty();\n-    } else {\n+      return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop))\n+              .filter(Objects::nonNull);\n+    }\n+    // transferStop is Location Area/Line\n+    else {\n       return getTransfersFromTransferStop(graph)\n-          .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n-          .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n-          .map(simpleTransfer -> {\n-            List<Edge> edges = getTransferEdges(simpleTransfer);\n-            return getFlexAccessEgress(edges,\n-                getFlexVertex(edges.get(0)),\n-                getFinalStop(simpleTransfer)\n-            );\n-          });\n+              .stream()\n+              .filter(transfer -> getFinalStop(transfer) != null)\n+              .map(transfer -> {\n+                List<Edge> edges = getTransferEdges(transfer);\n+                return getFlexAccessEgress(\n+                        edges,\n+                        getFlexVertex(edges.get(0)),\n+                        getFinalStop(transfer)\n+                );\n+              })\n+              .filter(Objects::nonNull);\n     }\n   }\n \n   protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n+    // this code is a little repetitive but needed as a performance improvement. previously\n+    // the flex path was checked before this method was called. this meant that every path\n+    // was traversed twice leading to a noticeable slowdown.\n     State state = flexEdge.traverse(accessEgress.state);\n+    if (state == null) {\n+      return null;\n+    }\n     for (Edge e : transferEdges) {\n       state = e.traverse(state);\n+      if (state == null) {\n+        return null;\n+      }\n     }\n \n     int[] times = getFlexTimes(flexEdge, state);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex a4cf6ca411..9880f9fdd3 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -151,16 +159,32 @@ public abstract class FlexAccessEgressTemplate {\n     int[] times = getFlexTimes(flexEdge, state);\n \n     return new FlexAccessEgress(\n-        stop,\n-        times[0],\n-        times[1],\n-        times[2],\n-        fromStopIndex,\n-        toStopIndex, secondsFromStartOfTime,\n-        trip,\n-        state,\n-        transferEdges.isEmpty()\n+      stop,\n+      times[0],\n+      times[1],\n+      times[2],\n+      fromStopIndex,\n+      toStopIndex,\n+      secondsFromStartOfTime,\n+      trip,\n+      state,\n+      transferEdges.isEmpty()\n     );\n   }\n \n+  @Override\n+  public String toString() {\n+    return MoreObjects\n+      .toStringHelper(this)\n+      .add(\"accessEgress\", accessEgress)\n+      .add(\"trip\", trip)\n+      .add(\"fromStopIndex\", fromStopIndex)\n+      .add(\"toStopIndex\", toStopIndex)\n+      .add(\"transferStop\", transferStop)\n+      .add(\"secondsFromStartOfTime\", secondsFromStartOfTime)\n+      .add(\"serviceDate\", serviceDate)\n+      .add(\"calculator\", calculator)\n+      .add(\"flexParams\", flexParams)\n+      .toString();\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9880f9fdd3..8c66b0e4ba 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -171,20 +186,4 @@ public abstract class FlexAccessEgressTemplate {\n       transferEdges.isEmpty()\n     );\n   }\n-\n-  @Override\n-  public String toString() {\n-    return MoreObjects\n-      .toStringHelper(this)\n-      .add(\"accessEgress\", accessEgress)\n-      .add(\"trip\", trip)\n-      .add(\"fromStopIndex\", fromStopIndex)\n-      .add(\"toStopIndex\", toStopIndex)\n-      .add(\"transferStop\", transferStop)\n-      .add(\"secondsFromStartOfTime\", secondsFromStartOfTime)\n-      .add(\"serviceDate\", serviceDate)\n-      .add(\"calculator\", calculator)\n-      .add(\"flexParams\", flexParams)\n-      .toString();\n-  }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NzM3OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492647378", "body": "Could you use the constant here. The ultimate goal would be to have enums in the internal model.", "bodyText": "Could you use the constant here. The ultimate goal would be to have enums in the internal model.", "bodyHTML": "<p dir=\"auto\">Could you use the constant here. The ultimate goal would be to have enums in the internal model.</p>", "author": "t2gran", "createdAt": "2020-09-22T11:02:21Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex b8d1abee30..a029a7c4e5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -70,7 +70,9 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n       if (stopTimes[toIndex].dropOffType == 1) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n-        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate,\n+            scheduledFlexPathCalculator\n+        ));\n       }\n     }\n \n", "next_change": {"commit": "904839ba268e86576cc228199e187c632ea97b73", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex a029a7c4e5..80dc936998 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -68,7 +69,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n \n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n-      if (stopTimes[toIndex].dropOffType == 1) continue;\n+      if (stopTimes[toIndex].dropOffType == PICKDROP_NONE) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n         res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate,\n             scheduledFlexPathCalculator\n", "next_change": {"commit": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 80dc936998..861b12de89 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -71,9 +71,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n       if (stopTimes[toIndex].dropOffType == PICKDROP_NONE) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n-        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate,\n-            scheduledFlexPathCalculator\n-        ));\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, date, scheduledCalculator));\n       }\n     }\n \n", "next_change": {"commit": "a4238b9e374d6c4ac17885244ac9791b638e2b4e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 861b12de89..3fca97f2f5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -64,12 +73,12 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n     int fromIndex = getFromIndex(access);\n \n-    if (fromIndex == -1) return Stream.empty();\n+    if (fromIndex == -1) { return Stream.empty(); }\n \n     ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n \n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n-      if (stopTimes[toIndex].dropOffType == PICKDROP_NONE) continue;\n+      if (stopTimes[toIndex].dropOffType == NONE.getGtfsCode()) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n         res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, date, scheduledCalculator));\n       }\n", "next_change": {"commit": "58cbb432a5cf7be976a046ecadcf07b39a0ad343", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 3fca97f2f5..47552cb46a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -80,7 +79,16 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n       if (stopTimes[toIndex].dropOffType == NONE.getGtfsCode()) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n-        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, date, scheduledCalculator));\n+        res.add(new FlexAccessTemplate(\n+                access,\n+                this,\n+                fromIndex,\n+                toIndex,\n+                stop,\n+                date,\n+                scheduledCalculator,\n+                config\n+        ));\n       }\n     }\n \n", "next_change": {"commit": "606d32d4829990ad0f392370d8fb0e9e74301793", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 47552cb46a..509654fc83 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -97,7 +97,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   @Override\n   public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n-      NearbyStop egress, FlexServiceDate date, FlexPathCalculator calculator, FlexConfig config\n+      NearbyStop egress, FlexServiceDate date, FlexPathCalculator calculator, FlexParameters config\n   ) {\n     FlexPathCalculator scheduledCalculator = new ScheduledFlexPathCalculator(calculator, this);\n \n", "next_change": {"commit": "3ab9c9377de8245fa45207ec36504ae1ba651efe", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 509654fc83..830d2d10ce 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -97,7 +97,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   @Override\n   public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n-      NearbyStop egress, FlexServiceDate date, FlexPathCalculator calculator, FlexParameters config\n+      NearbyStop egress, FlexServiceDate date, FlexPathCalculator calculator, FlexParameters params\n   ) {\n     FlexPathCalculator scheduledCalculator = new ScheduledFlexPathCalculator(calculator, this);\n \n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 830d2d10ce..4aa0e7589a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -97,29 +109,38 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   @Override\n   public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n-      NearbyStop egress, FlexServiceDate date, FlexPathCalculator calculator, FlexParameters params\n+    NearbyStop egress,\n+    FlexServiceDate date,\n+    FlexPathCalculator calculator,\n+    FlexParameters params\n   ) {\n     FlexPathCalculator scheduledCalculator = new ScheduledFlexPathCalculator(calculator, this);\n \n     int toIndex = getToIndex(egress);\n \n-    if (toIndex == -1) { return Stream.empty(); }\n+    if (toIndex == -1) {\n+      return Stream.empty();\n+    }\n \n     ArrayList<FlexEgressTemplate> res = new ArrayList<>();\n \n-    for (int fromIndex = toIndex - 1; fromIndex >= 0; fromIndex--) {\n-      if (stopTimes[fromIndex].pickupType == NONE.getGtfsCode()) continue;\n+    for (int fromIndex = toIndex; fromIndex >= 0; fromIndex--) {\n+      if (getPickupType(fromIndex).isNotRoutable()) {\n+        continue;\n+      }\n       for (StopLocation stop : expandStops(stopTimes[fromIndex].stop)) {\n-        res.add(new FlexEgressTemplate(\n-                egress,\n-                this,\n-                fromIndex,\n-                toIndex,\n-                stop,\n-                date,\n-                scheduledCalculator,\n-                params\n-        ));\n+        res.add(\n+          new FlexEgressTemplate(\n+            egress,\n+            this,\n+            fromIndex,\n+            toIndex,\n+            stop,\n+            date,\n+            scheduledCalculator,\n+            params\n+          )\n+        );\n       }\n     }\n \n", "next_change": {"commit": "91d95559cd6a000a02b52a3aa6ed69be7d78ba56", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 4aa0e7589a..dd621aff5a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -138,7 +145,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n             stop,\n             date,\n             scheduledCalculator,\n-            params\n+            config\n           )\n         );\n       }\n", "next_change": {"commit": "5541b432be83160ee3106d73e4e6860d622f7f1a", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex dd621aff5a..cb968a80a3 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -145,7 +146,7 @@ public class ScheduledDeviatedTrip\n             stop,\n             date,\n             scheduledCalculator,\n-            config\n+            params\n           )\n         );\n       }\n", "next_change": {"commit": "4d69562c6d9da31af0a42c255e0ab48f6282dbea", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex cb968a80a3..ed37d9a7d6 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -146,7 +146,7 @@ public class ScheduledDeviatedTrip\n             stop,\n             date,\n             scheduledCalculator,\n-            params\n+            config\n           )\n         );\n       }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MDk2Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492650963", "body": "These are good candidates for UnitTests", "bodyText": "These are good candidates for UnitTests", "bodyHTML": "<p dir=\"auto\">These are good candidates for UnitTests</p>", "author": "t2gran", "createdAt": "2020-09-22T11:09:37Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n+      StopAtDistance egress, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int toIndex = getToIndex(egress);\n+\n+    if (toIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexEgressTemplate> res = new ArrayList<>();\n+\n+    for (int fromIndex = toIndex - 1; fromIndex >= 0; fromIndex--) {\n+      if (stopTimes[fromIndex].pickupType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[fromIndex].stop)) {\n+        res.add(new FlexEgressTemplate(egress, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public int earliestDepartureTime(\n+      int departureTime, int fromStopIndex, int toStopIndex, int flexTime\n+  ) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = fromStopIndex; stopTime == MISSING_VALUE && i >= 0; i--) {\n+      stopTime = stopTimes[i].departureTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime >= departureTime ? stopTime : -1;\n+  }\n+\n+  @Override\n+  public int latestArrivalTime(int arrivalTime, int fromStopIndex, int toStopIndex, int flexTime) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = toStopIndex; stopTime == MISSING_VALUE && i < stopTimes.length; i++) {\n+      stopTime = stopTimes[i].arrivalTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime <= arrivalTime ? stopTime : -1;\n+  }\n+", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "63a118283c72455f8f6fd0f5b5ce65282c840624", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex b8d1abee30..25a11b99ff 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -120,22 +148,42 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n   }\n \n   @Override\n-  public Collection<StopLocation> getStops() {\n+  public Set<StopLocation> getStops() {\n     return Arrays\n         .stream(stopTimes)\n         .map(scheduledDeviatedStopTime -> scheduledDeviatedStopTime.stop)\n         .collect(Collectors.toSet());\n   }\n \n+  @Override\n+  public BookingInfo getDropOffBookingInfo(int i) {\n+    return dropOffBookingInfos[i];\n+  }\n+\n+  @Override\n+  public BookingInfo getPickupBookingInfo(int i) {\n+    return pickupBookingInfos[i];\n+  }\n+\n+  @Override\n+  public boolean isBoardingPossible(NearbyStop stop) {\n+    return getFromIndex(stop) != -1;\n+  }\n+\n+  @Override\n+  public boolean isAlightingPossible(NearbyStop stop) {\n+    return getToIndex(stop) != -1;\n+  }\n+\n   private Collection<StopLocation> expandStops(StopLocation stop) {\n     return stop instanceof FlexLocationGroup\n         ? ((FlexLocationGroup) stop).getLocations()\n         : Collections.singleton(stop);\n   }\n \n-  private int getFromIndex(StopAtDistance accessEgress) {\n+  private int getFromIndex(NearbyStop accessEgress) {\n     for (int i = 0; i < stopTimes.length; i++) {\n-      if (stopTimes[i].pickupType == 1) continue; // No pickup allowed here\n+      if (stopTimes[i].pickupType == NONE.getGtfsCode()) continue; // No pickup allowed here\n       StopLocation stop = stopTimes[i].stop;\n       if (stop instanceof FlexLocationGroup) {\n         if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n", "next_change": {"commit": "a6fbfc88a796a662585756fd4349d56e15e0b878", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 25a11b99ff..ec41116420 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -183,7 +194,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   private int getFromIndex(NearbyStop accessEgress) {\n     for (int i = 0; i < stopTimes.length; i++) {\n-      if (stopTimes[i].pickupType == NONE.getGtfsCode()) continue; // No pickup allowed here\n+      if (!stopTimes[i].pickupType.isRoutable()) continue; // No pickup allowed here\n       StopLocation stop = stopTimes[i].stop;\n       if (stop instanceof FlexLocationGroup) {\n         if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n", "next_change": {"commit": "9e2dd7e7d68da0263b5485e00edddb3e0f08bf54", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex ec41116420..766c7b242f 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -194,7 +202,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   private int getFromIndex(NearbyStop accessEgress) {\n     for (int i = 0; i < stopTimes.length; i++) {\n-      if (!stopTimes[i].pickupType.isRoutable()) continue; // No pickup allowed here\n+      if (getPickupType(i).isNotRoutable()) continue;\n       StopLocation stop = stopTimes[i].stop;\n       if (stop instanceof FlexLocationGroup) {\n         if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n", "next_change": {"commit": "8dda17eabdfa97cf27cc9ea7db36c5611529d225", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 766c7b242f..735199d9b5 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -202,7 +202,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   private int getFromIndex(NearbyStop accessEgress) {\n     for (int i = 0; i < stopTimes.length; i++) {\n-      if (getPickupType(i).isNotRoutable()) continue;\n+      if (getPickupType(i).isNotRoutable()) { continue; }\n       StopLocation stop = stopTimes[i].stop;\n       if (stop instanceof FlexLocationGroup) {\n         if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 735199d9b5..4aa0e7589a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -196,20 +218,21 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n \n   private Collection<StopLocation> expandStops(StopLocation stop) {\n     return stop instanceof FlexLocationGroup\n-        ? ((FlexLocationGroup) stop).getLocations()\n-        : Collections.singleton(stop);\n+      ? ((FlexLocationGroup) stop).getLocations()\n+      : Collections.singleton(stop);\n   }\n \n   private int getFromIndex(NearbyStop accessEgress) {\n     for (int i = 0; i < stopTimes.length; i++) {\n-      if (getPickupType(i).isNotRoutable()) { continue; }\n+      if (getPickupType(i).isNotRoutable()) {\n+        continue;\n+      }\n       StopLocation stop = stopTimes[i].stop;\n       if (stop instanceof FlexLocationGroup) {\n         if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n           return i;\n         }\n-      }\n-      else {\n+      } else {\n         if (stop.equals(accessEgress.stop)) {\n           return i;\n         }\n", "next_change": {"commit": "93ecd799dc22301f9582378eff59f101d32c3482", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 4aa0e7589a..ee60130e99 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -228,8 +251,8 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n         continue;\n       }\n       StopLocation stop = stopTimes[i].stop;\n-      if (stop instanceof FlexLocationGroup) {\n-        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+      if (stop instanceof GroupStop groupStop) {\n+        if (groupStop.getLocations().contains(accessEgress.stop)) {\n           return i;\n         }\n       } else {\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MTM4OQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492651389", "body": "UnitTests", "bodyText": "UnitTests", "bodyHTML": "<p dir=\"auto\">UnitTests</p>", "author": "t2gran", "createdAt": "2020-09-22T11:10:26Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -51,7 +127,49 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n         .collect(Collectors.toSet());\n   }\n \n-  private static class ScheduledDeviatedStopTime {\n+  private Collection<StopLocation> expandStops(StopLocation stop) {\n+    return stop instanceof FlexLocationGroup\n+        ? ((FlexLocationGroup) stop).getLocations()\n+        : Collections.singleton(stop);\n+  }\n+\n+  private int getFromIndex(StopAtDistance accessEgress) {\n+    for (int i = 0; i < stopTimes.length; i++) {\n+      if (stopTimes[i].pickupType == 1) continue; // No pickup allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private int getToIndex(StopAtDistance accessEgress) {\n+    for (int i = stopTimes.length - 1; i >= 0; i--) {\n+      if (stopTimes[i].dropOffType == 1) continue; // No drop off allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex b8d1abee30..4aa0e7589a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -151,16 +241,17 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     return -1;\n   }\n \n-  private int getToIndex(StopAtDistance accessEgress) {\n+  private int getToIndex(NearbyStop accessEgress) {\n     for (int i = stopTimes.length - 1; i >= 0; i--) {\n-      if (stopTimes[i].dropOffType == 1) continue; // No drop off allowed here\n+      if (getDropOffType(i).isNotRoutable()) {\n+        continue;\n+      }\n       StopLocation stop = stopTimes[i].stop;\n       if (stop instanceof FlexLocationGroup) {\n         if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n           return i;\n         }\n-      }\n-      else {\n+      } else {\n         if (stop.equals(accessEgress.stop)) {\n           return i;\n         }\n", "next_change": {"commit": "93ecd799dc22301f9582378eff59f101d32c3482", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 4aa0e7589a..ee60130e99 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -247,8 +270,8 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n         continue;\n       }\n       StopLocation stop = stopTimes[i].stop;\n-      if (stop instanceof FlexLocationGroup) {\n-        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+      if (stop instanceof GroupStop groupStop) {\n+        if (groupStop.getLocations().contains(accessEgress.stop)) {\n           return i;\n         }\n       } else {\n", "next_change": null}]}}, {"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex b8d1abee30..4aa0e7589a 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -170,16 +261,26 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n   }\n \n   private static class ScheduledDeviatedStopTime implements Serializable {\n+\n     private final StopLocation stop;\n     private final int departureTime;\n     private final int arrivalTime;\n-    private final int pickupType;\n-    private final int dropOffType;\n+    private final PickDrop pickupType;\n+    private final PickDrop dropOffType;\n \n     private ScheduledDeviatedStopTime(StopTime st) {\n       this.stop = st.getStop();\n-      this.arrivalTime = st.getArrivalTime();\n-      this.departureTime = st.getDepartureTime();\n+\n+      // Store the time the user is guaranteed to arrive at latest\n+      this.arrivalTime =\n+        st.getFlexWindowEnd() != MISSING_VALUE ? st.getFlexWindowEnd() : st.getArrivalTime();\n+      // Store the time the user needs to be ready for pickup\n+      this.departureTime =\n+        st.getFlexWindowStart() != MISSING_VALUE ? st.getFlexWindowStart() : st.getDepartureTime();\n+\n+      // TODO: Store the window for a stop, and allow the user to have an \"unguaranteed\"\n+      // pickup/dropoff between the start and end of the window\n+\n       this.pickupType = st.getPickupType();\n       this.dropOffType = st.getDropOffType();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1NDM2OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492654368", "body": "Rename `flexContinuousPickup`", "bodyText": "Rename flexContinuousPickup", "bodyHTML": "<p dir=\"auto\">Rename <code>flexContinuousPickup</code></p>", "author": "t2gran", "createdAt": "2020-09-22T11:16:59Z", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;\n \n-    private int continuousPickup;\n+    // Disabled by default\n+    private int continuousPickup = MISSING_VALUE;\n \n-    private int continuousDropOff;\n+    // Disabled by default\n+    private int continuousDropOff = MISSING_VALUE;\n ", "originalCommit": "681acd20acf9c56073616856d09c49f43668be45", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "199fa2e32cd31bcd0dbf540aed2bccde274dc913", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/StopTime.java b/src/main/java/org/opentripplanner/model/StopTime.java\nindex 81cdacce21..dffa966224 100644\n--- a/src/main/java/org/opentripplanner/model/StopTime.java\n+++ b/src/main/java/org/opentripplanner/model/StopTime.java\n", "chunk": "@@ -47,10 +47,10 @@ public final class StopTime implements Comparable<StopTime> {\n     private int maxDepartureTime = MISSING_VALUE;\n \n     // Disabled by default\n-    private int continuousPickup = MISSING_VALUE;\n+    private int flexContinuousPickup = MISSING_VALUE;\n \n     // Disabled by default\n-    private int continuousDropOff = MISSING_VALUE;\n+    private int flexContinuousDropOff = MISSING_VALUE;\n \n     public StopTime() { }\n \n", "next_change": {"commit": "90483d3d9f3d74e66939bc35fb28e3bbf8aee4aa", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/StopTime.java b/src/main/java/org/opentripplanner/model/StopTime.java\nindex dffa966224..748652e05d 100644\n--- a/src/main/java/org/opentripplanner/model/StopTime.java\n+++ b/src/main/java/org/opentripplanner/model/StopTime.java\n", "chunk": "@@ -52,6 +52,8 @@ public final class StopTime implements Comparable<StopTime> {\n     // Disabled by default\n     private int flexContinuousDropOff = MISSING_VALUE;\n \n+    private BookingInfo bookingInfo;\n+\n     public StopTime() { }\n \n     public StopTime(StopTime st) {\n", "next_change": {"commit": "93f83195d9427ed8c8ac0dcd896e5078b6b31f4a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/StopTime.java b/src/main/java/org/opentripplanner/model/StopTime.java\nindex 748652e05d..c03d54ea5e 100644\n--- a/src/main/java/org/opentripplanner/model/StopTime.java\n+++ b/src/main/java/org/opentripplanner/model/StopTime.java\n", "chunk": "@@ -52,7 +51,9 @@ public final class StopTime implements Comparable<StopTime> {\n     // Disabled by default\n     private int flexContinuousDropOff = MISSING_VALUE;\n \n-    private BookingInfo bookingInfo;\n+    private BookingInfo dropOffBookingInfo;\n+\n+    private BookingInfo pickupBookingInfo;\n \n     public StopTime() { }\n \n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/StopTime.java b/src/main/java/org/opentripplanner/model/StopTime.java\nindex c03d54ea5e..f6f5ef83bb 100644\n--- a/src/main/java/org/opentripplanner/model/StopTime.java\n+++ b/src/main/java/org/opentripplanner/model/StopTime.java\n", "chunk": "@@ -14,276 +13,310 @@ import org.opentripplanner.util.time.TimeUtils;\n  */\n public final class StopTime implements Comparable<StopTime> {\n \n-    public static final int MISSING_VALUE = -999;\n-\n-    private Trip trip;\n-\n-    private StopLocation stop;\n-\n-    private int arrivalTime = MISSING_VALUE;\n-\n-    private int departureTime = MISSING_VALUE;\n+  public static final int MISSING_VALUE = -999;\n \n-    private int timepoint = MISSING_VALUE;\n+  private Trip trip;\n \n-    private int stopSequence;\n+  private StopLocation stop;\n \n-    private String stopHeadsign;\n+  private int arrivalTime = MISSING_VALUE;\n \n-    private String routeShortName;\n+  private int departureTime = MISSING_VALUE;\n \n-    private int pickupType;\n+  private int timepoint = MISSING_VALUE;\n \n-    private int dropOffType;\n+  private int stopSequence;\n \n-    private double shapeDistTraveled = MISSING_VALUE;\n+  private String stopHeadsign;\n \n-    /** This is a Conveyal extension to the GTFS spec to support Seattle on/off peak fares. */\n-    private String farePeriodId;\n+  private List<String> headsignVias;\n \n-    private int flexWindowStart = MISSING_VALUE;\n+  private String routeShortName;\n \n-    private int flexWindowEnd = MISSING_VALUE;\n+  private PickDrop pickupType = PickDrop.SCHEDULED;\n \n-    // Disabled by default\n-    private int flexContinuousPickup = MISSING_VALUE;\n+  private PickDrop dropOffType = PickDrop.SCHEDULED;\n \n-    // Disabled by default\n-    private int flexContinuousDropOff = MISSING_VALUE;\n+  private double shapeDistTraveled = MISSING_VALUE;\n \n-    private BookingInfo dropOffBookingInfo;\n+  /** This is a Conveyal extension to the GTFS spec to support Seattle on/off peak fares. */\n+  private String farePeriodId;\n \n-    private BookingInfo pickupBookingInfo;\n+  private int flexWindowStart = MISSING_VALUE;\n \n-    public StopTime() { }\n+  private int flexWindowEnd = MISSING_VALUE;\n \n-    public StopTime(StopTime st) {\n-        this.trip = st.trip;\n-        this.stop = st.stop;\n-        this.arrivalTime = st.arrivalTime;\n-        this.departureTime = st.departureTime;\n-        this.timepoint = st.timepoint;\n-        this.stopSequence = st.stopSequence;\n-        this.stopHeadsign = st.stopHeadsign;\n-        this.routeShortName = st.routeShortName;\n-        this.pickupType = st.pickupType;\n-        this.dropOffType = st.dropOffType;\n-        this.shapeDistTraveled = st.shapeDistTraveled;\n-        this.farePeriodId = st.farePeriodId;\n-        this.flexWindowStart = st.flexWindowStart;\n-        this.flexWindowEnd = st.flexWindowEnd;\n-        this.flexContinuousPickup = st.flexContinuousPickup;\n-        this.flexContinuousDropOff = st.flexContinuousDropOff;\n-        this.dropOffBookingInfo = st.dropOffBookingInfo;\n-        this.pickupBookingInfo = st.pickupBookingInfo;\n-    }\n+  // Disabled by default\n+  private int flexContinuousPickup = MISSING_VALUE;\n \n-    /**\n-     * The id is used to navigate/link StopTime to other entities (Map from StopTime.id -> Entity.id).\n-     * There is no need to navigate in the opposite direction. The StopTime id is NOT stored in a\n-     * StopTime field.\n-     * <p/>\n-     * New ids should only be created when a travel search result is mapped to an itinerary, so even\n-     * if creating new objects are expensive, the few extra objects created during the mapping process\n-     * is ok.\n-     */\n-    public StopTimeKey getId() {\n-        return new StopTimeKey(trip.getId(), stopSequence);\n-    }\n+  // Disabled by default\n+  private int flexContinuousDropOff = MISSING_VALUE;\n \n-    public Trip getTrip() {\n-        return trip;\n-    }\n+  private BookingInfo dropOffBookingInfo;\n \n-    public void setTrip(Trip trip) {\n-        this.trip = trip;\n-    }\n+  private BookingInfo pickupBookingInfo;\n \n-    public int getStopSequence() {\n-        return stopSequence;\n-    }\n+  public StopTime() {}\n \n-    public void setStopSequence(int stopSequence) {\n-        this.stopSequence = stopSequence;\n-    }\n+  public StopTime(StopTime st) {\n+    this.trip = st.trip;\n+    this.stop = st.stop;\n+    this.arrivalTime = st.arrivalTime;\n+    this.departureTime = st.departureTime;\n+    this.timepoint = st.timepoint;\n+    this.stopSequence = st.stopSequence;\n+    this.stopHeadsign = st.stopHeadsign;\n+    this.routeShortName = st.routeShortName;\n+    this.pickupType = st.pickupType;\n+    this.dropOffType = st.dropOffType;\n+    this.shapeDistTraveled = st.shapeDistTraveled;\n+    this.farePeriodId = st.farePeriodId;\n+    this.flexWindowStart = st.flexWindowStart;\n+    this.flexWindowEnd = st.flexWindowEnd;\n+    this.flexContinuousPickup = st.flexContinuousPickup;\n+    this.flexContinuousDropOff = st.flexContinuousDropOff;\n+    this.dropOffBookingInfo = st.dropOffBookingInfo;\n+    this.pickupBookingInfo = st.pickupBookingInfo;\n+    this.headsignVias = st.headsignVias;\n+  }\n \n-    public StopLocation getStop() {\n-        return stop;\n-    }\n+  /**\n+   * The id is used to navigate/link StopTime to other entities (Map from StopTime.id -> Entity.id).\n+   * There is no need to navigate in the opposite direction. The StopTime id is NOT stored in a\n+   * StopTime field.\n+   * <p/>\n+   * New ids should only be created when a travel search result is mapped to an itinerary, so even\n+   * if creating new objects are expensive, the few extra objects created during the mapping process\n+   * is ok.\n+   */\n+  public StopTimeKey getId() {\n+    return new StopTimeKey(trip.getId(), stopSequence);\n+  }\n \n-    public void setStop(StopLocation stop) {\n-        this.stop = stop;\n-    }\n+  public Trip getTrip() {\n+    return trip;\n+  }\n \n-    public boolean isArrivalTimeSet() {\n-        return arrivalTime != MISSING_VALUE;\n-    }\n-\n-    /**\n-     * @return arrival time, in seconds since midnight\n-     */\n-    public int getArrivalTime() {\n-        return arrivalTime;\n-    }\n-\n-    public void setArrivalTime(int arrivalTime) {\n-        this.arrivalTime = arrivalTime;\n-    }\n-\n-    public void clearArrivalTime() {\n-        this.arrivalTime = MISSING_VALUE;\n-    }\n-\n-    public boolean isDepartureTimeSet() {\n-        return departureTime != MISSING_VALUE;\n-    }\n-\n-    /**\n-     * @return departure time, in seconds since midnight\n-     */\n-    public int getDepartureTime() {\n-        return departureTime;\n-    }\n-\n-    public void setDepartureTime(int departureTime) {\n-        this.departureTime = departureTime;\n-    }\n-\n-    public void clearDepartureTime() {\n-        this.departureTime = MISSING_VALUE;\n-    }\n-\n-    public boolean isTimepointSet() {\n-        return timepoint != MISSING_VALUE;\n-    }\n-\n-    /**\n-     * @return 1 if the stop-time is a timepoint location\n-     */\n-    public int getTimepoint() {\n-        return timepoint;\n-    }\n-\n-    public void setTimepoint(int timepoint) {\n-        this.timepoint = timepoint;\n-    }\n-\n-    public void clearTimepoint() {\n-        this.timepoint = MISSING_VALUE;\n-    }\n-\n-    public String getStopHeadsign() {\n-        return stopHeadsign;\n-    }\n-\n-    public void setStopHeadsign(String headSign) {\n-        this.stopHeadsign = headSign;\n-    }\n-\n-    public String getRouteShortName() {\n-        return routeShortName;\n-    }\n-\n-    public void setRouteShortName(String routeShortName) {\n-        this.routeShortName = routeShortName;\n-    }\n-\n-    public int getPickupType() {\n-        return pickupType;\n-    }\n-\n-    public void setPickupType(int pickupType) {\n-        this.pickupType = pickupType;\n-    }\n-\n-    public int getDropOffType() {\n-        return dropOffType;\n-    }\n-\n-    public void setDropOffType(int dropOffType) {\n-        this.dropOffType = dropOffType;\n-    }\n-\n-    public boolean isShapeDistTraveledSet() {\n-        return shapeDistTraveled != MISSING_VALUE;\n-    }\n-\n-    public double getShapeDistTraveled() {\n-        return shapeDistTraveled;\n-    }\n-\n-    public void setShapeDistTraveled(double shapeDistTraveled) {\n-        this.shapeDistTraveled = shapeDistTraveled;\n-    }\n-\n-    public void clearShapeDistTraveled() {\n-        this.shapeDistTraveled = MISSING_VALUE;\n-    }\n-\n-    public String getFarePeriodId() {\n-        return farePeriodId;\n-    }\n-\n-    public void setFarePeriodId(String farePeriodId) {\n-        this.farePeriodId = farePeriodId;\n-    }\n-\n-    public void setFlexWindowStart(int flexWindowStart) {\n-        this.flexWindowStart = flexWindowStart;\n-    }\n-\n-    public int getFlexWindowStart() {\n-        return flexWindowStart;\n-    }\n-\n-    public void setFlexWindowEnd(int flexWindowEnd) {\n-        this.flexWindowEnd = flexWindowEnd;\n-    }\n-\n-    public int getFlexWindowEnd() {\n-        return flexWindowEnd;\n-    }\n-\n-    public int getFlexContinuousPickup() {\n-        return flexContinuousPickup == MISSING_VALUE ? 1 : flexContinuousPickup;\n-    }\n-\n-    public void setFlexContinuousPickup(int flexContinuousPickup) {\n-        this.flexContinuousPickup = flexContinuousPickup;\n-    }\n-\n-    public int getFlexContinuousDropOff() {\n-        return flexContinuousDropOff == MISSING_VALUE ? 1 : flexContinuousDropOff;\n-    }\n-\n-    public void setFlexContinuousDropOff(int flexContinuousDropOff) {\n-        this.flexContinuousDropOff = flexContinuousDropOff;\n-    }\n-\n-    public BookingInfo getDropOffBookingInfo() {\n-        return dropOffBookingInfo;\n-    }\n+  public void setTrip(Trip trip) {\n+    this.trip = trip;\n+  }\n \n-    public void setDropOffBookingInfo(BookingInfo dropOffBookingInfo) {\n-        this.dropOffBookingInfo = dropOffBookingInfo;\n-    }\n+  public int getStopSequence() {\n+    return stopSequence;\n+  }\n \n-    public BookingInfo getPickupBookingInfo() {\n-        return pickupBookingInfo;\n-    }\n+  public void setStopSequence(int stopSequence) {\n+    this.stopSequence = stopSequence;\n+  }\n \n-    public void setPickupBookingInfo(BookingInfo pickupBookingInfo) {\n-        this.pickupBookingInfo = pickupBookingInfo;\n-    }\n+  public StopLocation getStop() {\n+    return stop;\n+  }\n \n-    public int compareTo(StopTime o) {\n-        return this.getStopSequence() - o.getStopSequence();\n-    }\n+  public void setStop(StopLocation stop) {\n+    this.stop = stop;\n+  }\n \n-    @Override\n-    public String toString() {\n-      return \"StopTime(seq=\" + getStopSequence() + \" stop=\" + getStop().getId() + \" trip=\"\n-                + getTrip().getId() + \" times=\" + TimeUtils.timeToStrLong(getArrivalTime())\n-                + \"-\" + TimeUtils.timeToStrLong(getDepartureTime()) + \")\";\n-    }\n+  public boolean isArrivalTimeSet() {\n+    return arrivalTime != MISSING_VALUE;\n+  }\n+\n+  /**\n+   * @return arrival time, in seconds since midnight\n+   */\n+  public int getArrivalTime() {\n+    return arrivalTime;\n+  }\n+\n+  public void setArrivalTime(int arrivalTime) {\n+    this.arrivalTime = arrivalTime;\n+  }\n+\n+  public void clearArrivalTime() {\n+    this.arrivalTime = MISSING_VALUE;\n+  }\n+\n+  public boolean isDepartureTimeSet() {\n+    return departureTime != MISSING_VALUE;\n+  }\n+\n+  /**\n+   * @return departure time, in seconds since midnight\n+   */\n+  public int getDepartureTime() {\n+    return departureTime;\n+  }\n+\n+  public void setDepartureTime(int departureTime) {\n+    this.departureTime = departureTime;\n+  }\n+\n+  public void clearDepartureTime() {\n+    this.departureTime = MISSING_VALUE;\n+  }\n+\n+  public boolean isTimepointSet() {\n+    return timepoint != MISSING_VALUE;\n+  }\n+\n+  /**\n+   * @return 1 if the stop-time is a timepoint location\n+   */\n+  public int getTimepoint() {\n+    return timepoint;\n+  }\n+\n+  public void setTimepoint(int timepoint) {\n+    this.timepoint = timepoint;\n+  }\n+\n+  public void clearTimepoint() {\n+    this.timepoint = MISSING_VALUE;\n+  }\n+\n+  public String getStopHeadsign() {\n+    return stopHeadsign;\n+  }\n+\n+  public void setStopHeadsign(String headSign) {\n+    this.stopHeadsign = headSign;\n+  }\n+\n+  public String getRouteShortName() {\n+    return routeShortName;\n+  }\n+\n+  public void setRouteShortName(String routeShortName) {\n+    this.routeShortName = routeShortName;\n+  }\n+\n+  public PickDrop getPickupType() {\n+    return pickupType;\n+  }\n+\n+  public void setPickupType(PickDrop pickupType) {\n+    this.pickupType = pickupType;\n+  }\n+\n+  public PickDrop getDropOffType() {\n+    return dropOffType;\n+  }\n+\n+  public void setDropOffType(PickDrop dropOffType) {\n+    this.dropOffType = dropOffType;\n+  }\n+\n+  public boolean isShapeDistTraveledSet() {\n+    return shapeDistTraveled != MISSING_VALUE;\n+  }\n+\n+  public double getShapeDistTraveled() {\n+    return shapeDistTraveled;\n+  }\n+\n+  public void setShapeDistTraveled(double shapeDistTraveled) {\n+    this.shapeDistTraveled = shapeDistTraveled;\n+  }\n+\n+  public void clearShapeDistTraveled() {\n+    this.shapeDistTraveled = MISSING_VALUE;\n+  }\n+\n+  public String getFarePeriodId() {\n+    return farePeriodId;\n+  }\n+\n+  public void setFarePeriodId(String farePeriodId) {\n+    this.farePeriodId = farePeriodId;\n+  }\n+\n+  public void setFlexWindowStart(int flexWindowStart) {\n+    this.flexWindowStart = flexWindowStart;\n+  }\n+\n+  public int getFlexWindowStart() {\n+    return flexWindowStart;\n+  }\n+\n+  public void setFlexWindowEnd(int flexWindowEnd) {\n+    this.flexWindowEnd = flexWindowEnd;\n+  }\n+\n+  public int getFlexWindowEnd() {\n+    return flexWindowEnd;\n+  }\n+\n+  public int getFlexContinuousPickup() {\n+    return flexContinuousPickup == MISSING_VALUE ? 1 : flexContinuousPickup;\n+  }\n+\n+  public void setFlexContinuousPickup(int flexContinuousPickup) {\n+    this.flexContinuousPickup = flexContinuousPickup;\n+  }\n+\n+  public int getFlexContinuousDropOff() {\n+    return flexContinuousDropOff == MISSING_VALUE ? 1 : flexContinuousDropOff;\n+  }\n+\n+  public void setFlexContinuousDropOff(int flexContinuousDropOff) {\n+    this.flexContinuousDropOff = flexContinuousDropOff;\n+  }\n+\n+  public BookingInfo getDropOffBookingInfo() {\n+    return dropOffBookingInfo;\n+  }\n+\n+  public void setDropOffBookingInfo(BookingInfo dropOffBookingInfo) {\n+    this.dropOffBookingInfo = dropOffBookingInfo;\n+  }\n+\n+  public BookingInfo getPickupBookingInfo() {\n+    return pickupBookingInfo;\n+  }\n+\n+  public void setPickupBookingInfo(BookingInfo pickupBookingInfo) {\n+    this.pickupBookingInfo = pickupBookingInfo;\n+  }\n+\n+  public List<String> getHeadsignVias() {\n+    return headsignVias;\n+  }\n+\n+  public void setHeadsignVias(List<String> headsignVias) {\n+    this.headsignVias = headsignVias;\n+  }\n+\n+  public int compareTo(StopTime o) {\n+    return this.getStopSequence() - o.getStopSequence();\n+  }\n+\n+  public void cancel() {\n+    pickupType = PickDrop.CANCELLED;\n+    dropOffType = PickDrop.CANCELLED;\n+  }\n+\n+  public void cancelDropOff() {\n+    dropOffType = PickDrop.CANCELLED;\n+  }\n+\n+  public void cancelPickup() {\n+    pickupType = PickDrop.CANCELLED;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return (\n+      \"StopTime(seq=\" +\n+      getStopSequence() +\n+      \" stop=\" +\n+      getStop().getId() +\n+      \" trip=\" +\n+      getTrip().getId() +\n+      \" times=\" +\n+      TimeUtils.timeToStrLong(getArrivalTime()) +\n+      \"-\" +\n+      TimeUtils.timeToStrLong(getDepartureTime()) +\n+      \")\"\n+    );\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}, {"oid": "1e268b26b76f66baf7347beed502c68a9353bb53", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1e268b26b76f66baf7347beed502c68a9353bb53", "message": "Rename StopAtDistance NearbyStop\n\nAlso move mapping code to AccessEgressMapper", "committedDate": "2020-09-24T06:53:15Z", "type": "commit"}, {"oid": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "message": "improve DistanceCalculator\n\n- rename from and to indext to stop index\n- rename DistanceAndDuration to FlexPath\n- rename getDuration to calculateFlexPath\n- rename DistanceCalculator FlexPathCalculator\n- fix potential NPE in StreetDistanceCalculator", "committedDate": "2020-09-24T07:00:22Z", "type": "commit"}, {"oid": "42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "message": "Fix comment in SimpleStreetSplitter", "committedDate": "2020-09-24T07:05:54Z", "type": "commit"}, {"oid": "71f72ce0442a141c189e89fb9a9f616584db566e", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/71f72ce0442a141c189e89fb9a9f616584db566e", "message": "Decouple FlexAccessEgress from Raptor", "committedDate": "2020-09-24T07:43:07Z", "type": "commit"}, {"oid": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "message": "Update FlexRouter based on comments", "committedDate": "2020-09-24T08:22:11Z", "type": "commit"}, {"oid": "904839ba268e86576cc228199e187c632ea97b73", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/904839ba268e86576cc228199e187c632ea97b73", "message": "Use constant for pickup/dropoff types", "committedDate": "2020-09-24T08:24:55Z", "type": "commit"}, {"oid": "199fa2e32cd31bcd0dbf540aed2bccde274dc913", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/199fa2e32cd31bcd0dbf540aed2bccde274dc913", "message": "Prefix continuous stop flags with flex", "committedDate": "2020-09-24T08:26:15Z", "type": "commit"}, {"oid": "3476ac74e362cab2b3048643555f0a50d70369ab", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/3476ac74e362cab2b3048643555f0a50d70369ab", "message": "Move FlexTripEdge to separate package", "committedDate": "2020-09-24T08:28:02Z", "type": "commit"}, {"oid": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "message": "Rename FlexServicesOnDate to FlexServiceDate and use it deeper", "committedDate": "2020-09-24T08:42:17Z", "type": "commit"}, {"oid": "dad87843e87453b99b29750c65a25b3a3f865d58", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dad87843e87453b99b29750c65a25b3a3f865d58", "message": "Move private functions down", "committedDate": "2020-09-24T08:43:15Z", "type": "commit"}, {"oid": "a90d7ed6ba1607139510e269292605b9327acfd2", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a90d7ed6ba1607139510e269292605b9327acfd2", "message": "Do not pass in the whole request to FlexRouter", "committedDate": "2020-09-24T09:01:11Z", "type": "commit"}, {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2d309285ec07c8e3cfde7affcfbd6470733458d6", "message": "Merge remote-tracking branch 'origin/dev-2.x' into flex-upstream-routing", "committedDate": "2020-09-24T09:02:30Z", "type": "commit"}, {"oid": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/69b08774efc0cdb575e7cc72163ef1a56fe00167", "message": "Adapt changes from discussion", "committedDate": "2020-09-25T08:10:38Z", "type": "commit"}, {"oid": "558e06d0941eb87cc56301cd5b8bb093690638ae", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/558e06d0941eb87cc56301cd5b8bb093690638ae", "message": "Add initial docs", "committedDate": "2020-09-25T08:42:34Z", "type": "commit"}, {"oid": "4fe831096cf1f973a18ef69ed88f442a893c74fc", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4fe831096cf1f973a18ef69ed88f442a893c74fc", "message": "Add javadoc", "committedDate": "2020-09-25T08:50:53Z", "type": "commit"}, {"oid": "76163e1ed4c3ded3d32027798a8e7bdbd45d6b0a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/76163e1ed4c3ded3d32027798a8e7bdbd45d6b0a", "message": "Add Entur as additional contact", "committedDate": "2020-09-25T09:05:03Z", "type": "commit"}, {"oid": "aad1781643f2cec742877ae1f84f9852018680e7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/aad1781643f2cec742877ae1f84f9852018680e7", "message": "Fix legal name", "committedDate": "2020-09-25T09:12:36Z", "type": "commit"}, {"oid": "e9b59cc461641341397d35b60e4f061eb9382452", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e9b59cc461641341397d35b60e4f061eb9382452", "message": "Merge remote-tracking branch 'origin/dev-2.x' into flex-upstream-routing", "committedDate": "2020-09-25T09:12:52Z", "type": "commit"}]}