{"pr_number": 3890, "pr_title": "suggest list type columns for annotations with multiple values (PLFM-6013)", "pr_author": "zimingd", "pr_createdAt": "2020-01-14T01:36:56Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890", "timeline": [{"oid": "11197923869863d23e78af910d4f428a18515367", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/11197923869863d23e78af910d4f428a18515367", "message": "suggest list type columns for annotations with multiple values", "committedDate": "2020-01-14T01:26:27Z", "type": "commit"}, {"oid": "97f5b51cce59926e85b55c67151f180e0ba9f27c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/97f5b51cce59926e85b55c67151f180e0ba9f27c", "message": "regenerated hashCode(), equals() and toString() for ColumnAggregation", "committedDate": "2020-01-14T01:39:16Z", "type": "commit"}, {"oid": "e259094809a45fa367568fe95142fa5c27e69d8b", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e259094809a45fa367568fe95142fa5c27e69d8b", "message": "fix tests", "committedDate": "2020-01-14T02:06:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0NjUwMw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890#discussion_r367646503", "body": "optional might work better than illegal arg for getListType();", "bodyText": "optional might work better than illegal arg for getListType();", "bodyHTML": "<p dir=\"auto\">optional might work better than illegal arg for getListType();</p>", "author": "john-hill", "createdAt": "2020-01-16T20:59:01Z", "path": "lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java", "diffHunk": "@@ -885,9 +886,19 @@ public ColumnAggregation mapRow(ResultSet rs, int rowNum)\n \t\t\t\tColumnModel model = new ColumnModel();\r\n \t\t\t\tmodel.setName(aggregation.getColumnName());\r\n \t\t\t\tColumnType type = AnnotationType.valueOf(typeString).getColumnType();\r\n+\r\n+\t\t\t\t//check if a LIST columnType needs to be used\r\n+\t\t\t\tif(aggregation.getListSize() > 1){\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\ttype = ColumnTypeListMappings.forNonListType(type).getListType();\r", "originalCommit": "e259094809a45fa367568fe95142fa5c27e69d8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY2NjgzNw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890#discussion_r367666837", "bodyText": "Other parts of code is relying on it throwing an exception being thrown if unexpected usage of  conversion to list type occurs", "author": "zimingd", "createdAt": "2020-01-16T21:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0NjUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "8b473eeb0e94afc5192352e429fb122dee322fac", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex bedd2f7871..26e941a4e4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -886,19 +887,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\t\tColumnModel model = new ColumnModel();\n \t\t\t\tmodel.setName(aggregation.getColumnName());\n \t\t\t\tColumnType type = AnnotationType.valueOf(typeString).getColumnType();\n-\n-\t\t\t\t//check if a LIST columnType needs to be used\n-\t\t\t\tif(aggregation.getListSize() > 1){\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\ttype = ColumnTypeListMappings.forNonListType(type).getListType();\n-\t\t\t\t\t} catch (IllegalArgumentException e){\n-\t\t\t\t\t\t//do nothing because a list type mapping does not exist\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n \t\t\t\tmodel.setColumnType(type);\n-\t\t\t\tif(ColumnType.STRING == type || ColumnType.STRING_LIST==type) {\n-\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxStringElementSize());\n+\t\t\t\tif(ColumnType.STRING == type) {\n+\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxSize());\n \t\t\t\t}\n \t\t\t\tresults.add(model);\n \t\t\t}\n", "next_change": {"commit": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 26e941a4e4..a493eddbba 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -887,9 +886,19 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\t\tColumnModel model = new ColumnModel();\n \t\t\t\tmodel.setName(aggregation.getColumnName());\n \t\t\t\tColumnType type = AnnotationType.valueOf(typeString).getColumnType();\n+\n+\t\t\t\t//check if a LIST columnType needs to be used\n+\t\t\t\tif(aggregation.getMaxListSize() > 1){\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\ttype = ColumnTypeListMappings.listType(type);\n+\t\t\t\t\t} catch (IllegalArgumentException e){\n+\t\t\t\t\t\t//do nothing because a list type mapping does not exist\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\tmodel.setColumnType(type);\n-\t\t\t\tif(ColumnType.STRING == type) {\n-\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxSize());\n+\t\t\t\tif(ColumnType.STRING == type || ColumnType.STRING_LIST==type) {\n+\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxStringElementSize());\n \t\t\t\t}\n \t\t\t\tresults.add(model);\n \t\t\t}\n", "next_change": {"commit": "3ac68ccba8dab267caf2a26d41ffe1a8b4d9518a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a493eddbba..b5b51355b8 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -907,49 +962,43 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n-\t\tNamedParameterJdbcTemplate namedTemplate = new NamedParameterJdbcTemplate(this.template);\n-\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n-\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n-\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\t\tresults.put(parentId, crc);\n-\t\t\t}\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n+\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n+\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\tresults.put(parentId, crc);\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n+\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n-\n-\t\t\t@Override\n-\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n-\t\t\t\t\tthrows SQLException {\n-\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n-\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n-\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\t\tif(rs.wasNull()) {\n-\t\t\t\t\tbenefactorId = null;\n-\t\t\t\t}\n-\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t\t}}, parentId);\n+\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n+\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n+\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n+\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\tif (rs.wasNull()) {\n+\t\t\t\tbenefactorId = null;\n+\t\t\t}\n+\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t}, objectType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n-\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n-\t\tif(entityContainerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "8c20f608666217165b66723ac3965874c6462b7c", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b5b51355b8..2d153d065e 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -996,7 +999,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "73b5c657d9a6747dcbb86596c082f07f1941f4ab", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 2d153d065e..e483ef0872 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -965,43 +1006,48 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n-\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n-\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\tresults.put(parentId, crc);\n+\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n+\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n+\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\t\tresults.put(parentId, crc);\n+\t\t\t}\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n-\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n-\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n-\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\tif (rs.wasNull()) {\n-\t\t\t\tbenefactorId = null;\n-\t\t\t}\n-\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t}, objectType.name(), parentId);\n+\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n+\n+\t\t\t@Override\n+\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n+\t\t\t\t\tthrows SQLException {\n+\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n+\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n+\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\t\tif(rs.wasNull()) {\n+\t\t\t\t\tbenefactorId = null;\n+\t\t\t\t}\n+\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t\t}}, parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n+\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n+\t\tif(entityContainerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "a69ed47d5e17f009bbb54991051f1d21920d5643", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e483ef0872..a3c349db57 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1006,48 +965,43 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n-\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n-\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\t\tresults.put(parentId, crc);\n-\t\t\t}\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n+\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n+\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\tresults.put(parentId, crc);\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n+\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n-\n-\t\t\t@Override\n-\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n-\t\t\t\t\tthrows SQLException {\n-\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n-\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n-\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\t\tif(rs.wasNull()) {\n-\t\t\t\t\tbenefactorId = null;\n-\t\t\t\t}\n-\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t\t}}, parentId);\n+\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n+\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n+\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n+\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\tif (rs.wasNull()) {\n+\t\t\t\tbenefactorId = null;\n+\t\t\t}\n+\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t}, objectType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n-\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n-\t\tif(entityContainerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "26cad81b6c87d74217f0a9119469e06fb5958f65", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -965,43 +1006,48 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n-\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n-\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\tresults.put(parentId, crc);\n+\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n+\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n+\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\t\tresults.put(parentId, crc);\n+\t\t\t}\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n-\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n-\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n-\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\tif (rs.wasNull()) {\n-\t\t\t\tbenefactorId = null;\n-\t\t\t}\n-\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t}, objectType.name(), parentId);\n+\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n+\n+\t\t\t@Override\n+\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n+\t\t\t\t\tthrows SQLException {\n+\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n+\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n+\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\t\tif(rs.wasNull()) {\n+\t\t\t\t\tbenefactorId = null;\n+\t\t\t\t}\n+\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t\t}}, parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n+\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n+\t\tif(entityContainerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1006,48 +995,43 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n-\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n-\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\t\tresults.put(parentId, crc);\n-\t\t\t}\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n+\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n+\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\tresults.put(parentId, crc);\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n+\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n-\n-\t\t\t@Override\n-\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n-\t\t\t\t\tthrows SQLException {\n-\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n-\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n-\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\t\tif(rs.wasNull()) {\n-\t\t\t\t\tbenefactorId = null;\n-\t\t\t\t}\n-\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t\t}}, parentId);\n+\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n+\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n+\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n+\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\tif (rs.wasNull()) {\n+\t\t\t\tbenefactorId = null;\n+\t\t\t}\n+\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t}, objectType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n-\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n-\t\tif(entityContainerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1029,7 +1161,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1161,7 +1149,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1149,7 +1167,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1163,11 +1227,11 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\t\tbenefactorId = null;\n \t\t\t}\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t}, objectType.name(), parentId);\n+\t\t}, mainType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(MainType mainType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1231,7 +1238,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(MainType mainType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1236,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1039,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1009,12 +1055,11 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n-\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n+\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n+\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1039,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1068,8 +1053,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e483ef0872..a3c349db57 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1009,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "26cad81b6c87d74217f0a9119469e06fb5958f65", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1009,12 +1055,11 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n-\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n+\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n+\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1039,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1068,8 +1053,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1023,9 +1068,8 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1068,8 +1053,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0OTI0Mg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890#discussion_r367649242", "body": "max(json_lenght())\r\nNeed  a test that would show this returns the wrong value.", "bodyText": "max(json_lenght())\nNeed  a test that would show this returns the wrong value.", "bodyHTML": "<p dir=\"auto\">max(json_lenght())<br>\nNeed  a test that would show this returns the wrong value.</p>", "author": "john-hill", "createdAt": "2020-01-16T21:05:33Z", "path": "lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java", "diffHunk": "@@ -289,10 +292,12 @@ public static Long getReservedColumnId(String columnName) {\n \r\n \tpublic static final String P_LIMIT = \"pLimit\";\r\n \t\r\n-\tpublic static final String SELECT_DISTINCT_ANNOTATION_COLUMNS_TEMPLATE = \"SELECT A.\"\r\n-\t\t\t+ ANNOTATION_REPLICATION_COL_KEY + \", GROUP_CONCAT(DISTINCT A.\"\r\n-\t\t\t+ ANNOTATION_REPLICATION_COL_TYPE + \"), MAX(LENGTH(A.\"\r\n-\t\t\t+ ANNOTATION_REPLICATION_COL_STRING_VALUE + \"))\" + \" FROM \"\r\n+\tpublic static final String SELECT_DISTINCT_ANNOTATION_COLUMNS_TEMPLATE = \"SELECT \"\r\n+\t\t\t+\"A.\" + ANNOTATION_REPLICATION_COL_KEY\r\n+\t\t\t+\", GROUP_CONCAT(DISTINCT A.\" + ANNOTATION_REPLICATION_COL_TYPE + \")\"\r\n+\t\t\t+\", MAX(\"+ANNOTATION_REPLICATION_COL_MAX_STRING_LENGTH+\")\"\r\n+\t\t\t+\", JSON_LENGTH(\"+ANNOTATION_REPLICATION_COL_STRING_LIST_VALUE+\")\"\r", "originalCommit": "e259094809a45fa367568fe95142fa5c27e69d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex 39ec604797..1802372bcd 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -296,7 +296,7 @@ public class TableConstants {\n \t\t\t+\"A.\" + ANNOTATION_REPLICATION_COL_KEY\n \t\t\t+\", GROUP_CONCAT(DISTINCT A.\" + ANNOTATION_REPLICATION_COL_TYPE + \")\"\n \t\t\t+\", MAX(\"+ANNOTATION_REPLICATION_COL_MAX_STRING_LENGTH+\")\"\n-\t\t\t+\", JSON_LENGTH(\"+ANNOTATION_REPLICATION_COL_STRING_LIST_VALUE+\")\"\n+\t\t\t+\", MAX(JSON_LENGTH(\"+ANNOTATION_REPLICATION_COL_STRING_LIST_VALUE+\"))\"\n \t\t\t+ \" FROM \"\n \t\t\t+ ENTITY_REPLICATION_TABLE + \" AS E\" + \" INNER JOIN \"\n \t\t\t+ ANNOTATION_REPLICATION_TABLE + \" AS A\" + \" ON E.\"\n", "next_change": {"commit": "77343c35cb3a4554a39539eacdc5e82ce59e4502", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex 1802372bcd..f50f01c78d 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -298,58 +308,56 @@ public class TableConstants {\n \t\t\t+\", MAX(\"+ANNOTATION_REPLICATION_COL_MAX_STRING_LENGTH+\")\"\n \t\t\t+\", MAX(JSON_LENGTH(\"+ANNOTATION_REPLICATION_COL_STRING_LIST_VALUE+\"))\"\n \t\t\t+ \" FROM \"\n-\t\t\t+ ENTITY_REPLICATION_TABLE + \" AS E\" + \" INNER JOIN \"\n-\t\t\t+ ANNOTATION_REPLICATION_TABLE + \" AS A\" + \" ON E.\"\n-\t\t\t+ ENTITY_REPLICATION_COL_ID + \" = A.\"\n-\t\t\t+ ANNOTATION_REPLICATION_COL_ENTITY_ID + \" WHERE E.\"\n-\t\t\t+ \"%1$s IN (:\"\n-\t\t\t+ PARENT_ID_PARAMETER_NAME + \") GROUP BY A.\"\n-\t\t\t+ ANNOTATION_REPLICATION_COL_KEY + \" LIMIT :\" + P_LIMIT\n+\t\t\t+ OBJECT_REPLICATION_TABLE + \" AS E\" \n+\t\t\t+ \" INNER JOIN \"\n+\t\t\t+ ANNOTATION_REPLICATION_TABLE + \" AS A\" + \" ON E.\" + OBJECT_REPLICATION_COL_OBJECT_TYPE + \" = A.\" + ANNOTATION_REPLICATION_COL_OBJECT_TYPE\n+\t\t\t+ \" AND \" + OBJECT_REPLICATION_COL_OBJECT_ID + \" = A.\" + ANNOTATION_REPLICATION_COL_OBJECT_ID \n+\t\t\t+ \" WHERE E.\" + ANNOTATION_REPLICATION_COL_OBJECT_TYPE + \"=:\" + OBJECT_TYPE_PARAM_NAME\n+\t\t\t// This can be the object id or the parent id according to the view type filter (e.g. project filters on the object id)\n+\t\t\t+ \" AND %1$s IN (:\"+ PARENT_ID_PARAM_NAME + \")\"\n+\t\t\t+ \" GROUP BY A.\" + ANNOTATION_REPLICATION_COL_KEY \n+\t\t\t+ \" LIMIT :\" + P_LIMIT\n \t\t\t+ \" OFFSET :\" + P_OFFSET;\n \t\n \tpublic static final String CRC_ALIAS = \"CRC\";\n \t\n-\tpublic static final String SELECT_ENTITY_CHILD_CRC =\n+\tpublic static final String SELECT_OBJECT_CHILD_CRC =\n \t\t\t\"SELECT \"\n-\t\t\t\t\t+ENTITY_REPLICATION_COL_PARENT_ID\n+\t\t\t\t\t+OBJECT_REPLICATION_COL_PARENT_ID\n \t\t\t\t\t+\", SUM(CRC32(CONCAT(\"\n-\t\t\t\t\t+ENTITY_REPLICATION_COL_ID\n-\t\t\t\t\t+\",'-',\"+ENTITY_REPLICATION_COL_ETAG\n-\t\t\t\t\t+\",'-',\"+ENTITY_REPLICATION_COL_BENEFACTOR_ID\n+\t\t\t\t\t+OBJECT_REPLICATION_COL_OBJECT_ID\n+\t\t\t\t\t+\",'-',\"+OBEJCT_REPLICATION_COL_ETAG\n+\t\t\t\t\t+\",'-',\"+OBJECT_REPLICATION_COL_BENEFACTOR_ID\n \t\t\t\t\t+ \"))) AS \"+CRC_ALIAS\n-\t\t\t\t\t+\" FROM \"+ENTITY_REPLICATION_TABLE\n-\t\t\t\t\t+\" WHERE \"+ENTITY_REPLICATION_COL_PARENT_ID+\" IN (:\"+PARENT_ID_PARAMETER_NAME+\")\"\n-\t\t\t\t\t+\" GROUP BY \"+ENTITY_REPLICATION_COL_PARENT_ID;\n+\t\t\t\t\t+\" FROM \"+OBJECT_REPLICATION_TABLE\n+\t\t\t\t\t+\" WHERE \"+ OBJECT_REPLICATION_COL_OBJECT_TYPE + \"=:\" + OBJECT_TYPE_PARAM_NAME\n+\t\t\t\t\t+\" AND \" + OBJECT_REPLICATION_COL_PARENT_ID+\" IN (:\"+PARENT_ID_PARAM_NAME+\")\"\n+\t\t\t\t\t+\" GROUP BY \"+OBJECT_REPLICATION_COL_PARENT_ID;\n \t\n-\tpublic static final String SELECT_ENTITY_CHILD_ID_ETAG = \n+\tpublic static final String SELECT_OBJECT_CHILD_ID_ETAG = \n \t\t\t\"SELECT \"\n-\t\t\t+ ENTITY_REPLICATION_COL_ID\n-\t\t\t+\", \"+ENTITY_REPLICATION_COL_ETAG\n-\t\t\t+\", \"+ENTITY_REPLICATION_COL_BENEFACTOR_ID\n-\t\t\t+ \" FROM \"+ENTITY_REPLICATION_TABLE\n-\t\t\t+ \" WHERE \"+ENTITY_REPLICATION_COL_PARENT_ID+\" = ?\";\n-\t\n-\tpublic static final String BATCH_INSERT_REPLICATION_SYNC_EXP =\n-\t\t\t\"INSERT INTO \"+REPLICATION_SYNC_EXPIRATION_TABLE\n-\t\t\t+\" (\"+REPLICATION_SYNC_EXP_COL_ID+\", \"+REPLICATION_SYNC_EXP_COL_EXPIRES+\")\"\n-\t\t\t+\" VALUES (?,?) ON DUPLICATE KEY UPDATE\"\n-\t\t\t+\" \"+REPLICATION_SYNC_EXP_COL_EXPIRES+\" = ?\";\n-\t\n-\tpublic static final String TRUNCATE_REPLICATION_SYNC_EXPIRATION_TABLE = \n-\t\t\t\"TRUNCATE TABLE \"+REPLICATION_SYNC_EXPIRATION_TABLE;\n+\t\t\t+ OBJECT_REPLICATION_COL_OBJECT_ID\n+\t\t\t+\", \" + OBEJCT_REPLICATION_COL_ETAG\n+\t\t\t+\", \" + OBJECT_REPLICATION_COL_BENEFACTOR_ID\n+\t\t\t+ \" FROM \" + OBJECT_REPLICATION_TABLE\n+\t\t\t+ \" WHERE \" + OBJECT_REPLICATION_COL_OBJECT_TYPE + \" = ?\"\n+\t\t\t+ \" AND \" + OBJECT_REPLICATION_COL_PARENT_ID + \" = ?\";\n \t\t\t\n-\t\n-\tpublic static final String SELECT_NON_EXPIRED_IDS =\n-\t\t\t\"SELECT \"\n-\t\t\t\t\t+REPLICATION_SYNC_EXP_COL_ID\n-\t\t\t\t\t+\" FROM \"+REPLICATION_SYNC_EXPIRATION_TABLE\n-\t\t\t\t\t+\" WHERE \"\n-\t\t\t\t\t+REPLICATION_SYNC_EXP_COL_EXPIRES+\" > :\"+EXPIRES_PARAM\n-\t\t\t\t\t+\" AND \"+REPLICATION_SYNC_EXP_COL_ID+\" IN (:\"+ID_PARAMETER_NAME+\")\";\n-\t\n \t/**\n \t * Marker for a table's label indicating the version is 'in progress'.\n \t */\n \tpublic static final String IN_PROGRESS = \"in progress\";\n+\t\n+\t/**\n+\t * Given the values of an enumeration produces a joined string of the {@link Enum#name()} of each item surrounded by single quote (') and joined by\n+\t * a comma so that it can be used to defined a MySQL enum\n+\t * \n+\t * @param values\n+\t * @return\n+\t */\n+\tpublic static String joinEnumForSQL(Enum<?>[] values) {\n+\t\treturn Stream.of(values).map( e -> \"'\" + e.name() + \"'\").collect(Collectors.joining(\",\"));\n+\t}\n+\t\n \n }\n", "next_change": {"commit": "12abad419cb4205d24388c7ccc53f774202cfb37", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex f50f01c78d..cb48359698 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -356,7 +366,11 @@ public class TableConstants {\n \t * @return\n \t */\n \tpublic static String joinEnumForSQL(Enum<?>[] values) {\n-\t\treturn Stream.of(values).map( e -> \"'\" + e.name() + \"'\").collect(Collectors.joining(\",\"));\n+\t\treturn joinEnumForSQL(Stream.of(values));\n+\t}\n+\t\n+\tpublic static String joinEnumForSQL(Stream<Enum<?>> valuesStream) {\n+\t\treturn valuesStream.map( e -> \"'\" + e.name() + \"'\").collect(Collectors.joining(\",\"));\n \t}\n \t\n \n", "next_change": {"commit": "03acbc62205b1f9d7fffa931fceba5c06e9d18e2", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex cb48359698..a44679070c 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -370,8 +384,15 @@ public class TableConstants {\n \t}\n \t\n \tpublic static String joinEnumForSQL(Stream<Enum<?>> valuesStream) {\n-\t\treturn valuesStream.map( e -> \"'\" + e.name() + \"'\").collect(Collectors.joining(\",\"));\n+\t\treturn joinValueForSQL(valuesStream, Enum::name);\n \t}\n \t\n+\tpublic static String joinStringForSQL(Stream<String> valuesStream) {\n+\t\treturn joinValueForSQL(valuesStream, Function.identity());\n+\t}\n+\t\n+\tpublic static <T> String joinValueForSQL(Stream<T> valuesStream, Function<T, String> valueMapper) {\n+\t\treturn valuesStream.map( e -> \"'\" + valueMapper.apply(e) + \"'\").collect(Collectors.joining(\",\"));\n+\t}\n \n }\n", "next_change": {"commit": "36bcd82636fe856711b237227b17ac7a85d758af", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex a44679070c..2a43929017 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -387,10 +390,6 @@ public class TableConstants {\n \t\treturn joinValueForSQL(valuesStream, Enum::name);\n \t}\n \t\n-\tpublic static String joinStringForSQL(Stream<String> valuesStream) {\n-\t\treturn joinValueForSQL(valuesStream, Function.identity());\n-\t}\n-\t\n \tpublic static <T> String joinValueForSQL(Stream<T> valuesStream, Function<T, String> valueMapper) {\n \t\treturn valuesStream.map( e -> \"'\" + valueMapper.apply(e) + \"'\").collect(Collectors.joining(\",\"));\n \t}\n", "next_change": {"commit": "8d6c3f186a5c5c29708863f92b7aab80202e804b", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex 2a43929017..fc6a6e2d92 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -375,23 +314,4 @@ public class TableConstants {\n \t */\n \tpublic static final String IN_PROGRESS = \"in progress\";\n \t\n-\t/**\n-\t * Given the values of an enumeration produces a joined string of the {@link Enum#name()} of each item surrounded by single quote (') and joined by\n-\t * a comma so that it can be used to defined a MySQL enum\n-\t * \n-\t * @param values\n-\t * @return\n-\t */\n-\tpublic static String joinEnumForSQL(Enum<?>[] values) {\n-\t\treturn joinEnumForSQL(Stream.of(values));\n-\t}\n-\t\n-\tpublic static String joinEnumForSQL(Stream<Enum<?>> valuesStream) {\n-\t\treturn joinValueForSQL(valuesStream, Enum::name);\n-\t}\n-\t\n-\tpublic static <T> String joinValueForSQL(Stream<T> valuesStream, Function<T, String> valueMapper) {\n-\t\treturn valuesStream.map( e -> \"'\" + valueMapper.apply(e) + \"'\").collect(Collectors.joining(\",\"));\n-\t}\n-\n }\n", "next_change": {"commit": "96079dcf050650cadb76cef2c2ad36d15af8c734", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex fc6a6e2d92..4c4e8ade28 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -314,4 +324,9 @@ public class TableConstants {\n \t */\n \tpublic static final String IN_PROGRESS = \"in progress\";\n \t\n+\tpublic static final String JOIN_NOT_SUPPORTED_IN_THIS_CONTEX_MESSAGE = \"The JOIN keyword is not supported in this context\";\n+\n+\tpublic static final Supplier<IllegalArgumentException> JOIN_NOT_SUPPORTED_IN_THIS_CONTEXT = () -> new IllegalArgumentException(\n+\t\t\tJOIN_NOT_SUPPORTED_IN_THIS_CONTEX_MESSAGE);\n+\t\n }\n", "next_change": {"commit": "3edb1b251dcfe39bf385faccd91b3031cad08b2c", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex 4c4e8ade28..b6be62da68 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -329,4 +338,6 @@ public class TableConstants {\n \tpublic static final Supplier<IllegalArgumentException> JOIN_NOT_SUPPORTED_IN_THIS_CONTEXT = () -> new IllegalArgumentException(\n \t\t\tJOIN_NOT_SUPPORTED_IN_THIS_CONTEX_MESSAGE);\n \t\n+\tpublic static final String DEFINING_SQL_WITH_GROUP_BY_ERROR = \"The defining SQL of a materialized view with a view dependency cannot include a group by clause\";\n+\t\n }\n", "next_change": {"commit": "1ff106523a353c2b51d12485907c937211190bb7", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex b6be62da68..4138cb8f1d 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -340,4 +341,6 @@ public class TableConstants {\n \t\n \tpublic static final String DEFINING_SQL_WITH_GROUP_BY_ERROR = \"The defining SQL of a materialized view with a view dependency cannot include a group by clause\";\n \t\n+\tpublic static final String MAXIMUM_OF_ITEMS_IN_A_DATASET_EXCEEDED = \"Maximum of %,d items in a dataset exceeded.\";\n+\t\n }\n", "next_change": {"commit": "7f1a7441adeccccd41f713bb0452f52313863978", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex 4138cb8f1d..d407811ed6 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -343,4 +343,6 @@ public class TableConstants {\n \t\n \tpublic static final String MAXIMUM_OF_ITEMS_IN_A_DATASET_EXCEEDED = \"Maximum of %,d items in a dataset exceeded.\";\n \t\n+\tpublic static final String MAXIMUM_OF_ITEMS_IN_A_DATASET_COLLECTION_EXCEEDED = \"Maximum of %,d items in a dataset collection exceeded.\";\n+\t\n }\n", "next_change": {"commit": "9c8556624ed556071d06415da071427a2b6c679e", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex d407811ed6..3b292b8d1b 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -344,5 +365,7 @@ public class TableConstants {\n \tpublic static final String MAXIMUM_OF_ITEMS_IN_A_DATASET_EXCEEDED = \"Maximum of %,d items in a dataset exceeded.\";\n \t\n \tpublic static final String MAXIMUM_OF_ITEMS_IN_A_DATASET_COLLECTION_EXCEEDED = \"Maximum of %,d items in a dataset collection exceeded.\";\n+\n+\tpublic static final Long COLUMN_NO_CARDINALITY = -1L;\n \t\n }\n", "next_change": {"commit": "3bf4a532cd9897fb0143b0858347400cfd4f261e", "changed_code": [{"header": "diff --git a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\nindex 3b292b8d1b..a9e737dd6a 100644\n--- a/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n+++ b/lib/models/src/main/java/org/sagebionetworks/repo/model/table/TableConstants.java\n", "chunk": "@@ -366,6 +366,6 @@ public class TableConstants {\n \t\n \tpublic static final String MAXIMUM_OF_ITEMS_IN_A_DATASET_COLLECTION_EXCEEDED = \"Maximum of %,d items in a dataset collection exceeded.\";\n \n-\tpublic static final Long COLUMN_NO_CARDINALITY = -1L;\n+\tpublic static final Long COLUMN_NO_CARDINALITY = 0L;\n \t\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY1MDIwNA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890#discussion_r367650204", "body": "maxListSize", "bodyText": "maxListSize", "bodyHTML": "<p dir=\"auto\">maxListSize</p>", "author": "john-hill", "createdAt": "2020-01-16T21:07:52Z", "path": "lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java", "diffHunk": "@@ -885,9 +886,19 @@ public ColumnAggregation mapRow(ResultSet rs, int rowNum)\n \t\t\t\tColumnModel model = new ColumnModel();\r\n \t\t\t\tmodel.setName(aggregation.getColumnName());\r\n \t\t\t\tColumnType type = AnnotationType.valueOf(typeString).getColumnType();\r\n+\r\n+\t\t\t\t//check if a LIST columnType needs to be used\r\n+\t\t\t\tif(aggregation.getListSize() > 1){\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\ttype = ColumnTypeListMappings.forNonListType(type).getListType();\r\n+\t\t\t\t\t} catch (IllegalArgumentException e){\r\n+\t\t\t\t\t\t//do nothing because a list type mapping does not exist\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\r\n \t\t\t\tmodel.setColumnType(type);\r\n-\t\t\t\tif(ColumnType.STRING == type) {\r\n-\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxSize());\r\n+\t\t\t\tif(ColumnType.STRING == type || ColumnType.STRING_LIST==type) {\r\n+\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxStringElementSize());\r", "originalCommit": "e259094809a45fa367568fe95142fa5c27e69d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b473eeb0e94afc5192352e429fb122dee322fac", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex bedd2f7871..26e941a4e4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -886,19 +887,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\t\tColumnModel model = new ColumnModel();\n \t\t\t\tmodel.setName(aggregation.getColumnName());\n \t\t\t\tColumnType type = AnnotationType.valueOf(typeString).getColumnType();\n-\n-\t\t\t\t//check if a LIST columnType needs to be used\n-\t\t\t\tif(aggregation.getListSize() > 1){\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\ttype = ColumnTypeListMappings.forNonListType(type).getListType();\n-\t\t\t\t\t} catch (IllegalArgumentException e){\n-\t\t\t\t\t\t//do nothing because a list type mapping does not exist\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n \t\t\t\tmodel.setColumnType(type);\n-\t\t\t\tif(ColumnType.STRING == type || ColumnType.STRING_LIST==type) {\n-\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxStringElementSize());\n+\t\t\t\tif(ColumnType.STRING == type) {\n+\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxSize());\n \t\t\t\t}\n \t\t\t\tresults.add(model);\n \t\t\t}\n", "next_change": {"commit": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 26e941a4e4..a493eddbba 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -887,9 +886,19 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\t\tColumnModel model = new ColumnModel();\n \t\t\t\tmodel.setName(aggregation.getColumnName());\n \t\t\t\tColumnType type = AnnotationType.valueOf(typeString).getColumnType();\n+\n+\t\t\t\t//check if a LIST columnType needs to be used\n+\t\t\t\tif(aggregation.getMaxListSize() > 1){\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\ttype = ColumnTypeListMappings.listType(type);\n+\t\t\t\t\t} catch (IllegalArgumentException e){\n+\t\t\t\t\t\t//do nothing because a list type mapping does not exist\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\tmodel.setColumnType(type);\n-\t\t\t\tif(ColumnType.STRING == type) {\n-\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxSize());\n+\t\t\t\tif(ColumnType.STRING == type || ColumnType.STRING_LIST==type) {\n+\t\t\t\t\tmodel.setMaximumSize(aggregation.getMaxStringElementSize());\n \t\t\t\t}\n \t\t\t\tresults.add(model);\n \t\t\t}\n", "next_change": {"commit": "3ac68ccba8dab267caf2a26d41ffe1a8b4d9518a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a493eddbba..b5b51355b8 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -907,49 +962,43 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n-\t\tNamedParameterJdbcTemplate namedTemplate = new NamedParameterJdbcTemplate(this.template);\n-\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n-\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n-\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\t\tresults.put(parentId, crc);\n-\t\t\t}\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n+\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n+\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\tresults.put(parentId, crc);\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n+\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n-\n-\t\t\t@Override\n-\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n-\t\t\t\t\tthrows SQLException {\n-\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n-\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n-\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\t\tif(rs.wasNull()) {\n-\t\t\t\t\tbenefactorId = null;\n-\t\t\t\t}\n-\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t\t}}, parentId);\n+\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n+\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n+\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n+\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\tif (rs.wasNull()) {\n+\t\t\t\tbenefactorId = null;\n+\t\t\t}\n+\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t}, objectType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n-\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n-\t\tif(entityContainerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "8c20f608666217165b66723ac3965874c6462b7c", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b5b51355b8..2d153d065e 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -996,7 +999,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "73b5c657d9a6747dcbb86596c082f07f1941f4ab", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 2d153d065e..e483ef0872 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -965,43 +1006,48 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n-\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n-\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\tresults.put(parentId, crc);\n+\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n+\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n+\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\t\tresults.put(parentId, crc);\n+\t\t\t}\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n-\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n-\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n-\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\tif (rs.wasNull()) {\n-\t\t\t\tbenefactorId = null;\n-\t\t\t}\n-\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t}, objectType.name(), parentId);\n+\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n+\n+\t\t\t@Override\n+\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n+\t\t\t\t\tthrows SQLException {\n+\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n+\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n+\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\t\tif(rs.wasNull()) {\n+\t\t\t\t\tbenefactorId = null;\n+\t\t\t\t}\n+\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t\t}}, parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n+\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n+\t\tif(entityContainerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "a69ed47d5e17f009bbb54991051f1d21920d5643", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e483ef0872..a3c349db57 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1006,48 +965,43 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n-\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n-\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\t\tresults.put(parentId, crc);\n-\t\t\t}\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n+\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n+\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\tresults.put(parentId, crc);\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n+\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n-\n-\t\t\t@Override\n-\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n-\t\t\t\t\tthrows SQLException {\n-\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n-\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n-\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\t\tif(rs.wasNull()) {\n-\t\t\t\t\tbenefactorId = null;\n-\t\t\t\t}\n-\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t\t}}, parentId);\n+\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n+\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n+\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n+\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\tif (rs.wasNull()) {\n+\t\t\t\tbenefactorId = null;\n+\t\t\t}\n+\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t}, objectType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n-\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n-\t\tif(entityContainerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "26cad81b6c87d74217f0a9119469e06fb5958f65", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -965,43 +1006,48 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n-\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n-\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\tresults.put(parentId, crc);\n+\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n+\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n+\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\t\tresults.put(parentId, crc);\n+\t\t\t}\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n-\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n-\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n-\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\tif (rs.wasNull()) {\n-\t\t\t\tbenefactorId = null;\n-\t\t\t}\n-\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t}, objectType.name(), parentId);\n+\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n+\n+\t\t\t@Override\n+\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n+\t\t\t\t\tthrows SQLException {\n+\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n+\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n+\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\t\tif(rs.wasNull()) {\n+\t\t\t\t\tbenefactorId = null;\n+\t\t\t\t}\n+\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t\t}}, parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n+\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n+\t\tif(entityContainerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1006,48 +995,43 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \t\n \t@Override\n-\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(List<Long> parentIds) {\n+\tpublic Map<Long, Long> getSumOfChildCRCsForEachParent(ObjectType objectType, List<Long> parentIds) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentIds, \"parentIds\");\n \t\tfinal Map<Long, Long> results = new HashMap<>();\n \t\tif(parentIds.isEmpty()){\n \t\t\treturn results;\n \t\t}\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(PARENT_ID_PARAMETER_NAME, parentIds);\n-\t\tnamedTemplate.query(SELECT_ENTITY_CHILD_CRC, param, new RowCallbackHandler() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void processRow(ResultSet rs) throws SQLException {\n-\t\t\t\tLong parentId = rs.getLong(ENTITY_REPLICATION_COL_PARENT_ID);\n-\t\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n-\t\t\t\tresults.put(parentId, crc);\n-\t\t\t}\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(PARENT_ID_PARAM_NAME, parentIds);\n+\t\tnamedTemplate.query(SELECT_OBJECT_CHILD_CRC, param, (ResultSet rs) -> {\n+\t\t\tLong parentId = rs.getLong(OBJECT_REPLICATION_COL_PARENT_ID);\n+\t\t\tLong crc = rs.getLong(CRC_ALIAS);\n+\t\t\tresults.put(parentId, crc);\n \t\t});\n \t\treturn results;\n \t}\n \n \t@Override\n-\tpublic List<IdAndEtag> getEntityChildren(Long parentId) {\n+\tpublic List<IdAndEtag> getObjectChildren(ObjectType objectType, Long parentId) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(parentId, \"parentId\");\n-\t\treturn this.template.query(SELECT_ENTITY_CHILD_ID_ETAG, new RowMapper<IdAndEtag>(){\n-\n-\t\t\t@Override\n-\t\t\tpublic IdAndEtag mapRow(ResultSet rs, int rowNum)\n-\t\t\t\t\tthrows SQLException {\n-\t\t\t\tLong id = rs.getLong(TableConstants.ENTITY_REPLICATION_COL_ID);\n-\t\t\t\tString etag = rs.getString(ENTITY_REPLICATION_COL_ETAG);\n-\t\t\t\tLong benefactorId = rs.getLong(ENTITY_REPLICATION_COL_BENEFACTOR_ID);\n-\t\t\t\tif(rs.wasNull()) {\n-\t\t\t\t\tbenefactorId = null;\n-\t\t\t\t}\n-\t\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t\t}}, parentId);\n+\t\treturn this.template.query(SELECT_OBJECT_CHILD_ID_ETAG, (ResultSet rs, int rowNum) -> {\n+\t\t\tLong id = rs.getLong(TableConstants.OBJECT_REPLICATION_COL_OBJECT_ID);\n+\t\t\tString etag = rs.getString(OBEJCT_REPLICATION_COL_ETAG);\n+\t\t\tLong benefactorId = rs.getLong(OBJECT_REPLICATION_COL_BENEFACTOR_ID);\n+\t\t\tif (rs.wasNull()) {\n+\t\t\t\tbenefactorId = null;\n+\t\t\t}\n+\t\t\treturn new IdAndEtag(id, etag, benefactorId);\n+\t\t}, objectType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(List<Long> entityContainerIds) {\n-\t\tValidateArgument.required(entityContainerIds, \"entityContainerIds\");\n-\t\tif(entityContainerIds.isEmpty()){\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n \t\t}\n \t\t/*\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1029,7 +1161,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1161,7 +1149,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1149,7 +1167,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1163,11 +1227,11 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\t\tbenefactorId = null;\n \t\t\t}\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n-\t\t}, objectType.name(), parentId);\n+\t\t}, mainType.name(), parentId);\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ViewObjectType objectType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(MainType mainType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1231,7 +1238,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(MainType mainType, List<Long> containerIds) {\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n \t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n \t\tif(containerIds.isEmpty()){\n \t\t\treturn new LinkedList<Long>();\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1236,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1039,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1009,12 +1055,11 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n-\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n+\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n+\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1039,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1068,8 +1053,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e483ef0872..a3c349db57 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1009,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "26cad81b6c87d74217f0a9119469e06fb5958f65", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1009,12 +1055,11 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n-\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n+\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n+\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1055,11 +1039,12 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t * ID. Therefore, start off with all of the IDs expired, so the\n \t\t * non-expired IDs can be removed.\n \t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(entityContainerIds);\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n-\t\tparam.addValue(ID_PARAMETER_NAME, entityContainerIds);\n-\t\tparam.addValue(EXPIRES_PARAM, System.currentTimeMillis());\n+\t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, objectType.name());\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n \t\t// remove all that are not expired.\n \t\texpiredId.removeAll(nonExpiredIds);\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1068,8 +1053,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex a3c349db57..fc968050da 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1023,9 +1068,8 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "2f356350572cf6e77e7224ecb1b6de981bf021b3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex fc968050da..00b97c3d54 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1068,8 +1053,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n+\t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 00b97c3d54..3f08e2b95b 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1053,7 +1185,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "f1ad6154dd34bb04e28e50ee4816206994837ea3", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3f08e2b95b..22f85a5c74 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1185,7 +1173,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "3d29075cb9fc0255fac5ad9d0df5197540c79ec8", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 22f85a5c74..f411143746 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1173,7 +1191,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(objectType, \"objectType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f411143746..1339d60437 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1191,9 +1255,9 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ViewObjectType objectType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n-\t\tValidateArgument.required(objectType, \"objectType\");\n+\t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n \t\t\treturn;\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1339d60437..f4fa0bbc4f 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1255,7 +1262,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(MainType mainType, final List<Long> toSet,\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n \t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n", "next_change": {"commit": "c2991d9ade275250812e3b83a31df1bf2008a5c9", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex f4fa0bbc4f..28b0ccb1d4 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1263,7 +1265,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "24da3a94cd52445f918725c84451f7c854fef38d", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 28b0ccb1d4..e240f96417 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1265,7 +1260,7 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \t@Override\n \tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\t\t\tfinal long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n \t\tValidateArgument.required(toSet, \"toSet\");\n \t\tif(toSet.isEmpty()){\n", "next_change": {"commit": "d42b5267245eb30d0817f94941f03b5a011b3a8f", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e240f96417..83e975765d 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1238,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "919f6b90db2530aacaddc6cfe1c307a591d6246b", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 83e975765d..b9f7ff62ae 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,29 +1233,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "fbeea95ceb0f8fb0eddf2c46d3d25ff0298aa500", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex b9f7ff62ae..e4327cb02c 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,59 +1233,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "dc7f42ee1d3e3ab9c549aa99292d280d9d77b407", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex e4327cb02c..3cda68c536 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1233,29 +1238,59 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\t\n+\n \t@Override\n-\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n-\t\tValidateArgument.required(objectId, \"objectId\");\n+\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n+\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n+\t\tif(containerIds.isEmpty()){\n+\t\t\treturn new LinkedList<Long>();\n+\t\t}\n+\t\t/*\n+\t\t * An ID that does not exist, should be treated the same as an expired\n+\t\t * ID. Therefore, start off with all of the IDs expired, so the\n+\t\t * non-expired IDs can be removed.\n+\t\t */\n+\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, objectId);\n+\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\treturn nonExpiredIds.isEmpty();\n+\t\t// remove all that are not expired.\n+\t\texpiredId.removeAll(nonExpiredIds);\n+\t\t// return the remain.\n+\t\treturn new LinkedList<Long>(expiredId);\n \t}\n \n \t@Override\n-\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n-\t\t\tLong newExpirationDateMS) {\n+\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n+\t\t\tfinal Long newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(objectId, \"objectId\");\n-\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n-\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n+\t\tValidateArgument.required(toSet, \"toSet\");\n+\t\tif(toSet.isEmpty()){\n+\t\t\treturn;\n+\t\t}\n+\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n+\t\t\t\tLong idToSet = toSet.get(i);\n+\t\t\t\tint index = 1;\n+\t\t\t\tps.setString(index++, mainType.name());\n+\t\t\t\tps.setLong(index++, idToSet);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t\tps.setLong(index++, newExpirationDateMS);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic int getBatchSize() {\n+\t\t\t\treturn toSet.size();\n+\t\t\t}\n+\t\t});\n+\t\t\n \t}\n \n-\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "cecdb701ea3cf9cc6d189a190d9ba228c32f3cef", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 3cda68c536..1f2ef7e6d5 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1238,59 +1251,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \t\t\treturn new IdAndEtag(id, etag, benefactorId);\n \t\t}, mainType.name(), parentId);\n \t}\n-\n+\t\n \t@Override\n-\tpublic List<Long> getExpiredContainerIds(ReplicationType mainType, List<Long> containerIds) {\n-\t\tValidateArgument.required(containerIds, \"entityContainerIds\");\n-\t\tif(containerIds.isEmpty()){\n-\t\t\treturn new LinkedList<Long>();\n-\t\t}\n-\t\t/*\n-\t\t * An ID that does not exist, should be treated the same as an expired\n-\t\t * ID. Therefore, start off with all of the IDs expired, so the\n-\t\t * non-expired IDs can be removed.\n-\t\t */\n-\t\tLinkedHashSet<Long> expiredId = new LinkedHashSet<Long>(containerIds);\n+\tpublic boolean isSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId) {\n+\t\tValidateArgument.required(objectId, \"objectId\");\n \t\t// Query for those that are not expired.\n \t\tMapSqlParameterSource param = new MapSqlParameterSource();\n \t\tparam.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparam.addValue(ID_PARAM_NAME, containerIds);\n+\t\tparam.addValue(ID_PARAM_NAME, objectId);\n \t\tparam.addValue(EXPIRES_PARAM_NAME, System.currentTimeMillis());\n \t\tList<Long> nonExpiredIds =  namedTemplate.queryForList(SELECT_NON_EXPIRED_IDS, param, Long.class);\n-\t\t// remove all that are not expired.\n-\t\texpiredId.removeAll(nonExpiredIds);\n-\t\t// return the remain.\n-\t\treturn new LinkedList<Long>(expiredId);\n+\t\treturn nonExpiredIds.isEmpty();\n \t}\n \n \t@Override\n-\tpublic void setContainerSynchronizationExpiration(ReplicationType mainType, final List<Long> toSet,\n-\t\t\tfinal Long newExpirationDateMS) {\n+\tpublic void setSynchronizationLockExpiredForObject(ReplicationType mainType, Long objectId,\n+\t\t\tLong newExpirationDateMS) {\n \t\tValidateArgument.required(mainType, \"mainType\");\n-\t\tValidateArgument.required(toSet, \"toSet\");\n-\t\tif(toSet.isEmpty()){\n-\t\t\treturn;\n-\t\t}\n-\t\ttemplate.batchUpdate(BATCH_INSERT_REPLICATION_SYNC_EXP, new BatchPreparedStatementSetter() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n-\t\t\t\tLong idToSet = toSet.get(i);\n-\t\t\t\tint index = 1;\n-\t\t\t\tps.setString(index++, mainType.name());\n-\t\t\t\tps.setLong(index++, idToSet);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t\tps.setLong(index++, newExpirationDateMS);\n-\t\t\t}\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic int getBatchSize() {\n-\t\t\t\treturn toSet.size();\n-\t\t\t}\n-\t\t});\n-\t\t\n+\t\tValidateArgument.required(objectId, \"objectId\");\n+\t\tValidateArgument.required(newExpirationDateMS, \"newExpirationDateMS\");\n+\t\ttemplate.update(BATCH_INSERT_REPLICATION_SYNC_EXP, mainType.name(),objectId, newExpirationDateMS, newExpirationDateMS);\t\t\n \t}\n \n+\n \t@Override\n \tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n", "next_change": {"commit": "beeb5de888db1ab6fa2dfa4d18e074f27eb52a62", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\nindex 1f2ef7e6d5..f9aaa95fdc 100644\n--- a/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n+++ b/lib/lib-table-cluster/src/main/java/org/sagebionetworks/table/cluster/TableIndexDAOImpl.java\n", "chunk": "@@ -1275,22 +1290,29 @@ public class TableIndexDAOImpl implements TableIndexDAO {\n \n \n \t@Override\n-\tpublic List<Long> getRowIds(String sql, Map<String, Object> parameters) {\n+\tpublic List<IdAndVersion> getRowIdAndVersions(String sql, Map<String, Object> parameters) {\n \t\tValidateArgument.required(sql, \"sql\");\n \t\tValidateArgument.required(parameters, \"parameters\");\n \t\t// We use spring to create create the prepared statement\n-\t\treturn namedTemplate.queryForList(sql, new MapSqlParameterSource(parameters), Long.class);\n+\t\treturn namedTemplate.query(sql, new MapSqlParameterSource(parameters), (ResultSet rs, int rowNum) -> \n+\t\t\tIdAndVersion.newBuilder().setId(rs.getLong(1)).setVersion(rs.getLong(2)).build()\n+\t\t);\n \t}\n \n \t@Override\n-\tpublic long getSumOfFileSizes(ReplicationType mainType, List<Long> rowIds) {\n-\t\tValidateArgument.required(rowIds, \"rowIds\");\n-\t\tif(rowIds.isEmpty()) {\n+\tpublic long getSumOfFileSizes(ReplicationType mainType, List<IdAndVersion> rowIdAndVersions) {\n+\t\tValidateArgument.required(rowIdAndVersions, \"rowIdAndVersions\");\n+\t\tif(rowIdAndVersions.isEmpty()) {\n \t\t\treturn 0L;\n \t\t}\n \t\tMapSqlParameterSource params = new MapSqlParameterSource();\n \t\tparams.addValue(OBJECT_TYPE_PARAM_NAME, mainType.name());\n-\t\tparams.addValue(ID_PARAM_NAME, rowIds);\n+\t\t\n+\t\tList<Long[]> idAndVersionParam = rowIdAndVersions.stream()\n+\t\t\t\t.map((IdAndVersion id) -> new Long[] {id.getId(), id.getVersion().orElseThrow(() -> new IllegalArgumentException(\"The object with id \" + id + \" must specify a version.\"))})\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\n+\t\tparams.addValue(ID_PARAM_NAME, idAndVersionParam);\n \n \t\tLong sum = namedTemplate.queryForObject(SQL_SUM_FILE_SIZES, params, Long.class);\n \t\t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY1MDY2Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890#discussion_r367650667", "body": "all 3s?", "bodyText": "all 3s?", "bodyHTML": "<p dir=\"auto\">all 3s?</p>", "author": "john-hill", "createdAt": "2020-01-16T21:08:53Z", "path": "lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java", "diffHunk": "@@ -2625,6 +2628,8 @@ public void testWriteAnnotationDtoToPreparedStatementLongList() throws SQLExcept\n \t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"456\\\",\\\"789\\\"]\");\r", "originalCommit": "e259094809a45fa367568fe95142fa5c27e69d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71e94f304e56f72d9f86fb2aa755f3e2f145acca", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex c91dfea1c1..05d3b20a2d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2628,8 +2625,6 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"456\\\",\\\"789\\\"]\");\n \t\tverify(mockPreparedStatement).setString(10, \"[123,456,789]\");\n \t\tverify(mockPreparedStatement).setString(11, null);\n-\t\tverify(mockPreparedStatement).setLong(12, 3);\n-\n \t}\n \n \t@Test\n", "next_change": {"commit": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 05d3b20a2d..6b56ca7a7e 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2622,9 +2625,11 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n \t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n \n-\t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"456\\\",\\\"789\\\"]\");\n-\t\tverify(mockPreparedStatement).setString(10, \"[123,456,789]\");\n+\t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n+\t\tverify(mockPreparedStatement).setString(10, \"[123,4560,789]\");\n \t\tverify(mockPreparedStatement).setString(11, null);\n+\t\tverify(mockPreparedStatement).setLong(12, 4);\n+\n \t}\n \n \t@Test\n", "next_change": {"commit": "3ac68ccba8dab267caf2a26d41ffe1a8b4d9518a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 6b56ca7a7e..39fb99d55d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2613,22 +2717,24 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(Arrays.asList(\"123\", \"4560\", \"789\"));\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setLong(1, annotationDto.getEntityId());\n-\t\tverify(mockPreparedStatement).setString(2, annotationDto.getKey());\n-\t\tverify(mockPreparedStatement).setString(3, annotationDto.getType().name());\n-\t\tverify(mockPreparedStatement).setString(4, annotationDto.getValue().get(0));\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\t\n+\t\tverify(mockPreparedStatement).setString(1, ObjectType.ENTITY.name());\n+\t\tverify(mockPreparedStatement).setLong(2, annotationDto.getEntityId());\n+\t\tverify(mockPreparedStatement).setString(3, annotationDto.getKey());\n+\t\tverify(mockPreparedStatement).setString(4, annotationDto.getType().name());\n+\t\tverify(mockPreparedStatement).setString(5, annotationDto.getValue().get(0));\n \n \t\t// can be a long or a double\n-\t\tverify(mockPreparedStatement).setLong(5, 123L);\n-\t\tverify(mockPreparedStatement).setDouble(6, 123);\n-\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setLong(6, 123L);\n+\t\tverify(mockPreparedStatement).setDouble(7, 123);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \n-\t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n-\t\tverify(mockPreparedStatement).setString(10, \"[123,4560,789]\");\n-\t\tverify(mockPreparedStatement).setString(11, null);\n-\t\tverify(mockPreparedStatement).setLong(12, 4);\n+\t\tverify(mockPreparedStatement).setString(10, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n+\t\tverify(mockPreparedStatement).setString(11, \"[123,4560,789]\");\n+\t\tverify(mockPreparedStatement).setString(12, null);\n+\t\tverify(mockPreparedStatement).setLong(13, 4);\n \n \t}\n \n", "next_change": {"commit": "73b5c657d9a6747dcbb86596c082f07f1941f4ab", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 39fb99d55d..d26faf75c0 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2717,24 +2790,22 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(Arrays.asList(\"123\", \"4560\", \"789\"));\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\t\n-\t\tverify(mockPreparedStatement).setString(1, ObjectType.ENTITY.name());\n-\t\tverify(mockPreparedStatement).setLong(2, annotationDto.getEntityId());\n-\t\tverify(mockPreparedStatement).setString(3, annotationDto.getKey());\n-\t\tverify(mockPreparedStatement).setString(4, annotationDto.getType().name());\n-\t\tverify(mockPreparedStatement).setString(5, annotationDto.getValue().get(0));\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n+\t\tverify(mockPreparedStatement).setLong(1, annotationDto.getEntityId());\n+\t\tverify(mockPreparedStatement).setString(2, annotationDto.getKey());\n+\t\tverify(mockPreparedStatement).setString(3, annotationDto.getType().name());\n+\t\tverify(mockPreparedStatement).setString(4, annotationDto.getValue().get(0));\n \n \t\t// can be a long or a double\n-\t\tverify(mockPreparedStatement).setLong(6, 123L);\n-\t\tverify(mockPreparedStatement).setDouble(7, 123);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setLong(5, 123L);\n+\t\tverify(mockPreparedStatement).setDouble(6, 123);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n \n-\t\tverify(mockPreparedStatement).setString(10, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n-\t\tverify(mockPreparedStatement).setString(11, \"[123,4560,789]\");\n-\t\tverify(mockPreparedStatement).setString(12, null);\n-\t\tverify(mockPreparedStatement).setLong(13, 4);\n+\t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n+\t\tverify(mockPreparedStatement).setString(10, \"[123,4560,789]\");\n+\t\tverify(mockPreparedStatement).setString(11, null);\n+\t\tverify(mockPreparedStatement).setLong(12, 4);\n \n \t}\n \n", "next_change": {"commit": "20b989f9983bb72dd3f3cc88252d9536fe835c06", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2790,22 +2726,24 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(Arrays.asList(\"123\", \"4560\", \"789\"));\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setLong(1, annotationDto.getEntityId());\n-\t\tverify(mockPreparedStatement).setString(2, annotationDto.getKey());\n-\t\tverify(mockPreparedStatement).setString(3, annotationDto.getType().name());\n-\t\tverify(mockPreparedStatement).setString(4, annotationDto.getValue().get(0));\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\t\n+\t\tverify(mockPreparedStatement).setString(1, ObjectType.ENTITY.name());\n+\t\tverify(mockPreparedStatement).setLong(2, annotationDto.getEntityId());\n+\t\tverify(mockPreparedStatement).setString(3, annotationDto.getKey());\n+\t\tverify(mockPreparedStatement).setString(4, annotationDto.getType().name());\n+\t\tverify(mockPreparedStatement).setString(5, annotationDto.getValue().get(0));\n \n \t\t// can be a long or a double\n-\t\tverify(mockPreparedStatement).setLong(5, 123L);\n-\t\tverify(mockPreparedStatement).setDouble(6, 123);\n-\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setLong(6, 123L);\n+\t\tverify(mockPreparedStatement).setDouble(7, 123);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \n-\t\tverify(mockPreparedStatement).setString(9, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n-\t\tverify(mockPreparedStatement).setString(10, \"[123,4560,789]\");\n-\t\tverify(mockPreparedStatement).setString(11, null);\n-\t\tverify(mockPreparedStatement).setLong(12, 4);\n+\t\tverify(mockPreparedStatement).setString(10, \"[\\\"123\\\",\\\"4560\\\",\\\"789\\\"]\");\n+\t\tverify(mockPreparedStatement).setString(11, \"[123,4560,789]\");\n+\t\tverify(mockPreparedStatement).setString(12, null);\n+\t\tverify(mockPreparedStatement).setLong(13, 4);\n \n \t}\n \n", "next_change": {"commit": "706b99c206fc2b1e82c9c63a6a0f1d1881894094", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..132f22e8ab 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2744,6 +2870,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(11, \"[123,4560,789]\");\n \t\tverify(mockPreparedStatement).setString(12, null);\n \t\tverify(mockPreparedStatement).setLong(13, 4);\n+\t\tverify(mockPreparedStatement).setLong(14, 4);\n \n \t}\n \n", "next_change": {"commit": "66e8689e8147dd558bf5c178047795db7c6d855a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 132f22e8ab..98e8e96e86 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2870,7 +2795,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(11, \"[123,4560,789]\");\n \t\tverify(mockPreparedStatement).setString(12, null);\n \t\tverify(mockPreparedStatement).setLong(13, 4);\n-\t\tverify(mockPreparedStatement).setLong(14, 4);\n+\t\tverify(mockPreparedStatement).setLong(14, 3);\n \n \t}\n \n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 98e8e96e86..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2804,7 +2769,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2769,7 +2850,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2852,11 +2732,11 @@ public class SQLUtilsTest {\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(8, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2744,7 +2747,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(8, Types.DOUBLE);\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2814,13 +2752,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(6, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2766,7 +2783,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2783,7 +2864,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2865,12 +2745,12 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 39fb99d55d..d26faf75c0 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2743,13 +2814,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(6, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "20b989f9983bb72dd3f3cc88252d9536fe835c06", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2814,13 +2752,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(6, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2766,7 +2783,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2783,7 +2864,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2865,12 +2745,12 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2828,13 +2766,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(6, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(7, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2780,7 +2797,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2797,7 +2878,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2879,10 +2759,10 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2770,7 +2773,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "0af9cfc5e0f754b22b161685e9e88103c4f6ba52", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 1df0cb6d82..b0647c0e8d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2779,7 +2760,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n \t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n-\t\n+\t\t\n \t@Test\n \tpublic void testCreateInsertViewFromSnapshot() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n", "next_change": {"commit": "84f28d490efd3738bb0360a7b40b47ca2c48c5ee", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b0647c0e8d..240f8f9076 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2762,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertViewFromSnapshot() {\n+\tpublic void testCreateInsertStatement() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertViewFromSnapshot(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": {"commit": "2640fe980b0d54b832bbe8656c77ea71737099e6", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 240f8f9076..9476b125f3 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2788,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertStatement() {\n+\tpublic void testCreateInsertIntoTableIndex() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertIntoTableIndex(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 6b56ca7a7e..39fb99d55d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2637,13 +2743,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(6, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "73b5c657d9a6747dcbb86596c082f07f1941f4ab", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 39fb99d55d..d26faf75c0 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2743,13 +2814,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(6, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "20b989f9983bb72dd3f3cc88252d9536fe835c06", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2814,13 +2752,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"123.456\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\t// value can be a double\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(6, 123.456);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(7, 123.456);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setNull(7, Types.VARCHAR);\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.VARCHAR);\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2766,7 +2783,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2783,7 +2864,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n \t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2865,12 +2745,12 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(8, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2828,13 +2766,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(6, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(7, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2780,7 +2797,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2797,7 +2878,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2879,10 +2759,10 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2770,7 +2773,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "0af9cfc5e0f754b22b161685e9e88103c4f6ba52", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 1df0cb6d82..b0647c0e8d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2779,7 +2760,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n \t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n-\t\n+\t\t\n \t@Test\n \tpublic void testCreateInsertViewFromSnapshot() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n", "next_change": {"commit": "84f28d490efd3738bb0360a7b40b47ca2c48c5ee", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b0647c0e8d..240f8f9076 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2762,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertViewFromSnapshot() {\n+\tpublic void testCreateInsertStatement() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertViewFromSnapshot(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": {"commit": "2640fe980b0d54b832bbe8656c77ea71737099e6", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 240f8f9076..9476b125f3 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2788,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertStatement() {\n+\tpublic void testCreateInsertIntoTableIndex() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertIntoTableIndex(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 39fb99d55d..d26faf75c0 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2757,13 +2828,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n+\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(7, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "20b989f9983bb72dd3f3cc88252d9536fe835c06", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2828,13 +2766,13 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"NAN\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\t// the approximation of NaN is null.\n-\t\tverify(mockPreparedStatement).setNull(6, Types.DOUBLE);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.DOUBLE);\n \t\t// 7 is the abstract enum for doubles.  Null since this is a finite value\n-\t\tverify(mockPreparedStatement).setString(7, AbstractDouble.NAN.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NAN.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2780,7 +2797,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2797,7 +2878,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2879,10 +2759,10 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2770,7 +2773,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "0af9cfc5e0f754b22b161685e9e88103c4f6ba52", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 1df0cb6d82..b0647c0e8d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2779,7 +2760,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n \t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n-\t\n+\t\t\n \t@Test\n \tpublic void testCreateInsertViewFromSnapshot() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n", "next_change": {"commit": "84f28d490efd3738bb0360a7b40b47ca2c48c5ee", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b0647c0e8d..240f8f9076 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2762,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertViewFromSnapshot() {\n+\tpublic void testCreateInsertStatement() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertViewFromSnapshot(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": {"commit": "2640fe980b0d54b832bbe8656c77ea71737099e6", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 240f8f9076..9476b125f3 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2788,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertStatement() {\n+\tpublic void testCreateInsertIntoTableIndex() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertIntoTableIndex(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex d26faf75c0..0dd868516c 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2842,11 +2780,11 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(5, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(6, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n-\t\tverify(mockPreparedStatement).setString(7, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(8, Types.BOOLEAN);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n+\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "d23dc0751d44f995f8a95b92375719b66d2aeee4", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2780,7 +2797,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2797,7 +2878,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2879,10 +2759,10 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2758,7 +2761,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"+Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.POSITIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.POSITIVE_INFINITY.getEnumerationValue());\n", "next_change": null}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2770,7 +2773,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "0af9cfc5e0f754b22b161685e9e88103c4f6ba52", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 1df0cb6d82..b0647c0e8d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2779,7 +2760,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n \t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n-\t\n+\t\t\n \t@Test\n \tpublic void testCreateInsertViewFromSnapshot() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n", "next_change": {"commit": "84f28d490efd3738bb0360a7b40b47ca2c48c5ee", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b0647c0e8d..240f8f9076 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2762,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertViewFromSnapshot() {\n+\tpublic void testCreateInsertStatement() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertViewFromSnapshot(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": {"commit": "2640fe980b0d54b832bbe8656c77ea71737099e6", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 240f8f9076..9476b125f3 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2788,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertStatement() {\n+\tpublic void testCreateInsertIntoTableIndex() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertIntoTableIndex(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 0dd868516c..dc1430577d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2792,7 +2809,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "d2fc3185473ad57494bd2f529ff27afa96b01d54", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex dc1430577d..9ede67eb74 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2809,7 +2890,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ViewObjectType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "73a3785daef231cd8aaa581233ab77cb71f4ffa5", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 9ede67eb74..b4ab3b17a6 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2891,10 +2771,10 @@ public class SQLUtilsTest {\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n \t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n-\t\tverify(mockPreparedStatement).setNull(6, Types.BIGINT);\n-\t\tverify(mockPreparedStatement).setDouble(7, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n-\t\tverify(mockPreparedStatement).setString(8, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n-\t\tverify(mockPreparedStatement).setNull(9, Types.BOOLEAN);\n+\t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n+\t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n+\t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n+\t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n \t\n \t@Test\n", "next_change": {"commit": "c3678a8662056ff066d1e7bc5bd250bf98eda68a", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b4ab3b17a6..1df0cb6d82 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2770,7 +2773,7 @@ public class SQLUtilsTest {\n \t\t// string value\n \t\tannotationDto.setValue(\"-Infinity\");\n \t\t// Call under test\n-\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(MainType.ENTITY, mockPreparedStatement, annotationDto);\n+\t\tSQLUtils.writeAnnotationDtoToPreparedStatement(ReplicationType.ENTITY, mockPreparedStatement, annotationDto);\n \t\tverify(mockPreparedStatement).setNull(7, Types.BIGINT);\n \t\tverify(mockPreparedStatement).setDouble(8, AbstractDouble.NEGATIVE_INFINITY.getApproximateValue());\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n", "next_change": {"commit": "0af9cfc5e0f754b22b161685e9e88103c4f6ba52", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 1df0cb6d82..b0647c0e8d 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2779,7 +2760,7 @@ public class SQLUtilsTest {\n \t\tverify(mockPreparedStatement).setString(9, AbstractDouble.NEGATIVE_INFINITY.getEnumerationValue());\n \t\tverify(mockPreparedStatement).setNull(10, Types.BOOLEAN);\n \t}\n-\t\n+\t\t\n \t@Test\n \tpublic void testCreateInsertViewFromSnapshot() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n", "next_change": {"commit": "84f28d490efd3738bb0360a7b40b47ca2c48c5ee", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex b0647c0e8d..240f8f9076 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2762,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertViewFromSnapshot() {\n+\tpublic void testCreateInsertStatement() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertViewFromSnapshot(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": {"commit": "2640fe980b0d54b832bbe8656c77ea71737099e6", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\nindex 240f8f9076..9476b125f3 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/SQLUtilsTest.java\n", "chunk": "@@ -2788,11 +2788,11 @@ public class SQLUtilsTest {\n \t}\n \t\t\n \t@Test\n-\tpublic void testCreateInsertStatement() {\n+\tpublic void testCreateInsertIntoTableIndex() {\n \t\tString[] headers = new String[] {\"foo\",\"bar\"};\n \t\ttableId = IdAndVersion.parse(\"syn999.23\");\n \t\t// call under test\n-\t\tString sql = SQLUtils.createInsertStatement(tableId, headers);\n+\t\tString sql = SQLUtils.createInsertIntoTableIndex(tableId, headers);\n \t\tassertEquals(\"INSERT INTO T999_23 (foo,bar) VALUES  (?,?)\", sql);\n \t}\n \t\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY1MTg5OQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/3890#discussion_r367651899", "body": "first annotation should not be a list.", "bodyText": "first annotation should not be a list.", "bodyHTML": "<p dir=\"auto\">first annotation should not be a list.</p>", "author": "john-hill", "createdAt": "2020-01-16T21:11:55Z", "path": "lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java", "diffHunk": "@@ -1839,28 +1866,84 @@ public void testCaseSensitiveAnnotationNamesPLFM_5449() {\n \t\t// call under test\r\n \t\ttableIndexDAO.addEntityData(Lists.newArrayList(file1));\r\n \t}\r\n+\r\n+\t//PLFM-6013\r\n+\t@Test\r\n+\tpublic void testGetPossibleAnnotationsForContainers_ListColumns(){\r\n+\t\t// delete all data\r\n+\t\ttableIndexDAO.deleteEntityData(Lists.newArrayList(2L,3L));\r\n+\r\n+\r\n+\t\tString annoKey = \"myAnnotation\";\r\n+\r\n+\t\t// setup some hierarchy.\r\n+\t\tEntityDTO file1 = createEntityDTO(2L, EntityType.file, 0);\r\n+\t\tfile1.setParentId(333L);\r\n+\r", "originalCommit": "e259094809a45fa367568fe95142fa5c27e69d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "963cc4fc5fb829450c173871c2e554064d9027d1", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\nindex 069ace91ab..ad5b2c223b 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n", "chunk": "@@ -1866,51 +1839,6 @@ public class TableIndexDAOImplTest {\n \t\t// call under test\n \t\ttableIndexDAO.addEntityData(Lists.newArrayList(file1));\n \t}\n-\n-\t//PLFM-6013\n-\t@Test\n-\tpublic void testGetPossibleAnnotationsForContainers_ListColumns(){\n-\t\t// delete all data\n-\t\ttableIndexDAO.deleteEntityData(Lists.newArrayList(2L,3L));\n-\n-\n-\t\tString annoKey = \"myAnnotation\";\n-\n-\t\t// setup some hierarchy.\n-\t\tEntityDTO file1 = createEntityDTO(2L, EntityType.file, 0);\n-\t\tfile1.setParentId(333L);\n-\n-\t\tAnnotationDTO annotationDTO1 = new AnnotationDTO();\n-\t\tannotationDTO1.setKey(annoKey);\n-\t\tannotationDTO1.setType(AnnotationType.STRING);\n-\t\tannotationDTO1.setEntityId(2L);\n-\t\tannotationDTO1.setValue(Arrays.asList(\"123\", \"123456\"));\n-\t\tfile1.setAnnotations(Collections.singletonList(annotationDTO1));\n-\n-\t\tEntityDTO file2 = createEntityDTO(3L, EntityType.file, 0);\n-\t\tfile2.setParentId(222L);\n-\t\tAnnotationDTO annotationDTO2 = new AnnotationDTO();\n-\t\tannotationDTO2.setKey(annoKey);\n-\t\tannotationDTO2.setType(AnnotationType.STRING);\n-\t\tannotationDTO2.setEntityId(3L);\n-\t\tannotationDTO2.setValue(Arrays.asList(\"12\", \"1234\"));\n-\t\tfile2.setAnnotations(Collections.singletonList(annotationDTO2));\n-\n-\t\ttableIndexDAO.addEntityData(Lists.newArrayList(file1, file2));\n-\n-\t\tSet<Long> containerIds = Sets.newHashSet(222L, 333L);\n-\t\tlong limit = 5;\n-\t\tlong offset = 0;\n-\t\tList<ColumnModel> columns = tableIndexDAO.getPossibleColumnModelsForContainers(containerIds, ViewTypeMask.File.getMask(), limit, offset);\n-\t\tassertNotNull(columns);\n-\t\tassertEquals(1, columns.size());\n-\n-\t\tColumnModel cm = columns.get(0);\n-\t\tassertEquals(annoKey, cm.getName());\n-\t\tassertEquals(ColumnType.STRING_LIST, cm.getColumnType());\n-\t\tassertEquals(6L, cm.getMaximumSize());\n-\n-\t}\n \t\n \t@Test\n \tpublic void testExpandFromAggregation() {\n", "next_change": {"commit": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\nindex ad5b2c223b..439ae3bc9f 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n", "chunk": "@@ -1839,6 +1866,60 @@ public class TableIndexDAOImplTest {\n \t\t// call under test\n \t\ttableIndexDAO.addEntityData(Lists.newArrayList(file1));\n \t}\n+\n+\t//PLFM-6013\n+\t@Test\n+\tpublic void testGetPossibleAnnotationsForContainers_ListColumns(){\n+\t\t// delete all data\n+\t\ttableIndexDAO.deleteEntityData(Lists.newArrayList(2L,3L));\n+\n+\n+\t\tString annoKey = \"myAnnotation\";\n+\n+\t\t// setup some hierarchy.\n+\t\tEntityDTO file1 = createEntityDTO(2L, EntityType.file, 0);\n+\t\tfile1.setParentId(333L);\n+\n+\t\tAnnotationDTO annotationDTO1 = new AnnotationDTO();\n+\t\tannotationDTO1.setKey(annoKey);\n+\t\tannotationDTO1.setType(AnnotationType.STRING);\n+\t\tannotationDTO1.setEntityId(2L);\n+\t\tannotationDTO1.setValue(Arrays.asList(\"123\"));\n+\t\tfile1.setAnnotations(Collections.singletonList(annotationDTO1));\n+\n+\t\tEntityDTO file2 = createEntityDTO(3L, EntityType.file, 0);\n+\t\tfile2.setParentId(222L);\n+\t\tAnnotationDTO annotationDTO2 = new AnnotationDTO();\n+\t\tannotationDTO2.setKey(annoKey);\n+\t\tannotationDTO2.setType(AnnotationType.STRING);\n+\t\tannotationDTO2.setEntityId(3L);\n+\t\tannotationDTO2.setValue(Arrays.asList(\"12\",  \"123456\", \"1234\"));\n+\t\tfile2.setAnnotations(Collections.singletonList(annotationDTO2));\n+\n+\t\tEntityDTO file3 = createEntityDTO(4L, EntityType.file, 0);\n+\t\tfile3.setParentId(222L);\n+\t\tAnnotationDTO annotationDTO3 = new AnnotationDTO();\n+\t\tannotationDTO3.setKey(annoKey);\n+\t\tannotationDTO3.setType(AnnotationType.STRING);\n+\t\tannotationDTO3.setEntityId(3L);\n+\t\tannotationDTO3.setValue(Arrays.asList(\"12345\"));\n+\t\tfile3.setAnnotations(Collections.singletonList(annotationDTO3));\n+\n+\t\ttableIndexDAO.addEntityData(Lists.newArrayList(file1, file2));\n+\n+\t\tSet<Long> containerIds = Sets.newHashSet(222L, 333L);\n+\t\tlong limit = 5;\n+\t\tlong offset = 0;\n+\t\tList<ColumnModel> columns = tableIndexDAO.getPossibleColumnModelsForContainers(containerIds, ViewTypeMask.File.getMask(), limit, offset);\n+\t\tassertNotNull(columns);\n+\t\tassertEquals(1, columns.size());\n+\n+\t\tColumnModel cm = columns.get(0);\n+\t\tassertEquals(annoKey, cm.getName());\n+\t\tassertEquals(ColumnType.STRING_LIST, cm.getColumnType());\n+\t\tassertEquals(6L, cm.getMaximumSize());\n+\n+\t}\n \t\n \t@Test\n \tpublic void testExpandFromAggregation() {\n", "next_change": null}, {"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\nindex ad5b2c223b..439ae3bc9f 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n", "chunk": "@@ -1846,21 +1927,32 @@ public class TableIndexDAOImplTest {\n \t\tColumnAggregation one = new ColumnAggregation();\n \t\tone.setColumnName(\"foo\");\n \t\tone.setColumnTypeConcat(concatTypes(AnnotationType.STRING, AnnotationType.DOUBLE));\n-\t\tone.setMaxSize(101L);\n-\t\t\n+\t\tone.setMaxStringElementSize(101L);\n+\t\tone.setMaxListSize(1L);\n+\n+\n \t\tColumnAggregation two = new ColumnAggregation();\n \t\ttwo.setColumnName(\"bar\");\n \t\ttwo.setColumnTypeConcat(concatTypes(AnnotationType.DOUBLE, AnnotationType.LONG));\n-\t\ttwo.setMaxSize(0L);\n-\t\t\n+\t\ttwo.setMaxStringElementSize(0L);\n+\t\ttwo.setMaxListSize(1L);\n+\n+\n \t\tColumnAggregation three = new ColumnAggregation();\n \t\tthree.setColumnName(\"foobar\");\n \t\tthree.setColumnTypeConcat(concatTypes(AnnotationType.STRING));\n-\t\tthree.setMaxSize(202L);\n+\t\tthree.setMaxStringElementSize(202L);\n+\t\tthree.setMaxListSize(1L);\n+\n+\t\tColumnAggregation four = new ColumnAggregation();\n+\t\tfour.setColumnName(\"barbaz\");\n+\t\tfour.setColumnTypeConcat(concatTypes(AnnotationType.STRING));\n+\t\tfour.setMaxStringElementSize(111L);\n+\t\tfour.setMaxListSize(3L);\n \n \t\t// call under test\n-\t\tList<ColumnModel> results = TableIndexDAOImpl.expandFromAggregation(Lists.newArrayList(one,two,three));\n-\t\tassertEquals(5, results.size());\n+\t\tList<ColumnModel> results = TableIndexDAOImpl.expandFromAggregation(Lists.newArrayList(one,two,three,four));\n+\t\tassertEquals(6, results.size());\n \t\t// zero\n \t\tColumnModel cm = results.get(0);\n \t\tassertEquals(\"foo\", cm.getName());\n", "next_change": {"commit": "706b99c206fc2b1e82c9c63a6a0f1d1881894094", "changed_code": [{"header": "diff --git a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\nindex 439ae3bc9f..3fa7941ccc 100644\n--- a/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n+++ b/lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java\n", "chunk": "@@ -1957,31 +2148,37 @@ public class TableIndexDAOImplTest {\n \t\tColumnModel cm = results.get(0);\n \t\tassertEquals(\"foo\", cm.getName());\n \t\tassertEquals(ColumnType.STRING, cm.getColumnType());\n+\t\tassertNull(cm.getMaximumListLength());\n \t\tassertEquals(new Long(101), cm.getMaximumSize());\n \t\t// one\n \t\tcm = results.get(1);\n \t\tassertEquals(\"foo\", cm.getName());\n \t\tassertEquals(ColumnType.DOUBLE, cm.getColumnType());\n+\t\tassertNull(cm.getMaximumListLength());\n \t\tassertEquals(null, cm.getMaximumSize());\n \t\t// two\n \t\tcm = results.get(2);\n \t\tassertEquals(\"bar\", cm.getName());\n \t\tassertEquals(ColumnType.DOUBLE, cm.getColumnType());\n+\t\tassertNull(cm.getMaximumListLength());\n \t\tassertEquals(null, cm.getMaximumSize());\n \t\t// three\n \t\tcm = results.get(3);\n \t\tassertEquals(\"bar\", cm.getName());\n \t\tassertEquals(ColumnType.INTEGER, cm.getColumnType());\n+\t\tassertNull(cm.getMaximumListLength());\n \t\tassertEquals(null, cm.getMaximumSize());\n \t\t// four\n \t\tcm = results.get(4);\n \t\tassertEquals(\"foobar\", cm.getName());\n \t\tassertEquals(ColumnType.STRING, cm.getColumnType());\n+\t\tassertNull(cm.getMaximumListLength());\n \t\tassertEquals(new Long(202), cm.getMaximumSize());\n \t\t// five\n \t\tcm = results.get(5);\n \t\tassertEquals(\"barbaz\", cm.getName());\n \t\tassertEquals(ColumnType.STRING_LIST, cm.getColumnType());\n+\t\tassertEquals(3L, cm.getMaximumListLength());\n \t\tassertEquals(new Long(111), cm.getMaximumSize());\n \t}\n \t\n", "next_change": null}]}}]}}]}}, {"oid": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "message": "fix bug in ColumnType suggestion and other code review changes", "committedDate": "2020-01-16T21:53:29Z", "type": "commit"}, {"oid": "e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e6b5f02e62e966cdc9edf3d4b626e5e11296a671", "message": "fix bug in ColumnType suggestion and other code review changes", "committedDate": "2020-01-16T21:53:29Z", "type": "forcePushed"}]}