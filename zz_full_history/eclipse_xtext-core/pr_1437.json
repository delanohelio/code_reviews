{"pr_number": 1437, "pr_title": "[eclipse/xtext#1679] Refactor more Xtend to java.", "pr_author": "ArneDeutsch", "pr_createdAt": "2020-04-03T08:40:20Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1437", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDQzMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402854431", "body": "This was already Java on master. Let's see if we do have any semantic changes :)", "bodyText": "This was already Java on master. Let's see if we do have any semantic changes :)", "bodyHTML": "<p dir=\"auto\">This was already Java on master. Let's see if we do have any semantic changes :)</p>", "author": "szarnekow", "createdAt": "2020-04-03T08:55:55Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -155,20 +83,19 @@ public boolean isPortableURIFragment(String uriFragment) {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -83,19 +155,20 @@ public class PortableURIs {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n \t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n \t\tmock.setEType(desc.descriptionEClass);\n-\t\tIScope scope = globalScopeProvider.getScope(resource, mock, alwaysTrue());\n-\t\tIEObjectDescription description = head(scope.getElements(desc.descriptionQualifiedName));\n-\t\tif (description == null)\n-\t\t\treturn null;\n-\t\tEObject container = EcoreUtil.resolve(description.getEObjectOrProxy(), resource);\n-\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\tIScope scope = globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream( //\n+\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d -> {\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n \t}\n \n \t/**\n-\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n \t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n \t * exported EObject.\n \t * \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NTU4Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402855586", "body": "this reverts the fixed comment", "bodyText": "this reverts the fixed comment", "bodyHTML": "<p dir=\"auto\">this reverts the fixed comment</p>", "author": "szarnekow", "createdAt": "2020-04-03T08:57:14Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -155,20 +83,19 @@ public boolean isPortableURIFragment(String uriFragment) {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);\n \t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n \t\tmock.setEType(desc.descriptionEClass);\n-\t\tIScope scope = globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n-\t\tOptional<IEObjectDescription> description = Streams.stream( //\n-\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n-\t\treturn description.map(d -> {\n-\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n-\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n-\t\t}).orElse(null);\n+\t\tIScope scope = globalScopeProvider.getScope(resource, mock, alwaysTrue());\n+\t\tIEObjectDescription description = head(scope.getElements(desc.descriptionQualifiedName));\n+\t\tif (description == null)\n+\t\t\treturn null;\n+\t\tEObject container = EcoreUtil.resolve(description.getEObjectOrProxy(), resource);\n+\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n \t}\n \n \t/**\n-\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -83,19 +155,20 @@ public class PortableURIs {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n \t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n \t\tmock.setEType(desc.descriptionEClass);\n-\t\tIScope scope = globalScopeProvider.getScope(resource, mock, alwaysTrue());\n-\t\tIEObjectDescription description = head(scope.getElements(desc.descriptionQualifiedName));\n-\t\tif (description == null)\n-\t\t\treturn null;\n-\t\tEObject container = EcoreUtil.resolve(description.getEObjectOrProxy(), resource);\n-\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\tIScope scope = globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream( //\n+\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d -> {\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n \t}\n \n \t/**\n-\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n \t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n \t * exported EObject.\n \t * \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjAwNA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402856004", "body": "Version on master appears to be cleaner and has the original source comment.", "bodyText": "Version on master appears to be cleaner and has the original source comment.", "bodyHTML": "<p dir=\"auto\">Version on master appears to be cleaner and has the original source comment.</p>", "author": "szarnekow", "createdAt": "2020-04-03T08:57:42Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -180,16 +107,15 @@ public EObject resolve(StorageAwareResource resource, String portableFragment) {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n-\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n-\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n-\t\tif (object == null || object.eResource().getResourceSet() != null) {\n-\t\t\treturn toPortableURI(sourceResource, object);\n-\t\t}\n+\t\tResource resource = sourceResource.getResourceSet().getResource(targetURI.trimFragment(), false);", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -107,15 +180,16 @@ public class PortableURIs {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n-\t\tResource resource = sourceResource.getResourceSet().getResource(targetURI.trimFragment(), false);\n-\t\tEObject to = resource == null ? null : resource.getEObject(targetURI.fragment());\n-\t\tif (to == null || (to.eResource() != null && to.eResource().getResourceSet() != null))\n-\t\t\treturn toPortableURI(sourceResource, to);\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n \t\treturn null;\n \t}\n \n \t/**\n-\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> if no portable URI can be\n \t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n \t * \n \t * @param sourceResource\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjM2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402856361", "body": "I prefer the curly braces on master", "bodyText": "I prefer the curly braces on master", "bodyHTML": "<p dir=\"auto\">I prefer the curly braces on master</p>", "author": "szarnekow", "createdAt": "2020-04-03T08:58:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -200,13 +126,11 @@ public URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n-\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\tif (targetObject == null || targetObject.eIsProxy())", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -126,11 +200,13 @@ public class PortableURIs {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n-\t\tif (targetObject == null || targetObject.eIsProxy())\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n \t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n \t\tString portableFragment = getPortableURIFragment(targetObject);\n-\t\tif (portableFragment != null)\n+\t\tif (portableFragment != null) {\n \t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n \t\treturn null;\n \t}\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NzMwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402857303", "body": "isAncestor does this check already", "bodyText": "isAncestor does this check already", "bodyHTML": "<p dir=\"auto\">isAncestor does this check already</p>", "author": "szarnekow", "createdAt": "2020-04-03T08:59:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -141,44 +217,52 @@ public class PortableURIs {\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null)\n+\t\tif (desc == null) {\n \t\t\treturn null;\n-\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t});\n-\t\tif (containerDesc != null)\n-\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n-\t\treturn null;\n+\t\t}\n+\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t}).map(containerDesc -> {\n+\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n+\t\t\treturn toFragmentString(fragmentDescription);\n+\t\t}).findFirst().orElse(null);\n \t}\n \n-\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n+\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n+\t\t\tEObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n+\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n+\t\t\t\tfragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n-\t\tif (desc.descriptionRelativeFragment != null)\n+\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n+\t\tif (desc.descriptionRelativeFragment != null) {\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n+\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n \t\tIterator<String> segments = Splitter.on(\"#\").split(fragmentString).iterator();\n-\t\tsegments.next();\n+\t\tsegments.next(); // skip first\n \t\tURI eClassURI = URI.createURI(URI.decode(segments.next()));\n-\t\tEPackage ePackage = packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n-\t\tResource eResource = ePackage == null ? null : ePackage.eResource();\n-\t\tEClass eClass = (EClass) (eResource == null ? null : eResource.getEObject(eClassURI.fragment()));\n-\t\tQualifiedName qname = QualifiedName.create(toList(Splitter.on(\":\").split(URI.decode(segments.next()))));\n+\t\tEPackage ePackage = this.packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n+\t\tEClass eClass = EcorePackage.Literals.EOBJECT;\n+\t\tif (ePackage != null) {\n+\t\t\tResource resource = ePackage.eResource();\n+\t\t\tif (resource != null) {\n+\t\t\t\teClass = (EClass) resource.getEObject(eClassURI.fragment());\n+\t\t\t}\n+\t\t}\n+\t\tQualifiedName qname = QualifiedName.create(Splitter.on(\":\").splitToList(URI.decode(segments.next())));\n \t\tString fragment = segments.hasNext() ? URI.decode(segments.next()) : null;\n-\t\treturn new PortableFragmentDescription(eClass == null ? EcorePackage.Literals.EOBJECT : eClass, qname,\n-\t\t\t\tfragment);\n+\t\treturn new PortableURIs.PortableFragmentDescription(eClass, qname, fragment);\n \t}\n \n \t/**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1Nzg1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402857855", "body": "Not sure if I like IterableExtensions being used here given that this class was already reviewed and ported to Java a few days ago", "bodyText": "Not sure if I like IterableExtensions being used here given that this class was already reviewed and ported to Java a few days ago", "bodyHTML": "<p dir=\"auto\">Not sure if I like IterableExtensions being used here given that this class was already reviewed and ported to Java a few days ago</p>", "author": "szarnekow", "createdAt": "2020-04-03T08:59:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -8,9 +8,12 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n+import static com.google.common.base.Predicates.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -8,12 +8,9 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n-import static com.google.common.base.Predicates.*;\n-import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n-\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Objects;\n+import java.util.Optional;\n \n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.EClass;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODMyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858323", "body": "I prefer the version on master.", "bodyText": "I prefer the version on master.", "bodyHTML": "<p dir=\"auto\">I prefer the version on master.</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:00:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t});\n+\t\tif (containerDesc != null)\n+\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n+\t\treturn null;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n-\t\t\tEObject target) {\n+\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n-\t\t\t\tfragmentToTarget);\n+\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n-\t\tif (desc.descriptionRelativeFragment != null) {\n+\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n+\t\tif (desc.descriptionRelativeFragment != null)\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n-\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -141,44 +217,52 @@ public class PortableURIs {\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null)\n+\t\tif (desc == null) {\n \t\t\treturn null;\n-\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t});\n-\t\tif (containerDesc != null)\n-\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n-\t\treturn null;\n+\t\t}\n+\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t}).map(containerDesc -> {\n+\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n+\t\t\treturn toFragmentString(fragmentDescription);\n+\t\t}).findFirst().orElse(null);\n \t}\n \n-\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n+\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n+\t\t\tEObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n+\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n+\t\t\t\tfragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n-\t\tif (desc.descriptionRelativeFragment != null)\n+\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n+\t\tif (desc.descriptionRelativeFragment != null) {\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n+\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n \t\tIterator<String> segments = Splitter.on(\"#\").split(fragmentString).iterator();\n-\t\tsegments.next();\n+\t\tsegments.next(); // skip first\n \t\tURI eClassURI = URI.createURI(URI.decode(segments.next()));\n-\t\tEPackage ePackage = packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n-\t\tResource eResource = ePackage == null ? null : ePackage.eResource();\n-\t\tEClass eClass = (EClass) (eResource == null ? null : eResource.getEObject(eClassURI.fragment()));\n-\t\tQualifiedName qname = QualifiedName.create(toList(Splitter.on(\":\").split(URI.decode(segments.next()))));\n+\t\tEPackage ePackage = this.packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n+\t\tEClass eClass = EcorePackage.Literals.EOBJECT;\n+\t\tif (ePackage != null) {\n+\t\t\tResource resource = ePackage.eResource();\n+\t\t\tif (resource != null) {\n+\t\t\t\teClass = (EClass) resource.getEObject(eClassURI.fragment());\n+\t\t\t}\n+\t\t}\n+\t\tQualifiedName qname = QualifiedName.create(Splitter.on(\":\").splitToList(URI.decode(segments.next())));\n \t\tString fragment = segments.hasNext() ? URI.decode(segments.next()) : null;\n-\t\treturn new PortableFragmentDescription(eClass == null ? EcorePackage.Literals.EOBJECT : eClass, qname,\n-\t\t\t\tfragment);\n+\t\treturn new PortableURIs.PortableFragmentDescription(eClass, qname, fragment);\n \t}\n \n \t/**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODU0NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858545", "body": "Could use the short class name for the inner type, though.", "bodyText": "Could use the short class name for the inner type, though.", "bodyHTML": "<p dir=\"auto\">Could use the short class name for the inner type, though.</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:00:33Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t});\n+\t\tif (containerDesc != null)\n+\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n+\t\treturn null;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n-\t\t\tEObject target) {\n+\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n-\t\t\t\tfragmentToTarget);\n+\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n-\t\tif (desc.descriptionRelativeFragment != null) {\n+\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n+\t\tif (desc.descriptionRelativeFragment != null)\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n-\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {\n \t\tIterator<String> segments = Splitter.on(\"#\").split(fragmentString).iterator();\n-\t\tsegments.next(); // skip first\n+\t\tsegments.next();\n \t\tURI eClassURI = URI.createURI(URI.decode(segments.next()));\n-\t\tEPackage ePackage = this.packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n-\t\tEClass eClass = EcorePackage.Literals.EOBJECT;\n-\t\tif (ePackage != null) {\n-\t\t\tResource resource = ePackage.eResource();\n-\t\t\tif (resource != null) {\n-\t\t\t\teClass = (EClass) resource.getEObject(eClassURI.fragment());\n-\t\t\t}\n-\t\t}\n-\t\tQualifiedName qname = QualifiedName.create(Splitter.on(\":\").splitToList(URI.decode(segments.next())));\n+\t\tEPackage ePackage = packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n+\t\tResource eResource = ePackage == null ? null : ePackage.eResource();\n+\t\tEClass eClass = (EClass) (eResource == null ? null : eResource.getEObject(eClassURI.fragment()));\n+\t\tQualifiedName qname = QualifiedName.create(toList(Splitter.on(\":\").split(URI.decode(segments.next()))));\n \t\tString fragment = segments.hasNext() ? URI.decode(segments.next()) : null;\n-\t\treturn new PortableURIs.PortableFragmentDescription(eClass, qname, fragment);\n+\t\treturn new PortableFragmentDescription(eClass == null ? EcorePackage.Literals.EOBJECT : eClass, qname,", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -141,44 +217,52 @@ public class PortableURIs {\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null)\n+\t\tif (desc == null) {\n \t\t\treturn null;\n-\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t});\n-\t\tif (containerDesc != null)\n-\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n-\t\treturn null;\n+\t\t}\n+\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t}).map(containerDesc -> {\n+\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n+\t\t\treturn toFragmentString(fragmentDescription);\n+\t\t}).findFirst().orElse(null);\n \t}\n \n-\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n+\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n+\t\t\tEObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n+\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n+\t\t\t\tfragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n-\t\tif (desc.descriptionRelativeFragment != null)\n+\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n+\t\tif (desc.descriptionRelativeFragment != null) {\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n+\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n \t\tIterator<String> segments = Splitter.on(\"#\").split(fragmentString).iterator();\n-\t\tsegments.next();\n+\t\tsegments.next(); // skip first\n \t\tURI eClassURI = URI.createURI(URI.decode(segments.next()));\n-\t\tEPackage ePackage = packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n-\t\tResource eResource = ePackage == null ? null : ePackage.eResource();\n-\t\tEClass eClass = (EClass) (eResource == null ? null : eResource.getEObject(eClassURI.fragment()));\n-\t\tQualifiedName qname = QualifiedName.create(toList(Splitter.on(\":\").split(URI.decode(segments.next()))));\n+\t\tEPackage ePackage = this.packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n+\t\tEClass eClass = EcorePackage.Literals.EOBJECT;\n+\t\tif (ePackage != null) {\n+\t\t\tResource resource = ePackage.eResource();\n+\t\t\tif (resource != null) {\n+\t\t\t\teClass = (EClass) resource.getEObject(eClassURI.fragment());\n+\t\t\t}\n+\t\t}\n+\t\tQualifiedName qname = QualifiedName.create(Splitter.on(\":\").splitToList(URI.decode(segments.next())));\n \t\tString fragment = segments.hasNext() ? URI.decode(segments.next()) : null;\n-\t\treturn new PortableFragmentDescription(eClass == null ? EcorePackage.Literals.EOBJECT : eClass, qname,\n-\t\t\t\tfragment);\n+\t\treturn new PortableURIs.PortableFragmentDescription(eClass, qname, fragment);\n \t}\n \n \t/**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODgxMg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858812", "body": "This reverts the cleanup that is present on master.", "bodyText": "This reverts the cleanup that is present on master.", "bodyHTML": "<p dir=\"auto\">This reverts the cleanup that is present on master.</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:00:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -276,10 +192,21 @@ protected String toFragmentString(PortableURIs.PortableFragmentDescription desc)\n \t * @return a fragment path from the given container to the child, or <code>null</null> is fromContainer == toChild\n \t * \n \t * @see #getEObject(EObject,String)\n-\t * @throws IllegalArgumentException if the child is not a child of the given container.\n \t */\n-\tpublic String getFragment(EObject fromContainer, EObject toChild) throws IllegalArgumentException {\n-\t\treturn Strings.emptyToNull(EcoreUtil.getRelativeURIFragmentPath(fromContainer, toChild));\n+\tpublic String getFragment(EObject fromContainer, EObject toChild) {", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba4d35c23b908a7198073657ff06f289450b194c", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\nindex 02f457616..1ea71fb1c 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java\n", "chunk": "@@ -192,21 +276,10 @@ public class PortableURIs {\n \t * @return a fragment path from the given container to the child, or <code>null</null> is fromContainer == toChild\n \t * \n \t * @see #getEObject(EObject,String)\n+\t * @throws IllegalArgumentException if the child is not a child of the given container.\n \t */\n-\tpublic String getFragment(EObject fromContainer, EObject toChild) {\n-\t\tif (Objects.equals(fromContainer, toChild))\n-\t\t\treturn null;\n-\t\tInternalEObject lastChild = (InternalEObject) toChild;\n-\t\tInternalEObject lastContainer = lastChild.eInternalContainer();\n-\t\tString result = lastContainer.eURIFragmentSegment(lastChild.eContainingFeature(), lastChild);\n-\t\twhile (lastContainer != null && !lastContainer.equals(fromContainer)) {\n-\t\t\tlastChild = lastContainer;\n-\t\t\tlastContainer = lastContainer.eInternalContainer();\n-\t\t\tif (lastContainer == null)\n-\t\t\t\tthrow new IllegalStateException(\"No more containers for element \" + lastChild);\n-\t\t\tresult = lastContainer.eURIFragmentSegment(lastChild.eContainingFeature(), lastChild) + \"/\" + result;\n-\t\t}\n-\t\treturn result;\n+\tpublic String getFragment(EObject fromContainer, EObject toChild) throws IllegalArgumentException {\n+\t\treturn Strings.emptyToNull(EcoreUtil.getRelativeURIFragmentPath(fromContainer, toChild));\n \t}\n \n \t/**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDAwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860001", "body": "IterableExtensions are still being used here. Can this be simplified, e.g. by using FluentIterable or streams?", "bodyText": "IterableExtensions are still being used here. Can this be simplified, e.g. by using FluentIterable or streams?", "bodyHTML": "<p dir=\"auto\">IterableExtensions are still being used here. Can this be simplified, e.g. by using FluentIterable or streams?</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:02:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -56,25 +52,19 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\treturn doesStorageExist(resource);\n \t}\n \n-\t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n-\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n-\t */\n \t@Override\n \tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n \t\ttry {\n-\t\t\tResourceStorageProviderAdapter stateProvider = head(\n-\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tResourceStorageProviderAdapter stateProvider = getResourceStorageProviderAdapter(resourceSet);\n \t\t\tif (stateProvider != null) {\n \t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n \t\t\t\tif (loadable != null)\n \t\t\t\t\treturn loadable;\n \t\t\t}\n-\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\tif (resourceSet.getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n \t\t\t\t\tCollections.emptyMap())) {\n-\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\treturn createResourceStorageLoadable(resourceSet.getURIConverter()\n \t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n \t\t\t}\n \t\t\treturn createResourceStorageLoadable(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDcxMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860711", "body": "`@Pure` can be removed", "bodyText": "@Pure can be removed", "bodyHTML": "<p dir=\"auto\"><code>@Pure</code> can be removed</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:03:13Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\treturn;\n+\t\t}\n+\t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n+\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n+\t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n+\t}\n+\n+\t/**\n+\t * @return whether a stored resource state exists for the given resource\n+\t */\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\tif (stateProvider != null && stateProvider.getResourceStorageLoadable(resource) != null)\n+\t\t\treturn true;\n+\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\tCollections.emptyMap()))\n+\t\t\treturn true;\n+\t\tif (resource.getURI().isArchive())\n+\t\t\treturn false;\n+\t\tURI uri = getFileSystemAccess(resource).getURI(computeOutputPath(resource));\n+\t\treturn uri != null && resource.getResourceSet().getURIConverter().exists(uri, null);\n+\t}\n+\n+\tprotected AbstractFileSystemAccess2 getFileSystemAccess(StorageAwareResource resource) {\n+\t\tAbstractFileSystemAccess2 fsa = fileSystemAccessProvider.get();\n+\t\tfsa.setContext(resource);\n+\t\tfsa.setOutputConfigurations(\n+\t\t\t\ttoMap(outputConfigurationProvider.getOutputConfigurations(resource), it -> it.getName()));\n+\t\treturn fsa;\n+\t}\n+\n+\tprotected String computeOutputPath(StorageAwareResource resource) {\n+\t\treturn getBinaryStorageURI(resource.getURI()).deresolve(getSourceContainerURI(resource), false, false, true)\n+\t\t\t\t.path();\n+\t}\n+\n+\tprotected URI getSourceContainerURI(StorageAwareResource resource) {\n+\t\treturn resource.getURI().trimSegments(1).appendSegment(\"\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasStorageFor(URI uri) {\n+\t\treturn new ExtensibleURIConverterImpl().exists(getBinaryStorageURI(uri), Collections.emptyMap());\n+\t}\n+\n+\tprotected URI getBinaryStorageURI(URI sourceURI) {\n+\t\treturn sourceURI.trimSegments(1).appendSegment(\".\" + sourceURI.lastSegment() + \"bin\");\n+\t}\n+\n+\t@Pure", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -149,7 +144,6 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\treturn sourceURI.trimSegments(1).appendSegment(\".\" + sourceURI.lastSegment() + \"bin\");\n \t}\n \n-\t@Pure\n \tpublic boolean isStoreNodeModel() {\n \t\treturn storeNodeModel;\n \t}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDkwNw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860907", "body": "`@Accessors` can be removed", "bodyText": "@Accessors can be removed", "bodyHTML": "<p dir=\"auto\"><code>@Accessors</code> can be removed</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:03:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -42,12 +42,8 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t@Inject\n \tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n \n-\t@Accessors\n \tprivate boolean storeNodeModel = false;\n \n-\t/**\n-\t * @return whether the given resource should be loaded from stored resource state\n-\t */\n \t@Override\n \tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n \t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MTM1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402861359", "body": "EcoreUtil.getAdapter?", "bodyText": "EcoreUtil.getAdapter?", "bodyHTML": "<p dir=\"auto\">EcoreUtil.getAdapter?</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:03:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\treturn;\n+\t\t}\n+\t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n+\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n+\t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n+\t}\n+\n+\t/**\n+\t * @return whether a stored resource state exists for the given resource\n+\t */\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceStorageProviderAdapter stateProvider = head(", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -106,21 +113,9 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n \t}\n \n-\t/**\n-\t * @return whether a stored resource state exists for the given resource\n-\t */\n-\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n-\t\tResourceStorageProviderAdapter stateProvider = head(\n-\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n-\t\tif (stateProvider != null && stateProvider.getResourceStorageLoadable(resource) != null)\n-\t\t\treturn true;\n-\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n-\t\t\t\tCollections.emptyMap()))\n-\t\t\treturn true;\n-\t\tif (resource.getURI().isArchive())\n-\t\t\treturn false;\n-\t\tURI uri = getFileSystemAccess(resource).getURI(computeOutputPath(resource));\n-\t\treturn uri != null && resource.getResourceSet().getURIConverter().exists(uri, null);\n+\tprotected ResourceStorageProviderAdapter getResourceStorageProviderAdapter(ResourceSet resourceSet) {\n+\t\treturn (ResourceStorageProviderAdapter) EcoreUtil.getExistingAdapter(\n+\t\t\t\tresourceSet, ResourceStorageProviderAdapter.class);\n \t}\n \n \tprotected AbstractFileSystemAccess2 getFileSystemAccess(StorageAwareResource resource) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODc5MA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402868790", "body": "I prefer equals", "bodyText": "I prefer equals", "bodyHTML": "<p dir=\"auto\">I prefer equals</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:13:15Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageProviderAdapter.java", "diffHunk": "@@ -19,7 +19,7 @@\n public class ResourceStorageProviderAdapter extends AdapterImpl {\n \t@Override\n \tpublic boolean isAdapterForType(Object type) {\n-\t\treturn ResourceStorageProviderAdapter.class.equals(type);\n+\t\treturn type == ResourceStorageProviderAdapter.class;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDE1Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402870153", "body": "fieldname should be `uri`", "bodyText": "fieldname should be uri", "bodyHTML": "<p dir=\"auto\">fieldname should be <code>uri</code></p>", "author": "szarnekow", "createdAt": "2020-04-03T09:15:36Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex 7de35aa1c..f1ffad988 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -42,14 +42,14 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \n \tprivate List<QualifiedName> importedNames = Collections.emptyList();\n \n-\tprivate URI uRI;\n+\tprivate URI uri;\n \n \tpublic void updateResourceURI(URI uri) {\n \t\tfor (SerializableReferenceDescription ref : references)\n-\t\t\tref.updateResourceURI(uri, uRI);\n+\t\t\tref.updateResourceURI(uri, this.uri);\n \t\tfor (SerializableEObjectDescription desc : descriptions)\n \t\t\tdesc.updateResourceURI(uri);\n-\t\tuRI = uri;\n+\t\tthis.uri = uri;\n \t}\n \n \t@Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDMzMA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402870330", "body": "parametername should be `uri`", "bodyText": "parametername should be uri", "bodyHTML": "<p dir=\"auto\">parametername should be <code>uri</code></p>", "author": "szarnekow", "createdAt": "2020-04-03T09:15:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex 7de35aa1c..f1ffad988 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -121,20 +121,20 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \t}\n \n \tpublic URI getURI() {\n-\t\treturn uRI;\n+\t\treturn uri;\n \t}\n \n-\tpublic void setURI(URI uRI) {\n-\t\tthis.uRI = uRI;\n+\tpublic void setURI(URI uri) {\n+\t\tthis.uri = uri;\n \t}\n \n \tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n \t\tSerializableResourceDescription description = new SerializableResourceDescription();\n \t\tdescription.setURI(desc.getURI());\n-\t\tdescription.descriptions = toList(\n-\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));\n-\t\tdescription.references = toList(\n-\t\t\t\tmap(desc.getReferenceDescriptions(), it -> SerializableResourceDescription.createCopy(it)));\n+\t\tdescription.descriptions = Lists.newArrayList(\n+\t\t\t\tmap(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n+\t\tdescription.references = Lists.newArrayList(\n+\t\t\t\tmap(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n \t\tdescription.importedNames = Lists.newArrayList(desc.getImportedNames());\n \t\treturn description;\n \t}\n", "next_change": {"commit": "e283b69ab6a27ddd70fa2e89cd5a7e95cfad92d3", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex f1ffad988..248648d28 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -132,9 +132,9 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \t\tSerializableResourceDescription description = new SerializableResourceDescription();\n \t\tdescription.setURI(desc.getURI());\n \t\tdescription.descriptions = Lists.newArrayList(\n-\t\t\t\tmap(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n+\t\t\t\ttransform(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n \t\tdescription.references = Lists.newArrayList(\n-\t\t\t\tmap(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n+\t\t\t\ttransform(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n \t\tdescription.importedNames = Lists.newArrayList(desc.getImportedNames());\n \t\treturn description;\n \t}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTA2Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871067", "body": "I prefer the version on master", "bodyText": "I prefer the version on master", "bodyHTML": "<p dir=\"auto\">I prefer the version on master</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:17:20Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -8,11 +8,12 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95d18858428ed6886e274f745ac8a002f76a2f79", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java\nindex 4e6aa4ee8..fc824e48b 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java\n", "chunk": "@@ -8,12 +8,11 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n-import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n-\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Set;\n \n+import org.eclipse.emf.common.notify.Adapter;\n import org.eclipse.emf.common.notify.impl.AdapterImpl;\n import org.eclipse.emf.common.util.URI;\n import org.eclipse.emf.ecore.resource.ResourceSet;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTI2MA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871260", "body": "I prefer the version on master", "bodyText": "I prefer the version on master", "bodyHTML": "<p dir=\"auto\">I prefer the version on master</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:17:41Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -46,27 +45,25 @@\n \tpublic void load(Map<?, ?> options) throws IOException {\n \t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n \t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n-\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled())", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b4381a2e0dc4dcafe4b19fd15e63a3d5b97a60e", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java\nindex 432841550..9982647d8 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java\n", "chunk": "@@ -41,29 +42,62 @@ public class StorageAwareResource extends LazyLinkingResource {\n \n \tprivate IResourceDescription resourceDescription = null;\n \n+\tprivate static final int STACK_TRACE_LIMIT = 10;\n+\n+\t/**\n+\t * Modify the argument StackOverflowError so that it only retains the first and last {@link #STACK_TRACE_LIMIT}\n+\t * stack trace elements of {@code ex} if it has more than that.\n+\t *\n+\t * @param ex\n+\t *            the StackOverflowError; may get modified\n+\t */\n+\t@SuppressWarnings(\"nls\")\n+\tprivate static void trimStackOverflowErrorStackTrace(final StackOverflowError ex) {\n+\t\tint stackTraceLength = ex.getStackTrace().length;\n+\t\tif (stackTraceLength > STACK_TRACE_LIMIT * 2 + 1) {\n+\t\t\tStackTraceElement[] stackTraceElements = new StackTraceElement[(STACK_TRACE_LIMIT * 2) + 1];\n+\t\t\tSystem.arraycopy(ex.getStackTrace(), 0, stackTraceElements, 0, STACK_TRACE_LIMIT);\n+\t\t\tstackTraceElements[STACK_TRACE_LIMIT] = new StackTraceElement(\"\", \"\\n\\t\\t\\t <Skipped multiple lines> \\n\",\n+\t\t\t\t\tnull, -1);\n+\t\t\tSystem.arraycopy(ex.getStackTrace(), stackTraceLength - STACK_TRACE_LIMIT, stackTraceElements,\n+\t\t\t\t\tSTACK_TRACE_LIMIT + 1, STACK_TRACE_LIMIT);\n+\t\t\tex.setStackTrace(stackTraceElements);\n+\t\t}\n+\t}\n+\t  \n+\tprivate void clearAndUnload() {\n+\t\tif (contents != null) {\n+\t\t\tcontents.clear();\n+\t\t}\n+\t\tif (eAdapters != null) {\n+\t\t\teAdapters.clear();\n+\t\t}\n+\t\tunload();\t\t\n+\t}\n+\t\n \t@Override\n \tpublic void load(Map<?, ?> options) throws IOException {\n \t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n \t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n-\t\t\tif (StorageAwareResource.LOG.isDebugEnabled())\n-\t\t\t\tStorageAwareResource.LOG.debug(\"Loading \" + this.getURI() + \" from storage.\");\n+\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n \t\t\ttry {\n-\t\t\t\tloadFromStorage(resourceStorageFacade.getOrCreateResourceStorageLoadable(this));\n+\t\t\t\tResourceStorageLoadable in = resourceStorageFacade.getOrCreateResourceStorageLoadable(this);\n+\t\t\t\tloadFromStorage(in);\n \t\t\t\treturn;\n \t\t\t} catch (IOException e) {\n-\t\t\t\tif (contents != null)\n-\t\t\t\t\tcontents.clear();\n-\t\t\t\tif (eAdapters != null)\n-\t\t\t\t\teAdapters.clear();\n-\t\t\t\tunload();\n+\t\t\t\tclearAndUnload();\n+\t\t\t} catch (StackOverflowError e) {\n+\t\t\t\ttrimStackOverflowErrorStackTrace(e);\n+\t\t\t\tLOG.warn(\"Failed to load \" + uri + \" from storage\", e); //$NON-NLS-1$//$NON-NLS-2$\n+\t\t\t\tclearAndUnload();\n \t\t\t}\n \t\t}\n \t\tsuper.load(options);\n \t}\n \n \tpublic void loadFromStorage(ResourceStorageLoadable storageInputStream) throws IOException {\n-\t\tif (storageInputStream == null)\n-\t\t\tthrow new NullPointerException(\"storageInputStream\");\n+\t\t// check the argument for null before the internal state is modified\n+\t\tPreconditions.checkNotNull(storageInputStream, \"storageInputStream\");\n \t\tStopwatches.StoppedTask task = Stopwatches.forTask(\"Loading from storage\");\n \t\ttask.start();\n \t\tisLoading = true;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTQ3Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871476", "body": "I prefer the version on matser", "bodyText": "I prefer the version on matser", "bodyHTML": "<p dir=\"auto\">I prefer the version on matser</p>", "author": "szarnekow", "createdAt": "2020-04-03T09:18:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResourceDescriptionManager.java", "diffHunk": "@@ -21,10 +21,9 @@\n \t@Override\n \tpublic IResourceDescription getResourceDescription(Resource resource) {\n \t\tif (resource instanceof StorageAwareResource) {\n-\t\t\tIResourceDescription result = ((StorageAwareResource) resource).getResourceDescription();\n-\t\t\tif (result != null) {\n-\t\t\t\treturn result;\n-\t\t\t}\n+\t\t\tIResourceDescription resourceDescription = ((StorageAwareResource) resource).getResourceDescription();", "originalCommit": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "url": "https://github.com/eclipse/xtext-core/commit/6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-03T09:31:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MDQ4Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403040482", "body": "{@link #shouldLoadFromStorage}", "bodyText": "{@link #shouldLoadFromStorage}", "bodyHTML": "<p dir=\"auto\">{<a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/link/hovercard\" href=\"https://github.com/link\">@link</a> #shouldLoadFromStorage}</p>", "author": "tivervac", "createdAt": "2020-04-03T14:21:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\nindex 83b883c98..61f7cfc7d 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n", "chunk": "@@ -23,20 +23,18 @@ import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n  */\n public interface IResourceStorageFacade {\n \t/**\n-\t * @return whether the given resource should and can be loaded from stored resource state\n+\t * @return whether the given {@link StorageAwareResource resource} should and can be loaded from stored resource state\n \t */\n \tboolean shouldLoadFromStorage(StorageAwareResource resource);\n \n \t/**\n-\t * @return whether storage data exists for the given URI\n+\t * @return whether storage data exists for the given {@link URI}\n \t */\n \tboolean hasStorageFor(URI uri);\n \n \t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n-\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n+\t * Finds or creates a {@link ResourceStorageLoadable} for the given resource. Clients should first call\n+\t * {@link #shouldLoadFromStorage(StorageAwareResource)} to check whether there exists a storage version of the given resource.\n \t */\n \tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MDg3MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403040871", "body": "Doesn't agree with the actual return type, and it's a useless comment", "bodyText": "Doesn't agree with the actual return type, and it's a useless comment", "bodyHTML": "<p dir=\"auto\">Doesn't agree with the actual return type, and it's a useless comment</p>", "author": "tivervac", "createdAt": "2020-04-03T14:22:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\nindex 83b883c98..61f7cfc7d 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n", "chunk": "@@ -23,20 +23,18 @@ import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n  */\n public interface IResourceStorageFacade {\n \t/**\n-\t * @return whether the given resource should and can be loaded from stored resource state\n+\t * @return whether the given {@link StorageAwareResource resource} should and can be loaded from stored resource state\n \t */\n \tboolean shouldLoadFromStorage(StorageAwareResource resource);\n \n \t/**\n-\t * @return whether storage data exists for the given URI\n+\t * @return whether storage data exists for the given {@link URI}\n \t */\n \tboolean hasStorageFor(URI uri);\n \n \t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n-\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n+\t * Finds or creates a {@link ResourceStorageLoadable} for the given resource. Clients should first call\n+\t * {@link #shouldLoadFromStorage(StorageAwareResource)} to check whether there exists a storage version of the given resource.\n \t */\n \tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MTI1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403041255", "body": "@link these types please", "bodyText": "@link these types please", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/link/hovercard\" href=\"https://github.com/link\">@link</a> these types please</p>", "author": "tivervac", "createdAt": "2020-04-03T14:22:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n+\n+\t/**\n+\t * Saves the resource using the given file system access.\n+\t */\n+\tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\nindex 83b883c98..61f7cfc7d 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n", "chunk": "@@ -46,12 +44,12 @@ public interface IResourceStorageFacade {\n \tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n \n \t/**\n-\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n+\t * Creates a fresh {@link ResourceStorageWritable} wrapping the given {@link OutputStream}\n \t */\n \tResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n \n \t/**\n-\t * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n+\t * Creates a fresh {@link ResourceStorageLoadable} wrapping the given {@link InputStream}\n \t */\n \tResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MTMwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403041308", "body": "@link these types please", "bodyText": "@link these types please", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/link/hovercard\" href=\"https://github.com/link\">@link</a> these types please</p>", "author": "tivervac", "createdAt": "2020-04-03T14:22:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n+\n+\t/**\n+\t * Saves the resource using the given file system access.\n+\t */\n+\tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n+\t */\n+\tResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageLoadable wrapping the given InputStream", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\nindex 83b883c98..61f7cfc7d 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java\n", "chunk": "@@ -46,12 +44,12 @@ public interface IResourceStorageFacade {\n \tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n \n \t/**\n-\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n+\t * Creates a fresh {@link ResourceStorageWritable} wrapping the given {@link OutputStream}\n \t */\n \tResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n \n \t/**\n-\t * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n+\t * Creates a fresh {@link ResourceStorageLoadable} wrapping the given {@link InputStream}\n \t */\n \tResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MjI3Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403042272", "body": "Doesn't agree with actual type and is a pretty useless comment", "bodyText": "Doesn't agree with actual type and is a pretty useless comment", "bodyHTML": "<p dir=\"auto\">Doesn't agree with actual type and is a pretty useless comment</p>", "author": "tivervac", "createdAt": "2020-04-03T14:24:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -56,25 +52,19 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\treturn doesStorageExist(resource);\n \t}\n \n-\t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n-\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n-\t */\n \t@Override\n \tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n \t\ttry {\n-\t\t\tResourceStorageProviderAdapter stateProvider = head(\n-\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tResourceStorageProviderAdapter stateProvider = getResourceStorageProviderAdapter(resourceSet);\n \t\t\tif (stateProvider != null) {\n \t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n \t\t\t\tif (loadable != null)\n \t\t\t\t\treturn loadable;\n \t\t\t}\n-\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\tif (resourceSet.getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n \t\t\t\t\tCollections.emptyMap())) {\n-\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\treturn createResourceStorageLoadable(resourceSet.getURIConverter()\n \t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n \t\t\t}\n \t\t\treturn createResourceStorageLoadable(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MzE4NA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403043184", "body": "s/ResourceStorageFacade.LOG/LOG/", "bodyText": "s/ResourceStorageFacade.LOG/LOG/", "bodyHTML": "<p dir=\"auto\">s/ResourceStorageFacade.LOG/LOG/</p>", "author": "tivervac", "createdAt": "2020-04-03T14:25:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -83,6 +73,22 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\t\tthrow new RuntimeIOException(e);\n \t\t}\n \t}\n+\t\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\tResourceStorageProviderAdapter stateProvider = getResourceStorageProviderAdapter(resourceSet);\n+\t\tif (stateProvider != null && stateProvider.getResourceStorageLoadable(resource) != null)\n+\t\t\treturn true;\n+\t\t// check for next to original location, i.e. jars\n+\t\tif (resourceSet.getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\tCollections.emptyMap()))\n+\t\t\treturn true;\n+\t\t// if it's an archive URI, we don't need to look up the source folder-output folder scheme\n+\t\tif (resource.getURI().isArchive())\n+\t\t\treturn false;\n+\t\tURI uri = getFileSystemAccess(resource).getURI(computeOutputPath(resource));\n+\t\treturn uri != null && resourceSet.getURIConverter().exists(uri, null);\n+\t}\n \n \t@Override\n \tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n", "next_change": null}, {"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -90,7 +96,8 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\ttry {\n \t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n \t\t} catch (IOException e) {\n-\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\t// something went wrong when writing the resource - stream's content is bogus and not written to disk\n+\t\t\tLOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n \t\t\treturn;\n \t\t}\n \t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MzU2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403043562", "body": "`@link` on this and the next line please", "bodyText": "@link on this and the next line please", "bodyHTML": "<p dir=\"auto\"><code>@link</code> on this and the next line please</p>", "author": "tivervac", "createdAt": "2020-04-03T14:26:07Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\nindex 3e68a30f6..986147e04 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java\n", "chunk": "@@ -56,25 +52,19 @@ public class ResourceStorageFacade implements IResourceStorageFacade {\n \t\treturn doesStorageExist(resource);\n \t}\n \n-\t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n-\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n-\t */\n \t@Override\n \tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n \t\ttry {\n-\t\t\tResourceStorageProviderAdapter stateProvider = head(\n-\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tResourceStorageProviderAdapter stateProvider = getResourceStorageProviderAdapter(resourceSet);\n \t\t\tif (stateProvider != null) {\n \t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n \t\t\t\tif (loadable != null)\n \t\t\t\t\treturn loadable;\n \t\t\t}\n-\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\tif (resourceSet.getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n \t\t\t\t\tCollections.emptyMap())) {\n-\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\treturn createResourceStorageLoadable(resourceSet.getURIConverter()\n \t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n \t\t\t}\n \t\t\treturn createResourceStorageLoadable(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0NDUzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403044532", "body": "s/ResourceStorageLoadable.LOG/LOG/", "bodyText": "s/ResourceStorageLoadable.LOG/LOG/", "bodyHTML": "<p dir=\"auto\">s/ResourceStorageLoadable.LOG/LOG/</p>", "author": "tivervac", "createdAt": "2020-04-03T14:27:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.zip.ZipInputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.nodemodel.impl.SerializableNodeModel;\n+import org.eclipse.xtext.nodemodel.serialization.DeserializationConversionContext;\n+import org.eclipse.xtext.parser.ParseResult;\n+\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageLoadable {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageLoadable.class);\n+\n+\tprivate final InputStream in;\n+\n+\tprivate final boolean storeNodeModel;\n+\n+\tpublic ResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tthis.in = in;\n+\t\tthis.storeNodeModel = storeNodeModel;\n+\t}\n+\n+\tprotected void loadIntoResource(StorageAwareResource resource) throws IOException {\n+\t\tif (!resource.isLoadedFromStorage())\n+\t\t\tthrow new IllegalStateException(\"Please use StorageAwareResource#load(ResourceStorageLoadable).\");\n+\t\ttry (ZipInputStream zin = new ZipInputStream(in)) {\n+\t\t\tloadEntries(resource, zin);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Load entries from the storage. Overriding methods should first delegate to super before adding their own entries.\n+\t */\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tzipIn.getNextEntry();\n+\t\treadContents(resource, new BufferedInputStream(zipIn));\n+\t\tzipIn.getNextEntry();\n+\t\treadResourceDescription(resource, new BufferedInputStream(zipIn));\n+\t\tif (storeNodeModel) {\n+\t\t\tzipIn.getNextEntry();\n+\t\t\treadNodeModel(resource, new BufferedInputStream(zipIn));\n+\t\t}\n+\t}\n+\n+\tprotected void readContents(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\tnew BinaryResourceImpl.EObjectInputStream(inputStream, Collections.emptyMap()) {\n+\t\t\t@Override\n+\t\t\tpublic int readCompressedInt() throws IOException {\n+\t\t\t\tresourceSet = null;\n+\t\t\t\treturn super.readCompressedInt();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic InternalEObject loadEObject() throws IOException {\n+\t\t\t\tInternalEObject result = super.loadEObject();\n+\t\t\t\thandleLoadEObject(result, this);\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}.loadResource(resource);\n+\t}\n+\n+\tprotected Object handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\treturn null;\n+\t}\n+\n+\tprotected void readResourceDescription(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\ttry {\n+\t\t\tSerializableResourceDescription description = (SerializableResourceDescription) new ObjectInputStream(\n+\t\t\t\t\tinputStream).readObject();\n+\t\t\tdescription.updateResourceURI(resource.getURI());\n+\t\t\tresource.setResourceDescription(description);\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\tprotected void readNodeModel(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\tSerializableNodeModel serializableNodeModel = new SerializableNodeModel(resource);\n+\t\tif (!resource.getResourceSet().getURIConverter().exists(resource.getURI(),\n+\t\t\t\tresource.getResourceSet().getLoadOptions())) {\n+\t\t\tResourceStorageLoadable.LOG.info(\"Skipping loading node model for synthetic resource \" + resource.getURI());", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java\nindex 753c780b8..edf4e242d 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java\n", "chunk": "@@ -100,9 +101,10 @@ public class ResourceStorageLoadable {\n \n \tprotected void readNodeModel(StorageAwareResource resource, InputStream inputStream) throws IOException {\n \t\tSerializableNodeModel serializableNodeModel = new SerializableNodeModel(resource);\n+\t\t// if this is a synthetic resource (i.e. tests or so, don't load the node model)\n \t\tif (!resource.getResourceSet().getURIConverter().exists(resource.getURI(),\n \t\t\t\tresource.getResourceSet().getLoadOptions())) {\n-\t\t\tResourceStorageLoadable.LOG.info(\"Skipping loading node model for synthetic resource \" + resource.getURI());\n+\t\t\tLOG.info(\"Skipping loading node model for synthetic resource \" + resource.getURI());\n \t\t\treturn;\n \t\t}\n \t\tString completeContent = CharStreams.toString(\n", "next_change": {"commit": "5d251e5af2fbb8284525e965a82c677fb6ffe954", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java\nindex edf4e242d..02cbd4b50 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java\n", "chunk": "@@ -107,14 +106,15 @@ public class ResourceStorageLoadable {\n \t\t\tLOG.info(\"Skipping loading node model for synthetic resource \" + resource.getURI());\n \t\t\treturn;\n \t\t}\n-\t\tString completeContent = CharStreams.toString(\n-\t\t\t\tnew InputStreamReader(resource.getResourceSet().getURIConverter().createInputStream(resource.getURI()),\n-\t\t\t\t\t\tresource.getEncoding()));\n-\t\tDeserializationConversionContext deserializationContext = new DeserializationConversionContext(resource,\n-\t\t\t\tcompleteContent);\n-\t\tserializableNodeModel.readObjectData(new DataInputStream(inputStream), deserializationContext);\n-\t\tresource.setParseResult(new ParseResult(head(resource.getContents()), serializableNodeModel.root,\n-\t\t\t\tdeserializationContext.hasErrors()));\n+\t\ttry (InputStreamReader reader = new InputStreamReader(resource.getResourceSet().getURIConverter().createInputStream(resource.getURI()),\n+\t\t\t\tresource.getEncoding())) {\n+\t\t\tString completeContent = CharStreams.toString(reader);\n+\t\t\tDeserializationConversionContext deserializationContext = new DeserializationConversionContext(resource,\n+\t\t\t\t\tcompleteContent);\n+\t\t\tserializableNodeModel.readObjectData(new DataInputStream(inputStream), deserializationContext);\n+\t\t\tresource.setParseResult(new ParseResult(head(resource.getContents()), serializableNodeModel.root,\n+\t\t\t\t\tdeserializationContext.hasErrors()));\n+\t\t}\n \t}\n \n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0ODUzNA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403048534", "body": "You could use `userData.keySet().stream().toArray(String[]::new)`", "bodyText": "You could use userData.keySet().stream().toArray(String[]::new)", "bodyHTML": "<p dir=\"auto\">You could use <code>userData.keySet().stream().toArray(String[]::new)</code></p>", "author": "tivervac", "createdAt": "2020-04-03T14:32:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.HashMap;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+\n+/**\n+ * @since 2.8\n+ */\n+public class SerializableEObjectDescription\n+\t\timplements IEObjectDescription, Externalizable, SerializableEObjectDescriptionProvider {\n+\tprotected URI eObjectURI;\n+\n+\tprotected EClass eClass;\n+\n+\tprotected QualifiedName qualifiedName;\n+\n+\tprotected HashMap<String, String> userData;\n+\n+\tprotected transient EObject eObjectOrProxy;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\teObjectURI = uri.appendFragment(eObjectURI.fragment());\n+\t}\n+\n+\t@Override\n+\tpublic EObject getEObjectOrProxy() {\n+\t\tif (eObjectOrProxy == null) {\n+\t\t\tEObject proxy = EcoreUtil.create(eClass);\n+\t\t\t((InternalEObject) proxy).eSetProxyURI(eObjectURI);\n+\t\t\teObjectOrProxy = proxy;\n+\t\t}\n+\t\treturn eObjectOrProxy;\n+\t}\n+\n+\t@Override\n+\tpublic QualifiedName getName() {\n+\t\treturn qualifiedName;\n+\t}\n+\n+\t@Override\n+\tpublic String getUserData(String key) {\n+\t\treturn userData.get(key);\n+\t}\n+\n+\t@Override\n+\tpublic String[] getUserDataKeys() {\n+\t\treturn (String[]) Conversions.unwrapArray(userData.keySet(), String.class);", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java\nindex 301e9eca6..c3fb3c162 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java\n", "chunk": "@@ -66,7 +65,7 @@ public class SerializableEObjectDescription\n \n \t@Override\n \tpublic String[] getUserDataKeys() {\n-\t\treturn (String[]) Conversions.unwrapArray(userData.keySet(), String.class);\n+\t\treturn userData.keySet().toArray(new String[0]);\n \t}\n \n \t@Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0OTIyMA==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403049220", "body": "Update copyright", "bodyText": "Update copyright", "bodyHTML": "<p dir=\"auto\">Update copyright</p>", "author": "tivervac", "createdAt": "2020-04-03T14:34:00Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java\nindex f598f37d8..e0d084b0e 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java\n", "chunk": "@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n  * This program and the accompanying materials are made available under the\n  * terms of the Eclipse Public License 2.0 which is available at\n  * http://www.eclipse.org/legal/epl-2.0.\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MDU0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403050547", "body": "I don't immediately say why the casts are needed? Isn't SerializableEObjectDescription instanceof IEObjectDescription", "bodyText": "I don't immediately say why the casts are needed? Isn't SerializableEObjectDescription instanceof IEObjectDescription", "bodyHTML": "<p dir=\"auto\">I don't immediately say why the casts are needed? Isn't SerializableEObjectDescription instanceof IEObjectDescription</p>", "author": "tivervac", "createdAt": "2020-04-03T14:35:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NDM2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r412994362", "bodyText": "True. But a List< SerializableEObjectDescription> is not a List<IEObjectDescription>.", "author": "szarnekow", "createdAt": "2020-04-22T13:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MDU0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex 7de35aa1c..f1ffad988 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -42,14 +42,14 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \n \tprivate List<QualifiedName> importedNames = Collections.emptyList();\n \n-\tprivate URI uRI;\n+\tprivate URI uri;\n \n \tpublic void updateResourceURI(URI uri) {\n \t\tfor (SerializableReferenceDescription ref : references)\n-\t\t\tref.updateResourceURI(uri, uRI);\n+\t\t\tref.updateResourceURI(uri, this.uri);\n \t\tfor (SerializableEObjectDescription desc : descriptions)\n \t\t\tdesc.updateResourceURI(uri);\n-\t\tuRI = uri;\n+\t\tthis.uri = uri;\n \t}\n \n \t@Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MTEzOQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403051139", "body": "SerializableResourceDescription::createCopy", "bodyText": "SerializableResourceDescription::createCopy", "bodyHTML": "<p dir=\"auto\">SerializableResourceDescription::createCopy</p>", "author": "tivervac", "createdAt": "2020-04-03T14:36:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {\n+\t\tthis.uRI = uRI;\n+\t}\n+\n+\tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n+\t\tSerializableResourceDescription description = new SerializableResourceDescription();\n+\t\tdescription.setURI(desc.getURI());\n+\t\tdescription.descriptions = toList(\n+\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex 7de35aa1c..f1ffad988 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -121,20 +121,20 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \t}\n \n \tpublic URI getURI() {\n-\t\treturn uRI;\n+\t\treturn uri;\n \t}\n \n-\tpublic void setURI(URI uRI) {\n-\t\tthis.uRI = uRI;\n+\tpublic void setURI(URI uri) {\n+\t\tthis.uri = uri;\n \t}\n \n \tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n \t\tSerializableResourceDescription description = new SerializableResourceDescription();\n \t\tdescription.setURI(desc.getURI());\n-\t\tdescription.descriptions = toList(\n-\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));\n-\t\tdescription.references = toList(\n-\t\t\t\tmap(desc.getReferenceDescriptions(), it -> SerializableResourceDescription.createCopy(it)));\n+\t\tdescription.descriptions = Lists.newArrayList(\n+\t\t\t\tmap(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n+\t\tdescription.references = Lists.newArrayList(\n+\t\t\t\tmap(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n \t\tdescription.importedNames = Lists.newArrayList(desc.getImportedNames());\n \t\treturn description;\n \t}\n", "next_change": {"commit": "e283b69ab6a27ddd70fa2e89cd5a7e95cfad92d3", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex f1ffad988..248648d28 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -132,9 +132,9 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \t\tSerializableResourceDescription description = new SerializableResourceDescription();\n \t\tdescription.setURI(desc.getURI());\n \t\tdescription.descriptions = Lists.newArrayList(\n-\t\t\t\tmap(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n+\t\t\t\ttransform(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n \t\tdescription.references = Lists.newArrayList(\n-\t\t\t\tmap(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n+\t\t\t\ttransform(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n \t\tdescription.importedNames = Lists.newArrayList(desc.getImportedNames());\n \t\treturn description;\n \t}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MTE5MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403051191", "body": "SerializableResourceDescription::createCopy", "bodyText": "SerializableResourceDescription::createCopy", "bodyHTML": "<p dir=\"auto\">SerializableResourceDescription::createCopy</p>", "author": "tivervac", "createdAt": "2020-04-03T14:36:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {\n+\t\tthis.uRI = uRI;\n+\t}\n+\n+\tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n+\t\tSerializableResourceDescription description = new SerializableResourceDescription();\n+\t\tdescription.setURI(desc.getURI());\n+\t\tdescription.descriptions = toList(\n+\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));\n+\t\tdescription.references = toList(\n+\t\t\t\tmap(desc.getReferenceDescriptions(), it -> SerializableResourceDescription.createCopy(it)));", "originalCommit": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe6bd769753173588d1d7a544783cae0cbd38d82", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex 7de35aa1c..f1ffad988 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -121,20 +121,20 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \t}\n \n \tpublic URI getURI() {\n-\t\treturn uRI;\n+\t\treturn uri;\n \t}\n \n-\tpublic void setURI(URI uRI) {\n-\t\tthis.uRI = uRI;\n+\tpublic void setURI(URI uri) {\n+\t\tthis.uri = uri;\n \t}\n \n \tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n \t\tSerializableResourceDescription description = new SerializableResourceDescription();\n \t\tdescription.setURI(desc.getURI());\n-\t\tdescription.descriptions = toList(\n-\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));\n-\t\tdescription.references = toList(\n-\t\t\t\tmap(desc.getReferenceDescriptions(), it -> SerializableResourceDescription.createCopy(it)));\n+\t\tdescription.descriptions = Lists.newArrayList(\n+\t\t\t\tmap(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n+\t\tdescription.references = Lists.newArrayList(\n+\t\t\t\tmap(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n \t\tdescription.importedNames = Lists.newArrayList(desc.getImportedNames());\n \t\treturn description;\n \t}\n", "next_change": {"commit": "e283b69ab6a27ddd70fa2e89cd5a7e95cfad92d3", "changed_code": [{"header": "diff --git a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\nindex f1ffad988..248648d28 100644\n--- a/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n+++ b/org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java\n", "chunk": "@@ -132,9 +132,9 @@ public class SerializableResourceDescription extends AbstractResourceDescription\n \t\tSerializableResourceDescription description = new SerializableResourceDescription();\n \t\tdescription.setURI(desc.getURI());\n \t\tdescription.descriptions = Lists.newArrayList(\n-\t\t\t\tmap(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n+\t\t\t\ttransform(desc.getExportedObjects(), SerializableResourceDescription::createCopy));\n \t\tdescription.references = Lists.newArrayList(\n-\t\t\t\tmap(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n+\t\t\t\ttransform(desc.getReferenceDescriptions(), SerializableResourceDescription::createCopy));\n \t\tdescription.importedNames = Lists.newArrayList(desc.getImportedNames());\n \t\treturn description;\n \t}\n", "next_change": null}]}}]}}, {"oid": "d66845132010a2e32fc8de27be2a9fca04f28850", "url": "https://github.com/eclipse/xtext-core/commit/d66845132010a2e32fc8de27be2a9fca04f28850", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-22T13:31:43Z", "type": "forcePushed"}, {"oid": "fe6bd769753173588d1d7a544783cae0cbd38d82", "url": "https://github.com/eclipse/xtext-core/commit/fe6bd769753173588d1d7a544783cae0cbd38d82", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-24T06:30:38Z", "type": "commit"}, {"oid": "fe6bd769753173588d1d7a544783cae0cbd38d82", "url": "https://github.com/eclipse/xtext-core/commit/fe6bd769753173588d1d7a544783cae0cbd38d82", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>", "committedDate": "2020-04-24T06:30:38Z", "type": "forcePushed"}]}